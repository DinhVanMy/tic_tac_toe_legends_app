# Source Code Summary

## Directory Structure
```
./
  firebase_options.dart
  main.dart
  Components/
    confetti_oneforall_widget.dart
    confetti_widget_custom.dart
    emotes_picker_widget.dart
    extensions.dart
    free_scroll_view.dart
    ingame_user_card.dart
    invite_request_dialog.dart
    placeholder_custom_widget.dart
    primary_button.dart
    primary_with_icon_button.dart
    profile_tooltip_widget.dart
    user_card.dart
    belong_to_users/
      avatar_user_widget.dart
    customized_widgets/
      draggble_fab_widget.dart
      slide_to_confirm_widget.dart
      tts_change_setting_widget.dart
    daily_gift/
      daily_gift_page.dart
      daily_reward_controller.dart
      daily_reward_storage.dart
      reward_model.dart
    daily_mission/
      constant_data.dart
      missions_page.dart
      mission_controller.dart
      mission_model.dart
      Widgets/
        daily_mission.dart
        monthly_mission.dart
        weekly_mission.dart
    fortune_wheel/
      fortune_wheel_page.dart
      controller/
        fortune_wheel_controller.dart
      painters/
        wheel_outline_painter.dart
        wheel_slice_painter.dart
      widgets/
        fortune_wheel.dart
        fortune_wheel_child.dart
        wheel_result_indicator.dart
        wheel_slice.dart
    friend_zone/
      direction_routes_service.dart
      friend_zone_map_controller.dart
      friend_zone_map_page.dart
      friend_zone_map_service.dart
      tinder_cards/
        example_model_card.dart
        tinder_cards_controller.dart
        tinder_cards_widget.dart
    gifphy/
      display_gif_widget.dart
      preview_gif_widget.dart
      stack_image_widget.dart
    rippleanimation/
      circle_painter.dart
      ripple_animation_widget.dart
    shimmers/
      chats_placeholder_widget.dart
      friendavatar_placeholder_widget.dart
      lives_placeholder_widget.dart
      messages_placeholder_widget.dart
      posts_placeholder_widget.dart
      urls_placeholder_widget.dart
  Configs/
    assets_path.dart
    constants.dart
    messages.dart
    page_route.dart
    paint_draws/
      bubble_chat_painter.dart
      star_confetti_draws.dart
    theme/
      colors.dart
      size_config.dart
      theme_dark.dart
      theme_light.dart
    translation/
      en.dart
      translation.dart
      vi.dart
  Controller/
    auth_controller.dart
    check_network_controller.dart
    language_controller.dart
    matching_controller.dart
    notification_controller.dart
    online_status_controller.dart
    profile_controller.dart
    room_controller.dart
    speech_to_text_controller.dart
    splace_controller.dart
    text_to_speech_controller.dart
    theme_controller.dart
    webview_controller.dart
    Animations/
      carousel_controller.dart
      confetti_controller.dart
      countdown_animation_controller.dart
      dotted_border_animation_controller.dart
      dot_matching_animation_controller.dart
      Overlays/
        draw_tria.dart
        profile_tooltip.dart
    Bindings/
      check_network_binding.dart
    Console/
      play_with_bot_controller.dart
      play_with_player_controller.dart
    MainHome/
      main_home_controller.dart
      notify_in_main_controller.dart
    Music/
      background_music_controller.dart
      effective_music_controller.dart
  Data/
    chat_friend_controller.dart
    fetch_firestore_database.dart
    gemini_api_controller.dart
  Enums/
    firebase_exception.dart
    popup_position.dart
  Models/
    call_model.dart
    champion_model.dart
    chat_friend_settings_model.dart
    gemini_model.dart
    general_notifications_model.dart
    live_sream_model.dart
    message_friend_model.dart
    minimax_arg.dart
    queue_model.dart
    room_model.dart
    user_model.dart
    Functions/
      color_string_reverse_function.dart
      compress_image_function.dart
      fetch_firestore_data_functions.dart
      general_bottomsheet_show_function.dart
      gradient_generator_functions.dart
      hyperlink_text_function.dart
      notification_add_functions.dart
      permission_handle_functions.dart
      time_functions.dart
  Pages/
    Admin/
      app_routes.dart
      source_code.md
      controllers/
        admin_controller.dart
        dashboard_overview_controller.dart
        support_system_controller.dart
      middlewares/
        admin_middleware.dart
      models/
        user_model.dart
      Pages/
        admin_home_page.dart
        admin_setting_page.dart
        dashboard_overview.dart
        tabs/
          analytics_tab.dart
          announcements_tab.dart
          content_moderation_tab.dart
          game_management_tab.dart
          user_management_tab.dart
          user_support_system_tab.dart
        widgets/
          admin_access_widget.dart
      services/
        admin_service.dart
    Auth/
      auth_page.dart
    Chat/
      chat_screen.dart
      Widgets/
        chat_mess_item.dart
        option_card.dart
        section_widget.dart
    Friends/
      chat_with_friend_page.dart
      listen_latest_messages_controller.dart
      messenger_page.dart
      Widgets/
        agora_call_controller.dart
        agora_call_page.dart
        agora_end_of_call_lay.dart
        background_list_controller.dart
        background_list_sheet.dart
        chat_friend_item.dart
        messages_widget.dart
        notes_widget.dart
        Agoras_widget/
          agora_background_sheet.dart
          beauty_filter_option_controller.dart
          beauty_filter_option_sheet.dart
    GamePage/
      Console/
        Breakout_Game/
          breakout_gamelobby_page.dart
          breakout_gameplay_controller.dart
          breakout_gameplay_page.dart
        Bubble_Shooter/
          bubble_shooter_gameplay_page.dart
          bubble_shooter_lobby_page.dart.dart
          controllers/
            bubble_shooter_gameplay_controller.dart
          model/
            bubble_models.dart
          utils/
            combo_calculator.dart
            device_detector.dart
            game_storage.dart
            haptic_manager.dart
            sound_manager.dart
          views/
            bubble_grid_ui.dart
            components/
              animated_bubble_scale.dart
              animated_combo_message.dart
              animated_score_display.dart
              bubble_background.dart
              bubble_collision_ripple.dart
              bubble_widget.dart
              countdown_widget.dart
              falling_bubble_physics.dart
              game_state_overlay.dart
              glowing_bubble.dart
              particle_system.dart
              powerup_button.dart
              pulsing_bubble_hint.dart
              screen_shake_widget.dart
              shooter_area.dart
              shooting_path_overlay.dart
              tutorial_overlay.dart
              effects/
                ripple_effect.dart
                trail_effect.dart
        General_Widgets/
          gaming_button_custom.dart
          gaming_dialogs.dart
        HeroMerge_Game/
          hero_merge_controller.dart
          hero_merge_gamelobby_page.dart
          hero_merge_gameplay_page.dart
        Match3_Game/
          match3_gameplay_controller.dart
          match3_gameplay_page.dart
          match3_lobby_page.dart
        Minesweeper_Game/
          minesweeper_gamelobby_page.dart
          minesweeper_game_controller.dart
          minesweeper_game_page.dart
        sodoku_game/
          dynamic_sodoku_controller.dart
          sodoku_gamelobby_page.dart
          sodoku_gameplay_page.dart
      PlayerGame/
        body_multi_player.dart
        multi_player.dart
        ui_playing_multi_board.dart
      Shop/
        shop_page.dart
        Widgets/
          champions_page.dart
          emotes_page.dart
          maps_page.dart
      SingleGame/
        play_with_bot_page.dart
        ui_playing_board.dart
      Widgets/
        core/
          countdown_waiting_widget.dart
          line_painter.dart
    HomePage/
      home_page.dart
      Bottom/
        bottom_button_custom.dart
        bottom_nav_bar.dart
        button_nav_bar_curve.dart
      Drawer/
        drawer_nav_bar.dart
        Widgets/
          cham_ranking_drawer.dart
          player_ranking_drawer.dart
      Widgets/
        expansion_side_left.dart
        expansion_side_right.dart
        jajas_top_icon_widget.dart
        looping_carousel_widget.dart
        middle_custom_widget.dart
    LobbyPage/
      lobby_page.dart
      Widget/
        end_drawer_lobby.dart
        game_info.dart
        pricing_area.dart
        room_info.dart
    Login/
      change_password_dialog.dart
      login_sheet.dart
    MainHome/
      main_home.dart
    Registration/
      register_sheet.dart
    RoomPage/
      room_page.dart
    Setting/
      setting_screen_main.dart
      Widgets/
        locale_button.dart
    Society/
      social_media_page.dart
      social_post_controller.dart
      social_post_model.dart
      About/
        user_about_controller.dart
        user_about_page.dart
      agora_livestreaming/
        agora_livestreaming_controller.dart
        agora_livestreaming_page.dart
        create_livestream_room_page.dart
        livestream_controller.dart
        livestream_doc_service.dart
        source_code.md
        Widgets/
          bubbles_effect_widget.dart
          livestream_comment_list_widget.dart
      Comment/
        comment_post_model.dart
        post_comment_controller.dart
        post_comment_list_sheet.dart
        post_reply_comment_controller.dart
        post_reply_comment_list_sheet.dart
      Reels/
        create_reel_page.dart
        like_animation_widget.dart
        reel_controller.dart
        reel_model.dart
        reel_page.dart
        api/
          fetch_url_api_controller.dart
          fetch_url_link_api_page.dart
          video_api_model.dart
          video_player_preview_page.dart
          video_thumbnail.dart
        comment/
          reel_comment_controller.dart
          reel_comment_list_sheet.dart
          reel_reply_comment_controller.dart
          reel_reply_comment_list_sheet.dart
        whitecodel/
          video_controller_service.dart
          video_full_screen_widget.dart
          whitecodel_reels_controller.dart
          whitecodel_reels_page.dart
      Widgets/
        create_post_page.dart
        expandable_text_custom.dart
        like_user_list_sheet.dart
        notification_badge_custom.dart
        optional_tile_custom.dart
        post_edit_model.dart
        post_edit_sheet.dart
        post_list_card.dart
        post_notification_controller.dart
        post_notification_page.dart
        share_sheet_custom.dart
        social_livestreams_widget.dart
        social_posts_widget.dart
        post_notification_tabs/
          edit_notify_bottomsheet.dart
          post_comment_tab.dart
          post_like_tab.dart
          post_other_tab.dart
        post_polls/
          create_polls_inpost_page.dart
          poll_controller.dart
          post_polls_card.dart
          post_polls_model.dart
          test_poll.dart
          text_field_custom_widget.dart
    Splace/
      splace_page.dart
    UpdateProfile/
      border_frame_controller.dart
      update_profile_page.dart
    Web/
      web_view_edit_controller.dart
      web_view_edit_sheet.dart
      web_view_open.dart
      web_view_screen.dart
    Welcome/
      welcome_page.dart
  Test/
    customed_error_widget.dart
    game_history/
      game_history_page.dart
      Widgets/
        tictactoe_history_widget.dart
    livestream_preview/
      agora_preview_controller.dart
```


## File Contents


### firebase_options.dart

```dart
// File generated by FlutterFire CLI.
// ignore_for_file: type=lint
import 'package:firebase_core/firebase_core.dart' show FirebaseOptions;
import 'package:flutter/foundation.dart'
    show defaultTargetPlatform, kIsWeb, TargetPlatform;
import 'package:tictactoe_gameapp/Configs/constants.dart';

/// Default [FirebaseOptions] for use with your Firebase apps.
///
/// Example:
/// ```dart
/// import 'firebase_options.dart';
/// // ...
/// await Firebase.initializeApp(
///   options: DefaultFirebaseOptions.currentPlatform,
/// );
/// ```
class DefaultFirebaseOptions {
  static FirebaseOptions get currentPlatform {
    if (kIsWeb) {
      throw UnsupportedError(
        'DefaultFirebaseOptions have not been configured for web - '
        'you can reconfigure this by running the FlutterFire CLI again.',
      );
    }
    switch (defaultTargetPlatform) {
      case TargetPlatform.android:
        return android;
      case TargetPlatform.iOS:
        return ios;
      case TargetPlatform.macOS:
        throw UnsupportedError(
          'DefaultFirebaseOptions have not been configured for macos - '
          'you can reconfigure this by running the FlutterFire CLI again.',
        );
      case TargetPlatform.windows:
        throw UnsupportedError(
          'DefaultFirebaseOptions have not been configured for windows - '
          'you can reconfigure this by running the FlutterFire CLI again.',
        );
      case TargetPlatform.linux:
        throw UnsupportedError(
          'DefaultFirebaseOptions have not been configured for linux - '
          'you can reconfigure this by running the FlutterFire CLI again.',
        );
      default:
        throw UnsupportedError(
          'DefaultFirebaseOptions are not supported for this platform.',
        );
    }
  }

  static FirebaseOptions android = FirebaseOptions(
    apiKey: apiFirebaseKey,
    appId: apiFirebaseId,
    messagingSenderId: '71459166896',
    projectId: 'tictactoe-flutter-672ff',
    storageBucket: 'tictactoe-flutter-672ff.appspot.com',
  );

  static FirebaseOptions ios = FirebaseOptions(
    apiKey: apiFirebaseKey,
    appId: apiFirebaseId,
    messagingSenderId: '71459166896',
    projectId: 'tictactoe-flutter-672ff',
    storageBucket: 'tictactoe-flutter-672ff.appspot.com',
    iosBundleId: 'com.example.tictactoeGameapp',
  );
}

```

---


### main.dart

```dart
import 'package:firebase_app_check/firebase_app_check.dart';
import 'package:firebase_core/firebase_core.dart';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_dotenv/flutter_dotenv.dart';
import 'package:flutter_local_notifications/flutter_local_notifications.dart';
import 'package:get_storage/get_storage.dart';
import 'package:tictactoe_gameapp/Configs/page_route.dart';
import 'package:get/get.dart';
import 'package:tictactoe_gameapp/Configs/theme/theme_dark.dart';
import 'package:tictactoe_gameapp/Configs/theme/theme_light.dart';
import 'package:tictactoe_gameapp/Configs/translation/translation.dart';
import 'package:tictactoe_gameapp/Controller/auth_controller.dart';
import 'package:tictactoe_gameapp/Controller/language_controller.dart';
import 'package:tictactoe_gameapp/Controller/Music/background_music_controller.dart';
import 'package:tictactoe_gameapp/Controller/theme_controller.dart';
import 'package:tictactoe_gameapp/Pages/Admin/Pages/admin_home_page.dart';
import 'package:tictactoe_gameapp/Pages/Admin/app_routes.dart';
import 'package:tictactoe_gameapp/Pages/Splace/splace_page.dart';
import 'package:tictactoe_gameapp/Test/customed_error_widget.dart';
import 'firebase_options.dart';

final GlobalKey<NavigatorState> navigatorKey = GlobalKey<NavigatorState>();
Future<void> main() async {
  WidgetsFlutterBinding.ensureInitialized();
  await _setUpExternalLoad();
  await _setUpGeneralSystem();
  // await _setUpLocalNotifications();
  runApp(const MyApp());
}

Future<void> _setUpExternalLoad() async {
  await dotenv.load(fileName: ".env");
  await Firebase.initializeApp(
    options: DefaultFirebaseOptions.currentPlatform,
  );
  await FirebaseAppCheck.instance.activate(
    androidProvider: AndroidProvider.debug,
    appleProvider: AppleProvider.appAttest,
  );
  await GetStorage.init();
}

Future<void> _setUpGeneralSystem() async {
  await SystemChrome.setPreferredOrientations([
    DeviceOrientation.portraitUp,
    DeviceOrientation.portraitDown,
  ]);
  await SystemChrome.setEnabledSystemUIMode(SystemUiMode.immersiveSticky);
}

Future<void> _setUpLocalNotifications() async {
  FlutterLocalNotificationsPlugin flutterLocalNotificationsPlugin =
      FlutterLocalNotificationsPlugin();
  const AndroidInitializationSettings initializationSettingsAndroid =
      AndroidInitializationSettings('app_logo');
  const DarwinInitializationSettings initializationSettingsDarwin =
      DarwinInitializationSettings();
  const LinuxInitializationSettings initializationSettingsLinux =
      LinuxInitializationSettings(defaultActionName: 'Open notification');
  const InitializationSettings initializationSettings = InitializationSettings(
      android: initializationSettingsAndroid,
      iOS: initializationSettingsDarwin,
      macOS: initializationSettingsDarwin,
      linux: initializationSettingsLinux);
  await flutterLocalNotificationsPlugin.initialize(initializationSettings);
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});
  @override
  Widget build(BuildContext context) {
     AdminRoutes.setupAdminRoutes();
    final LanguageController languageController = Get.put(LanguageController());
    return GetMaterialApp(
      initialBinding: BindingsBuilder(() {
        Get.put(ThemeController(), permanent: true);
        Get.put(AuthController(), permanent: true);
        Get.put(BackgroundMusicController(), permanent: true);
        // Get.put(EffectiveMusicController(), permanent: false);
      }),
      // initialRoute: '/splace',
      getPages: pages, navigatorKey: navigatorKey,
      debugShowCheckedModeBanner: false,
      title: 'XO Game App',
      theme: lightTheme,
      darkTheme: darktheme,
      translations: AppTranslations(),
      locale: languageController.locale,
      fallbackLocale: const Locale('en'),
      builder: (context, child) {
        ErrorWidget.builder = (FlutterErrorDetails errorDetails) {
          return CustomErrorWidget(errorDetails: errorDetails);
        };
        return child!;
      },
      home: const SplacePage(),
      //  const MultiPlayer(
      //   roomId: "339C80AB",
      // ),
    );
  }
}

```

---


### Components\confetti_oneforall_widget.dart

```dart
import 'package:confetti/confetti.dart';
import 'package:flutter/material.dart';
import 'package:tictactoe_gameapp/Configs/paint_draws/star_confetti_draws.dart';

class ConfettiOneforallWidget extends StatelessWidget {
  final ConfettiController confettiController;
  const ConfettiOneforallWidget({super.key, required this.confettiController});

  @override
  Widget build(BuildContext context) {
    return Center(
      child: ConfettiWidget(
        confettiController: confettiController,
        blastDirectionality:
            BlastDirectionality.explosive, // Nổ theo mọi hướng từ trung tâm
        shouldLoop: false, // Không lặp lại
        colors: const [
          Colors.red,
          Colors.blue,
          Colors.green,
          Colors.yellow,
          Colors.purple,
          Colors.orange,
          Colors.pink,
          Colors.teal,
          Colors.cyan,
          Colors.amber
        ],
        createParticlePath: (size) {
          // Tạo hạt với các hình dạng khác nhau
          return DrawPath.drawStarOfficial(size);
        },
        numberOfParticles: 100, // Số lượng hạt nổ ra
        emissionFrequency: 0.05, // Tần suất nổ
        gravity: 1, // Lực hấp dẫn, tốc độ rơi của các hạt
        minBlastForce: 10, // Lực nổ nhỏ nhất
        maxBlastForce: 100, // Lực nổ lớn nhất
        particleDrag: 0.05, // Lực cản khi các hạt rơi xuống
      ),
    );
  }
}

```

---


### Components\confetti_widget_custom.dart

```dart
import 'package:confetti/confetti.dart';
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:tictactoe_gameapp/Configs/paint_draws/star_confetti_draws.dart';
import 'package:tictactoe_gameapp/Controller/Animations/confetti_controller.dart';

class ConfettiWidgetCustom extends StatelessWidget {
  final int quantity;
  const ConfettiWidgetCustom({super.key,  this.quantity = 100});

  @override
  Widget build(BuildContext context) {
    final ConfettiToController confettiToController =
        Get.put(ConfettiToController());
    return ConfettiWidget(
      confettiController: confettiToController.confettiController,
      blastDirectionality:
          BlastDirectionality.explosive, // Nổ theo mọi hướng từ trung tâm
      shouldLoop: false, // Không lặp lại
      colors: const [
        Colors.red,
        Colors.blue,
        Colors.green,
        Colors.yellow,
        Colors.purple,
        Colors.orange,
        Colors.pink,
        Colors.teal,
        Colors.cyan,
        Colors.amber
      ],
      createParticlePath: (size) {
        // Tạo hạt với các hình dạng khác nhau
        return DrawPath.drawStarOfficial(size);
      },
      numberOfParticles: quantity, // Số lượng hạt nổ ra
      emissionFrequency: 0.05, // Tần suất nổ
      gravity: 1, // Lực hấp dẫn, tốc độ rơi của các hạt
      minBlastForce: 10, // Lực nổ nhỏ nhất
      maxBlastForce: 100, // Lực nổ lớn nhất
      particleDrag: 0.05, // Lực cản khi các hạt rơi xuống
    );
  }
}


class ConfettiLikeWidgetCustom extends StatelessWidget {
  final int quantity;
  const ConfettiLikeWidgetCustom({super.key, this.quantity = 20}); // Giảm số lượng hạt xuống 20

  @override
  Widget build(BuildContext context) {
    final ConfettiToController confettiToController = Get.put(ConfettiToController());
    return ConfettiWidget(
      confettiController: confettiToController.confettiController,
      blastDirectionality: BlastDirectionality.explosive, // Nổ từ trung tâm ra mọi hướng
      shouldLoop: false, // Chỉ chạy một lần
      colors: const [
        Colors.red,
        Colors.blue,
        Colors.green,
        Colors.yellow,
        Colors.purple,
        Colors.orange,
        Colors.pink,
      ],
      createParticlePath: (size) => DrawPath.drawStarOfficial(size), // Hạt hình ngôi sao
      numberOfParticles: quantity, // Số lượng hạt tối ưu
      emissionFrequency: 0.01, // Tần suất nổ thấp để tránh dày đặc
      gravity: 0.3, // Lực hấp dẫn nhẹ để hạt rơi chậm tự nhiên
      minBlastForce: 5, // Lực nổ nhỏ nhất
      maxBlastForce: 15, // Lực nổ lớn nhất, giảm để nhẹ nhàng hơn
      particleDrag: 0.1, // Lực cản lớn hơn để hạt rơi nhanh và biến mất sớm
    );
  }
}
```

---


### Components\emotes_picker_widget.dart

```dart
import 'package:emoji_picker_flutter/emoji_picker_flutter.dart';
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:flutter/foundation.dart' as foundation;

class GlobalEmojiPicker extends StatelessWidget {
  final RxBool isEmojiPickerVisible;
  final Function(String emoji) onEmojiSelected; // Hàm callback khi chọn emoji
  final Function()? onBackspacePressed; // Hàm callback khi nhấn backspace
  const GlobalEmojiPicker({
    super.key,
    required this.isEmojiPickerVisible,
    required this.onEmojiSelected,
    this.onBackspacePressed,
  });

  @override
  Widget build(BuildContext context) {
    final ScrollController scrollController = ScrollController();
    return Obx(() {
      if (!isEmojiPickerVisible.value) {
        return const SizedBox.shrink();
      }
      return Positioned(
        bottom: 0,
        left: 0,
        right: 0,
        child: Container(
          color: Colors.white,
          child: EmojiPicker(
            // textEditingController: _controller,
            scrollController: scrollController,
            config: Config(
              height: 256,
              checkPlatformCompatibility: true,
              emojiViewConfig: EmojiViewConfig(
                emojiSizeMax: 28 *
                    (foundation.defaultTargetPlatform == TargetPlatform.iOS
                        ? 1.2
                        : 1.0),
              ),
              skinToneConfig: const SkinToneConfig(),
              categoryViewConfig: const CategoryViewConfig(),
              bottomActionBarConfig: const BottomActionBarConfig(),
              searchViewConfig: const SearchViewConfig(),
            ),
          ),
        ),
      );
    });
  }
}

class CustomEmojiPicker extends StatelessWidget {
  final RxBool isEmojiPickerVisible;
  final Function(String emoji) onEmojiSelected; // Hàm callback khi chọn emoji
  final Function()? onBackspacePressed; // Hàm callback khi nhấn backspace
  final double height; // Chiều cao của Emoji Picker
  final TextStyle? emojiTextStyle; // Kiểu chữ cho emoji
  final List<Color> backgroundColor; // Màu nền của picker
  final bool isSearchEmo;

  const CustomEmojiPicker({
    super.key,
    required this.onEmojiSelected,
    this.onBackspacePressed,
    this.height = 300,
    this.emojiTextStyle,
    required this.backgroundColor,
    required this.isEmojiPickerVisible,
    this.isSearchEmo = true,
  });

  @override
  Widget build(BuildContext context) {
    return Obx(() => isEmojiPickerVisible.value
        ? EmojiPicker(
            onEmojiSelected: (category, emoji) => onEmojiSelected(emoji.emoji),
            onBackspacePressed: onBackspacePressed,
            config: Config(
              height: height,
              checkPlatformCompatibility: true,
              emojiTextStyle: emojiTextStyle ?? const TextStyle(fontSize: 28),
              emojiViewConfig: _buildEmojiViewConfig(),
              skinToneConfig: _buildSkinToneConfig(),
              categoryViewConfig: _buildCategoryViewConfig(),
              bottomActionBarConfig: isSearchEmo
                  ? _buildBottomActionBarConfig()
                  : BottomActionBarConfig(
                      customBottomActionBar: (config, state, showSearchView) =>
                          const SizedBox(),
                    ),
              searchViewConfig: isSearchEmo
                  ? _buildSearchViewConfig()
                  : SearchViewConfig(
                      customSearchView: (config, state, showEmojiView) =>
                          const SizedBox(),
                    ),
            ),
          )
        : const SizedBox.shrink());
  }

  EmojiViewConfig _buildEmojiViewConfig() {
    return EmojiViewConfig(
      columns: 8,
      emojiSizeMax: 32.0,
      backgroundColor: backgroundColor.first.withOpacity(0.3),
      verticalSpacing: 10,
      horizontalSpacing: 8,
      gridPadding: const EdgeInsets.symmetric(horizontal: 10),
      recentsLimit: 30,
      replaceEmojiOnLimitExceed: true,
      loadingIndicator: const CircularProgressIndicator(),
      buttonMode: ButtonMode.MATERIAL,
    );
  }

  SkinToneConfig _buildSkinToneConfig() {
    return const SkinToneConfig(
      dialogBackgroundColor: Colors.white,
      indicatorColor: Colors.grey,
    );
  }

  CategoryViewConfig _buildCategoryViewConfig() {
    return CategoryViewConfig(
      tabBarHeight: 50,
      tabIndicatorAnimDuration: const Duration(milliseconds: 200),
      backgroundColor: backgroundColor.last.withOpacity(0.7),
      indicatorColor: Colors.blue,
      iconColor: Colors.blueGrey,
      iconColorSelected: Colors.white,
      backspaceColor: Colors.red,
      categoryIcons: const CategoryIcons(),
      customCategoryView: null,
    );
  }

  BottomActionBarConfig _buildBottomActionBarConfig() {
    return const BottomActionBarConfig(
      showBackspaceButton: true,
      showSearchViewButton: true,
      backgroundColor: Colors.blueGrey,
      buttonIconColor: Colors.white,
      customBottomActionBar: null,
    );
  }

  SearchViewConfig _buildSearchViewConfig() {
    return const SearchViewConfig(
      buttonColor: Colors.black,
      buttonIconColor: Colors.black26,
      hintText: 'Search Emoji...',
      customSearchView: null,
    );
  }
}

```

---


### Components\extensions.dart

```dart
import 'package:image_picker/image_picker.dart';

extension GetImageMimeType on XFile {
  String getMimeTypeFromExtension() {
    final extension = path.split('.').last;
    switch (extension) {
      case 'jpg':
        return 'image/jpeg';
      case 'png':
        return 'image/png';
      case 'webp':
        return 'image/webp';
      case 'heic':
        return 'image/heic';
      case 'heif':
        return 'image/heif';

      default:
        return 'application/octet-stream'; // Unknown type
    }
  }
}

```

---


### Components\free_scroll_view.dart

```dart
import 'package:flutter/gestures.dart';
import 'package:flutter/material.dart';

class FreeScrollView extends StatefulWidget {
  final Widget child;
  final ScrollPhysics physics;

  const FreeScrollView({super.key, this.physics = const ClampingScrollPhysics(), required this.child});

  @override
  State<FreeScrollView> createState() => _FreeScrollViewState();
}

class _FreeScrollViewState extends State<FreeScrollView> {
  final ScrollController _verticalController = ScrollController();
  final ScrollController _horizontalController = ScrollController();
  final Map<Type, GestureRecognizerFactory> _gestureRecognizers = <Type, GestureRecognizerFactory>{};

  @override
  void initState() {
    super.initState();
    _gestureRecognizers[PanGestureRecognizer] = GestureRecognizerFactoryWithHandlers<PanGestureRecognizer>(
        () => PanGestureRecognizer(),
        (instance) => instance
          ..onDown = _handleDragDown
          ..onStart = _handleDragStart
          ..onUpdate = _handleDragUpdate
          ..onEnd = _handleDragEnd
          ..onCancel = _handleDragCancel
          ..minFlingDistance = widget.physics.minFlingDistance
          ..minFlingVelocity = widget.physics.minFlingVelocity
          ..maxFlingVelocity = widget.physics.maxFlingVelocity
          ..velocityTrackerBuilder = ScrollConfiguration.of(context).velocityTrackerBuilder(context)
          ..dragStartBehavior = DragStartBehavior.start);
  }

  @override
  Widget build(BuildContext context) => Stack(children: [
        SingleChildScrollView(
            scrollDirection: Axis.horizontal,
            controller: _horizontalController,
            physics: widget.physics,
            child: SingleChildScrollView(
                scrollDirection: Axis.vertical, // ignore: avoid_redundant_argument_values
                controller: _verticalController,
                physics: widget.physics,
                child: widget.child)),
        Positioned.fill(
            child: RawGestureDetector(
          gestures: _gestureRecognizers,
          behavior: HitTestBehavior.opaque,
          excludeFromSemantics: true,
        )),
      ]);

  Drag? _horizontalDrag;
  Drag? _verticalDrag;
  ScrollHoldController? _horizontalHold;
  ScrollHoldController? _verticalHold;

  void _handleDragDown(DragDownDetails details) {
    _horizontalHold = _horizontalController.position.hold(() => _horizontalHold = null);
    _verticalHold = _verticalController.position.hold(() => _verticalHold = null);
  }

  void _handleDragStart(DragStartDetails details) {
    _horizontalDrag = _horizontalController.position.drag(details, () => _horizontalDrag = null);
    _verticalDrag = _verticalController.position.drag(details, () => _verticalDrag = null);
  }

  void _handleDragUpdate(DragUpdateDetails details) {
    _horizontalDrag?.update(DragUpdateDetails(
        sourceTimeStamp: details.sourceTimeStamp,
        delta: Offset(details.delta.dx, 0),
        primaryDelta: details.delta.dx,
        globalPosition: details.globalPosition));
    _verticalDrag?.update(DragUpdateDetails(
        sourceTimeStamp: details.sourceTimeStamp,
        delta: Offset(0, details.delta.dy),
        primaryDelta: details.delta.dy,
        globalPosition: details.globalPosition));
  }

  void _handleDragEnd(DragEndDetails details) {
    _horizontalDrag
        ?.end(DragEndDetails(velocity: details.velocity, primaryVelocity: details.velocity.pixelsPerSecond.dx));
    _verticalDrag
        ?.end(DragEndDetails(velocity: details.velocity, primaryVelocity: details.velocity.pixelsPerSecond.dy));
  }

  void _handleDragCancel() {
    _horizontalHold?.cancel();
    _horizontalDrag?.cancel();
    _verticalHold?.cancel();
    _verticalDrag?.cancel();
  }
}

```

---


### Components\ingame_user_card.dart

```dart
import 'package:flutter/material.dart';
import 'package:flutter_svg/svg.dart';
import 'package:tictactoe_gameapp/Configs/assets_path.dart';

class InGameUserCard extends StatelessWidget {
  final String icon;
  final String name;
  final String imageUrl;
  final Color color;
  final String coins;
  const InGameUserCard({
    super.key,
    required this.icon,
    required this.name,
    required this.imageUrl,
    required this.color,
    required this.coins,
  });

  @override
  Widget build(BuildContext context) {
    final w = MediaQuery.of(context).size.width;
    return Stack(
      clipBehavior: Clip.none,
      children: [
        Container(
          width: w / 2.6,
          height: 180,
          decoration: BoxDecoration(
              color: Theme.of(context).colorScheme.primaryContainer,
              borderRadius: BorderRadius.circular(20),
              border: Border.all(
                color: color,
                width: 5,
              )),
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              const SizedBox(height: 40),
              Text(
                name,
                maxLines: 1,
                overflow: TextOverflow.ellipsis,
                style: Theme.of(context).textTheme.titleLarge!.copyWith(
                      color: Colors.deepPurple,
                      fontWeight: FontWeight.bold,
                    ),
              ),
              const SizedBox(height: 5),
              Container(
                padding:
                    const EdgeInsets.symmetric(vertical: 5, horizontal: 30),
                decoration: BoxDecoration(
                  color: Theme.of(context).colorScheme.primary,
                  borderRadius: BorderRadius.circular(10),
                ),
                child: Column(
                  children: [
                    SvgPicture.asset(
                      icon,
                      width: 30,
                      colorFilter: ColorFilter.mode(
                          Theme.of(context).colorScheme.secondary,
                          BlendMode.srcIn),
                    ),
                  ],
                ),
              ),
              const SizedBox(height: 5),
              Row(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  SvgPicture.asset(
                    IconsPath.coinIcon,
                  ),
                  const SizedBox(width: 10),
                  Text("Coins : $coins")
                ],
              ),
            ],
          ),
        ),
        Positioned(
          top: -50,
          left: w / 2.6 / 2 - 50,
          child: Container(
            width: 100,
            height: 100,
            decoration: BoxDecoration(
              borderRadius: BorderRadius.circular(100),
              border: Border.all(
                color: color,
                width: 5,
              ),
              image: DecorationImage(
                image: NetworkImage(imageUrl),
                fit: BoxFit.cover,
              ),
            ),
          ),
        ),
      ],
    );
  }
}

```

---


### Components\invite_request_dialog.dart

```dart
import 'package:cached_network_image/cached_network_image.dart';
import 'package:flutter/material.dart';
import 'package:tictactoe_gameapp/Configs/assets_path.dart';
import 'package:tictactoe_gameapp/Models/user_model.dart';
import 'package:tictactoe_gameapp/Components/customized_widgets/slide_to_confirm_widget.dart';

class GameInviteRequestDialog extends StatelessWidget {
  final UserModel friend;
  final Function() onPressedAccept;
  final Function() onPressedRefuse;
  const GameInviteRequestDialog({
    super.key,
    required this.friend,
    required this.onPressedAccept,
    required this.onPressedRefuse,
  });

  @override
  Widget build(BuildContext context) {
    return Container(
      height: 300,
      width: 400,
      alignment: Alignment.center,
      // padding: const EdgeInsets.all(10.0),
      decoration: BoxDecoration(
        color: Colors.blueAccent.withOpacity(0.8),
        borderRadius: BorderRadius.circular(20),
        border: Border.all(color: Colors.white, width: 3),
      ),
      child: Stack(
        children: [
          Column(
            children: [
              const Text(
                "Invite",
                style: TextStyle(
                  color: Colors.yellowAccent,
                  fontSize: 20,
                ),
              ),
              const Divider(
                color: Colors.white,
              ),
              Row(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  CircleAvatar(
                    backgroundImage: CachedNetworkImageProvider(friend.image!),
                    radius: 30,
                  ),
                  const SizedBox(
                    width: 5,
                  ),
                  Column(
                    children: [
                      Text(
                        friend.name!,
                        style: const TextStyle(
                          fontWeight: FontWeight.bold,
                          fontSize: 20,
                          color: Colors.purple,
                        ),
                      ),
                      Row(
                        children: [
                          Image.asset(
                            TrimRanking.diamondTrim,
                            width: 25,
                          ),
                          const SizedBox(
                            width: 5,
                          ),
                          const Text(
                            "Master 1",
                            style: TextStyle(
                              fontSize: 15,
                              color: Colors.blueGrey,
                            ),
                          ),
                        ],
                      ),
                    ],
                  ),
                ],
              ),
              const SizedBox(height: 20),
              Container(
                decoration: const BoxDecoration(
                  border: Border(
                    top: BorderSide(color: Colors.blue, width: 1), // Viền trên
                    bottom:
                        BorderSide(color: Colors.blue, width: 1), // Viền dưới
                  ),
                ),
                child: ShaderMask(
                  shaderCallback: (Rect bounds) {
                    return const LinearGradient(
                      begin: Alignment.centerLeft,
                      end: Alignment.centerRight,
                      colors: [
                        Colors.transparent, // Màu mờ ở trái
                        Colors.black, // Màu rõ ở giữa
                        Colors.transparent, // Màu mờ ở phải
                      ],
                      stops: [0.0, 0.5, 1.0],
                    ).createShader(bounds);
                  },
                  blendMode:
                      BlendMode.dstIn, // Kết hợp shader với nội dung container
                  child: Container(
                    width: double.infinity,
                    height: 90,
                    color: Colors.blueAccent.withOpacity(0.5),
                    child: const SingleChildScrollView(
                      child: Column(
                        children: [
                          Text(
                            'Invited you to join room',
                            style: TextStyle(color: Colors.white, fontSize: 18),
                          ),
                          Text(
                            'Ranked , 1 Vs 1',
                            style: TextStyle(color: Colors.white, fontSize: 18),
                          ),
                          Text(
                            'roomId: ',
                            style: TextStyle(color: Colors.white, fontSize: 13),
                          ),
                          Text(
                            'I hear you\'re strong! Want to team up?',
                            style: TextStyle(color: Colors.white, fontSize: 13),
                          ),
                        ],
                      ),
                    ),
                  ),
                ),
              ),
              const SizedBox(height: 20),
              Row(
                mainAxisAlignment: MainAxisAlignment.spaceEvenly,
                children: [
                  ElevatedButton(
                    onPressed: onPressedRefuse,
                    style: ElevatedButton.styleFrom(
                      backgroundColor: Colors.redAccent,
                      fixedSize: const Size(120, 30),
                    ),
                    child: const Text(
                      'Refuse',
                      style: TextStyle(color: Colors.white),
                    ),
                  ),
                  ElevatedButton(
                    onPressed: () {},
                    style: ElevatedButton.styleFrom(
                      backgroundColor: Colors.lightBlueAccent,
                      fixedSize: const Size(120, 30),
                    ),
                    child: const Text(
                      'Waiting',
                      style: TextStyle(color: Colors.white),
                    ),
                  ),
                  ElevatedButton(
                    onPressed: onPressedAccept,
                    style: ElevatedButton.styleFrom(
                      backgroundColor: Colors.yellow[700],
                      fixedSize: const Size(120, 30),
                    ),
                    child: const Text(
                      'Accept',
                      style: TextStyle(color: Colors.white),
                    ),
                  ),
                ],
              )
            ],
          ),
          Positioned(
            top: -10,
            right: -10,
            child: IconButton(
              onPressed: onPressedRefuse,
              icon: const Icon(
                Icons.cancel_outlined,
                size: 40,
                color: Colors.yellowAccent,
              ),
            ),
          ),
        ],
      ),
    );
  }
}

class CallInviteRequestDialog extends StatelessWidget {
  final UserModel friend;
  final Function() onPressedAccept;
  final Function() onPressedRefuse;
  final bool isVideoCall;
  final double height;
  final double width;
  const CallInviteRequestDialog(
      {super.key,
      required this.friend,
      required this.onPressedAccept,
      required this.onPressedRefuse,
      required this.isVideoCall,  this.height = 400,  this.width =400});

  @override
  Widget build(BuildContext context) {
    return Container(
      height: height,
      width: width,
      alignment: Alignment.center,
      // padding: const EdgeInsets.all(10.0),
      decoration: BoxDecoration(
        color: Colors.greenAccent.withOpacity(0.5),
        borderRadius: BorderRadius.circular(20),
        border: Border.all(color: Colors.white, width: 3),
      ),
      child: Column(
        children: [
          const Text(
            "Calling...",
            style: TextStyle(
              color: Colors.black,
              fontSize: 25,
              fontWeight: FontWeight.bold,
            ),
          ),
          const Divider(
            color: Colors.white,
          ),
          Row(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              CircleAvatar(
                backgroundImage: CachedNetworkImageProvider(friend.image!),
                radius: 30,
              ),
              const SizedBox(
                width: 5,
              ),
              Column(
                children: [
                  Text(
                    friend.name!,
                    style: const TextStyle(
                      fontWeight: FontWeight.bold,
                      fontSize: 20,
                      color: Colors.purple,
                    ),
                  ),
                  Row(
                    children: [
                      Image.asset(
                        TrimRanking.diamondTrim,
                        width: 25,
                      ),
                      const SizedBox(
                        width: 5,
                      ),
                      const Text(
                        "Master 1",
                        style: TextStyle(
                          fontSize: 15,
                          color: Colors.blueGrey,
                        ),
                      ),
                    ],
                  ),
                ],
              ),
            ],
          ),
          const Spacer(),
          Container(
            decoration: const BoxDecoration(
              border: Border(
                top: BorderSide(color: Colors.blue, width: 1), // Viền trên
                bottom: BorderSide(color: Colors.blue, width: 1), // Viền dưới
              ),
            ),
            child: ShaderMask(
              shaderCallback: (Rect bounds) {
                return const LinearGradient(
                  begin: Alignment.centerLeft,
                  end: Alignment.centerRight,
                  colors: [
                    Colors.transparent, // Màu mờ ở trái
                    Colors.black, // Màu rõ ở giữa
                    Colors.transparent, // Màu mờ ở phải
                  ],
                  stops: [0.0, 0.5, 1.0],
                ).createShader(bounds);
              },
              blendMode:
                  BlendMode.dstIn, // Kết hợp shader với nội dung container
              child: Container(
                width: double.infinity,
                height: 90,
                color: Colors.blueAccent.withOpacity(0.5),
                child: SingleChildScrollView(
                  child: Column(
                    children: [
                      Column(
                        children: [
                          Text(
                            isVideoCall
                                ? 'You have a video call'
                                : 'You have a voice call',
                            style: const TextStyle(
                              color: Colors.lightGreenAccent,
                              fontSize: 20,
                              fontWeight: FontWeight.bold,
                            ),
                          ),
                          Icon(
                            isVideoCall ? Icons.video_call : Icons.call_end,
                            size: 50,
                            color: Colors.greenAccent,
                          )
                        ],
                      ),
                    ],
                  ),
                ),
              ),
            ),
          ),
          const Spacer(),
          CallSlider(
            onAccept: onPressedAccept,
            onDecline: onPressedRefuse,
            isVideoCall: isVideoCall,
          ),
          const Spacer(),
        ],
      ),
    );
  }
}

```

---


### Components\placeholder_custom_widget.dart

```dart
import 'package:flutter/material.dart';
import 'package:tictactoe_gameapp/Configs/assets_path.dart';

class PlaceholderImageCustomWidget extends StatelessWidget {
  final double defaultHeight;
  const PlaceholderImageCustomWidget({super.key, this.defaultHeight = 100});

  @override
  Widget build(BuildContext context) {
    return LayoutBuilder(
      builder: (context, constraints) {
        double height = constraints.maxHeight.isFinite
            ? constraints.maxHeight
            : defaultHeight;
        return ClipRRect(
          borderRadius: BorderRadius.circular(12),
          child: Image.asset(
            GifsPath.loadingGif2,
            fit: BoxFit.cover,
            height: height,
            width: constraints.maxWidth,
          ),
        );
      },
    );
  }
}

```

---


### Components\primary_button.dart

```dart
import 'package:flutter/material.dart';

class PrimaryButton extends StatelessWidget {
  final String buttonText;
  final VoidCallback onTap;
  const PrimaryButton(
      {super.key, required this.buttonText, required this.onTap});

  @override
  Widget build(BuildContext context) {
    return InkWell(
      onTap: onTap,
      child: Container(
        height: 70,
        decoration: BoxDecoration(
          color: Theme.of(context).colorScheme.primary,
          borderRadius: BorderRadius.circular(20),
        ),
        child: Row(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Text(
              buttonText,
              style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                  color: Theme.of(context).colorScheme.primaryContainer),
            ),
          ],
        ),
      ),
    );
  }
}
```

---


### Components\primary_with_icon_button.dart

```dart
import 'package:flutter/material.dart';
import 'package:flutter_svg/flutter_svg.dart';
import 'package:tictactoe_gameapp/Configs/assets_path.dart';

class PrimaryIconWithButton extends StatelessWidget {
  final String buttonText;
  final VoidCallback onTap;
  final Color color;
  final String iconPath;
  final double? width;
  final double? height;
  final bool isLogo;
  const PrimaryIconWithButton(
      {super.key,
      this.width,
      this.height = 70.0,
      required this.buttonText,
      required this.onTap,
      required this.iconPath,
      required this.color,
      this.isLogo = false});

  @override
  Widget build(BuildContext context) {
    return InkWell(
      onTap: onTap,
      child: Container(
        height: height,
        width: width,
        decoration: BoxDecoration(
          color: color,
          borderRadius: BorderRadius.circular(20),
          boxShadow: const [
            BoxShadow(
              color: Colors.black38,
              blurRadius: 2.0,
              spreadRadius: 0.0,
              offset: Offset(3, 3),
            ),
          ],
        ),
        child: Row(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            isLogo
                ? Image.asset(
                    IconsPath.applogo,
                    width: 40,
                  )
                : SvgPicture.asset(
                    iconPath,
                    width: 40,
                  ),
            const SizedBox(
              width: 10,
            ),
            Text(
              buttonText,
              style: Theme.of(context).textTheme.headlineMedium?.copyWith(
                    color: Theme.of(context).colorScheme.primaryContainer,
                  ),
            ),
          ],
        ),
      ),
    );
  }
}

```

---


### Components\profile_tooltip_widget.dart

```dart
import 'package:flutter/material.dart';
import 'package:tictactoe_gameapp/Components/belong_to_users/avatar_user_widget.dart';
import 'package:tictactoe_gameapp/Configs/assets_path.dart';
import 'package:tictactoe_gameapp/Models/user_model.dart';

class ProfileTooltipCustom extends StatelessWidget {
  final UserModel friend;
  final VoidCallback onTapInfo;
  const ProfileTooltipCustom(
      {super.key, required this.friend, required this.onTapInfo});

  @override
  Widget build(BuildContext context) {
    return Container(
      padding: const EdgeInsets.all(10),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(20),
      ),
      width: 200,
      height: 150,
      child: SingleChildScrollView(
        child: Column(
          children: [
            GestureDetector(
              onTap: onTapInfo,
              child: AvatarUserWidget(
                radius: 30,
                imagePath: friend.image!,
                gradientColors:
                    friend.avatarFrame ?? ["#FFE0E0E0", "#FFB0BEC5"],
              ),
            ),
            const SizedBox(height: 5),
            Text(
              friend.name!,
              style: const TextStyle(
                fontWeight: FontWeight.bold,
                fontSize: 20,
                color: Colors.deepPurple,
              ),
            ),
            Text(friend.email!),
            const Divider(),
            Column(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                Text("Total Wins: ${friend.totalWins ?? "0"}"),
                Text("Total Coins: ${friend.totalCoins ?? "0"}"),
              ],
            ),
            const SizedBox(height: 5),
            Row(
              children: [
                const Text("Tier"),
                const Spacer(flex: 3),
                Image.asset(
                  TrimRanking.diamondTrim,
                  width: 40,
                ),
                const Spacer(flex: 1),
                const Text("Master 1"),
              ],
            ),
            const SizedBox(height: 5),
            SingleChildScrollView(
              scrollDirection: Axis.horizontal,
              child: Row(
                children: [
                  const Text("Recently"),
                  const SizedBox(
                    width: 10,
                  ),
                  ClipRRect(
                    borderRadius: BorderRadius.circular(50),
                    child: Image.asset(
                      ChampionsPathA.aatrox,
                      width: 40,
                    ),
                  ),
                  const SizedBox(
                    width: 5,
                  ),
                  ClipRRect(
                    borderRadius: BorderRadius.circular(50),
                    child: Image.asset(
                      ChampionsPathA.ahri,
                      width: 40,
                    ),
                  ),
                  const SizedBox(
                    width: 5,
                  ),
                  ClipRRect(
                    borderRadius: BorderRadius.circular(50),
                    child: Image.asset(
                      ChampionsPathA.akali,
                      width: 40,
                    ),
                  ),
                ],
              ),
            ),
            const Divider(
              color: Colors.blueGrey,
            ),
            SingleChildScrollView(
              scrollDirection: Axis.horizontal,
              child: Row(
                children: [
                  IconButton(
                    onPressed: onTapInfo,
                    icon: const Icon(
                      Icons.info,
                      size: 30,
                      color: Colors.blueAccent,
                    ),
                  ),
                  IconButton(
                    onPressed: () {},
                    icon: const Icon(
                      Icons.circle_notifications,
                      size: 30,
                      color: Colors.blueAccent,
                    ),
                  ),
                  IconButton(
                    onPressed: () {},
                    icon: const Icon(
                      Icons.flag,
                      size: 30,
                      color: Colors.blueAccent,
                    ),
                  ),
                  IconButton(
                    onPressed: () {},
                    icon: const Icon(
                      Icons.message_outlined,
                      color: Colors.blueAccent,
                      size: 30,
                    ),
                  ),
                  IconButton(
                    onPressed: () {},
                    icon: const Icon(
                      Icons.person_add_alt,
                      size: 30,
                      color: Colors.blueAccent,
                    ),
                  ),
                ],
              ),
            )
          ],
        ),
      ),
    );
  }
}

```

---


### Components\user_card.dart

```dart
import 'package:flutter/material.dart';
import 'package:flutter_svg/svg.dart';
import 'package:get/get.dart';
import 'package:tictactoe_gameapp/Components/belong_to_users/avatar_user_widget.dart';
import 'package:tictactoe_gameapp/Controller/Animations/Overlays/profile_tooltip.dart';
import 'package:tictactoe_gameapp/Controller/auth_controller.dart';
import 'package:tictactoe_gameapp/Enums/popup_position.dart';
import 'package:tictactoe_gameapp/Models/user_model.dart';

import '../Configs/assets_path.dart';

class UserCard extends StatelessWidget {
  final UserModel user;
  final String status;

  const UserCard({
    super.key,
    required this.user,
    required this.status,
  });

  @override
  Widget build(BuildContext context) {
    final w = MediaQuery.of(context).size.width;
    final AuthController authController = Get.find();
    final ProfileTooltip profileTooltip = Get.put(ProfileTooltip());
    final GlobalKey itemKey = GlobalKey();
    return Stack(
      clipBehavior: Clip.none,
      children: [
        Container(
          width: w / 2.6,
          height: 160,
          decoration: BoxDecoration(
            color: Theme.of(context).colorScheme.primaryContainer,
            borderRadius: BorderRadius.circular(20),
            border: Border.all(
              color: user.email == authController.getCurrentUserEmail()
                  ? Colors.blueAccent
                  : Colors.redAccent,
              width: 2,
            ),
          ),
          child: Column(
            children: [
              const SizedBox(height: 50),
              Text(
                user.name ?? '',
                maxLines: 1,
                overflow: TextOverflow.ellipsis,
                style: Theme.of(context).textTheme.titleLarge!.copyWith(
                      color: user.email == authController.getCurrentUserEmail()
                          ? Colors.blueAccent
                          : Colors.redAccent,
                      fontWeight: FontWeight.bold,
                    ),
              ),
              Text(
                user.role ?? '',
                style: Theme.of(context)
                    .textTheme
                    .bodyMedium!
                    .copyWith(color: Colors.grey),
              ),
              const SizedBox(height: 10),
              Row(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  SvgPicture.asset(
                    IconsPath.coinIcon,
                    width: 20,
                  ),
                  const SizedBox(width: 10),
                  Text(
                    "${user.totalCoins ?? "00"} Coins",
                    style: Theme.of(context).textTheme.bodyMedium!.copyWith(
                          color:
                              user.email == authController.getCurrentUserEmail()
                                  ? Colors.blueAccent
                                  : Colors.redAccent,
                        ),
                  ),
                ],
              ),
              status == ""
                  ? const SizedBox()
                  : status == "ready"
                      ? Row(
                          mainAxisAlignment: MainAxisAlignment.center,
                          children: [
                            const Icon(
                              Icons.done,
                              color: Colors.green,
                              size: 20,
                            ),
                            const SizedBox(width: 10),
                            Text(status),
                          ],
                        )
                      : Row(
                          mainAxisAlignment: MainAxisAlignment.center,
                          children: [
                            const Icon(
                              Icons.watch_later_outlined,
                              color: Colors.orange,
                              size: 20,
                            ),
                            const SizedBox(width: 10),
                            Text(status),
                          ],
                        ),
            ],
          ),
        ),
        Positioned(
          bottom: 50,
          left: w / 2.6 / 2 - 110,
          child: Image.asset(
            BorderRanking.challBorder,
            width: 220,
          ),
        ),
        Positioned(
          top: -50,
          left: w / 2.6 / 2 - 50,
          child: GestureDetector(
            key: itemKey,
            onTap: () => profileTooltip.showProfileTooltip(
              context,
              itemKey,
              user,
              PopupPosition.above,
              null,
              null,
              null,
              // user.email == authController.getCurrentUserEmail()
              //     ? Colors.lightBlueAccent
              //     : Colors.redAccent,
            ),
            child: Container(
              width: 95,
              height: 95,
              decoration: BoxDecoration(
                  color: Theme.of(context).colorScheme.secondary,
                  shape: BoxShape.circle),
              child: AvatarUserWidget(
                radius: 40,
                imagePath: user.image!,
                gradientColors: user.avatarFrame,
              ),
            ),
          ),
        ),
      ],
    );
  }
}

```

---


### Components\belong_to_users\avatar_user_widget.dart

```dart
import 'package:cached_network_image/cached_network_image.dart';
import 'package:flutter/material.dart';
import 'package:flutter_animate/flutter_animate.dart';
import 'package:tictactoe_gameapp/Models/Functions/color_string_reverse_function.dart';

class AvatarUserWidget extends StatelessWidget {
  final double radius;
  final String imagePath;
  final List<String>? gradientColors;
  final double borderThickness;

  const AvatarUserWidget({
    super.key,
    required this.radius,
    required this.imagePath,
    this.gradientColors,
    this.borderThickness = 3,
  });

  @override
  Widget build(BuildContext context) {
    return gradientColors != null && gradientColors!.isNotEmpty
        ? Container(
            width: radius * 2,
            height: radius * 2,
            padding: EdgeInsets.all(borderThickness),
            decoration: BoxDecoration(
              shape: BoxShape.circle,
              gradient: LinearGradient(
                colors: gradientColors!
                    .map((hex) => ColorStringReverseFunction.hexToColor(hex))
                    .toList(),
                begin: Alignment.topLeft,
                end: Alignment.bottomRight,
              ),
            ),
            child: ClipOval(
              child: CachedNetworkImage(
                imageUrl: imagePath,
                placeholder: (context, url) => _buildPlacholderWidget(),
                errorWidget: (context, url, error) => _buildErrorWidget(),
                fit: BoxFit.cover,
                width: radius * 2 - borderThickness * 2,
                height: radius * 2 - borderThickness * 2,
              ),
            ),
          )
        : ClipOval(
            child: CachedNetworkImage(
              imageUrl: imagePath,
              placeholder: (context, url) => _buildPlacholderWidget(),
              errorWidget: (context, url, error) => _buildErrorWidget(),
              fit: BoxFit.cover,
              width: radius * 2,
              height: radius * 2,
            ),
          );
  }

  Widget _buildPlacholderWidget() {
    return ColoredBox(
      color: Colors.blueAccent,
      child: Icon(
        Icons.person,
        size: radius,
        color: Colors.deepPurple[100],
      ),
    ).animate(onPlay: (controller) => controller.repeat(reverse: true)).shimmer(
          delay: 400.ms,
          duration: 1800.ms,
          colors: [Colors.deepPurple[100]!, Colors.deepPurple[50]!],
          size: 1.8,
          blendMode: BlendMode.srcATop,
        );
  }

  Widget _buildErrorWidget() {
    return ColoredBox(
      color: Colors.blueGrey,
      child: Icon(
        Icons.error,
        size: radius,
        color: Colors.red,
      ),
    );
  }
}

```

---


### Components\customized_widgets\draggble_fab_widget.dart

```dart
import 'dart:async';
import 'package:flutter/material.dart';
import 'package:get/get.dart';

class DraggableFloatingActionButton extends StatelessWidget {
  final Widget child;
  final Function()? onPressed;

  // Khởi tạo controller

  const DraggableFloatingActionButton({
    super.key,
    required this.child,
    this.onPressed,
  });

  @override
  Widget build(BuildContext context) {
    final DraggableFABController controller = Get.put(DraggableFABController());
    final maxWidth = MediaQuery.of(context).size.width;
    final maxHeight = MediaQuery.of(context).size.height;

    return Obx(() {
      // Lấy vị trí từ controller
      double left = controller.posX.value;
      double top = controller.posY.value;

      // Điều chỉnh vị trí khi button bị ẩn một nửa
      if (controller.isHalfHidden.value) {
        if (left < 0) left = -controller.buttonSize / 2; // Cạnh trái
        if (left > maxWidth - controller.buttonSize / 2) {
          left = maxWidth - controller.buttonSize / 2; // Cạnh phải
        }
        if (top < 0) top = -controller.buttonSize / 2; // Cạnh trên
        if (top > maxHeight - controller.buttonSize / 2) {
          top = maxHeight - controller.buttonSize / 2; // Cạnh dưới
        }
      }

      return Positioned(
        left: left,
        top: top,
        child: GestureDetector(
          // Khi bắt đầu kéo
          onPanStart: (_) {
            controller.isDragging.value = true;
            controller.resetHideTimer();
          },
          // Khi đang kéo
          onPanUpdate: (details) {
            controller.updatePosition(details, maxWidth, maxHeight);
          },
          // Khi kết thúc kéo
          onPanEnd: (_) {
            controller.onPanEnd(maxWidth, maxHeight);
          },
          // Xử lý nhấn button
          onTap: () {
            if (!controller.isDragging.value && onPressed != null) {
              onPressed!();
            }
          },
          child: FloatingActionButton(
            splashColor: Colors.white,
            backgroundColor: controller.isDragging.value
                ? Colors.blueGrey
                : Colors.blueAccent,
            onPressed: null, // Đã xử lý ở onTap của GestureDetector
            child: child,
          ),
        ),
      );
    });
  }
}

class DraggableFABController extends GetxController {
  // Vị trí của button
  final RxDouble posX = 391.0.obs; // Vị trí mặc định ban đầu
  final RxDouble posY = 661.0.obs;

  // Trạng thái kéo và ẩn
  final RxBool isDragging = false.obs;
  final RxBool isHalfHidden = false.obs;

  // Kích thước button (giả sử là 56dp, có thể thay đổi)
  final double buttonSize = 56.0;

  // Timer để đếm thời gian không tương tác
  Timer? _hideTimer;

  // Bắt đầu đếm thời gian để ẩn button sau 5 giây
  void startHideTimer() {
    _hideTimer?.cancel();
    _hideTimer = Timer(const Duration(seconds: 5), () {
      isHalfHidden.value = true;
      // Mặc định ẩn vào cạnh phải
      posX.value = Get.width - buttonSize / 2;
    });
  }

  // Reset timer khi có tương tác
  void resetHideTimer() {
    isHalfHidden.value = false;
    startHideTimer();
  }

  // Cập nhật vị trí khi kéo
  void updatePosition(
      DragUpdateDetails details, double maxWidth, double maxHeight) {
    posX.value =
        (posX.value + details.delta.dx).clamp(0.0, maxWidth - buttonSize);
    posY.value =
        (posY.value + details.delta.dy).clamp(0.0, maxHeight - buttonSize);
    resetHideTimer();
  }

  // Xử lý khi kết thúc kéo
  void onPanEnd(double maxWidth, double maxHeight) {
    isDragging.value = false;
    // Kiểm tra vị trí để ẩn một nửa button nếu gần cạnh
    if (posX.value < buttonSize / 2) {
      posX.value = -buttonSize / 2; // Ẩn vào cạnh trái
      isHalfHidden.value = true;
    } else if (posX.value > maxWidth - buttonSize / 2) {
      posX.value = maxWidth - buttonSize / 2; // Ẩn vào cạnh phải
      isHalfHidden.value = true;
    } else if (posY.value < buttonSize / 2) {
      posY.value = -buttonSize / 2; // Ẩn vào cạnh trên
      isHalfHidden.value = true;
    } else if (posY.value > maxHeight - buttonSize / 2) {
      posY.value = maxHeight - buttonSize / 2; // Ẩn vào cạnh dưới
      isHalfHidden.value = true;
    } else {
      startHideTimer(); // Nếu không gần cạnh, bắt đầu đếm 5 giây
    }
  }

  @override
  void onClose() {
    _hideTimer?.cancel();
    super.onClose();
  }
}

```

---


### Components\customized_widgets\slide_to_confirm_widget.dart

```dart
import 'package:flutter/material.dart';
import 'package:get/get.dart';

class CallSliderController extends GetxController {
  // Vị trí kéo (từ -120 đến 120)
  var dragPosition = 0.0.obs;

  // Hàm xử lý cập nhật vị trí kéo
  void updateDragPosition(double delta) {
    dragPosition.value += delta;

    // Giới hạn vị trí kéo
    if (dragPosition.value > 120) {
      dragPosition.value = 120;
    } else if (dragPosition.value < -120) {
      dragPosition.value = -120;
    }
  }

  // Hàm xử lý khi người dùng kết thúc kéo
  void onDragEnd({
    required VoidCallback onAccept,
    required VoidCallback onDecline,
  }) {
    if (dragPosition.value > 100) {
      onAccept();
    } else if (dragPosition.value < -100) {
      onDecline();
    } else {
      resetDragPosition();
    }
  }

  // Hàm reset vị trí kéo
  void resetDragPosition() {
    dragPosition.value = 0.0;
  }
}

class CallSlider extends StatelessWidget {
  final VoidCallback onAccept;
  final VoidCallback onDecline;
  final bool isVideoCall;

  const CallSlider({
    super.key,
    required this.onAccept,
    required this.onDecline,
    required this.isVideoCall,
  });

  @override
  Widget build(BuildContext context) {
    final CallSliderController controller = Get.put(CallSliderController());

    return Center(
      child: Container(
        width: 300,
        height: 80,
        decoration: BoxDecoration(
          gradient: LinearGradient(
            colors: [Colors.grey[300]!, Colors.grey[400]!, Colors.grey[300]!],
            begin: Alignment.topLeft,
            end: Alignment.bottomRight,
          ),
          borderRadius: BorderRadius.circular(40),
          boxShadow: const [
            BoxShadow(
              color: Colors.black26,
              blurRadius: 6,
              offset: Offset(0, 2),
            ),
          ],
        ),
        child: Stack(
          alignment: Alignment.center,
          clipBehavior: Clip.none,
          children: [
            // Text for Decline and Accept
            const Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                Padding(
                  padding: EdgeInsets.only(left: 16),
                  child: Text(
                    "Decline",
                    style: TextStyle(
                        color: Colors.red, fontWeight: FontWeight.bold),
                  ),
                ),
                Padding(
                  padding: EdgeInsets.only(right: 16),
                  child: Text(
                    "Accept",
                    style: TextStyle(
                        color: Colors.green, fontWeight: FontWeight.bold),
                  ),
                ),
              ],
            ),

            // Sliding Ball with Animation
            Obx(() {
              return AnimatedPositioned(
                duration: const Duration(milliseconds: 300),
                curve: Curves.easeOut,
                left: 115 + controller.dragPosition.value,
                child: GestureDetector(
                  onHorizontalDragUpdate: (details) {
                    controller.updateDragPosition(details.delta.dx);
                  },
                  onHorizontalDragEnd: (details) {
                    controller.onDragEnd(
                      onAccept: onAccept,
                      onDecline: onDecline,
                    );
                  },
                  child: Transform.rotate(
                    angle: controller.dragPosition.value / 120,
                    child: Container(
                      width: 70,
                      height: 70,
                      decoration: const BoxDecoration(
                        shape: BoxShape.circle,
                        color: Colors.white,
                        boxShadow: [
                          BoxShadow(
                            color: Colors.black26,
                            blurRadius: 6,
                            offset: Offset(0, 2),
                          ),
                        ],
                      ),
                      child: isVideoCall
                          ? Icon(
                              Icons.video_call_rounded,
                              color: controller.dragPosition.value != 0
                                  ? controller.dragPosition.value > 0
                                      ? Colors.blue
                                      : Colors.red
                                  : Colors.black,
                              size: 36,
                            )
                          : Icon(
                              Icons.phone,
                              color: controller.dragPosition.value != 0
                                  ? controller.dragPosition.value > 0
                                      ? Colors.green
                                      : Colors.red
                                  : Colors.black,
                              size: 36,
                            ),
                    ),
                  ),
                ),
              );
            }),
          ],
        ),
      ),
    );
  }
}

```

---


### Components\customized_widgets\tts_change_setting_widget.dart

```dart
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:tictactoe_gameapp/Controller/text_to_speech_controller.dart';

class TtsChangeSettingWidget extends StatelessWidget {
  final TextToSpeechController ttsController;
  const TtsChangeSettingWidget({super.key, required this.ttsController});

  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        Row(
          mainAxisAlignment: MainAxisAlignment.spaceBetween,
          children: [
            Expanded(
              child: Obx(
                () => SwitchListTile(
                  title: const Text("Echo Mode"),
                  value: ttsController.isEchoMode.value,
                  onChanged: (bool value) {
                    ttsController.isEchoMode.value = value;
                    if (value) {
                      ttsController.isAlexaMode.value = false;
                    }
                  },
                ),
              ),
            ),
            Expanded(
              child: Obx(
                () => SwitchListTile(
                  title: const Text("Alexa Mode"),
                  value: ttsController.isAlexaMode.value,
                  onChanged: (bool value) {
                    ttsController.isAlexaMode.value = value;
                    if (value) {
                      ttsController.isEchoMode.value = false;
                    }
                  },
                ),
              ),
            ),
          ],
        ),
        const SizedBox(height: 16),
        Obx(() => Slider(
              value: ttsController.volume.value,
              onChanged: ttsController.setVolume,
              min: 0.0,
              max: 1.0,
              divisions: 10,
              label: "Volume: ${ttsController.volume.value}",
            )),
        Obx(() => Slider(
              value: ttsController.pitch.value,
              onChanged: ttsController.setPitch,
              min: 0.5,
              max: 2.0,
              divisions: 15,
              label: "Pitch: ${ttsController.pitch.value}",
            )),
        Obx(() => Slider(
              value: ttsController.rate.value,
              onChanged: ttsController.setRate,
              min: 0.0,
              max: 1.0,
              divisions: 10,
              label: "Rate: ${ttsController.rate.value}",
            )),
      ],
    );
  }
}

```

---


### Components\daily_gift\daily_gift_page.dart

```dart
import 'package:flutter/material.dart';
import 'package:flutter_svg/flutter_svg.dart';
import 'package:get/get.dart';
import 'package:tictactoe_gameapp/Configs/assets_path.dart';
import 'package:tictactoe_gameapp/Configs/messages.dart';
import 'package:tictactoe_gameapp/Components/daily_gift/daily_reward_controller.dart';
import 'package:tictactoe_gameapp/Components/daily_gift/reward_model.dart';

class DailyRewardPage extends StatelessWidget {
  const DailyRewardPage({super.key});

  @override
  Widget build(BuildContext context) {
    final DailyRewardController controller = Get.put(DailyRewardController());
    const List<String> heroGifts = [
      ChampionsPathA.ahri,
      ChampionsPathA.akali,
      ChampionsPathA.aphelios,
      ChampionsPathA.annie,
    ];
    return Center(
      child: Stack(
        clipBehavior: Clip.none,
        children: [
          Container(
            height: 400,
            width: 400,
            padding: const EdgeInsets.all(20),
            decoration: BoxDecoration(
              gradient: const LinearGradient(
                  colors: [Colors.purpleAccent, Colors.deepPurpleAccent]),
              borderRadius: BorderRadius.circular(20),
              border: Border.all(width: 10, color: Colors.blueAccent),
            ),
            child: Column(
              children: [
                const Text(
                  "Return tomorrow for the next reward!",
                  textAlign: TextAlign.center,
                  style: TextStyle(
                    color: Colors.white,
                    fontSize: 20,
                    fontWeight: FontWeight.bold,
                  ),
                ),
                const Divider(
                  color: Colors.white,
                  thickness: 3.0,
                ),
                Expanded(
                  child: Obx(() {
                    return GridView.builder(
                      gridDelegate:
                          const SliverGridDelegateWithFixedCrossAxisCount(
                        crossAxisCount: 4,
                        mainAxisSpacing: 10,
                        crossAxisSpacing: 10,
                      ),
                      itemCount: controller.rewards.length,
                      itemBuilder: (context, index) {
                        final reward = controller.rewards[index];
                        final isToday = controller.isToday(reward.date);
                        final isPast = controller.isPast(reward.date);
                        Color backgroundColor;
                        if (isToday) {
                          backgroundColor = Colors.blue; // Ngày hiện tại
                        } else if (isPast) {
                          backgroundColor = Colors.grey[400]!; // Ngày trước đó
                        } else {
                          backgroundColor =
                              Colors.lightGreen; // Ngày trong tương lai
                        }
                        return GestureDetector(
                          onTap: () async {
                            if (!reward.isCollected && isToday) {
                              await controller.collectReward(index);
                              successMessage(
                                  "Congratulation! You received ${reward.date.day}");
                            } else if (reward.isCollected) {
                              errorMessage(
                                  "You've already collected this reward!");
                            } else {
                              errorMessage(
                                  "This reward is not available today!");
                            }
                          },
                          child: reward.isCollected
                              ? ClipRect(
                                  clipBehavior: Clip.antiAlias,
                                  child: Banner(
                                      message: "Done",
                                      location: BannerLocation.topStart,
                                      color: Colors.blueAccent,
                                      child: Container(
                                        decoration: BoxDecoration(
                                          color: reward.isCollected
                                              ? Colors.blueGrey
                                              : backgroundColor,
                                          borderRadius:
                                              BorderRadius.circular(10),
                                          border: isToday
                                              ? Border.all(
                                                  color: reward.isCollected
                                                      ? Colors.redAccent
                                                      : Colors.white,
                                                  width: 4)
                                              : null,
                                        ),
                                        child: reward.rewardType ==
                                                RewardType.coin
                                            ? Column(
                                                mainAxisAlignment:
                                                    MainAxisAlignment.center,
                                                children: [
                                                  Text(
                                                    "${reward.date.day}00",
                                                    style: const TextStyle(
                                                      color:
                                                          Colors.yellowAccent,
                                                      fontSize: 18,
                                                      fontWeight:
                                                          FontWeight.bold,
                                                    ),
                                                  ),
                                                  SvgPicture.asset(
                                                    IconsPath.coinIcon,
                                                    colorFilter:
                                                        const ColorFilter
                                                            .linearToSrgbGamma(),
                                                  )
                                                ],
                                              )
                                            : ClipRRect(
                                                borderRadius:
                                                    BorderRadius.circular(10),
                                                child: Image.asset(
                                                  heroGifts[
                                                      index % heroGifts.length],
                                                  fit: BoxFit.cover,
                                                  width: 20,
                                                ),
                                              ),
                                      )),
                                )
                              : Container(
                                  decoration: BoxDecoration(
                                    color: reward.isCollected
                                        ? Colors.blueGrey
                                        : backgroundColor,
                                    borderRadius: BorderRadius.circular(10),
                                    border: isToday
                                        ? Border.all(
                                            color: reward.isCollected
                                                ? Colors.redAccent
                                                : Colors.white,
                                            width: 4)
                                        : null,
                                  ),
                                  child: reward.rewardType == RewardType.coin
                                      ? Column(
                                          mainAxisAlignment:
                                              MainAxisAlignment.center,
                                          children: [
                                            Text(
                                              "${reward.date.day}00",
                                              style: const TextStyle(
                                                color: Colors.yellowAccent,
                                                fontSize: 18,
                                                fontWeight: FontWeight.bold,
                                              ),
                                            ),
                                            SvgPicture.asset(
                                              IconsPath.coinIcon,
                                              colorFilter: const ColorFilter
                                                  .linearToSrgbGamma(),
                                            )
                                          ],
                                        )
                                      : ClipRRect(
                                          borderRadius:
                                              BorderRadius.circular(10),
                                          child: Image.asset(
                                            heroGifts[index % heroGifts.length],
                                            fit: BoxFit.cover,
                                            width: 20,
                                          ),
                                        ),
                                ),
                        );
                      },
                    );
                  }),
                ),
              ],
            ),
          ),
          Positioned(
            bottom: -15,
            left: 130,
            right: 130,
            child: Container(
              height: 50,
              alignment: Alignment.center,
              decoration: BoxDecoration(
                  color: Colors.green,
                  borderRadius: BorderRadius.circular(20),
                  border: Border.all(color: Colors.greenAccent, width: 3),
                  boxShadow: const [
                    BoxShadow(
                      spreadRadius: 2.0,
                      color: Colors.greenAccent,
                      blurRadius: 15.0,
                      offset: Offset(3, 3),
                    ),
                    BoxShadow(
                      spreadRadius: 2.0,
                      color: Colors.greenAccent,
                      blurRadius: 15.0,
                      offset: Offset(-3, -3),
                    ),
                  ]),
              child: const Text(
                "Claim",
                style: TextStyle(
                  color: Colors.white,
                  fontSize: 20,
                  fontWeight: FontWeight.bold,
                ),
              ),
            ),
          ),
          Positioned(
            top: -20,
            left: 50,
            right: 50,
            child: Stack(
              clipBehavior: Clip.none,
              children: [
                Container(
                  alignment: Alignment.center,
                  height: 50,
                  decoration: BoxDecoration(
                    color: Colors.lightBlueAccent,
                    borderRadius: BorderRadius.circular(20),
                    border: Border.all(color: Colors.white, width: 5),
                  ),
                  child: const Text(
                    "Reward Calendar",
                    style: TextStyle(
                      color: Colors.white,
                      fontSize: 25,
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                ),
                Positioned(
                  top: -30,
                  left: 50,
                  right: 50,
                  child: Container(
                    alignment: Alignment.center,
                    height: 35,
                    decoration: BoxDecoration(
                      color: Colors.purpleAccent[400],
                      borderRadius: BorderRadius.circular(20),
                      border: Border.all(color: Colors.white, width: 3),
                    ),
                    child: Obx(() => Text(
                          "${controller.today.value.day.toString()}-${controller.today.value.month.toString()}-${controller.today.value.year.toString()}",
                          style: const TextStyle(
                            color: Colors.white,
                            fontSize: 25,
                            fontWeight: FontWeight.bold,
                          ),
                        )),
                  ),
                ),
              ],
            ),
          ),
          Positioned(
            top: -30,
            right: -30,
            child: IconButton(
              onPressed: () {
                Get.back();
              },
              icon: const Icon(
                Icons.cancel,
                size: 40,
                color: Colors.redAccent,
              ),
            ),
          ),
        ],
      ),
    );
  }
}

```

---


### Components\daily_gift\daily_reward_controller.dart

```dart
import 'package:get/get.dart';
import 'package:tictactoe_gameapp/Components/daily_gift/daily_reward_storage.dart';
import 'package:tictactoe_gameapp/Components/daily_gift/reward_model.dart';

class DailyRewardController extends GetxController {
  final rewards = <Reward>[].obs;
  final today = DateTime.now().obs;
  final RewardStorage rewardStorage = RewardStorage(); // Sử dụng RewardStorage

  @override
  void onInit() {
    super.onInit();
    rewardStorage
        .checkAndClearOldRewards(today.value); // Kiểm tra và xóa phần thưởng cũ
    loadRewards();
    ever(today, (_) => loadRewards()); // Tải lại phần thưởng khi ngày thay đổi
    updateToday(); // Cập nhật ngày hiện tại ngay khi init
  }

  // Tải trạng thái phần thưởng
  void loadRewards() {
    final currentMonth = today.value.month;
    final currentYear = today.value.year;

    // Nếu danh sách chưa có dữ liệu, tạo phần thưởng theo tháng
    if (rewards.isEmpty) {
      rewards.value = generateMonthlyRewards(currentYear, currentMonth);
    }

    // Lấy danh sách ngày đã nhận phần thưởng trong tháng
    final collectedRewards =
        rewardStorage.loadCollectedRewards(currentMonth, currentYear);

    // Cập nhật trạng thái phần thưởng đã nhận
    for (var reward in rewards) {
      reward.isCollected = collectedRewards.contains(reward.date);
    }
  }

  // Hàm cập nhật ngày hiện tại
  void updateToday() {
    final now = DateTime.now();
    if (now.day != today.value.day ||
        now.month != today.value.month ||
        now.year != today.value.year) {
      today.value = now; // Chỉ cập nhật khi ngày thay đổi
      rewardStorage
          .checkAndClearOldRewards(today.value); // Xóa phần thưởng cũ nếu cần
      loadRewards(); // Tải lại phần thưởng cho tháng mới
    }
  }

  // Hàm nhận phần thưởng
  Future<void> collectReward(int index) async {
    final reward = rewards[index];
    if (isToday(reward.date) && !reward.isCollected) {
      reward.isCollected = true;
      rewardStorage.saveRewardCollected(reward.date); // Lưu phần thưởng đã nhận
      rewards.refresh(); // Cập nhật lại danh sách phần thưởng
    }
  }

  // Kiểm tra xem ngày hiện tại có trùng với ngày phần thưởng hay không
  bool isToday(DateTime date) {
    final now = today.value;
    return date.day == now.day &&
        date.month == now.month &&
        date.year == now.year;
  }

  // Kiểm tra nếu ngày thuộc về quá khứ
  bool isPast(DateTime date) {
    return date.isBefore(today.value);
  }

  // Kiểm tra nếu ngày thuộc về tương lai
  bool isFuture(DateTime date) {
    return date.isAfter(today.value);
  }

  // Tạo danh sách phần thưởng theo tháng
  List<Reward> generateMonthlyRewards(int year, int month) {
    int daysInMonth = DateTime(year, month + 1, 0).day;

    // Tạo danh sách phần thưởng cho mỗi ngày trong tháng
    return List.generate(daysInMonth, (index) {
      late final RewardType type;

      // Cứ mỗi ngày thứ 7, 14, 21, 28 thì phần thưởng sẽ là hero, còn lại là coin
      if ((index + 1) % 7 == 0) {
        type = RewardType.hero;
      } else {
        type = RewardType.coin;
      }

      return Reward(
        date: DateTime(year, month, index + 1),
        rewardType: type,
      );
    });
  }
}

```

---


### Components\daily_gift\daily_reward_storage.dart

```dart
import 'package:get_storage/get_storage.dart';

class RewardStorage {
  final GetStorage _box = GetStorage();

  // Lưu trạng thái đã nhận phần thưởng trong ngày hôm nay
  void saveRewardCollected(DateTime date) {
    final key = 'reward_${date.day}_${date.month}_${date.year}';
    _box.write(key, true);
    _box.write('last_saved_month', date.month); // Lưu tháng hiện tại để theo dõi
  }

  // Kiểm tra trạng thái đã nhận phần thưởng của ngày
  bool isRewardCollected(DateTime date) {
    final key = 'reward_${date.day}_${date.month}_${date.year}';
    return _box.read(key) ?? false;
  }

  // Tải tất cả các phần thưởng đã nhận trong tháng
  Set<DateTime> loadCollectedRewards(int month, int year) {
    Set<DateTime> collectedDates = {};
    for (int day = 1; day <= DateTime(year, month + 1, 0).day; day++) {
      final date = DateTime(year, month, day);
      if (isRewardCollected(date)) {
        collectedDates.add(date);
      }
    }
    return collectedDates;
  }

  // Xóa tất cả các phần thưởng đã lưu của tháng trước
  void clearPreviousMonthRewards(int currentMonth, int currentYear) {
    // Lấy tháng đã lưu cuối cùng
    final lastSavedMonth = _box.read('last_saved_month') ?? currentMonth;

    // Nếu tháng mới khác với tháng cuối cùng đã lưu, xóa dữ liệu của tháng trước
    if (lastSavedMonth != currentMonth) {
      // Xóa phần thưởng của tháng trước
      for (int day = 1; day <= DateTime(currentYear, lastSavedMonth + 1, 0).day; day++) {
        final oldKey = 'reward_${day}_${lastSavedMonth}_$currentYear';
        _box.remove(oldKey); // Xóa các phần thưởng đã lưu của tháng trước
      }
      _box.write('last_saved_month', currentMonth); // Cập nhật lại tháng hiện tại sau khi xóa
    }
  }

  // Hàm kiểm tra và xóa phần thưởng của tháng trước nếu cần
  void checkAndClearOldRewards(DateTime currentDate) {
    clearPreviousMonthRewards(currentDate.month, currentDate.year);
  }
}

```

---


### Components\daily_gift\reward_model.dart

```dart
class Reward {
  final DateTime date;
  bool isCollected;
  final RewardType rewardType;

  Reward({
    required this.date,
    required this.rewardType,
    this.isCollected = false,
  });
}

enum RewardType {
  coin,
  hero,
  diamond,
}

```

---


### Components\daily_mission\constant_data.dart

```dart
import 'package:tictactoe_gameapp/Components/daily_mission/mission_model.dart';

final List<TaskModel> dailyMissions = [
  TaskModel(
    id: 'daily1',
    name: 'Complete 5 games',
    description: 'Play and complete 5 matches in any mode.',
    type: 'daily',
    reward: 50,
    status: 'incomplete',
    progress: 2, // Ví dụ: đã hoàn thành 2 trận
    goal: 5,     // Mục tiêu: hoàn thành 5 trận
    createdAt: DateTime.now(),
    updatedAt: DateTime.now(),
    deadline: DateTime.now().add(const Duration(hours: 24)),
  ),
  TaskModel(
    id: 'daily2',
    name: 'Win 3 matches',
    description: 'Win 3 matches in ranked mode.',
    type: 'daily',
    reward: 100,
    status: 'incomplete',
    progress: 1, // Ví dụ: đã thắng 1 trận
    goal: 3,     // Mục tiêu: thắng 3 trận
    createdAt: DateTime.now(),
    updatedAt: DateTime.now(),
    deadline: DateTime.now().add(const Duration(hours: 24)),
  ),
  TaskModel(
    id: 'daily3',
    name: 'Play for 30 minutes',
    description: 'Spend at least 30 minutes in the game today.',
    type: 'daily',
    reward: 20,
    status: 'incomplete',
    progress: 15, // Đã chơi 15 phút
    goal: 30,     // Mục tiêu: chơi 30 phút
    createdAt: DateTime.now(),
    updatedAt: DateTime.now(),
    deadline: DateTime.now().add(const Duration(hours: 24)),
  ),
  TaskModel(
    id: 'daily4',
    name: 'Score 50 points',
    description: 'Accumulate 50 points in any game mode.',
    type: 'daily',
    reward: 40,
    status: 'incomplete',
    progress: 25, // Đã tích lũy 25 điểm
    goal: 50,     // Mục tiêu: tích lũy 50 điểm
    createdAt: DateTime.now(),
    updatedAt: DateTime.now(),
    deadline: DateTime.now().add(const Duration(hours: 24)),
  ),
  TaskModel(
    id: 'daily5',
    name: 'Invite a friend',
    description: 'Invite a friend to play and complete a match together.',
    type: 'daily',
    reward: 30,
    status: 'incomplete',
    progress: 0,  // Chưa mời bạn nào
    goal: 1,      // Mục tiêu: mời 1 bạn
    createdAt: DateTime.now(),
    updatedAt: DateTime.now(),
    deadline: DateTime.now().add(const Duration(hours: 24)),
  ),
];

final List<TaskModel> weeklyMissions = [
  TaskModel(
    id: 'weekly1',
    name: 'Win 10 ranked matches',
    description: 'Win 10 matches in ranked mode this week.',
    type: 'weekly',
    reward: 500,
    status: 'incomplete',
    progress: 4,  // Đã thắng 4 trận
    goal: 10,     // Mục tiêu: thắng 10 trận
    createdAt: DateTime.now(),
    updatedAt: DateTime.now(),
    deadline: DateTime.now().add(const Duration(days: 7)),
  ),
  TaskModel(
    id: 'weekly2',
    name: 'Play 20 games',
    description: 'Complete 20 matches in any mode this week.',
    type: 'weekly',
    reward: 300,
    status: 'incomplete',
    progress: 10, // Đã chơi 10 trận
    goal: 20,     // Mục tiêu: chơi 20 trận
    createdAt: DateTime.now(),
    updatedAt: DateTime.now(),
    deadline: DateTime.now().add(const Duration(days: 7)),
  ),
  TaskModel(
    id: 'weekly3',
    name: 'Accumulate 200 points',
    description: 'Score a total of 200 points across all games this week.',
    type: 'weekly',
    reward: 250,
    status: 'incomplete',
    progress: 100, // Đã tích lũy 100 điểm
    goal: 200,     // Mục tiêu: tích lũy 200 điểm
    createdAt: DateTime.now(),
    updatedAt: DateTime.now(),
    deadline: DateTime.now().add(const Duration(days: 7)),
  ),
  TaskModel(
    id: 'weekly4',
    name: 'Invite 3 friends',
    description: 'Invite 3 different friends to play and complete matches with them.',
    type: 'weekly',
    reward: 150,
    status: 'incomplete',
    progress: 1,   // Đã mời 1 bạn
    goal: 3,       // Mục tiêu: mời 3 bạn
    createdAt: DateTime.now(),
    updatedAt: DateTime.now(),
    deadline: DateTime.now().add(const Duration(days: 7)),
  ),
  TaskModel(
    id: 'weekly5',
    name: 'Spend 5 hours in the game',
    description: 'Spend a total of 5 hours playing the game this week.',
    type: 'weekly',
    reward: 200,
    status: 'incomplete',
    progress: 2,   // Đã chơi 2 giờ
    goal: 5,       // Mục tiêu: chơi 5 giờ
    createdAt: DateTime.now(),
    updatedAt: DateTime.now(),
    deadline: DateTime.now().add(const Duration(days: 7)),
  ),
];

final List<TaskModel> monthlyMissions = [
  TaskModel(
    id: 'monthly1',
    name: 'Win 50 ranked matches',
    description: 'Win 50 matches in ranked mode this month.',
    type: 'monthly',
    reward: 1000,
    status: 'incomplete',
    progress: 20, // Đã thắng 20 trận
    goal: 50,     // Mục tiêu: thắng 50 trận
    createdAt: DateTime.now(),
    updatedAt: DateTime.now(),
    deadline: DateTime.now().add(const Duration(days: 30)),
  ),
  TaskModel(
    id: 'monthly2',
    name: 'Play 100 games',
    description: 'Complete 100 matches in any mode this month.',
    type: 'monthly',
    reward: 800,
    status: 'incomplete',
    progress: 45, // Đã chơi 45 trận
    goal: 100,    // Mục tiêu: chơi 100 trận
    createdAt: DateTime.now(),
    updatedAt: DateTime.now(),
    deadline: DateTime.now().add(const Duration(days: 30)),
  ),
  TaskModel(
    id: 'monthly3',
    name: 'Accumulate 1000 points',
    description: 'Score a total of 1000 points across all games this month.',
    type: 'monthly',
    reward: 750,
    status: 'incomplete',
    progress: 500, // Đã tích lũy 500 điểm
    goal: 1000,    // Mục tiêu: tích lũy 1000 điểm
    createdAt: DateTime.now(),
    updatedAt: DateTime.now(),
    deadline: DateTime.now().add(const Duration(days: 30)),
  ),
  TaskModel(
    id: 'monthly4',
    name: 'Invite 10 friends',
    description: 'Invite 10 friends to play and complete matches with them this month.',
    type: 'monthly',
    reward: 500,
    status: 'incomplete',
    progress: 4,  // Đã mời 4 bạn
    goal: 10,     // Mục tiêu: mời 10 bạn
    createdAt: DateTime.now(),
    updatedAt: DateTime.now(),
    deadline: DateTime.now().add(const Duration(days: 30)),
  ),
  TaskModel(
    id: 'monthly5',
    name: 'Spend 20 hours in the game',
    description: 'Spend a total of 20 hours playing the game this month.',
    type: 'monthly',
    reward: 600,
    status: 'incomplete',
    progress: 8,  // Đã chơi 8 giờ
    goal: 20,     // Mục tiêu: chơi 20 giờ
    createdAt: DateTime.now(),
    updatedAt: DateTime.now(),
    deadline: DateTime.now().add(const Duration(days: 30)),
  ),
];


// final List<TaskModel> dailyMissions = [
//   TaskModel(
//     id: 'daily1',
//     name: 'Complete 5 games',
//     description: 'Play and complete 5 matches in any mode.',
//     type: 'daily',
//     reward: 50,
//     status: 'incomplete',
//     createdAt: DateTime.now(),
//     updatedAt: DateTime.now(),
//     deadline: DateTime.now().add(const Duration(hours: 24)),
//   ),
//   TaskModel(
//     id: 'daily2',
//     name: 'Win 3 matches',
//     description: 'Win 3 matches in ranked mode.',
//     type: 'daily',
//     reward: 100,
//     status: 'incomplete',
//     createdAt: DateTime.now(),
//     updatedAt: DateTime.now(),
//     deadline: DateTime.now().add(const Duration(hours: 24)),
//   ),
//   TaskModel(
//     id: 'daily3',
//     name: 'Play for 30 minutes',
//     description: 'Spend at least 30 minutes in the game today.',
//     type: 'daily',
//     reward: 20,
//     status: 'incomplete',
//     createdAt: DateTime.now(),
//     updatedAt: DateTime.now(),
//     deadline: DateTime.now().add(const Duration(hours: 24)),
//   ),
//   TaskModel(
//     id: 'daily4',
//     name: 'Score 50 points',
//     description: 'Accumulate 50 points in any game mode.',
//     type: 'daily',
//     reward: 40,
//     status: 'incomplete',
//     createdAt: DateTime.now(),
//     updatedAt: DateTime.now(),
//     deadline: DateTime.now().add(const Duration(hours: 24)),
//   ),
//   TaskModel(
//     id: 'daily5',
//     name: 'Invite a friend',
//     description: 'Invite a friend to play and complete a match together.',
//     type: 'daily',
//     reward: 30,
//     status: 'incomplete',
//     createdAt: DateTime.now(),
//     updatedAt: DateTime.now(),
//     deadline: DateTime.now().add(const Duration(hours: 24)),
//   ),
// ];

// final List<TaskModel> weeklyMissions = [
//   TaskModel(
//     id: 'weekly1',
//     name: 'Win 10 ranked matches',
//     description: 'Win 10 matches in ranked mode this week.',
//     type: 'weekly',
//     reward: 500,
//     status: 'incomplete',
//     createdAt: DateTime.now(),
//     updatedAt: DateTime.now(),
//     deadline: DateTime.now().add(const Duration(days: 7)),
//   ),
//   TaskModel(
//     id: 'weekly2',
//     name: 'Play 20 games',
//     description: 'Complete 20 matches in any mode this week.',
//     type: 'weekly',
//     reward: 300,
//     status: 'incomplete',
//     createdAt: DateTime.now(),
//     updatedAt: DateTime.now(),
//     deadline: DateTime.now().add(const Duration(days: 7)),
//   ),
//   TaskModel(
//     id: 'weekly3',
//     name: 'Accumulate 200 points',
//     description: 'Score a total of 200 points across all games this week.',
//     type: 'weekly',
//     reward: 250,
//     status: 'incomplete',
//     createdAt: DateTime.now(),
//     updatedAt: DateTime.now(),
//     deadline: DateTime.now().add(const Duration(days: 7)),
//   ),
//   TaskModel(
//     id: 'weekly4',
//     name: 'Invite 3 friends',
//     description:
//         'Invite 3 different friends to play and complete matches with them.',
//     type: 'weekly',
//     reward: 150,
//     status: 'incomplete',
//     createdAt: DateTime.now(),
//     updatedAt: DateTime.now(),
//     deadline: DateTime.now().add(const Duration(days: 7)),
//   ),
//   TaskModel(
//     id: 'weekly5',
//     name: 'Spend 5 hours in the game',
//     description: 'Spend a total of 5 hours playing the game this week.',
//     type: 'weekly',
//     reward: 200,
//     status: 'incomplete',
//     createdAt: DateTime.now(),
//     updatedAt: DateTime.now(),
//     deadline: DateTime.now().add(const Duration(days: 7)),
//   ),
// ];

// final List<TaskModel> monthlyMissions = [
//   TaskModel(
//     id: 'monthly1',
//     name: 'Win 50 ranked matches',
//     description: 'Win 50 matches in ranked mode this month.',
//     type: 'monthly',
//     reward: 1000,
//     status: 'incomplete',
//     createdAt: DateTime.now(),
//     updatedAt: DateTime.now(),
//     deadline: DateTime.now().add(const Duration(days: 30)),
//   ),
//   TaskModel(
//     id: 'monthly2',
//     name: 'Play 100 games',
//     description: 'Complete 100 matches in any mode this month.',
//     type: 'monthly',
//     reward: 800,
//     status: 'incomplete',
//     createdAt: DateTime.now(),
//     updatedAt: DateTime.now(),
//     deadline: DateTime.now().add(const Duration(days: 30)),
//   ),
//   TaskModel(
//     id: 'monthly3',
//     name: 'Accumulate 1000 points',
//     description: 'Score a total of 1000 points across all games this month.',
//     type: 'monthly',
//     reward: 750,
//     status: 'incomplete',
//     createdAt: DateTime.now(),
//     updatedAt: DateTime.now(),
//     deadline: DateTime.now().add(const Duration(days: 30)),
//   ),
//   TaskModel(
//     id: 'monthly4',
//     name: 'Invite 10 friends',
//     description:
//         'Invite 10 friends to play and complete matches with them this month.',
//     type: 'monthly',
//     reward: 500,
//     status: 'incomplete',
//     createdAt: DateTime.now(),
//     updatedAt: DateTime.now(),
//     deadline: DateTime.now().add(const Duration(days: 30)),
//   ),
//   TaskModel(
//     id: 'monthly5',
//     name: 'Spend 20 hours in the game',
//     description: 'Spend a total of 20 hours playing the game this month.',
//     type: 'monthly',
//     reward: 600,
//     status: 'incomplete',
//     createdAt: DateTime.now(),
//     updatedAt: DateTime.now(),
//     deadline: DateTime.now().add(const Duration(days: 30)),
//   ),
// ];

```

---


### Components\daily_mission\missions_page.dart

```dart
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:tictactoe_gameapp/Configs/assets_path.dart';
import 'package:tictactoe_gameapp/Components/daily_mission/Widgets/daily_mission.dart';
import 'package:tictactoe_gameapp/Components/daily_mission/Widgets/monthly_mission.dart';
import 'package:tictactoe_gameapp/Components/daily_mission/Widgets/weekly_mission.dart';
import 'package:tictactoe_gameapp/Components/daily_mission/mission_controller.dart';

class MissionsPage extends StatelessWidget {
  final String userId;
  const MissionsPage({super.key, required this.userId});

  @override
  Widget build(BuildContext context) {
    final TaskController taskController =
        Get.put(TaskController(userId: userId));
    return Stack(
      clipBehavior: Clip.none,
      children: [
        Positioned(
            top: -150,
            left: 100,
            right: 100,
            child: Image.asset(
              TrimRanking.challTrim,
              width: 40,
            )),
        Container(
          height: 400,
          width: double.infinity,
          padding: const EdgeInsets.all(20),
          decoration: BoxDecoration(
            gradient: const LinearGradient(
                colors: [Colors.purpleAccent, Colors.deepPurpleAccent]),
            borderRadius: BorderRadius.circular(20),
            border: Border.all(width: 10, color: Colors.blueAccent),
          ),
          child: DefaultTabController(
            length: 3,
            child: Column(
              children: [
                const Text(
                  "Return tomorrow for the new missions!",
                  textAlign: TextAlign.center,
                  style: TextStyle(
                    color: Colors.white,
                    fontSize: 20,
                    fontWeight: FontWeight.bold,
                  ),
                ),
                TabBar(
                  labelColor: Colors.blueAccent,
                  unselectedLabelColor: Colors.blueGrey,
                  indicatorSize: TabBarIndicatorSize.tab,
                  indicatorColor: Colors.yellowAccent,
                  tabs: [
                    Container(
                      width: double.maxFinite,
                      alignment: Alignment.center,
                      decoration: const BoxDecoration(
                        color: Colors.lightBlueAccent,
                        borderRadius: BorderRadius.only(
                          topLeft: Radius.circular(20),
                          topRight: Radius.circular(20),
                        ),
                      ),
                      child: const Text(
                        "Daily",
                        style: TextStyle(
                          color: Colors.white,
                          fontSize: 18,
                          fontWeight: FontWeight.bold,
                        ),
                      ),
                    ),
                    Container(
                      width: double.maxFinite,
                      alignment: Alignment.center,
                      decoration: const BoxDecoration(
                        color: Colors.lightBlueAccent,
                        borderRadius: BorderRadius.only(
                          topLeft: Radius.circular(20),
                          topRight: Radius.circular(20),
                        ),
                      ),
                      child: const Text(
                        "Weekly",
                        style: TextStyle(
                          color: Colors.white,
                          fontSize: 18,
                          fontWeight: FontWeight.bold,
                        ),
                      ),
                    ),
                    Container(
                      width: double.maxFinite,
                      alignment: Alignment.center,
                      decoration: const BoxDecoration(
                        color: Colors.lightBlueAccent,
                        borderRadius: BorderRadius.only(
                          topLeft: Radius.circular(20),
                          topRight: Radius.circular(20),
                        ),
                      ),
                      child: const Text(
                        "Monthly",
                        style: TextStyle(
                          color: Colors.white,
                          fontSize: 18,
                          fontWeight: FontWeight.bold,
                        ),
                      ),
                    ),
                  ],
                ),
                Expanded(
                  child: TabBarView(
                    children: [
                      DailyMissionPage(taskController: taskController),
                      WeeklyMissionPage(taskController: taskController),
                      MonthlyMissionPage(taskController: taskController),
                    ],
                  ),
                ),
              ],
            ),
          ),
        ),
        Positioned(
          top: -20,
          left: 50,
          right: 50,
          child: Container(
            alignment: Alignment.center,
            height: 50,
            decoration: BoxDecoration(
              color: Colors.lightBlueAccent,
              borderRadius: BorderRadius.circular(20),
              border: Border.all(color: Colors.white, width: 5),
            ),
            child: const Text(
              "Missions",
              style: TextStyle(
                color: Colors.white,
                fontSize: 25,
                fontWeight: FontWeight.bold,
              ),
            ),
          ),
        ),
        Positioned(
          top: -40,
          right: -30,
          child: IconButton(
            onPressed: () {
              Get.back();
            },
            icon: const Icon(
              Icons.cancel,
              size: 40,
              color: Colors.redAccent,
            ),
          ),
        ),
      ],
    );
  }
}

```

---


### Components\daily_mission\mission_controller.dart

```dart
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:get/get.dart';
import 'package:tictactoe_gameapp/Configs/messages.dart';
import 'package:tictactoe_gameapp/Components/daily_mission/constant_data.dart';
import 'mission_model.dart'; // Đường dẫn đến model TaskModel

class TaskController extends GetxController {
  FirebaseFirestore db = FirebaseFirestore.instance;

  RxList<TaskModel> dailyTasks = <TaskModel>[].obs;
  RxList<TaskModel> weeklyTasks = <TaskModel>[].obs;
  RxList<TaskModel> monthlyTasks = <TaskModel>[].obs;

  final String userId;
  TaskController({required this.userId});

  @override
  void onInit() {
    super.onInit();
    listenForTasks();
  }

  // Lắng nghe nhiệm vụ của người chơi
  void listenForTasks() {
    db
        .collection('users')
        .doc(userId)
        .collection('tasks')
        .snapshots()
        .listen((snapshot) {
      for (var change in snapshot.docChanges) {
        TaskModel task = TaskModel.fromJson(change.doc.data()!, change.doc.id);

        if (task.type == 'daily') {
          _updateTaskList(dailyTasks, change, task);
        } else if (task.type == 'weekly') {
          _updateTaskList(weeklyTasks, change, task);
        } else if (task.type == 'monthly') {
          _updateTaskList(monthlyTasks, change, task);
        }
      }
    });
  }

  // Hàm cập nhật danh sách nhiệm vụ
  void _updateTaskList(
      RxList<TaskModel> taskList, DocumentChange change, TaskModel task) {
    if (change.type == DocumentChangeType.added) {
      taskList.add(task);
    } else if (change.type == DocumentChangeType.modified) {
      int index = taskList.indexWhere((t) => t.id == task.id);
      if (index != -1) {
        taskList[index] = task;
      }
    } else if (change.type == DocumentChangeType.removed) {
      taskList.removeWhere((t) => t.id == task.id);
    }
  }

  // Hàm thêm nhiệm vụ mới
  Future<void> addTask(TaskModel task) async {
    await db
        .collection('users')
        .doc(userId)
        .collection('tasks')
        .add(task.toJson());
  }

  // Kiểm tra và tạo nhiệm vụ Daily
  Future<void> checkAndCreateDailyTasks() async {
    var now = DateTime.now();
    var tasksSnapshot = await db
        .collection('users')
        .doc(userId)
        .collection('tasks')
        .where('type', isEqualTo: 'daily')
        .where('deadline', isGreaterThanOrEqualTo: now)
        .get();

    if (tasksSnapshot.docs.isEmpty) {
      // Tạo 5 nhiệm vụ Daily
      List<TaskModel> dailyMissions = _generateDailyMissions();
      for (var task in dailyMissions) {
        await addTask(task);
      }
    }
  }

  // Kiểm tra và tạo nhiệm vụ Weekly
  Future<void> checkAndCreateWeeklyTasks() async {
    var now = DateTime.now();
    var tasksSnapshot = await db
        .collection('users')
        .doc(userId)
        .collection('tasks')
        .where('type', isEqualTo: 'weekly')
        .where('deadline', isGreaterThanOrEqualTo: now)
        .get();

    if (tasksSnapshot.docs.isEmpty) {
      // Tạo 5 nhiệm vụ Weekly
      List<TaskModel> weeklyMissions = _generateWeeklyMissions();
      for (var task in weeklyMissions) {
        await addTask(task);
      }
    }
  }

  // Kiểm tra và tạo nhiệm vụ Monthly
  Future<void> checkAndCreateMonthlyTasks() async {
    var now = DateTime.now();
    var tasksSnapshot = await db
        .collection('users')
        .doc(userId)
        .collection('tasks')
        .where('type', isEqualTo: 'monthly')
        .where('deadline', isGreaterThanOrEqualTo: now)
        .get();

    if (tasksSnapshot.docs.isEmpty) {
      // Tạo 5 nhiệm vụ Monthly
      List<TaskModel> monthlyMissions = _generateMonthlyMissions();
      for (var task in monthlyMissions) {
        await addTask(task);
      }
    }
  }

  // Hàm reset trạng thái nhiệm vụ
  Future<void> resetTasksIfNeeded() async {
    var now = DateTime.now();

    // Reset daily tasks nếu đã qua 1 ngày
    await db
        .collection('users')
        .doc(userId)
        .collection('tasks')
        .where('type', isEqualTo: 'daily')
        .where('deadline', isLessThanOrEqualTo: now)
        .get()
        .then((snapshot) {
      for (var doc in snapshot.docs) {
        db
            .collection('users')
            .doc(userId)
            .collection('tasks')
            .doc(doc.id)
            .delete()
            .catchError((e) => errorMessage(e.toString()));
      }
    });

    // Reset weekly tasks nếu đã qua 1 tuần
    await db
        .collection('users')
        .doc(userId)
        .collection('tasks')
        .where('type', isEqualTo: 'weekly')
        .where('deadline', isLessThanOrEqualTo: now)
        .get()
        .then((snapshot) {
      for (var doc in snapshot.docs) {
        db
            .collection('users')
            .doc(userId)
            .collection('tasks')
            .doc(doc.id)
            .delete()
            .catchError((e) => errorMessage(e.toString()));
      }
    });

    // Reset monthly tasks nếu đã qua 1 tháng
    await db
        .collection('users')
        .doc(userId)
        .collection('tasks')
        .where('type', isEqualTo: 'monthly')
        .where('deadline', isLessThanOrEqualTo: now)
        .get()
        .then((snapshot) {
      for (var doc in snapshot.docs) {
        db
            .collection('users')
            .doc(userId)
            .collection('tasks')
            .doc(doc.id)
            .delete()
            .catchError((e) => errorMessage(e.toString()));
      }
    });
  }

  // Hàm tạo mẫu nhiệm vụ Daily
  List<TaskModel> _generateDailyMissions() {
    return dailyMissions;
  }

  // Hàm tạo mẫu nhiệm vụ Weekly
  List<TaskModel> _generateWeeklyMissions() {
    return weeklyMissions;
  }

  // Hàm tạo mẫu nhiệm vụ Monthly
  List<TaskModel> _generateMonthlyMissions() {
    return monthlyMissions;
  }

  void updateTaskByFieldId(
      {required String taskFieldId, int newProgress = 1}) async {
    final taskQuerySnapshot = await db
        .collection('users')
        .doc(userId)
        .collection('tasks')
        .where('id', isEqualTo: taskFieldId) // Lọc dựa trên trường 'id'
        .get();

    for (var taskDoc in taskQuerySnapshot.docs) {
      final taskData = taskDoc.data();
      final taskId = taskDoc.id; // Lấy taskId từ document

      if (taskData['progress'] < taskData['goal']) {
        await db
            .collection('users')
            .doc(userId)
            .collection('tasks')
            .doc(taskId) // Dùng taskId để cập nhật task tương ứng
            .update({
          'progress': FieldValue.increment(newProgress),
          'status': (taskData['progress'] + newProgress >= taskData['goal'])
              ? 'completed'
              : 'incomplete',
        });
      }
    }
  }

  String displayTime(DateTime dateTime) {
    // Lấy giờ theo định dạng 12 giờ
    int hour = dateTime.hour % 12 == 0 ? 12 : dateTime.hour % 12;
    String minutes = dateTime.minute.toString().padLeft(2, '0');

    // Xác định AM hay PM
    String period = dateTime.hour >= 12 ? 'PM' : 'AM';

    return "$hour:$minutes $period";
  }

  String displayDate(DateTime dateTime) {
    String day = dateTime.day.toString().padLeft(2, '0');
    String month = dateTime.month.toString().padLeft(2, '0');
    String year = dateTime.year.toString();
    return "$day/$month/$year";
  }
}

// void updateTasksByFieldIdWithBatch(
//      {required String taskFieldId, int newProgress = 1}) async {
//   final taskQuerySnapshot = await db
//       .collection('users')
//       .doc(userId)
//       .collection('tasks')
//       .where('id', isEqualTo: taskFieldId)  // Lọc dựa trên trường 'id'
//       .get();

//   WriteBatch batch = db.batch();

//   for (var taskDoc in taskQuerySnapshot.docs) {
//     final taskData = taskDoc.data();
//     final taskId = taskDoc.id;

//     if (taskData['progress'] < taskData['goal']) {
//       DocumentReference taskRef = db
//           .collection('users')
//           .doc(userId)
//           .collection('tasks')
//           .doc(taskId);

//       batch.update(taskRef, {
//         'progress': FieldValue.increment(newProgress),
//         'status': (taskData['progress'] + newProgress >= taskData['goal']) ? 'completed' : 'incomplete',
//       });
//     }
//   }

//   // Thực thi batch
//   await batch.commit();
// }

```

---


### Components\daily_mission\mission_model.dart

```dart
import 'package:cloud_firestore/cloud_firestore.dart';

class TaskModel {
  String id;
  String name;
  String description;
  String type;
  int reward;
  int progress;
  int goal;
  String status;
  DateTime createdAt;
  DateTime updatedAt;
  DateTime deadline;

  TaskModel({
    required this.id,
    required this.name,
    required this.description,
    required this.type,
    required this.reward,
    required this.progress,
    required this.goal,
    required this.status,
    required this.createdAt,
    required this.updatedAt,
    required this.deadline,
  });

  // Convert Firestore document to TaskModel
  factory TaskModel.fromJson(Map<String, dynamic> json, String id) {
    return TaskModel(
      id: json['id'],
      name: json['name'],
      description: json['description'],
      type: json['type'],
      reward: json['reward'],
      progress: json['progress'],
      goal: json['goal'],
      status: json['status'],
      createdAt: (json['createdAt'] as Timestamp).toDate(),
      updatedAt: (json['updatedAt'] as Timestamp).toDate(),
      deadline: (json['deadline'] as Timestamp).toDate(),
    );
  }

  // Convert TaskModel to Firestore document
  Map<String, dynamic> toJson() {
    return {
      'id' : id,
      'name': name,
      'description': description,
      'type': type,
      'reward': reward,
      'progress': progress,
      'goal': goal,
      'status': status,
      'createdAt': createdAt,
      'updatedAt': updatedAt,
      'deadline': deadline,
    };
  }
}

```

---


### Components\daily_mission\Widgets\daily_mission.dart

```dart
import 'package:flutter/material.dart';
import 'package:flutter_svg/flutter_svg.dart';
import 'package:get/get.dart';
import 'package:tictactoe_gameapp/Configs/assets_path.dart';
import 'package:tictactoe_gameapp/Configs/messages.dart';
import 'package:tictactoe_gameapp/Components/daily_mission/mission_controller.dart';

class DailyMissionPage extends StatelessWidget {
  final TaskController taskController;
  const DailyMissionPage({super.key, required this.taskController});

  @override
  Widget build(BuildContext context) {
    return Obx(() {
      if (taskController.dailyTasks.isEmpty) {
        WidgetsBinding.instance.addPostFrameCallback((_) async {
          Get.showOverlay(
            asyncFunction: () async {
              await taskController.checkAndCreateDailyTasks();
            },
            loadingWidget: Center(
              child: Container(
                decoration: BoxDecoration(
                  color: Colors.white,
                  borderRadius: BorderRadius.circular(100),
                ),
                child: const CircularProgressIndicator(
                  color: Colors.blue,
                ),
              ),
            ),
          );
        });
      }
      var dailyTasks = taskController.dailyTasks.toList();
      return ListView.builder(
        itemCount: dailyTasks.length,
        physics: const BouncingScrollPhysics(),
        itemBuilder: (context, index) {
          var dailyTask = dailyTasks[index];
          return Container(
            padding: const EdgeInsets.symmetric(vertical: 10, horizontal: 10),
            margin: const EdgeInsets.symmetric(vertical: 5),
            decoration: BoxDecoration(
              color: Colors.black.withOpacity(0.5),
              borderRadius: BorderRadius.circular(10),
            ),
            child: Row(
              children: [
                Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      "+${dailyTask.reward}",
                      style: const TextStyle(
                        color: Colors.white,
                        fontSize: 15,
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                    SvgPicture.asset(
                      IconsPath.coinIcon,
                      width: 35,
                      colorFilter: const ColorFilter.linearToSrgbGamma(),
                    ),
                  ],
                ),
                const SizedBox(
                  width: 10,
                ),
                Expanded(
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text(
                        dailyTask.name,
                        style:
                            const TextStyle(fontSize: 15, color: Colors.yellow),
                      ),
                      Text(
                        dailyTask.description,
                        style:
                            const TextStyle(fontSize: 13, color: Colors.white),
                      ),
                      const SizedBox(
                        height: 10,
                      ),
                      Row(
                        children: [
                          Container(
                            width: 100,
                            height: 25,
                            alignment: Alignment.center,
                            decoration: BoxDecoration(
                              color: Colors.blueGrey.shade400,
                              borderRadius: BorderRadius.circular(20),
                              border:
                                  Border.all(color: Colors.yellow, width: 3),
                            ),
                            child: Text(
                              "${dailyTask.progress} / ${dailyTask.goal}",
                              style: const TextStyle(
                                fontSize: 12,
                                color: Colors.black,
                                fontWeight: FontWeight.bold,
                              ),
                            ),
                          ),
                          const SizedBox(
                            width: 10,
                          ),
                          Text(
                            taskController.displayTime(dailyTask.deadline),
                            style: const TextStyle(
                              fontSize: 12,
                              color: Colors.grey,
                              fontWeight: FontWeight.bold,
                            ),
                          ),
                        ],
                      )
                    ],
                  ),
                ),
                const SizedBox(
                  width: 10,
                ),
                dailyTask.status == "incomplete"
                    ? GestureDetector(
                        onTap: () {
                          taskController.updateTaskByFieldId(
                              taskFieldId: dailyTask.id);
                          successMessage("Congratulations!");
                        },
                        child: Container(
                          width: 70,
                          height: 40,
                          alignment: Alignment.center,
                          padding: const EdgeInsets.all(5),
                          decoration: BoxDecoration(
                            borderRadius: BorderRadius.circular(10),
                            color: Colors.blueAccent,
                          ),
                          child: const Row(
                            mainAxisAlignment: MainAxisAlignment.center,
                            children: [
                              Text(
                                "Go",
                                style: TextStyle(
                                  fontSize: 18,
                                  color: Colors.white,
                                ),
                              ),
                              Icon(
                                Icons.keyboard_double_arrow_right,
                                color: Colors.white,
                              ),
                            ],
                          ),
                        ),
                      )
                    : GestureDetector(
                        onTap: () {},
                        child: Container(
                          width: 70,
                          height: 40,
                          alignment: Alignment.center,
                          padding: const EdgeInsets.all(5),
                          decoration: BoxDecoration(
                            borderRadius: BorderRadius.circular(10),
                            color: Colors.orange,
                          ),
                          child: const Row(
                            mainAxisAlignment: MainAxisAlignment.center,
                            children: [
                              Text(
                                "OK!",
                                style: TextStyle(
                                  fontSize: 18,
                                  color: Colors.white,
                                ),
                              ),
                              Icon(
                                Icons.done_all,
                                color: Colors.white,
                              ),
                            ],
                          ),
                        ),
                      ),
              ],
            ),
          );
        },
      );
    });
  }
}

```

---


### Components\daily_mission\Widgets\monthly_mission.dart

```dart
import 'package:flutter/material.dart';
import 'package:flutter_svg/svg.dart';
import 'package:get/get.dart';
import 'package:tictactoe_gameapp/Configs/assets_path.dart';
import 'package:tictactoe_gameapp/Components/daily_mission/mission_controller.dart';

class MonthlyMissionPage extends StatelessWidget {
  final TaskController taskController;
  const MonthlyMissionPage({super.key, required this.taskController});

  @override
  Widget build(BuildContext context) {
    return Obx(() {
      if (taskController.monthlyTasks.isEmpty) {
        WidgetsBinding.instance.addPostFrameCallback((_) async {
          Get.showOverlay(
            asyncFunction: () async {
              await taskController.checkAndCreateMonthlyTasks();
            },
            loadingWidget: Center(
              child: Container(
                decoration: BoxDecoration(
                  color: Colors.white,
                  borderRadius: BorderRadius.circular(100),
                ),
                child: const CircularProgressIndicator(
                  color: Colors.blue,
                ),
              ),
            ),
          );
        });
      }
      var monthlyTasks = taskController.monthlyTasks.toList();
      return ListView.builder(
        itemCount: monthlyTasks.length,
        physics: const BouncingScrollPhysics(),
        itemBuilder: (context, index) {
          var monthlyTask = monthlyTasks[index];
          return Container(
            padding: const EdgeInsets.symmetric(vertical: 10, horizontal: 10),
            margin: const EdgeInsets.symmetric(vertical: 5),
            decoration: BoxDecoration(
              color: Colors.black.withOpacity(0.5),
              borderRadius: BorderRadius.circular(10),
            ),
            child: Row(
              children: [
                Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      "+${monthlyTask.reward}",
                      style: const TextStyle(
                        color: Colors.white,
                        fontSize: 15,
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                    SvgPicture.asset(
                      IconsPath.coinIcon,
                      width: 35,
                      colorFilter: const ColorFilter.linearToSrgbGamma(),
                    ),
                  ],
                ),
                const SizedBox(
                  width: 10,
                ),
                Expanded(
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text(
                        monthlyTask.name,
                        style:
                            const TextStyle(fontSize: 15, color: Colors.yellow),
                      ),
                      Text(
                        monthlyTask.description,
                        style:
                            const TextStyle(fontSize: 13, color: Colors.white),
                      ),
                      const SizedBox(
                        height: 10,
                      ),
                      Row(
                        children: [
                          Container(
                            width: 100,
                            height: 25,
                            alignment: Alignment.center,
                            decoration: BoxDecoration(
                              color: Colors.blueGrey.shade400,
                              borderRadius: BorderRadius.circular(20),
                              border:
                                  Border.all(color: Colors.yellow, width: 3),
                            ),
                            child: Text(
                              "${monthlyTask.progress} / ${monthlyTask.goal}",
                              style: const TextStyle(
                                fontSize: 12,
                                color: Colors.black,
                                fontWeight: FontWeight.bold,
                              ),
                            ),
                          ),
                          const SizedBox(
                            width: 10,
                          ),
                          Text(
                            taskController.displayDate(monthlyTask.deadline),
                            style: const TextStyle(
                              fontSize: 12,
                              color: Colors.grey,
                              fontWeight: FontWeight.bold,
                            ),
                          ),
                        ],
                      )
                    ],
                  ),
                ),
                const SizedBox(
                  width: 10,
                ),
                GestureDetector(
                  onTap: () {},
                  child: Container(
                    width: 70,
                    height: 40,
                    alignment: Alignment.center,
                    padding: const EdgeInsets.all(5),
                    decoration: BoxDecoration(
                      borderRadius: BorderRadius.circular(10),
                      color: Colors.blueAccent,
                    ),
                    child: const Row(
                      mainAxisAlignment: MainAxisAlignment.center,
                      children: [
                        Text(
                          "Go",
                          style: TextStyle(
                            fontSize: 18,
                            color: Colors.white,
                          ),
                        ),
                        Icon(
                          Icons.keyboard_double_arrow_right,
                          color: Colors.white,
                        ),
                      ],
                    ),
                  ),
                )
              ],
            ),
          );
        },
      );
    });
  }
}

```

---


### Components\daily_mission\Widgets\weekly_mission.dart

```dart
import 'package:flutter/material.dart';
import 'package:flutter_svg/svg.dart';
import 'package:get/get.dart';
import 'package:tictactoe_gameapp/Configs/assets_path.dart';
import 'package:tictactoe_gameapp/Components/daily_mission/mission_controller.dart';

class WeeklyMissionPage extends StatelessWidget {
  final TaskController taskController;
  const WeeklyMissionPage({super.key, required this.taskController});

  @override
  Widget build(BuildContext context) {
    return Obx(() {
      if (taskController.weeklyTasks.isEmpty) {
        WidgetsBinding.instance.addPostFrameCallback((_) async {
          Get.showOverlay(
            asyncFunction: () async {
              await taskController.checkAndCreateWeeklyTasks();
            },
            loadingWidget: Center(
              child: Container(
                decoration: BoxDecoration(
                  color: Colors.white,
                  borderRadius: BorderRadius.circular(100),
                ),
                child: const CircularProgressIndicator(
                  color: Colors.blue,
                ),
              ),
            ),
          );
        });
      }
      var weeklyTasks = taskController.weeklyTasks.toList();
      return ListView.builder(
        itemCount: weeklyTasks.length,
        physics: const BouncingScrollPhysics(),
        itemBuilder: (context, index) {
          var weeklyTask = weeklyTasks[index];
          return Container(
            padding: const EdgeInsets.symmetric(vertical: 10, horizontal: 10),
            margin: const EdgeInsets.symmetric(vertical: 5),
            decoration: BoxDecoration(
              color: Colors.black.withOpacity(0.5),
              borderRadius: BorderRadius.circular(10),
            ),
            child: Row(
              children: [
                Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      "+${weeklyTask.reward}",
                      style: const TextStyle(
                        color: Colors.white,
                        fontSize: 15,
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                    SvgPicture.asset(
                      IconsPath.coinIcon,
                      width: 35,
                      colorFilter: const ColorFilter.linearToSrgbGamma(),
                    ),
                  ],
                ),
                const SizedBox(
                  width: 10,
                ),
                Expanded(
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text(
                        weeklyTask.name,
                        style:
                            const TextStyle(fontSize: 15, color: Colors.yellow),
                      ),
                      Text(
                        weeklyTask.description,
                        style:
                            const TextStyle(fontSize: 13, color: Colors.white),
                      ),
                      const SizedBox(
                        height: 10,
                      ),
                      SingleChildScrollView(
                        scrollDirection: Axis.horizontal,
                        child: Row(
                          children: [
                            Container(
                              width: 100,
                              height: 25,
                              alignment: Alignment.center,
                              decoration: BoxDecoration(
                                color: Colors.blueGrey.shade400,
                                borderRadius: BorderRadius.circular(20),
                                border:
                                    Border.all(color: Colors.yellow, width: 3),
                              ),
                              child: Text(
                                "${weeklyTask.progress} / ${weeklyTask.goal}",
                                style: const TextStyle(
                                  fontSize: 12,
                                  color: Colors.black,
                                  fontWeight: FontWeight.bold,
                                ),
                              ),
                            ),
                            const SizedBox(
                              width: 10,
                            ),
                            Text(
                              taskController.displayDate(weeklyTask.deadline),
                              style: const TextStyle(
                                fontSize: 12,
                                color: Colors.grey,
                                fontWeight: FontWeight.bold,
                              ),
                            ),
                          ],
                        ),
                      )
                    ],
                  ),
                ),
                const SizedBox(
                  width: 10,
                ),
                GestureDetector(
                  onTap: () {},
                  child: Container(
                    width: 70,
                    height: 40,
                    alignment: Alignment.center,
                    padding: const EdgeInsets.all(5),
                    decoration: BoxDecoration(
                      borderRadius: BorderRadius.circular(10),
                      color: Colors.blueAccent,
                    ),
                    child: const Row(
                      mainAxisAlignment: MainAxisAlignment.center,
                      children: [
                        Text(
                          "Go",
                          style: TextStyle(
                            fontSize: 18,
                            color: Colors.white,
                          ),
                        ),
                        Icon(
                          Icons.keyboard_double_arrow_right,
                          color: Colors.white,
                        ),
                      ],
                    ),
                  ),
                )
              ],
            ),
          );
        },
      );
    });
  }
}

```

---


### Components\fortune_wheel\fortune_wheel_page.dart

```dart
import 'package:flutter/material.dart';
import 'package:get/get.dart';

import 'widgets/fortune_wheel.dart';

class FortuneWheelMain extends StatefulWidget {
  const FortuneWheelMain({super.key});

  @override
  // ignore: library_private_types_in_public_api
  _FortuneWheelMainState createState() => _FortuneWheelMainState();
}

class _FortuneWheelMainState extends State<FortuneWheelMain> {
  FortuneWheelController<int> fortuneWheelController = FortuneWheelController();
  FortuneWheelChild? currentWheelChild;
  int currentBalance = 0;

  @override
  void initState() {
    super.initState();
    fortuneWheelController.addListener(() {
      if (fortuneWheelController.value == null) {
        return;
      }

      setState(() {
        currentWheelChild = fortuneWheelController.value;
      });

      if (fortuneWheelController.isAnimating) {
        return;
      }

      if (fortuneWheelController.shouldStartAnimation) {
        return;
      }

      setState(() {
        currentBalance += fortuneWheelController.value!.value;
      });
    });
  }

  @override
  Widget build(BuildContext context) {
    return Stack(
      children: [
        Center(
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              SizedBox(
                height: 80,
                width: 80,
                child: currentWheelChild != null
                    ? currentWheelChild!.foreground
                    : Container(
                        height: 80,
                        width: 80,
                        decoration: BoxDecoration(
                          color: Colors.grey,
                          borderRadius: BorderRadius.circular(50),
                        ),
                        child: const Icon(
                          Icons.question_mark,
                          color: Colors.white,
                          size: 50,
                        ),
                      ),
              ),
              const SizedBox(
                height: 20,
              ),
              SizedBox(
                child: FortuneWheel<int>(
                  controller: fortuneWheelController,
                  children: [
                    _createFortuneWheelChild(-50),
                    _createFortuneWheelChild(1000),
                    _createFortuneWheelChild(-50),
                    _createFortuneWheelChild(-500),
                    _createFortuneWheelChild(100),
                    _createFortuneWheelChild(-100),
                    _createFortuneWheelChild(200),
                    _createFortuneWheelChild(-100),
                  ],
                ),
              ),
              const SizedBox(height: 20),
              ElevatedButton(
                onPressed: () => fortuneWheelController.rotateTheWheel(),
                style: ElevatedButton.styleFrom(
                  backgroundColor: Colors.white,
                  elevation: 5,
                  shadowColor: Colors.black,
                ),
                child: const Padding(
                  padding: EdgeInsets.all(10),
                  child: Text(
                    'SPIN',
                    style: TextStyle(
                      fontWeight: FontWeight.bold,
                      color: Colors.blue,
                      fontSize: 20,
                    ),
                  ),
                ),
              ),
            ],
          ),
        ),
        Positioned(
          top: 180,
          right: 50,
          child: IconButton(
            onPressed: () => Get.back(),
            icon: const Icon(
              Icons.arrow_forward_ios,
              size: 40,
              color: Colors.yellowAccent,
            ),
          ),
        ),
        Positioned(
          top: 180,
          left: 50,
          child: IconButton(
            onPressed: () => Get.back(),
            icon: const Icon(
              Icons.arrow_back_ios_new,
              size: 40,
              color: Colors.yellowAccent,
            ),
          ),
        ),
      ],
    );
  }

  FortuneWheelChild<int> _createFortuneWheelChild(int value) {
    Color color = value.isNegative ? Colors.red : Colors.green;
    String verb = value.isNegative ? 'Lose' : 'Win';
    int valueString = value.abs();

    return FortuneWheelChild(
      foreground: _getWheelContentCircle(color, '$verb\n$valueString €'),
      value: value,
    );
  }

  Container _getWheelContentCircle(Color backgroundColor, String text) {
    return Container(
      width: 72,
      height: 72,
      padding: const EdgeInsets.all(8),
      decoration: BoxDecoration(
        color: backgroundColor,
        shape: BoxShape.circle,
        border: Border.all(color: Colors.white.withOpacity(0.8), width: 4),
      ),
      child: Center(
        child: FittedBox(
          fit: BoxFit.fitWidth,
          child: Text(
            text,
            style: const TextStyle(
              color: Colors.white,
              fontWeight: FontWeight.bold,
              fontSize: 20,
            ),
            textAlign: TextAlign.center,
          ),
        ),
      ),
    );
  }
}

```

---


### Components\fortune_wheel\controller\fortune_wheel_controller.dart

```dart
import 'package:flutter/widgets.dart';

import 'package:tictactoe_gameapp/Components/fortune_wheel/widgets/fortune_wheel_child.dart';

class FortuneWheelController<T> extends ChangeNotifier {
  FortuneWheelChild<T>? value;

  bool isAnimating = false;
  bool shouldStartAnimation = false;

  void rotateTheWheel() {
    shouldStartAnimation = true;
    notifyListeners();
  }

  void animationStarted() {
    shouldStartAnimation = false;
    isAnimating = true;
  }

  void setValue(FortuneWheelChild<T> fortuneWheelChild) {
    value = fortuneWheelChild;
    notifyListeners();
  }

  void animationFinished() {
    isAnimating = false;
    shouldStartAnimation = false;
    notifyListeners();
  }
}

```

---


### Components\fortune_wheel\painters\wheel_outline_painter.dart

```dart
import 'package:flutter/material.dart';

class WheelOutlinePainter extends CustomPainter {
  @override
  void paint(Canvas canvas, Size size) {
    Paint strokePaint = Paint();

    double strokeWidth = size.width / 25;

    strokePaint.color = Colors.white.withOpacity(0.33);
    strokePaint.strokeWidth = strokeWidth;
    strokePaint.style = PaintingStyle.stroke;

    canvas.drawCircle(
      Offset(size.width / 2, size.height / 2),
      (size.height / 2) - strokeWidth / 2,
      strokePaint
    );
  }

  @override
  bool shouldRepaint(CustomPainter oldDelegate) => false;
}
```

---


### Components\fortune_wheel\painters\wheel_slice_painter.dart

```dart
import 'package:flutter/material.dart';
import 'dart:math';

class WheelSlicePainter extends CustomPainter {
  WheelSlicePainter({
    required this.divider,
    required this.number,
    required this.color
  });

  final int divider;
  final int number;
  final Color? color;
  
  Paint? currentPaint;
  double angleWidth = 0;

  @override
  void paint(Canvas canvas, Size size) {
    _initializeFill();
    _drawSlice(canvas, size);
    _initializeStroke();
    _drawSlice(canvas, size);
  }

  void _initializeStroke() {
    currentPaint = Paint()
    ..color = Colors.white.withOpacity(0.2)
    ..strokeWidth = 2
    ..style = PaintingStyle.stroke;
  }

  void _initializeFill() {
    currentPaint = Paint()..color = color != null
      ? color!
      : Color.lerp(Colors.red, Colors.orange, number / (divider -1))!;
    
    angleWidth = pi * 2 / divider;
  }

  void _drawSlice(Canvas canvas, Size size) {
    canvas.drawArc(
      Rect.fromCenter(
        center: Offset(size.width / 2, size.height / 2),
        height: size.height,
        width: size.width,
      ),
      0,
      angleWidth,
      true,
      currentPaint!,
    );
  }

  @override
  bool shouldRepaint(CustomPainter oldDelegate) => true;
}
```

---


### Components\fortune_wheel\widgets\fortune_wheel.dart

```dart
import 'dart:math';
import 'package:flutter/material.dart';
import 'package:flutter/widgets.dart';
import 'package:tictactoe_gameapp/Components/fortune_wheel/widgets/wheel_result_indicator.dart';
import 'package:tictactoe_gameapp/Components/fortune_wheel/widgets/wheel_slice.dart';

import '../painters/wheel_outline_painter.dart';
import 'fortune_wheel_child.dart';
import '../controller/fortune_wheel_controller.dart';

export 'fortune_wheel_child.dart';
export '../controller/fortune_wheel_controller.dart';

class FortuneWheel<T> extends StatefulWidget {
  const FortuneWheel({
    super.key,
    required this.controller,
    this.turnsPerSecond = 10,
    this.rotationTimeLowerBound = 2000,
    this.rotationTimeUpperBound = 4000,
    required this.children,
  }) : assert(children.length > 1,
            'List with at least two elements must be given');

  final FortuneWheelController<T> controller;
  final List<FortuneWheelChild<T>> children;
  final int turnsPerSecond;
  final int rotationTimeLowerBound;
  final int rotationTimeUpperBound;

  @override
  // ignore: library_private_types_in_public_api
  _FortuneWheelState createState() => _FortuneWheelState();
}

class _FortuneWheelState extends State<FortuneWheel>
    with SingleTickerProviderStateMixin {
  late AnimationController _animationController;
  late double size;

  @override
  void dispose() {
    _animationController.dispose();
    widget.controller.dispose();
    super.dispose();
  }

  @override
  void initState() {
    _initiateAnimation();
    _initiateControllerSubscription();
    super.initState();
  }

  void _initiateAnimation() {
    _animationController = AnimationController(
      vsync: this,
      lowerBound: 0,
      upperBound: double.infinity,
    );

    _animationController.value = (0.5 / (widget.children.length));

    _animationController.addListener(() {
      widget.controller.setValue(widget.children[
          ((widget.children.length) * (_animationController.value % 1))
              .floor()]);

      if (_animationController.isCompleted) {
        widget.controller.animationFinished();
      }
    });
  }

  void _initiateControllerSubscription() {
    widget.controller.addListener(() {
      if (!widget.controller.shouldStartAnimation ||
          widget.controller.isAnimating) {
        return;
      }

      _startAnimation();
    });
  }

  void _startAnimation() {
    widget.controller.animationStarted();

    int milliseconds = Random().nextInt(widget.rotationTimeLowerBound) +
        (widget.rotationTimeUpperBound - widget.rotationTimeLowerBound);
    double rotateDistance = milliseconds / 500 * widget.turnsPerSecond;

    _animationController.value = _animationController.value % 1;

    _animationController.duration =
        Duration(milliseconds: milliseconds.toInt());

    _animationController.animateTo(_animationController.value + rotateDistance,
        curve: Curves.easeInOut);
  }

  @override
  Widget build(BuildContext context) {
    return LayoutBuilder(
        builder: (BuildContext context, BoxConstraints constraints) {
      size = min(constraints.maxHeight, constraints.maxWidth);

      return SizedBox(
        width: size,
        height: size,
        child: _getWheelContent(),
      );
    });
  }

  Stack _getWheelContent() {
    return Stack(
      children: [_getSlices(), _getCircleOutline(), _getIndicator()],
    );
  }

  WheelResultIndicator _getIndicator() => WheelResultIndicator(
      wheelSize: size,
      animationController: _animationController,
      childCount: widget.children.length);

  Widget _getSlices() {
    double fourthCircleAngle = pi / 2;
    double pieceAngle = pi * 2 / widget.children.length;

    return Stack(
      children: [
        for (int index = 0; index < widget.children.length; index++)
          Transform.rotate(
            angle: (-fourthCircleAngle) - (pieceAngle / 2),
            child: WheelSlice(
                index: index,
                size: size,
                fortuneWheelChildren: widget.children),
          ),
      ],
    );
  }

  CustomPaint _getCircleOutline() {
    return CustomPaint(
      painter: WheelOutlinePainter(),
      size: Size(size, size),
    );
  }
}

```

---


### Components\fortune_wheel\widgets\fortune_wheel_child.dart

```dart
import 'package:flutter/widgets.dart';

class FortuneWheelChild<T> {
  FortuneWheelChild({
    required this.foreground,
    this.background,
    required this.value
  });

  final Widget foreground;
  final Color? background;
  final T value;
}
```

---


### Components\fortune_wheel\widgets\wheel_result_indicator.dart

```dart
import 'dart:math';

import 'package:flutter/material.dart';
import 'package:tictactoe_gameapp/Configs/assets_path.dart';
import 'package:tictactoe_gameapp/Controller/Animations/Overlays/draw_tria.dart';

class WheelResultIndicator extends StatelessWidget {
  const WheelResultIndicator({
    super.key,
    required this.wheelSize,
    required this.animationController,
    required this.childCount,
  });

  final double wheelSize;
  final AnimationController animationController;
  final int childCount;

  @override
  Widget build(BuildContext context) {
    double indicatorSize = wheelSize / 9;
    Color indicatorColor = Colors.white;

    return Stack(
      children: [
        _getCenterIndicatorTriangle(wheelSize, indicatorSize, indicatorColor),
        _getCenterIndicatorCircle(indicatorColor, indicatorSize),
      ],
    );
  }

  Positioned _getCenterIndicatorTriangle(
      double wheelSize, double indicatorSize, Color indicatorColor) {
    return Positioned(
      top: wheelSize / 2 - indicatorSize,
      left: wheelSize / 2 - (indicatorSize / 2),
      child: AnimatedBuilder(
        builder: (BuildContext context, Widget? child) {
          return Transform.rotate(
            origin: Offset(0, indicatorSize / 2),
            angle: (animationController.value * pi * 2) - (pi / (childCount)),
            child: CustomPaint(
                painter: TrianglePainter(
                  color: Colors.white, alignment: Alignment.bottomCenter,
                  // fillColor: indicatorColor,
                ),
                size: Size(indicatorSize, indicatorSize)),
          );
        },
        animation: animationController,
      ),
    );
  }

  Center _getCenterIndicatorCircle(Color indicatorColor, double indicatorSize) {
    return Center(
      child: Container(
        decoration: BoxDecoration(
          shape: BoxShape.circle,
          color: indicatorColor,
          border: Border.all(
            color: Colors.white,
            width: 3,
          ),
        ),
        width: indicatorSize,
        height: indicatorSize,
        child: Image.asset(
          Jajas.spinner,
          width: 50,
          fit: BoxFit.cover,
        ),
      ),
    );
  }
}

```

---


### Components\fortune_wheel\widgets\wheel_slice.dart

```dart
import 'dart:math';

import 'package:flutter/material.dart';
import 'package:tictactoe_gameapp/Components/fortune_wheel/painters/wheel_slice_painter.dart';
import 'package:tictactoe_gameapp/Components/fortune_wheel/widgets/fortune_wheel_child.dart';

class WheelSlice extends StatelessWidget {
  const WheelSlice(
      {super.key,
      required this.index,
      required this.size,
      required this.fortuneWheelChildren});

  final int index;
  final double size;
  final List<FortuneWheelChild> fortuneWheelChildren;

  @override
  Widget build(BuildContext context) {
    int childCount = fortuneWheelChildren.length;
    double pieceAngle = (index / childCount * pi * 2);
    double pieceWidth =
        childCount == 2 ? size : sin(pi / childCount) * size / 2;
    double pieceHeight = size / 2;

    return Stack(
      children: [
        _getSliceBackground(pieceAngle, childCount),
        _getSliceForeground(pieceAngle, pieceWidth, pieceHeight)
      ],
    );
  }

  Widget _getSliceForeground(
      double pieceAngle, double pieceWidth, double pieceHeight) {
    double centerOffset = (pi / fortuneWheelChildren.length);
    double leftRotationOffset = (-pi / 2);

    return Transform.rotate(
      angle: leftRotationOffset + pieceAngle + centerOffset,
      alignment: Alignment.center,
      child: Stack(
        children: [
          Positioned(
              top: size / 2,
              left: size / 2 - pieceWidth / 2,
              child: Container(
                padding: EdgeInsets.all(size / fortuneWheelChildren.length / 4),
                height: pieceHeight,
                width: pieceWidth,
                child: FittedBox(
                    fit: BoxFit.scaleDown,
                    alignment: Alignment.center,
                    child: Transform.rotate(
                        angle: -pieceAngle - leftRotationOffset * 2,
                        child: fortuneWheelChildren[index].foreground)),
              )),
        ],
      ),
    );
  }

  Transform _getSliceBackground(double pieceAngle, int childCount) {
    return Transform.rotate(
      angle: pieceAngle,
      alignment: Alignment.center,
      child: Stack(
        children: [
          SizedBox(
            width: size,
            height: size,
            child: CustomPaint(
              painter: WheelSlicePainter(
                  divider: childCount,
                  number: index,
                  color: fortuneWheelChildren[index].background),
              size: Size(size, size),
            ),
          ),
        ],
      ),
    );
  }
}

```

---


### Components\friend_zone\direction_routes_service.dart

```dart
import 'dart:collection';
import 'package:get/get.dart';
import 'package:latlong2/latlong.dart';

class RouteService extends GetConnect {
  // Cache với LRU và TTL
  final _routeCache = LinkedHashMap<String, _CacheEntry>(
    equals: (a, b) => a == b,
    hashCode: (key) => key.hashCode,
  );

  // Giới hạn kích thước cache
  static const int _maxCacheSize = 50;
  // Thời gian sống của cache (5 phút)
  static const Duration _cacheTTL = Duration(minutes: 5);

  RouteService() {
    httpClient.baseUrl = 'https://router.project-osrm.org';
    httpClient.timeout = const Duration(seconds: 5); // Timeout 5 giây
  }

  Future<List<LatLng>> fetchRoute(LatLng start, LatLng end) async {
    // Tạo key cho cache
    final cacheKey =
        '${start.latitude.toStringAsFixed(6)},${start.longitude.toStringAsFixed(6)}-${end.latitude.toStringAsFixed(6)},${end.longitude.toStringAsFixed(6)}';

    // Kiểm tra cache
    if (_routeCache.containsKey(cacheKey)) {
      final entry = _routeCache[cacheKey]!;
      if (DateTime.now().difference(entry.timestamp) < _cacheTTL) {
        // Di chuyển mục vừa dùng lên đầu (LRU)
        _routeCache.remove(cacheKey);
        _routeCache[cacheKey] = entry;
        return entry.route;
      } else {
        // Xóa mục hết hạn
        _routeCache.remove(cacheKey);
      }
    }

    // Tạo endpoint với tối ưu hóa dữ liệu
    final endpoint =
        '/route/v1/driving/${start.longitude},${start.latitude};${end.longitude},${end.latitude}?overview=simplified&geometries=geojson&steps=false';

    // Gửi request với retry
    final response = await _retryRequest(endpoint);

    if (response.statusCode == 200) {
      final data = response.body;
      final List<LatLng> routePoints = [];

      // Parse dữ liệu GeoJSON nhanh hơn với vòng lặp tối ưu
      final coordinates = data['routes'][0]['geometry']['coordinates'] as List;
      routePoints
          .addAll(coordinates.map((coord) => LatLng(coord[1], coord[0])));

      // Quản lý cache
      if (_routeCache.length >= _maxCacheSize) {
        // Xóa mục cũ nhất (đầu tiên trong LinkedHashMap)
        _routeCache.remove(_routeCache.keys.first);
      }
      _routeCache[cacheKey] = _CacheEntry(routePoints, DateTime.now());

      return routePoints;
    } else {
      throw Exception('Failed to fetch route: ${response.statusCode}');
    }
  }

  // Hàm retry request với tối đa 2 lần thử lại
  Future<Response> _retryRequest(String endpoint) async {
    const maxRetries = 2;
    for (int attempt = 0; attempt <= maxRetries; attempt++) {
      try {
        final response =
            await get(endpoint).timeout(const Duration(seconds: 5));
        if (response.statusCode == 200) {
          return response;
        }
      } catch (e) {
        if (attempt == maxRetries) rethrow;
        await Future.delayed(
            Duration(milliseconds: 500 * (attempt + 1))); // Delay tăng dần
      }
    }
    throw Exception('Failed to fetch route after retries');
  }
}

// Lớp lưu trữ dữ liệu cache với thời gian
class _CacheEntry {
  final List<LatLng> route;
  final DateTime timestamp;

  _CacheEntry(this.route, this.timestamp);
}

```

---


### Components\friend_zone\friend_zone_map_controller.dart

```dart
import 'dart:async';
import 'package:flutter_map/flutter_map.dart';
import 'package:get/get.dart';
import 'package:geolocator/geolocator.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:latlong2/latlong.dart';
import 'package:tictactoe_gameapp/Components/friend_zone/direction_routes_service.dart';
import 'package:tictactoe_gameapp/Configs/messages.dart';
import 'package:tictactoe_gameapp/Models/user_model.dart';

class LocationController extends GetxController {
  final FirebaseFirestore _firestore = FirebaseFirestore.instance;
  late final MapController mapController;

  final Rx<Position?> currentPosition = Rx<Position?>(null);
  final Rx<LatLng?> friendLocation = Rx<LatLng?>(null);
  final RxDouble viewRadius = 5000.0.obs; // Bán kính tìm kiếm (mét)
  final RxList<UserModel> displayUsers = RxList<UserModel>();
  final RouteService _routeService = RouteService();
  final RxList<LatLng> routePoints = <LatLng>[].obs;

  StreamSubscription<Position>? _positionStreamSubscription;
  StreamSubscription<QuerySnapshot>? _nearbyUsersSubscription;
  Timer? _debounceTimer;

  final String userId;
  LocationController({required this.userId});

  @override
  void onInit() {
    super.onInit();
    mapController = MapController();
    mapController.mapEventStream.listen((event) {
      if (event is MapEventMoveEnd) {
        _lazyLoadOnCameraMove();
      }
    });
    _initializeLocationUpdates();
    // _startGpsMonitoring();
  }

  /// Khởi tạo cập nhật vị trí
  Future<void> _initializeLocationUpdates() async {
    await _fetchCurrentPosition();
    _listenToPositionUpdates();
    _fetchNearbyUsers(viewRadius.value);
  }

  /// Lấy vị trí hiện tại
  Future<void> _fetchCurrentPosition() async {
    try {
      final position = await Geolocator.getCurrentPosition(
        desiredAccuracy: LocationAccuracy.high,
      );
      currentPosition.value = position;
      _debouncedUpdateUserLocation(position);
      mapController.move(
        LatLng(position.latitude, position.longitude),
        14.0,
      );
    } catch (e) {
      errorMessage("Failed to get current location: $e");
    }
  }

  /// Theo dõi cập nhật vị trí theo thời gian thực
  void _listenToPositionUpdates() {
    _positionStreamSubscription = Geolocator.getPositionStream(
      desiredAccuracy: LocationAccuracy.best,
      distanceFilter: 10, // Chỉ cập nhật khi di chuyển 10m
    ).listen(
      (Position position) {
        currentPosition.value = position;
        _debouncedUpdateUserLocation(position);
        _fetchNearbyUsers(viewRadius.value);
      },
      onError: (e) {
        errorMessage("Location updates failed: $e");
        // _checkGpsStatus();
      },
    );
  }

  /// Debounce cập nhật vị trí lên Firestore
  void _debouncedUpdateUserLocation(Position position) {
    _debounceTimer?.cancel();
    _debounceTimer = Timer(const Duration(seconds: 5), () {
      _updateUserLocation(position);
    });
  }

  /// Cập nhật vị trí người dùng lên Firestore
  Future<void> _updateUserLocation(Position position) async {
    try {
      await _firestore.collection('users').doc(userId).update({
        'location': GeoPoint(position.latitude, position.longitude),
        'lastUpdated': FieldValue.serverTimestamp(),
      }).catchError((e) => errorMessage("Error when update loaction: $e"));
    } catch (e) {
      errorMessage("Failed to update location: $e");
    }
  }

  /// Tìm kiếm bạn bè theo tên
  Future<void> findFriendLocationByName(String friendName) async {
    try {
      final querySnapshot = await _firestore
          .collection('users')
          .where('name', isEqualTo: friendName)
          .limit(1)
          .get();
      if (querySnapshot.docs.isNotEmpty) {
        final userDoc = querySnapshot.docs.first;
        final GeoPoint? location = userDoc['location'];
        if (location != null) {
          friendLocation.value = LatLng(location.latitude, location.longitude);
          mapController.move(friendLocation.value!, 14.0);
        } else {
          errorMessage("This user has no location data.");
        }
      } else {
        errorMessage("No friend found with this name.");
      }
    } catch (e) {
      errorMessage("Error searching for friend: $e");
    }
  }

  /// Lấy danh sách người dùng gần đó
  void _fetchNearbyUsers(double radius) {
    final userPosition = currentPosition.value;
    if (userPosition == null) return;

    _nearbyUsersSubscription
        ?.cancel(); // Hủy subscription cũ để tránh trùng lặp
    _nearbyUsersSubscription = _firestore
        .collection('users')
        .where('location', isNotEqualTo: null)
        .snapshots()
        .listen((snapshot) {
      displayUsers.clear();
      for (var doc in snapshot.docs) {
        if (doc.id == userId) continue; // Bỏ qua chính người dùng
        final data = doc.data();
        final GeoPoint? location = data['location'];
        if (location != null) {
          final distance = Geolocator.distanceBetween(
            userPosition.latitude,
            userPosition.longitude,
            location.latitude,
            location.longitude,
          );
          if (distance <= radius) {
            final user = UserModel.fromJson(data);
            displayUsers.add(user);
          }
        }
      }
    }, onError: (e) {
      errorMessage("Error fetching nearby users: $e");
    });
  }

  /// Lazy load khi camera di chuyển
  void _lazyLoadOnCameraMove() {
    try {
      final cameraCenter = mapController.camera.center;
      if (currentPosition.value != null) {
        final radius = Geolocator.distanceBetween(
          cameraCenter.latitude,
          cameraCenter.longitude,
          currentPosition.value!.latitude,
          currentPosition.value!.longitude,
        );
        if (radius > viewRadius.value) {
          viewRadius.value = radius + 1000;
        }
        _fetchNearbyUsers(viewRadius.value);
      }
    } catch (e) {
      errorMessage("Error during camera move: $e");
    }
  }

  /// Lấy tuyến đường đến bạn bè
  Future<void> getRouteToFriend({
    required LatLng userPosition,
    required LatLng friendPos,
  }) async {
    try {
      routePoints.clear();
      final route = await _routeService.fetchRoute(userPosition, friendPos);
      routePoints.assignAll(route);
      mapController.move(friendPos, 14.0);
    } catch (e) {
      errorMessage("Error fetching route: $e");
    }
  }

  // /// Theo dõi trạng thái GPS
  // void _startGpsMonitoring() {
  //   _gpsCheckTimer = Timer.periodic(const Duration(seconds: 30), (timer) async {
  //     if (!await FriendZoneMapService.ensureLocationPermission()) {
  //       isGpsEnabled.value = false;
  //     } else {
  //       isGpsEnabled.value = true;
  //     }
  //   });
  // }

  // /// Kiểm tra trạng thái GPS khi có lỗi
  // void _checkGpsStatus() async {
  //   if (!await FriendZoneMapService.ensureLocationPermission()) {
  //     isGpsEnabled.value = false;
  //   }
  // }

  @override
  void onClose() {
    _positionStreamSubscription?.cancel();
    _nearbyUsersSubscription?.cancel();
    _debounceTimer?.cancel();
    // _gpsCheckTimer?.cancel();
    mapController.dispose();
    super.onClose();
  }
}

```

---


### Components\friend_zone\friend_zone_map_page.dart

```dart
import 'package:cached_network_image/cached_network_image.dart';
import 'package:flutter/material.dart';
import 'package:flutter_animate/flutter_animate.dart';
import 'package:flutter_map/flutter_map.dart';
import 'package:get/get.dart';
import 'package:latlong2/latlong.dart';
import 'package:tictactoe_gameapp/Components/belong_to_users/avatar_user_widget.dart';
import 'package:tictactoe_gameapp/Components/friend_zone/friend_zone_map_controller.dart';
import 'package:tictactoe_gameapp/Configs/assets_path.dart';
import 'package:tictactoe_gameapp/Configs/constants.dart';
import 'package:tictactoe_gameapp/Controller/Animations/Overlays/profile_tooltip.dart';
import 'package:tictactoe_gameapp/Data/fetch_firestore_database.dart';
import 'package:tictactoe_gameapp/Enums/popup_position.dart';
import 'package:tictactoe_gameapp/Models/user_model.dart';
import 'package:tictactoe_gameapp/Components/rippleanimation/ripple_animation_widget.dart';
import 'package:tictactoe_gameapp/Components/friend_zone/tinder_cards/tinder_cards_widget.dart';

class FriendZoneMapPage extends StatelessWidget {
  final FirestoreController firestoreController;
  final UserModel user;
  final LatLng latlng;

  const FriendZoneMapPage({
    super.key,
    required this.user,
    required this.firestoreController,
    required this.latlng,
  });

  @override
  Widget build(BuildContext context) {
    LatLng defaultLatLng = const LatLng(21.0000992, 105.8399243);
    final ProfileTooltip profileTooltip = Get.put(ProfileTooltip());
    final LocationController locationController =
        Get.put(LocationController(userId: user.id!));
    RxString searchText = "".obs;
    final TextEditingController textEditingController = TextEditingController();
    final FocusNode searchFocusNode =
        FocusNode(); // Thêm FocusNode để quản lý focus
    const List<String> mapUrl = [
      "https://tile.openstreetmap.org/{z}/{x}/{y}.png",
      'https://cartodb-basemaps-{s}.global.ssl.fastly.net/light_all/{z}/{x}/{y}.png',
      'https://cartodb-basemaps-{s}.global.ssl.fastly.net/dark_all/{z}/{x}/{y}.png'
    ];
    RxString selectedUrl = mapUrl[0].obs;
    RxBool isExpanded = false.obs;
    RxBool isSearching = false.obs;

    return Scaffold(
      body: Stack(
        children: [
          FlutterMap(
            mapController: locationController.mapController,
            options: MapOptions(
              initialCenter: locationController.currentPosition.value == null
                  ? latlng
                  : LatLng(locationController.currentPosition.value!.latitude,
                      locationController.currentPosition.value!.longitude),
              initialZoom: 14.0,
            ),
            children: [
              Obx(() => TileLayer(
                    urlTemplate: selectedUrl.value,
                    userAgentPackageName:
                        'com.example.app/tictactoe_gameapp/11218415.2142003',
                    errorImage: CachedNetworkImageProvider(user.image!),
                  )),
              Obx(() => locationController.routePoints.isNotEmpty
                  ? GestureDetector(
                      onDoubleTap: () => locationController.routePoints.clear(),
                      child: PolylineLayer(
                        polylines: [
                          Polyline(
                            points: locationController.routePoints,
                            gradientColors: [
                              Colors.blue,
                              Colors.blueAccent,
                              Colors.pinkAccent
                            ],
                            strokeWidth: 10,
                          ),
                        ],
                      ),
                    )
                  : const SizedBox()),
              Obx(
                () => MarkerLayer(
                  markers: [
                    ...locationController.displayUsers.map((nearUser) {
                      final LatLng nearUserLatLng = nearUser.location == null
                          ? defaultLatLng
                          : LatLng(
                              nearUser.location!.latitude,
                              nearUser.location!.longitude,
                            );
                      final GlobalKey markerKey = GlobalKey();
                      return Marker(
                        point: nearUserLatLng,
                        width: 50,
                        height: 50,
                        child: InkWell(
                          key: markerKey,
                          onDoubleTap: () async {
                            await locationController.getRouteToFriend(
                              userPosition:
                                  locationController.currentPosition.value ==
                                          null
                                      ? latlng
                                      : LatLng(
                                          locationController
                                              .currentPosition.value!.latitude,
                                          locationController.currentPosition
                                              .value!.longitude),
                              friendPos: nearUserLatLng,
                            );
                          },
                          onTap: () {
                            profileTooltip.showProfileTooltip(
                              context,
                              markerKey,
                              nearUser,
                              PopupPosition.above,
                              null,
                              null,
                              null,
                            );
                          },
                          child: AvatarUserWidget(
                            radius: 30,
                            imagePath: nearUser.image!,
                            gradientColors:
                                user.avatarFrame ?? ["#FF4CAF50", "#FF81C784"],
                          ),
                        ),
                      );
                    }),
                    Marker(
                      point: locationController.currentPosition.value == null
                          ? latlng
                          : LatLng(
                              locationController
                                  .currentPosition.value!.latitude,
                              locationController
                                  .currentPosition.value!.longitude),
                      height: 100,
                      width: 100,
                      child: const RipplesAnimationCustom(),
                    ),
                    Marker(
                      point: locationController.currentPosition.value == null
                          ? latlng
                          : LatLng(
                              locationController
                                  .currentPosition.value!.latitude,
                              locationController
                                  .currentPosition.value!.longitude),
                      width: 50,
                      height: 50,
                      child: AvatarUserWidget(
                        radius: 30,
                        imagePath: user.image!,
                        gradientColors: user.avatarFrame,
                      ),
                    ),
                  ],
                ),
              ),
            ],
          ),
          Positioned(
            top: 10,
            child: Obx(() => AnimatedContainer(
                duration: const Duration(milliseconds: 500),
                height: isExpanded.value ? 80 : 0,
                width: MediaQuery.sizeOf(context).width,
                padding: const EdgeInsets.only(top: 10, left: 10, right: 10),
                alignment: Alignment.center,
                decoration: BoxDecoration(
                  color: Colors.white.withOpacity(0.5),
                  borderRadius: BorderRadius.circular(50),
                ),
                child: Obx(() {
                  if (locationController.displayUsers.isEmpty) {
                    return const Center(
                      child: Text(
                        "No User is here?",
                        style: TextStyle(
                          color: Colors.black,
                          fontSize: 22,
                          fontWeight: FontWeight.bold,
                        ),
                      ),
                    );
                  } else {
                    var nearUsers = locationController.displayUsers.toList();
                    return ListView.builder(
                        itemCount: nearUsers.length,
                        scrollDirection: Axis.horizontal,
                        itemBuilder: (context, index) {
                          final nearUser = nearUsers[index];
                          return GestureDetector(
                            onTap: nearUsers.isEmpty
                                ? null
                                : () async {
                                    await Get.dialog(
                                      Dialog(
                                        backgroundColor: Colors.transparent,
                                        child: MapFriendTinderWidget(
                                          users: nearUsers,
                                          initialIndex: index,
                                        ),
                                      )
                                          .animate()
                                          .scale(duration: duration750)
                                          .fadeIn(duration: duration750),
                                    );
                                  },
                            child: Padding(
                              padding: const EdgeInsets.only(right: 10),
                              child: SingleChildScrollView(
                                child: Column(
                                  children: [
                                    AvatarUserWidget(
                                      radius: 20,
                                      imagePath: nearUser.image!,
                                      gradientColors: nearUser.avatarFrame,
                                    ),
                                    Text(
                                      nearUser.name!,
                                      style: TextStyle(
                                        color: index % 2 == 0
                                            ? Colors.green
                                            : Colors.deepPurple,
                                        fontWeight: FontWeight.w500,
                                      ),
                                    )
                                  ],
                                ),
                              ),
                            ),
                          );
                        });
                  }
                }))),
          ),
          Obx(() => isSearching.value
              ? Positioned(
                  top: 50, // Đặt vị trí cố định để tránh chồng lấn
                  left: 10,
                  right: 10,
                  child: Obx(
                    () => TextField(
                      controller: textEditingController,
                      focusNode: searchFocusNode, // Gắn FocusNode
                      textInputAction: TextInputAction.done,
                      onChanged: (value) {
                        searchText.value = value;
                      },
                      decoration: InputDecoration(
                        hintText: "Search someone...",
                        suffixIcon: searchText.value.isEmpty
                            ? const Icon(
                                Icons.search_off,
                                color: Colors.grey,
                              )
                            : IconButton(
                                onPressed: () async {
                                  if (searchText.value.isNotEmpty) {
                                    await Get.showOverlay(
                                      asyncFunction: () async {
                                        await locationController
                                            .findFriendLocationByName(
                                                searchText.value);
                                        if (locationController
                                                .friendLocation.value !=
                                            null) {
                                          await locationController
                                              .getRouteToFriend(
                                            userPosition: latlng,
                                            friendPos: locationController
                                                .friendLocation.value!,
                                          );
                                        }
                                      },
                                      loadingWidget: Container(
                                        width: double.infinity,
                                        height: double.infinity,
                                        decoration: const BoxDecoration(
                                          image: DecorationImage(
                                            image: AssetImage(
                                              GifsPath.transitionGif,
                                            ),
                                            fit: BoxFit.cover,
                                          ),
                                        ),
                                      ),
                                    ).then((_) {
                                      if (locationController
                                              .friendLocation.value !=
                                          null) {
                                        locationController.mapController
                                            .moveAndRotate(
                                          locationController
                                                  .friendLocation.value ??
                                              latlng,
                                          16,
                                          1,
                                        );
                                      }
                                      textEditingController.clear();
                                      searchText.value = "";
                                      searchFocusNode.unfocus();
                                    });
                                  }
                                },
                                icon: const Icon(
                                  Icons.search,
                                  color: Colors.blueAccent,
                                  size: 30,
                                ),
                              ),
                      ),
                    ),
                  ),
                )
              : const SizedBox.shrink()),
          Positioned(
            bottom: 20,
            left: 50,
            right: 50,
            child: Container(
              padding:
                  const EdgeInsets.symmetric(vertical: 5.0, horizontal: 5.0),
              alignment: Alignment.center,
              decoration: BoxDecoration(
                color: Colors.blueAccent.withOpacity(0.85),
                borderRadius: BorderRadius.circular(50),
              ),
              child: SingleChildScrollView(
                scrollDirection: Axis.horizontal,
                child: Row(
                  mainAxisAlignment: MainAxisAlignment.spaceBetween,
                  children: [
                    IconButton(
                      onPressed: () {
                        isExpanded.value = !isExpanded.value;
                      },
                      icon: const Icon(
                        Icons.location_history,
                        size: 40,
                        color: Colors.white,
                      ),
                    ),
                    IconButton(
                      onPressed: () {
                        isSearching.value = !isSearching.value;
                        if (isSearching.value) {
                          Future.delayed(const Duration(milliseconds: 100),
                              () => searchFocusNode.requestFocus());
                        }
                      },
                      icon: const Icon(
                        Icons.search_rounded,
                        size: 40,
                        color: Colors.white,
                      ),
                    ),
                    Container(
                      padding: const EdgeInsets.all(2.0),
                      decoration: const BoxDecoration(
                        color: Colors.white,
                        shape: BoxShape.circle,
                      ),
                      child: IconButton(
                        onPressed: () {
                          locationController.mapController.move(
                              locationController.currentPosition.value == null
                                  ? latlng
                                  : LatLng(
                                      locationController
                                          .currentPosition.value!.latitude,
                                      locationController
                                          .currentPosition.value!.longitude),
                              14.0);
                        },
                        icon: const Icon(
                          Icons.location_on,
                          size: 40,
                          color: Colors.purpleAccent,
                        ),
                      ),
                    ),
                    MenuAnchor(
                      builder: (context, controller, child) {
                        return IconButton(
                          onPressed: () {
                            if (controller.isOpen) {
                              controller.close();
                            } else {
                              controller.open();
                            }
                          },
                          icon: const Icon(
                            Icons.settings,
                            size: 40,
                            color: Colors.white,
                          ),
                        );
                      },
                      menuChildren: [
                        MenuItemButton(
                          onPressed: () => selectedUrl.value = mapUrl[0],
                          child: const Text('Default'),
                        ),
                        MenuItemButton(
                          onPressed: () => selectedUrl.value = mapUrl[1],
                          child: const Text('Light'),
                        ),
                        MenuItemButton(
                          onPressed: () => selectedUrl.value = mapUrl[2],
                          child: const Text('Dark'),
                        ),
                      ],
                    ),
                    IconButton(
                      onPressed: () => Get.back(),
                      icon: const Icon(
                        Icons.exit_to_app_rounded,
                        size: 40,
                        color: Colors.white,
                      ),
                    ),
                  ],
                ),
              ),
            ),
          ),
        ],
      ),
    );
  }
}
// Marker(
                    //   point: locationController.currentPosition.value == null
                    //       ? latlng
                    //       : LatLng(
                    //           locationController
                    //               .currentPosition.value!.latitude,
                    //           locationController
                    //               .currentPosition.value!.longitude),
                    //   height: MediaQuery.sizeOf(context).width,
                    //   width: MediaQuery.sizeOf(context).width,
                    //   child: Container(
                    //     decoration: BoxDecoration(
                    //       color: Colors.blue.withOpacity(0.1),
                    //       shape: BoxShape.circle,
                    //       border:
                    //           Border.all(color: Colors.blueAccent, width: 3),
                    //     ),
                    //   ),
                    // ),
 // ...firestoreController.friendsList.map((friend) {
                    //   final LatLng friendLatLng = friend.location == null
                    //       ? defaultLatLng
                    //       : LatLng(friend.location!.latitude,
                    //           friend.location!.longitude);
                    //   final GlobalKey itemKey = GlobalKey();
                    //   return Marker(
                    //     point: friendLatLng,
                    //     width: 50,
                    //     height: 50,
                    //     child: InkWell(
                    //       key: itemKey,
                    //       onDoubleTap: () async {
                    //         await locationController.getRouteToFriend(
                    //             userPosition: latlng, friendPos: friendLatLng);
                    //       },
                    //       onTap: () {
                    //         profileTooltip.showProfileTooltip(
                    //           context,
                    //           itemKey,
                    //           friend,
                    //           PopupPosition.above,
                    //           null,
                    //           null,
                    //           null,
                    //         );
                    //       },
                    //       child: Container(
                    //         decoration: BoxDecoration(
                    //           shape: BoxShape.circle,
                    //           color: Colors.redAccent,
                    //           border:
                    //               Border.all(color: Colors.redAccent, width: 3),
                    //         ),
                    //         child: CircleAvatar(
                    //           radius: 30,
                    //           backgroundImage: friend.image != null &&
                    //                   friend.image!.isNotEmpty
                    //               ? CachedNetworkImageProvider(friend.image!)
                    //               : null,
                    //           child:
                    //               friend.image == null || friend.image!.isEmpty
                    //                   ? const Icon(Icons.person_2_outlined)
                    //                   : null,
                    //         ),
                    //       ),
                    //     ),
                    //   );
                    // }),

                    // ...firestoreController.usersList.map(
                    //   (friend) {
                    //     final randomPosition = _generateRandomLatLng(
                    //       locationController.currentPosition.value == null
                    //           ? latlng
                    //           : LatLng(
                    //               locationController
                    //                   .currentPosition.value!.latitude,
                    //               locationController
                    //                   .currentPosition.value!.longitude),
                    //       0.009,
                    //     );
                    //     final GlobalKey itemKey = GlobalKey();
                    //     return Marker(
                    //       point: randomPosition,
                    //       width: 50,
                    //       height: 50,
                    //       child: InkWell(
                    //         key: itemKey,
                    //         onDoubleTap: () async {
                    //           await locationController.getRouteToFriend(
                    //               userPosition: latlng,
                    //               friendPos: randomPosition);
                    //         },
                    //         onTap: () {
                    //           profileTooltip.showProfileTooltip(
                    //             context,
                    //             itemKey,
                    //             friend,
                    //             PopupPosition.above,
                    //             null,
                    //             null,
                    //             null,
                    //           );
                    //         },
                    //         child: Container(
                    //           decoration: BoxDecoration(
                    //             shape: BoxShape.circle,
                    //             color: Colors.redAccent,
                    //             border: Border.all(
                    //                 color: Colors.redAccent, width: 3),
                    //           ),
                    //           child: CircleAvatar(
                    //             radius: 30,
                    //             backgroundImage: friend.image != null &&
                    //                     friend.image!.isNotEmpty
                    //                 ? CachedNetworkImageProvider(friend.image!)
                    //                 : null,
                    //             child: friend.image == null ||
                    //                     friend.image!.isEmpty
                    //                 ? const Icon(Icons.person_2_outlined)
                    //                 : null,
                    //           ),
                    //         ),
                    //       ),
                    //     );
                    //   },
                    // ),
```

---


### Components\friend_zone\friend_zone_map_service.dart

```dart
import 'package:flutter/material.dart';
import 'package:geolocator/geolocator.dart';
import 'package:get/get.dart';
import 'package:latlong2/latlong.dart';
import 'package:tictactoe_gameapp/Components/friend_zone/friend_zone_map_page.dart';
import 'package:tictactoe_gameapp/Configs/messages.dart';
import 'package:tictactoe_gameapp/Data/fetch_firestore_database.dart';
import 'package:tictactoe_gameapp/Models/user_model.dart';

class FriendZoneMapService {
  static Future<void> navigateFriendZoneMap({
    required UserModel user,
    required FirestoreController firestoreController,
  }) async {
    if (await ensureLocationPermission()) {
      late LatLng latlng;
      if (user.location != null) {
        latlng = LatLng(user.location!.latitude, user.location!.longitude);
      } else {
        latlng = const LatLng(21.0000992, 105.8399243);
      }
      Get.to(
        () => FriendZoneMapPage(
          user: user,
          firestoreController: firestoreController,
          latlng: latlng,
        ),
        transition: Transition.zoom,
      );
    } else {
      errorMessage("You need to grant location access to use the friend map.");
    }
  }

  static Future<bool> ensureLocationPermission() async {
    bool serviceEnabled;
    LocationPermission permission;

    // Check if location service is enabled
    serviceEnabled = await Geolocator.isLocationServiceEnabled();
    if (!serviceEnabled) {
      await _showLocationServiceDialog();
      serviceEnabled = await Geolocator.isLocationServiceEnabled();
      if (!serviceEnabled) return false;
    }

    // Check and request permission
    permission = await Geolocator.checkPermission();
    while (permission != LocationPermission.always &&
        permission != LocationPermission.whileInUse) {
      if (permission == LocationPermission.denied) {
        permission = await Geolocator.requestPermission();
      }
      if (permission == LocationPermission.deniedForever) {
        await _showPermissionDeniedForeverDialog();
        permission = await Geolocator.checkPermission();
      }
      if (permission == LocationPermission.denied ||
          permission == LocationPermission.deniedForever) {
        return false;
      }
    }
    return true;
  }

  // Custom dialog for location service disabled
  static Future<void> _showLocationServiceDialog() async {
    await Get.dialog(
      Dialog(
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(20)),
        elevation: 10,
        backgroundColor: Colors.transparent,
        child: Container(
          padding: const EdgeInsets.all(20),
          decoration: BoxDecoration(
            gradient: LinearGradient(
              colors: [Colors.blue.shade700, Colors.blue.shade400],
              begin: Alignment.topLeft,
              end: Alignment.bottomRight,
            ),
            borderRadius: BorderRadius.circular(20),
            boxShadow: [
              BoxShadow(
                color: Colors.black.withOpacity(0.3),
                blurRadius: 10,
                offset: const Offset(0, 5),
              ),
            ],
          ),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              const Icon(Icons.location_off, color: Colors.white, size: 50),
              const SizedBox(height: 15),
              const Text(
                "Location Service Disabled",
                style: TextStyle(
                  color: Colors.white,
                  fontSize: 22,
                  fontWeight: FontWeight.bold,
                ),
                textAlign: TextAlign.center,
              ),
              const SizedBox(height: 10),
              const Text(
                "Please enable location services to use the friend map feature.",
                style: TextStyle(color: Colors.white70, fontSize: 16),
                textAlign: TextAlign.center,
              ),
              const SizedBox(height: 20),
              Row(
                mainAxisAlignment: MainAxisAlignment.spaceEvenly,
                children: [
                  ElevatedButton(
                    onPressed: () async {
                      Get.back();
                      await Geolocator.openLocationSettings();
                    },
                    style: ElevatedButton.styleFrom(
                      backgroundColor: Colors.white,
                      foregroundColor: Colors.blue.shade700,
                      shape: RoundedRectangleBorder(
                        borderRadius: BorderRadius.circular(10),
                      ),
                      padding: const EdgeInsets.symmetric(
                          horizontal: 20, vertical: 10),
                    ),
                    child: const Text(
                      "Open Settings",
                      style:
                          TextStyle(fontSize: 16, fontWeight: FontWeight.bold),
                    ),
                  ),
                  TextButton(
                    onPressed: () => Get.back(),
                    child: const Text(
                      "Cancel",
                      style: TextStyle(
                        color: Colors.white,
                        fontSize: 16,
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                  ),
                ],
              ),
            ],
          ),
        ),
      ),
      barrierDismissible: false,
    );
  }

  // Custom dialog for permission denied forever
  static Future<void> _showPermissionDeniedForeverDialog() async {
    await Get.dialog(
      Dialog(
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(20)),
        elevation: 10,
        backgroundColor: Colors.transparent,
        child: Container(
          padding: const EdgeInsets.all(20),
          decoration: BoxDecoration(
            gradient: LinearGradient(
              colors: [Colors.red.shade700, Colors.red.shade400],
              begin: Alignment.topLeft,
              end: Alignment.bottomRight,
            ),
            borderRadius: BorderRadius.circular(20),
            boxShadow: [
              BoxShadow(
                color: Colors.black.withOpacity(0.3),
                blurRadius: 10,
                offset: const Offset(0, 5),
              ),
            ],
          ),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              const Icon(Icons.lock, color: Colors.white, size: 50),
              const SizedBox(height: 15),
              const Text(
                "Permission Denied",
                style: TextStyle(
                  color: Colors.white,
                  fontSize: 22,
                  fontWeight: FontWeight.bold,
                ),
                textAlign: TextAlign.center,
              ),
              const SizedBox(height: 10),
              const Text(
                "You've denied location access. Please grant permission in settings to use the friend map.",
                style: TextStyle(color: Colors.white70, fontSize: 16),
                textAlign: TextAlign.center,
              ),
              const SizedBox(height: 20),
              Row(
                mainAxisAlignment: MainAxisAlignment.spaceEvenly,
                children: [
                  ElevatedButton(
                    onPressed: () async {
                      Get.back();
                      await Geolocator.openLocationSettings();
                    },
                    style: ElevatedButton.styleFrom(
                      backgroundColor: Colors.white,
                      foregroundColor: Colors.red.shade700,
                      shape: RoundedRectangleBorder(
                        borderRadius: BorderRadius.circular(10),
                      ),
                      padding: const EdgeInsets.symmetric(
                          horizontal: 20, vertical: 10),
                    ),
                    child: const Text(
                      "Open Settings",
                      style:
                          TextStyle(fontSize: 16, fontWeight: FontWeight.bold),
                    ),
                  ),
                  TextButton(
                    onPressed: () => Get.back(),
                    child: const Text(
                      "Cancel",
                      style: TextStyle(
                        color: Colors.white,
                        fontSize: 16,
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                  ),
                ],
              ),
            ],
          ),
        ),
      ),
      barrierDismissible: false,
    );
  }
}

```

---


### Components\friend_zone\tinder_cards\example_model_card.dart

```dart
import 'package:flutter/material.dart';
import 'package:tictactoe_gameapp/Models/user_model.dart';
import 'package:tictactoe_gameapp/Pages/Society/About/user_about_page.dart';

class CardTinderWidget extends StatelessWidget {
  final UserModel user;
  final List<Color> colors;
  final int index;

  const CardTinderWidget(
      {super.key,
      required this.user,
      required this.colors,
      required this.index});

  @override
  Widget build(BuildContext context) {
    return Container(
      clipBehavior: Clip.hardEdge,
      decoration: BoxDecoration(
        borderRadius: const BorderRadius.all(Radius.circular(10)),
        color: Colors.white,
        boxShadow: [
          BoxShadow(
            color: Colors.grey.withOpacity(0.2),
            spreadRadius: 3,
            blurRadius: 7,
            offset: const Offset(0, 3),
          ),
        ],
      ),
      alignment: Alignment.center,
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Flexible(
            child: Container(
              decoration: BoxDecoration(
                gradient: LinearGradient(
                  begin: Alignment.topCenter,
                  end: Alignment.bottomCenter,
                  colors: colors,
                ),
              ),
              child: UserAboutPage(
                unknownableUser: user,
                isCardTinder: true,
              ),
            ),
          ),
          // Padding(
          //   padding: const EdgeInsets.all(16),
          //   child: Column(
          //     crossAxisAlignment: CrossAxisAlignment.start,
          //     children: [
          //       Text(
          //         user.name!,
          //         style: const TextStyle(
          //           color: Colors.black,
          //           fontWeight: FontWeight.bold,
          //           fontSize: 20,
          //         ),
          //       ),
          //       const SizedBox(height: 5),
          //       Text(
          //         user.email!,
          //         style: const TextStyle(
          //           color: Colors.grey,
          //           fontSize: 15,
          //         ),
          //       ),
          //       const SizedBox(height: 5),
          //       Text(
          //         user.lastActive != null
          //             ? TimeFunctions.displayTimeDefault(user.lastActive!)
          //             : "",
          //         style: const TextStyle(color: Colors.grey),
          //       ),
          //     ],
          //   ),
          // ),
        ],
      ),
    );
  }
}

```

---


### Components\friend_zone\tinder_cards\tinder_cards_controller.dart

```dart
import 'dart:ui';

import 'package:get/get.dart';
import 'package:flutter_card_swiper/flutter_card_swiper.dart';
import 'package:tictactoe_gameapp/Controller/theme_controller.dart';
import 'package:tictactoe_gameapp/Models/Functions/gradient_generator_functions.dart';

class TinderCardController extends GetxController {
  final CardSwiperController cardController = CardSwiperController();
  final ThemeController themeController = Get.find();
  late final List<List<Color>> newGradients;

  final int colorsLength;
  TinderCardController({required this.colorsLength});

  @override
  void onInit() {
    super.onInit();
    newGradients = List.generate(colorsLength, (_) {
      final colors = GradientGeneratorFunctions.getDynamicRandomGradientColors(
        colorCount: 2,
        isDarkMode: themeController.isDarkMode.value,
      );

      return colors;
    });
  }

  @override
  void onClose() {
    cardController.dispose();
    super.onClose();
  }

  bool onSwipe(
      int previousIndex, int? currentIndex, CardSwiperDirection direction) {
    print(
      'The card $previousIndex was swiped to the ${direction.name}. Now the card $currentIndex is on top',
    );
    return true;
  }

  bool onUndo(
      int? previousIndex, int currentIndex, CardSwiperDirection direction) {
    print(
      'The card $currentIndex was undone from the ${direction.name}',
    );
    return true;
  }

  void swipe(CardSwiperDirection direction) {
    cardController.swipe(direction);
  }

  void undo() {
    cardController.undo();
  }
}

```

---


### Components\friend_zone\tinder_cards\tinder_cards_widget.dart

```dart
import 'package:flutter/material.dart';
import 'package:flutter_card_swiper/flutter_card_swiper.dart';
import 'package:get/get.dart';
import 'package:tictactoe_gameapp/Models/user_model.dart';
import 'package:tictactoe_gameapp/Components/friend_zone/tinder_cards/example_model_card.dart';
import 'package:tictactoe_gameapp/Components/friend_zone/tinder_cards/tinder_cards_controller.dart';

class MapFriendTinderWidget extends StatelessWidget {
  final List<UserModel> users;
  final int initialIndex;
  const MapFriendTinderWidget({
    super.key,
    required this.users,
    required this.initialIndex,
  });

  @override
  Widget build(BuildContext context) {
    final TinderCardController controller =
        Get.put(TinderCardController(colorsLength: users.length));

    return Column(
      children: [
        Flexible(
          child: CardSwiper(
            controller: controller.cardController,
            initialIndex: initialIndex,
            cardsCount: users.length,
            onSwipe: controller.onSwipe,
            onUndo: controller.onUndo,
            numberOfCardsDisplayed: users.length < 3 ? users.length : 3,
            backCardOffset: const Offset(40, 40),
            padding: const EdgeInsets.all(0.0),
            cardBuilder: (context, index, horizontalThresholdPercentage,
                    verticalThresholdPercentage) =>
                CardTinderWidget(
              user: users[index],
              colors: controller.newGradients[index],
              index: initialIndex,
            ),
          ),
        ),
        const SizedBox(
          height: 20,
        ),
        _interactCardFAB(controller),
      ],
    );
  }

  Widget _interactCardFAB(TinderCardController controller) {
    return Row(
      mainAxisAlignment: MainAxisAlignment.spaceAround,
      children: [
        FloatingActionButton(
          heroTag: "1",
          elevation: 5.0,
          onPressed: controller.undo,
          child: const Icon(
            Icons.rotate_90_degrees_ccw_rounded,
            size: 30,
            color: Colors.blueAccent,
          ),
        ),
        FloatingActionButton(
          heroTag: "2",
          onPressed: () => controller.swipe(CardSwiperDirection.left),
          child: const Icon(
            Icons.keyboard_arrow_left,
            size: 30,
            color: Colors.blueAccent,
          ),
        ),
        FloatingActionButton(
          heroTag: "3",
          onPressed: () => controller.swipe(CardSwiperDirection.right),
          child: const Icon(
            Icons.keyboard_arrow_right,
            size: 30,
            color: Colors.blueAccent,
          ),
        ),
        FloatingActionButton(
          heroTag: "4",
          onPressed: () => controller.swipe(CardSwiperDirection.top),
          child: const Icon(
            Icons.keyboard_arrow_up,
            size: 30,
            color: Colors.blueAccent,
          ),
        ),
        FloatingActionButton(
          heroTag: "5",
          onPressed: () => controller.swipe(CardSwiperDirection.bottom),
          child: const Icon(
            Icons.keyboard_arrow_down,
            size: 30,
            color: Colors.blueAccent,
          ),
        ),
      ],
    );
  }
}

```

---


### Components\gifphy\display_gif_widget.dart

```dart
import 'package:cached_network_image/cached_network_image.dart';
import 'package:flutter/material.dart';
import 'package:flutter_animate/flutter_animate.dart';
import 'package:get/get.dart';

class DisplayGifWidget extends StatelessWidget {
  final String gifUrl;
  const DisplayGifWidget({super.key, required this.gifUrl});

  @override
  Widget build(BuildContext context) {
    return SizedBox(
      height: 100,
      child: GestureDetector(
        onTap: () {
          Get.dialog(
            Dialog(
              backgroundColor: Colors.transparent,
              insetPadding: const EdgeInsets.all(10),
              child: GestureDetector(
                onTap: () => Get.back(),
                child: InteractiveViewer(
                  boundaryMargin: const EdgeInsets.all(8),
                  minScale: 0.0005,
                  maxScale: 3,
                  child: Container(
                    width: double.infinity,
                    height: 200,
                    alignment: Alignment.topCenter,
                    decoration: BoxDecoration(
                      image: DecorationImage(
                        image: CachedNetworkImageProvider(gifUrl),
                        fit: BoxFit.fitWidth,
                      ),
                    ),
                  ),
                ),
              ),
            ).animate().scale(duration: const Duration(milliseconds: 600)),
          );
        },
        child: ClipRRect(
            borderRadius: BorderRadius.circular(10),
            child: CachedNetworkImage(
              imageUrl: gifUrl,
              placeholder: (context, url) => Container(
                padding:
                    const EdgeInsets.symmetric(vertical: 10, horizontal: 30),
                alignment: Alignment.center,
                decoration: BoxDecoration(
                    color: Colors.grey,
                    borderRadius: BorderRadius.circular(10)),
                child: const Icon(
                  Icons.image,
                  size: 50,
                  color: Colors.blueGrey,
                ),
              ),
              errorWidget: (context, url, error) => const Icon(Icons.error),
              fit: BoxFit.cover,
            )),
      ),
    );
  }
}

```

---


### Components\gifphy\preview_gif_widget.dart

```dart
import 'package:flutter/material.dart';
import 'package:get/get_rx/src/rx_types/rx_types.dart';
import 'package:get/get_state_manager/src/rx_flutter/rx_obx_widget.dart';
import 'package:giphy_picker/giphy_picker.dart';

class PreviewGifWidget extends StatelessWidget {
  final Rx<GiphyGif?> selectedGif;
  const PreviewGifWidget({super.key, required this.selectedGif});

  @override
  Widget build(BuildContext context) {
    return Obx(() => selectedGif.value == null
        ? const SizedBox()
        : SizedBox(
            height: 150,
            child: ClipRRect(
              borderRadius: BorderRadius.circular(10),
              child: Image.network(
                selectedGif.value!.images.original!.url!,
                loadingBuilder: (context, child, loadingProgress) {
                  if (loadingProgress == null) return child;
                  return Center(
                      child: Container(
                    padding: const EdgeInsets.symmetric(
                        vertical: 10, horizontal: 30),
                        alignment: Alignment.center,
                    decoration: BoxDecoration(
                        color: Colors.grey,
                        borderRadius: BorderRadius.circular(10)),
                    child: const Icon(
                      Icons.image,
                      size: 50,
                      color: Colors.blueGrey,
                    ),
                  ));
                },
                errorBuilder: (context, error, stackTrace) {
                  return const Center(
                    child: Text(
                      "Error loading GIF",
                      style:
                          TextStyle(fontSize: 20, fontWeight: FontWeight.bold),
                    ),
                  );
                },
              ),
            )));
  }
}

```

---


### Components\gifphy\stack_image_widget.dart

```dart
import 'dart:convert';
import 'dart:math';

import 'package:flutter/material.dart';
import 'package:flutter_animate/flutter_animate.dart';
import 'package:get/get.dart';
import 'package:tictactoe_gameapp/Pages/Society/social_post_model.dart';

class StackImageWidget extends StatelessWidget {
  final List<String> imageUrls;
  const StackImageWidget({super.key, required this.imageUrls});

  @override
  Widget build(BuildContext context) {
    return buildStackedImages(imageUrls);
  }

  Widget buildStackedImages(List<String> imageUrls) {
    return imageUrls.length < 2
        ? GestureDetector(
            onTap: () {
              _onTapToExtendImage();
            },
            child: DecoratedBox(
              decoration: BoxDecoration(
                border: Border.all(color: Colors.white, width: 2),
                borderRadius: BorderRadius.circular(10),
                boxShadow: const [
                  BoxShadow(
                    color: Colors.grey,
                    blurRadius: 4,
                    offset: Offset(2, 2),
                  ),
                  BoxShadow(
                    color: Colors.grey,
                    blurRadius: 4,
                    offset: Offset(-2, -2),
                  ),
                ],
              ),
              child: ClipRRect(
                borderRadius: BorderRadius.circular(8),
                child: Image.memory(
                  base64Decode(imageUrls.first),
                  fit: BoxFit.cover,
                ),
              ),
            ),
          )
        : SwipeDoubleTapStack(
            imageUrls: imageUrls,
          );
  }

  void _onTapToExtendImage() {
    Get.dialog(
      Dialog(
        backgroundColor: Colors.transparent,
        insetPadding: const EdgeInsets.all(10),
        child: GestureDetector(
          onTap: () => Get.back(),
          child: InteractiveViewer(
            boundaryMargin: const EdgeInsets.all(8),
            minScale: 0.00005,
            maxScale: 3,
            child: Container(
              width: double.infinity,
              height: 200,
              alignment: Alignment.topCenter,
              decoration: BoxDecoration(
                image: DecorationImage(
                  image: MemoryImage(
                    base64Decode(imageUrls.first),
                  ),
                  fit: BoxFit.fitWidth,
                ),
              ),
            ),
          ),
        ),
      ).animate().scale(duration: const Duration(milliseconds: 600)),
    );
  }
}

class NoneStackImageWidget extends StatelessWidget {
  final PostModel post;
  const NoneStackImageWidget({super.key, required this.post});

  @override
  Widget build(BuildContext context) {
    var currentIndex = 0.obs;
    return SizedBox(
      height: 100,
      child: ListView.builder(
          scrollDirection: Axis.horizontal,
          itemCount: post.imageUrls!.length,
          itemBuilder: (context, index) {
            return Row(
              children: [
                GestureDetector(
                  onTap: () {
                    currentIndex.value = index;
                    Get.dialog(
                      Dialog(
                        backgroundColor: Colors.transparent,
                        insetPadding: const EdgeInsets.all(10),
                        child: GestureDetector(
                          onTap: () => Get.back(),
                          child: PageView.builder(
                            controller:
                                PageController(initialPage: currentIndex.value),
                            onPageChanged: (index) {
                              currentIndex.value = index;
                            },
                            itemCount: post.imageUrls!.length,
                            itemBuilder: (context, index) {
                              return Container(
                                width: double.infinity,
                                height: 200,
                                alignment: Alignment.topCenter,
                                decoration: BoxDecoration(
                                  image: DecorationImage(
                                    image: MemoryImage(
                                      base64Decode(
                                        post.imageUrls![index],
                                      ),
                                    ),
                                    fit: BoxFit.fitWidth,
                                  ),
                                ),
                                child: Text(
                                  "${index + 1} / ${post.imageUrls!.length}",
                                  style: const TextStyle(
                                      fontSize: 25,
                                      fontWeight: FontWeight.bold,
                                      color: Colors.white),
                                ),
                              );
                              //  InteractiveViewer(
                              //   boundaryMargin:
                              //       const EdgeInsets.all(8),
                              //   minScale: 1,
                              //   maxScale: 3,
                              //   child:
                              //    ClipRRect(
                              //     borderRadius:
                              //         BorderRadius.circular(10),
                              //     child: Image.memory(
                              //       base64Decode(
                              //         post.imageUrls![index],
                              //       ),
                              //       width: double.infinity,
                              //     ),
                              //   ),
                              // );
                            },
                          ),
                        ),
                      )
                          .animate()
                          .scale(duration: const Duration(milliseconds: 750)),
                    );
                  },
                  child: ClipRRect(
                    borderRadius: BorderRadius.circular(10),
                    child: Image.memory(
                      base64Decode(
                        post.imageUrls![index],
                      ),
                    ),
                  ),
                ),
                const SizedBox(
                  width: 10,
                ),
              ],
            );
          }),
    );
  }
}

class SwipeDoubleTapStack extends StatefulWidget {
  final List<String> imageUrls;

  const SwipeDoubleTapStack({super.key, required this.imageUrls});

  @override
  State<SwipeDoubleTapStack> createState() => _SwipeDoubleTapStackState();
}

class _SwipeDoubleTapStackState extends State<SwipeDoubleTapStack>
    with SingleTickerProviderStateMixin {
  late RxList<String> images;
  late RxInt topIndex;

  late AnimationController _controller;
  late Animation<Offset> _offsetAnimation;

  @override
  void initState() {
    super.initState();
    images = RxList<String>.from(widget.imageUrls);
    topIndex = RxInt(images.length - 1);

    // Setup animation controller
    _controller = AnimationController(
      duration: const Duration(milliseconds: 750),
      vsync: this,
    );
    _offsetAnimation = Tween<Offset>(
      begin: Offset.zero,
      end: _generateRandomDirection(), // Random hướng
    ).animate(CurvedAnimation(parent: _controller, curve: Curves.easeInOut));
  }

  /// Hàm xử lý sự kiện double tap
  void _onDoubleTap() {
    if (images.isEmpty) return;

    final String topImage = images[topIndex.value];

    // Cập nhật hiệu ứng
    _offsetAnimation = Tween<Offset>(
      begin: Offset.zero,
      end: _generateRandomDirection(),
    ).animate(CurvedAnimation(parent: _controller, curve: Curves.easeInOut));

    // Chạy animation
    _controller.forward().then((_) {
      // Thay đổi trạng thái mà không cần setState
      images.removeAt(topIndex.value);
      images.insert(0, topImage);
      topIndex.value = images.length - 1;

      // Reset controller
      _controller.reset();
    });
  }

  Offset _generateRandomDirection() {
    final List<Offset> directions = [
      const Offset(1, 0), // Sang phải
      const Offset(-1, 0), // Sang trái
      const Offset(0, 1), // Xuống dưới
      const Offset(0, -1), // Lên trên
    ];
    return directions[Random().nextInt(directions.length)];
  }

  double _generateRandomAngle(int index) {
    final int sign = (index % 2 == 0) ? 1 : -1; // Quyết định chiều xoay
    final double baseAngle = 5 + index * 2; // Tăng dần theo index
    return sign * pi / 180 * (baseAngle + Random().nextDouble() * 5);
    // return (index % 3 == 0 ? -1 : 1) * pi / 180 * (5 + (index * 3) % 10);
  }

  void _onTapToExtendImageList({required int currentIndex}) {
    Get.dialog(
      Dialog(
        backgroundColor: Colors.transparent,
        insetPadding: const EdgeInsets.all(10),
        child: GestureDetector(
          onTap: () => Get.back(),
          child: PageView.builder(
            controller: PageController(initialPage: currentIndex),
            onPageChanged: (index) {
              currentIndex = index;
            },
            itemCount: images.length,
            itemBuilder: (context, index) {
              return InteractiveViewer(
                boundaryMargin: const EdgeInsets.all(8),
                minScale: 0.00005,
                maxScale: 3,
                child: Container(
                  height: 200,
                  alignment: Alignment.topCenter,
                  decoration: BoxDecoration(
                    image: DecorationImage(
                      image: MemoryImage(base64Decode(images[index])),
                      fit: BoxFit.fitWidth,
                    ),
                  ),
                  child: Text(
                    "${index + 1} / ${images.length}",
                    style: const TextStyle(
                        fontSize: 25,
                        fontWeight: FontWeight.bold,
                        color: Colors.white),
                  ),
                ),
              );
            },
          ),
        ),
      ).animate().scale(duration: const Duration(milliseconds: 750)),
    );
  }

  Widget _buildImage(String imageUrl, int index) {
    final bool isTopImage = index == topIndex.value;

    return AnimatedPositioned(
      duration: const Duration(milliseconds: 750),
      curve: Curves.easeInOut,
      top: isTopImage ? 0 : 8.0 * (index - topIndex.value),
      left: isTopImage ? 0 : 8.0 * (index - topIndex.value),
      child: Transform.rotate(
        angle: _generateRandomAngle(index),
        child: GestureDetector(
          onDoubleTap: _onDoubleTap,
          onTap: () => _onTapToExtendImageList(currentIndex: topIndex.value),
          child: SlideTransition(
            position: isTopImage
                ? _offsetAnimation
                : const AlwaysStoppedAnimation(Offset.zero),
            child: Container(
              height: 100,
              width: MediaQuery.sizeOf(context).width / 2 - 25,
              decoration: BoxDecoration(
                border: Border.all(color: Colors.white, width: 2),
                borderRadius: BorderRadius.circular(10),
                boxShadow: const [
                  BoxShadow(
                    color: Colors.grey,
                    blurRadius: 4,
                    offset: Offset(2, 2),
                  ),
                  BoxShadow(
                    color: Colors.grey,
                    blurRadius: 4,
                    offset: Offset(-2, -2),
                  ),
                ],
              ),
              child: ClipRRect(
                borderRadius: BorderRadius.circular(8),
                child: Image.memory(
                  base64Decode(imageUrl),
                  fit: BoxFit.cover,
                ),
              ),
            ),
          ),
        ),
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    return Obx(() => Stack(
          clipBehavior: Clip.none,
          children: images.asMap().entries.map((entry) {
            final index = entry.key;
            final imageUrl = entry.value;
            return _buildImage(imageUrl, index);
          }).toList(),
        ));
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }
}

```

---


### Components\rippleanimation\circle_painter.dart

```dart
import 'package:flutter/material.dart';
import 'dart:math' as math show sqrt;


class CirclePainter extends CustomPainter {

  late final Color colorValue;
  late final Animation<double> _animation;

  CirclePainter(
      this._animation, {
        required this.colorValue,
      }) : super(repaint: _animation);

  void circle(Canvas canvas, Rect rect, double value) {
    final double opacity = (1.0 - (value / 4.0)).clamp(0.0, 1.0);
    final Color color = colorValue.withOpacity(opacity);
    final double size = rect.width/2;
    final double area = size * size;
    final double radius = math.sqrt(area * value / 4);
    final Paint paint = Paint()..color = color;
    canvas.drawCircle(rect.center, radius, paint);
  }

  @override
  void paint(Canvas canvas, Size size) {
    final Rect rect = Rect.fromLTRB(0.0, 0.0, size.width, size.height);
    for(int wave = 3; wave >= 0; wave--) {
      circle(canvas, rect, wave + _animation.value);
    }
  }

  @override
  bool shouldRepaint(covariant CustomPainter oldDelegate) => true;

}
```

---


### Components\rippleanimation\ripple_animation_widget.dart

```dart
import 'package:flutter/material.dart';
import 'package:tictactoe_gameapp/Components/rippleanimation/circle_painter.dart';

class RipplesAnimationCustom extends StatefulWidget {
  const RipplesAnimationCustom({super.key});

  @override
  State<RipplesAnimationCustom> createState() => _RipplesAnimationCustomState();
}

class _RipplesAnimationCustomState extends State<RipplesAnimationCustom>
    with TickerProviderStateMixin {
  late AnimationController _controller;

  @override
  void initState() {
    super.initState();
    _controller = AnimationController(
      duration: const Duration(milliseconds: 1000),
      vsync: this,
    )..repeat();
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final size = MediaQuery.of(context).size;
    return CustomPaint(
      painter: CirclePainter(_controller, colorValue: Colors.blue),
      child: SizedBox(
        width: size.width / 1.3,
        height: size.height / 1.3,
        // child: const Center(
        //     child: Text(
        //   "Searching...",
        //   style: TextStyle(
        //     color: Colors.white,
        //     fontSize: 16,
        //   ),
        // )),
      ),
    );
  }
}

```

---


### Components\shimmers\chats_placeholder_widget.dart

```dart
import 'package:flutter/material.dart';
import 'package:flutter_animate/flutter_animate.dart';

class ChatsPlaceholderWidget extends StatelessWidget {
  const ChatsPlaceholderWidget({super.key});

  @override
  Widget build(BuildContext context) {
    return _messagesLoadingPlaceholder();
  }

  Widget _messagesLoadingPlaceholder() {
    return ListView.builder(
      physics: const BouncingScrollPhysics(),
      itemCount: 6, // Số lượng placeholder
      itemBuilder: (context, index) {
        return Padding(
          padding: const EdgeInsets.symmetric(horizontal: 10, vertical: 15),
          child: Row(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Container(
                width: 70,
                height: 70,
                decoration: BoxDecoration(
                  shape: BoxShape.circle,
                  color: Colors.deepPurple[100],
                ),
              ),
              const SizedBox(width: 10),
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Container(
                      width: 120,
                      height: 16,
                      color: Colors.deepPurple[100],
                    ),
                    const SizedBox(height: 10),
                    Container(
                      width: 200,
                      height: 12,
                      color: Colors.deepPurple[100],
                    ),
                  ],
                ),
              ),
              Container(
                width: 60,
                height: 14,
                color: Colors.deepPurple[100],
              ),
            ],
          ),
        )
            .animate(onPlay: (controller) => controller.repeat(reverse: true))
            .shimmer(
              delay: 400.ms,
              duration: 1800.ms,
              colors: [Colors.deepPurple[100]!, Colors.deepPurple[50]!],
              size: 1.8,
              blendMode: BlendMode.srcATop,
            );
      },
    );
  }
}

```

---


### Components\shimmers\friendavatar_placeholder_widget.dart

```dart
import 'package:flutter/material.dart';
import 'package:flutter_animate/flutter_animate.dart';

class FriendavatarPlaceholderWidget extends StatelessWidget {
  const FriendavatarPlaceholderWidget({super.key});

  @override
  Widget build(BuildContext context) {
    return _friendAvatarPlaceholder();
  }

  Widget _friendAvatarPlaceholder() {
    return Padding(
      padding: const EdgeInsets.all(8.0),
      child: Column(
        children: [
          Container(
            width: 70,
            height: 70,
            decoration: BoxDecoration(
              shape: BoxShape.circle,
              color: Colors.grey[300],
            ),
          ),
          const SizedBox(height: 5),
          Container(
            width: 60,
            height: 15,
            color: Colors.grey[300],
          ),
        ],
      ),
    ).animate(onPlay: (controller) => controller.repeat(reverse: true)).shimmer(
      delay: 500.ms,
      duration: 1500.ms,
      colors: [Colors.grey[300]!, Colors.grey[100]!],
    );
  }
}

```

---


### Components\shimmers\lives_placeholder_widget.dart

```dart
import 'package:flutter/material.dart';
import 'package:flutter_animate/flutter_animate.dart';

class LivesPlaceholderWidget extends StatelessWidget {
  const LivesPlaceholderWidget({super.key});

  @override
  Widget build(BuildContext context) {
    return _liveStreamsLoadingPlaceholder();
  }

  Widget _liveStreamsLoadingPlaceholder() {
    return GridView.builder(
      gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(
        crossAxisCount: 2,
        childAspectRatio: 0.7,
      ),
      itemCount: 8, // Số lượng placeholder
      itemBuilder: (context, index) {
        return Container(
          margin: const EdgeInsets.all(5),
          padding: const EdgeInsets.all(10),
          decoration: BoxDecoration(
            color: Colors.grey[300],
            borderRadius: BorderRadius.circular(10),
          ),
          child: Column(
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            children: [
              // Thumbnail
              Container(
                width: double.infinity,
                height: 120,
                color: Colors.red[200],
              ),
              // Thông tin streamer và tiêu đề
              Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Row(
                    children: [
                      Container(
                        width: 40,
                        height: 40,
                        decoration: BoxDecoration(
                          shape: BoxShape.circle,
                          color: Colors.red[200],
                        ),
                      ),
                      const SizedBox(width: 5),
                      Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          Container(
                            width: 80,
                            height: 14,
                            color: Colors.red[200],
                          ),
                          const SizedBox(height: 4),
                          Container(
                            width: 60,
                            height: 12,
                            color: Colors.red[200],
                          ),
                        ],
                      ),
                    ],
                  ),
                  const SizedBox(height: 6),
                  Container(
                    width: 100,
                    height: 15,
                    color: Colors.red[200],
                  ),
                  const SizedBox(height: 4),
                  Container(
                    width: 120,
                    height: 12,
                    color: Colors.red[200],
                  ),
                  const SizedBox(height: 4),
                  Align(
                    alignment: Alignment.centerRight,
                    child: Container(
                      width: 50,
                      height: 10,
                      color: Colors.red[200],
                    ),
                  ),
                ],
              ),
            ],
          ),
        )
            .animate(onPlay: (controller) => controller.repeat(reverse: true))
            .shimmer(
              delay: 200.ms,
              duration: 1000.ms,
              colors: [
                Colors.red[200]!,
                Colors.yellow[200]!,
                Colors.green[200]!,
                Colors.blue[200]!,
              ],
              stops: [0.0, 0.3, 0.6, 1.0],
              size: 2.0,
            );
      },
    );
  }
}

```

---


### Components\shimmers\messages_placeholder_widget.dart

```dart
import 'package:flutter/material.dart';
import 'package:flutter_animate/flutter_animate.dart';

class MessagesPlaceholderWidget extends StatelessWidget {
  final bool isMe;
  const MessagesPlaceholderWidget({super.key, required this.isMe});

  @override
  Widget build(BuildContext context) {
    return _chatMessagePlaceholder(isMe: isMe);
  }

  Widget _chatMessagePlaceholder({required bool isMe}) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 8.0),
      child: Row(
        mainAxisAlignment:
            isMe ? MainAxisAlignment.end : MainAxisAlignment.start,
        children: [
          if (!isMe) // Avatar chỉ hiển thị cho tin nhắn của người khác
            Container(
              width: 40,
              height: 40,
              decoration: BoxDecoration(
                shape: BoxShape.circle,
                color: Colors.grey[300],
              ),
            ),
          const SizedBox(width: 10),
          Container(
            width: 200,
            height: 50,
            decoration: BoxDecoration(
              color: Colors.grey[300],
              borderRadius: BorderRadius.circular(15),
            ),
          ),
        ],
      ),
    ).animate(onPlay: (controller) => controller.repeat(reverse: true)).shimmer(
      delay: 500.ms, // Độ trễ trước khi bắt đầu hiệu ứng
      duration: 1500.ms, // Thời gian một chu kỳ shimmer
      colors: [
        Colors.grey[300]!,
        Colors.grey[100]!
      ], // Màu gradient của shimmer
    );
  }
}

```

---


### Components\shimmers\posts_placeholder_widget.dart

```dart
import 'package:flutter/material.dart';
import 'package:flutter_animate/flutter_animate.dart';

class PostsPlaceholderWidget extends StatelessWidget {
  final int itemCount;
  const PostsPlaceholderWidget({super.key, this.itemCount = 3});

  @override
  Widget build(BuildContext context) {
    return _postPlaceholder();
  }

  Widget _postPlaceholder() {
    return ListView.builder(
      itemCount: itemCount,
      shrinkWrap: true,
      physics: const NeverScrollableScrollPhysics(),
      itemBuilder: (context, index) => Padding(
        padding: const EdgeInsets.symmetric(vertical: 10.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // Header: Avatar và tên người dùng
            Row(
              children: [
                Container(
                  width: 40,
                  height: 40,
                  decoration: BoxDecoration(
                    shape: BoxShape.circle,
                    color: Colors.grey[300],
                  ),
                ),
                const SizedBox(width: 10),
                Container(
                  width: 100,
                  height: 16,
                  color: Colors.grey[300],
                ),
              ],
            ),
            const SizedBox(height: 10),
            // Nội dung bài viết
            Container(
              width: double.infinity,
              height: 16,
              color: Colors.grey[300],
            ),
            const SizedBox(height: 6),
            Container(
              width: double.infinity,
              height: 16,
              color: Colors.grey[300],
            ),
            const SizedBox(height: 10),
            // Hình ảnh bài viết
            Container(
              width: double.infinity,
              height: 200,
              color: Colors.grey[300],
            ),
            const SizedBox(height: 10),
            // Footer: Like, comment, share
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                Container(
                  width: 80,
                  height: 16,
                  color: Colors.grey[300],
                ),
                Container(
                  width: 80,
                  height: 16,
                  color: Colors.grey[300],
                ),
                Container(
                  width: 80,
                  height: 16,
                  color: Colors.grey[300],
                ),
              ],
            ),
          ],
        ),
      )
          .animate(onPlay: (controller) => controller.repeat(reverse: true))
          .shimmer(
        delay: 500.ms,
        duration: 1500.ms,
        colors: [Colors.grey[300]!, Colors.grey[100]!],
      ),
    );
  }
}

```

---


### Components\shimmers\urls_placeholder_widget.dart

```dart
import 'package:flutter/material.dart';
import 'package:flutter_animate/flutter_animate.dart';

class UrlsPlaceholderWidget extends StatelessWidget {
  const UrlsPlaceholderWidget({super.key});

  @override
  Widget build(BuildContext context) {
    return _videosLoadingPlaceholder();
  }

  Widget _videosLoadingPlaceholder() {
    return ListView.builder(
      itemCount: 10, // Số lượng placeholder
      itemBuilder: (context, index) {
        return Padding(
          padding: const EdgeInsets.symmetric(vertical: 8.0, horizontal: 8.0),
          child: Row(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              ClipRRect(
                borderRadius: BorderRadius.circular(10),
                child: Container(
                  width: 100,
                  height: 80,
                  color: Colors.orange[200],
                ),
              ),
              const SizedBox(width: 12),
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Container(
                      width: 150,
                      height: 16,
                      color: Colors.orange[200],
                    ),
                    const SizedBox(height: 6),
                    Container(
                      width: 200,
                      height: 12,
                      color: Colors.orange[200],
                    ),
                    const SizedBox(height: 4),
                    Container(
                      width: 180,
                      height: 12,
                      color: Colors.orange[200],
                    ),
                  ],
                ),
              ),
            ],
          ),
        )
            .animate(onPlay: (controller) => controller.repeat(reverse: true))
            .shimmer(
              delay: 500.ms,
              duration: 1500.ms,
              colors: [Colors.orange[200]!, Colors.orange[50]!],
              size: 1.5,
            );
      },
    );
  }
}

```

---


### Configs\assets_path.dart

```dart
class IconsPath {
  static const basePath = "assets/icons/";
  static const backIcon = "${basePath}back.svg";
  static const coinIcon = "${basePath}Coin.svg";
  static const copyIcon = "${basePath}copy.svg";
  static const oIcon = "${basePath}o.svg";
  static const smsIcon = "${basePath}sms.svg";
  static const wonIcon = "${basePath}won.svg";
  static const xIcon = "${basePath}x.svg";
  static const applogo = "${basePath}appLogo.png";
  static const mic = "${basePath}mic.svg";
  static const camera = "${basePath}camera.svg";
  static const gallery = "${basePath}gallery.svg";
  static const game = "${basePath}game.svg";
  static const github = "${basePath}github.svg";
  static const google = "${basePath}google.svg";
  static const facebook = "${basePath}facebook.svg";
  static const group = "${basePath}group.svg";
  static const info = "${basePath}info.svg";
  static const save = "${basePath}save.svg";
  static const user = "${basePath}user.svg";
  static const youtube = "${basePath}youtube.svg";
}

class ImagePath {
  static const basePath = "assets/photos/";
  static const background1 = "${basePath}background1.png";
  static const background2 = "${basePath}background2.png";
  static const background3 = "${basePath}background3.jpg";
  static const background4 = "${basePath}background4.jpg";
  static const boy = "${basePath}boy.png";
  static const girl = "${basePath}girl.png";
  static const welcome1 = "${basePath}welcome1.png";
  static const welcome2 = "${basePath}welcome2.png";
  static const welcome3 = "${basePath}welcome3.png";
  static const board_3x3 = "${basePath}board_3x3.jpg";
  static const board_6x6 = "${basePath}board_6x6.jpg";
  static const board_9x9 = "${basePath}board_9x9.jpg";
  static const board_11x11 = "${basePath}board_11x11.jpg";
  static const map1 = "${basePath}map1.jpg";
  static const map2 = "${basePath}map2.jpg";
  static const map4 = "${basePath}map4.jpg";
  static const map5 = "${basePath}map5.jpg";
  static const map6 = "${basePath}map6.jpg";
  static const map7 = "${basePath}map7.jpg";
  static const map8 = "${basePath}map8.jpg";
  static const map9 = "${basePath}map9.jpg";
  static const map10 = "${basePath}map10.jpg";
}

class GifsPath {
  static const basePath = "assets/gifs/";
  static const lightGif = "${basePath}background_gif.gif";
  static const tictactoeGif = "${basePath}tictactoe_gif.gif";
  static const androidGif = "${basePath}android_gif.gif";
  static const chatbotGif = "${basePath}chatbot_gif.gif";
  static const chloe1 = "${basePath}chloe_1.gif";
  static const loadingGif = "${basePath}loading_gif.gif";
  static const loadingGif2 = "${basePath}loading2.gif";
  static const transitionGif = "${basePath}transition_gif.gif";
  static const cyberpunk = "${basePath}cyperpunk_gif.gif";
}

class AudioSPath {
  static const basePath = "assets/audios/";
  static const blindPick = "${basePath}blind_pick.mp3";
  static const coins = "${basePath}coins.mp3";
  static const defeat = "${basePath}defeat.mp3";
  static const infinityCastle = "${basePath}infinity_castle.mp3";
  static const nakime = "${basePath}nakime.mp3";
  static const swordEffect = "${basePath}sword_effect.mp3";
  static const victory = "${basePath}victory.mp3";
  static const welcomeSound = "${basePath}welcome_sound.mp3";
  static const matchingSound = "${basePath}matching_sound.mp3";
}

class EffectingsPath {
  static const basePath = "assets/effectings/";
  static const boosterEffect = "${basePath}booster.mp3";
  static const digitalEffect = "${basePath}digital.mp3";
  static const futuricEffect = "${basePath}futuric.mp3";
  static const rippleEffect = "${basePath}ripple_button.mp3";
}

class ChampionsPathA {
  static const basePath = "assets/champions/";

  static const aatrox = "${basePath}Aatrox.webp";
  static const ahri = "${basePath}ahri.webp";
  static const akali = "${basePath}Akali.webp";
  static const alistar = "${basePath}Alistar.webp";
  static const anivia = "${basePath}Anivia.jpg";
  static const annie = "${basePath}Annie.jpg";
  static const aphelios = "${basePath}Aphelios.webp";
  static const ashe = "${basePath}Ashe.webp";
  static const aurelionSol = "${basePath}AurelionSol.webp";
  static const aurora = "${basePath}Aurora.webp";
  static const belveth = "${basePath}Belveth.webp";
  static const brand = "${basePath}Brand.jpg";
  static const caitlyn = "${basePath}Caitlyn.webp";
  static const camille = "${basePath}Camille.webp";
  static const darius = "${basePath}Darius.webp";
  static const diana = "${basePath}Diana.webp";
  static const evelynn = "${basePath}Evelynn.webp";
  static const ezreal = "${basePath}Ezreal.webp";
  static const fiora = "${basePath}Fiora.webp";
  static const gwen = "${basePath}Gwen.jpg";
  static const jinx = "${basePath}jinx.jpg";
  static const kalista = "${basePath}Kalista.jpg";
  static const karma = "${basePath}Karma.webp";
  static const katarina = "${basePath}Katarina.webp";
  static const kayle = "${basePath}Kayle.webp";
  static const kayn = "${basePath}Kayn.webp";
  static const leblanc = "${basePath}Leblanc.webp";
}

class ChampionsPathB {
  static const basePath = "assets/champions/";

  static const lillia = "${basePath}Lillia.jpg";
  static const lux = "${basePath}Lux.webp";
  static const masterYi = "${basePath}MasterYi.webp";
  static const missfortune = "${basePath}MissFortune.webp";
  static const nasus = "${basePath}Nasus.webp";
  static const nautilus = "${basePath}Nautilus.webp";
  static const nunu = "${basePath}Nunu.webp";
  static const qi = "${basePath}Qi.webp";
  static const quinn = "${basePath}Quinn.webp";
  static const rengar = "${basePath}Rengar.webp";
  static const riven = "${basePath}Riven.webp";
  static const seraphine = "${basePath}Seraphine.jpg";
  static const sivir = "${basePath}Sivir.webp";
  static const sona = "${basePath}Sona.webp";
  static const sylas = "${basePath}Sylas.webp";
  static const talon = "${basePath}Talon.webp";
  static const teemo = "${basePath}Teemo.webp";
  static const tryndamere = "${basePath}Tryndamere.webp";
  static const twistedFate = "${basePath}TwistedFate.webp";
  static const varus = "${basePath}Varus.webp";
  static const viego = "${basePath}Viego.webp";
  static const volibear = "${basePath}Volibear.webp";
  static const yasuo = "${basePath}Yasuo.webp";
  static const yone = "${basePath}Yone.jpg";
  static const zed = "${basePath}Zed.jpg";
  static const zoe = "${basePath}Zoe.webp";
}

class BorderRanking {
  static const basePath = "assets/borders/";
  static const bronzeBorder = "${basePath}bronze_border.webp";
  static const challBorder = "${basePath}chall_border.webp";
  static const diamondBorder = "${basePath}diamond_border.webp";
  static const goldBorder = "${basePath}gold_border.webp";
  static const ironBorder = "${basePath}iron_border.webp";
  static const masterBorder = "${basePath}master_border.webp";
  static const platinumBorder = "${basePath}platinum_border.webp";
  static const silverBorder = "${basePath}silver_border.webp";
}

class TrimRanking {
  static const basePath = "assets/borders/";
  static const bronzeTrim = "${basePath}bronze_trim.webp";
  static const challTrim = "${basePath}chall_trim.webp";
  static const diamondTrim = "${basePath}diamond_trim.webp";
  static const goldTrim = "${basePath}gold_trim.webp";
  static const ironTrim = "${basePath}iron_trim.webp";
  static const masterTrim = "${basePath}master_trim.webp";
  static const platinumTrim = "${basePath}platinum_trim.webp";
  static const silverTrim = "${basePath}silver_trim.webp";
}

class Emotes {
  static const angryKittenEmote = "assets/emotes/Angry_Kitten_Emote.webp";
  static const beeHappyEmote = "assets/emotes/Bee_Happy_Emote.webp";
  static const beeMadEmote = "assets/emotes/Bee_Mad_Emote.webp";
  static const beeSadEmote = "assets/emotes/Bee_Sad_Emote.webp";
  static const cupEmote = "assets/emotes/Cup-Yay%21_Emote.webp";
  static const despairEmote = "assets/emotes/Despair_Emote.webp";
  static const dressedToKillEmote = "assets/emotes/Dressed_to_Kill_Emote.webp";
  static const goodAsGoldEmote = "assets/emotes/Good_as_Gold_Emote.webp";
  static const happyToSeeUEmote = "assets/emotes/Happy_To_See_You_Emote.webp";
  static const howDareEmote = "assets/emotes/How_Dare_You%3F_Emote.webp";
  static const lookingForEmote = "assets/emotes/Looking_for_This%3F_Emote.webp";
  static const penguEmote = "assets/emotes/M%27Pengu_Emote.webp";
  static const peacePoroEmote = "assets/emotes/Peace_Poro_Emote.webp";
  static const sadKittenEmote = "assets/emotes/Sad_Kitten_Emote.webp";
  static const seeEmote = "assets/emotes/See_Ya%21_Emote.webp";
  static const starRikuEmote = "assets/emotes/Star_Guardian_Riku_Emote.webp";
  static const starSakiEmote = "assets/emotes/Star_Guardian_Saki_Emote.webp";
  static const starTowaEmote = "assets/emotes/Star_Guardian_Towa_Emote.webp";
  static const thumbsUpEmote = "assets/emotes/Thumbs_Up_Emote.webp";
}

class Jajas {
  static const basePath = "assets/jajas/";
  static const spinner = "${basePath}spinner.png";
  static const framePlatinum = "${basePath}frame_platinum.png";
  static const event = "${basePath}event.png";
  static const banner = "${basePath}banner.png";
  static const clans = "${basePath}clans.png";
  static const mission = "${basePath}mission.png";
  static const quest = "${basePath}quest.png";
  static const worldNews = "${basePath}world_news.png";
  static const tinder = "${basePath}tinder.png";
  static const card0 = "${basePath}card_0.png";
  static const card1 = "${basePath}card_1.png";
  static const card2 = "${basePath}card_2.png";
  static const card3 = "${basePath}card_3.png";
  static const card4 = "${basePath}card_4.png";
  static const card5 = "${basePath}card_5.png";
}

const String defaltImage =
    "https://www.pngall.com/wp-content/uploads/5/Profile.png";

```

---


### Configs\constants.dart

```dart
import 'package:flutter/material.dart';
import 'package:flutter_dotenv/flutter_dotenv.dart';
import 'package:form_field_validator/form_field_validator.dart';
import 'package:tictactoe_gameapp/Configs/assets_path.dart';
import 'package:tictactoe_gameapp/Models/champion_model.dart';
import 'package:tictactoe_gameapp/Pages/GamePage/Console/sodoku_game/sodoku_gamelobby_page.dart';
import 'package:tictactoe_gameapp/Pages/GamePage/Console/Match3_Game/match3_lobby_page.dart';
import 'package:tictactoe_gameapp/Pages/GamePage/Console/Minesweeper_Game/minesweeper_gamelobby_page.dart';
import 'package:tictactoe_gameapp/Pages/GamePage/Console/HeroMerge_Game/hero_merge_gamelobby_page.dart';
import 'package:tictactoe_gameapp/Pages/GamePage/Console/Breakout_Game/breakout_gamelobby_page.dart';
import 'package:tictactoe_gameapp/Pages/GamePage/Console/Bubble_Shooter/bubble_shooter_lobby_page.dart.dart';

const String url1 = "https://github.com/DinhVanMy?tab=repositories";
const String url2 = "https://poki.com/";
const String videoPlaceholder =
    "https://www.iconpacks.net/icons/1/free-video-icon-833-thumb.png";
//api keys
String apiFirebaseKey = '${dotenv.env['API_FIREBASE_KEY']}';
String apiFirebaseId = '${dotenv.env['API_FIREBASE_ID']}';
String apiGemini = "${dotenv.env['API_GEMINI']}";
String apiAgoraAppId = "${dotenv.env['API_AGORA_ID']}";
String apiAgoraAppCertificate = "${dotenv.env['API_AGORA_CER']}";
String apiGifphy = "${dotenv.env['API_GIFPHY']}";
String pexelsApiKey = "${dotenv.env['YOUR_PEXELS_API_KEY']}";
String pixabayApiKey = "${dotenv.env['YOUR_PIXABAY_API_KEY']}";
String dailymotionApiKey = "${dotenv.env['YOUR_DAILYMOTION_API_KEY']}";

const duration750 = Duration(milliseconds: 750);
//----------------------------------------------------------------
final roomCodeValidator = MultiValidator([
  RequiredValidator(errorText: 'Room code is required'),
]);

final nameProfile = MultiValidator([
  RequiredValidator(errorText: 'Name is required'),
  MinLengthValidator(2, errorText: 'Name must be at least 2 characters long'),
  MaxLengthValidator(30, errorText: 'Name must be at most 30 characters long'),
  PatternValidator(r'^[a-zA-Z\s]*$',
      errorText: 'Name can only contain alphabetic characters'),
]);

final passwordValidator = MultiValidator([
  RequiredValidator(errorText: 'Password is required'),
  MinLengthValidator(8, errorText: 'password must be at least 8 digits long'),
  PatternValidator(r'(?=.*?[#?!@$%^&*-])',
      errorText: 'passwords must have at least one special character')
]);

final emaildValidator = MultiValidator([
  RequiredValidator(errorText: 'Email is required'),
  EmailValidator(errorText: "Enter a valid email address"),
]);

const pasNotMatchErrorText = "passwords do not match";
//----------------------------------------------------------------

const String contentAlertChatBot = """
Alert Message:

"Thank you for your questions! It seems like you have a lot of inquiries. To provide the best assistance, could we please address them one at a time? This way, we can ensure each question gets the attention it deserves. Feel free to let us know which one you'd like to start with!"

""";

class Cards {
  final String title;
  final String image;
  final Widget page;

  Cards({required this.title, required this.image, required this.page});
}

final List<Cards> images = [
  Cards(
    image: Jajas.card0,
    title: "SODOKU",
    page: const SodokuGamelobbyPage(),
  ),
  Cards(
    image: Jajas.card1,
    title: "MINESWEEPER",
    page: const MinesweeperGamelobbyPage(),
  ),
  Cards(
    image: Jajas.card2,
    title: "HERO MERGE",
    page: const HeroMergeGamelobbyPage(),
  ),
  Cards(
    image: Jajas.card3,
    title: "MATCH HERO",
    page: const Match3LobbyPage(),
  ),
  Cards(
    image: Jajas.card4,
    title: "Breaking Bad",
    page: const BreakoutGamelobbyPage(),
  ),
  Cards(
    image: Jajas.card5,
    title: "BUBBLE SHOOTER",
    page: const BubbleShooterLobbyPage(),
  ),
];

List<List<Color>> gradientColors = [
  [Colors.red, Colors.orange], // Gradient đỏ - cam
  [Colors.pink, Colors.purple], // Gradient hồng - tím
  [Colors.blue, Colors.lightBlueAccent], // Gradient xanh dương - xanh nhạt
  [Colors.green, Colors.teal], // Gradient xanh lá - xanh ngọc
  [Colors.yellow, Colors.orange], // Gradient vàng - cam
  [Colors.indigo, Colors.blue], // Gradient chàm - xanh dương
  [Colors.purple, Colors.blueAccent], // Gradient tím - xanh dương nhạt
  [Colors.deepOrange, Colors.orange], // Gradient cam đậm - cam
  [Colors.cyan, Colors.lightGreen], // Gradient xanh lam - xanh lá nhạt
  [Colors.brown, Colors.orangeAccent], // Gradient nâu - cam nhạt
  [Colors.deepPurple, Colors.purpleAccent], // Gradient tím đậm - tím nhạt
  [Colors.teal, Colors.cyanAccent], // Gradient xanh ngọc - xanh nhạt
  [Colors.lime, Colors.yellow], // Gradient chanh - vàng
  [Colors.amber, Colors.redAccent], // Gradient vàng hổ phách - đỏ nhạt
  [Colors.blueGrey, Colors.grey], // Gradient xanh xám - xám
  [Colors.lightBlue, Colors.tealAccent], // Gradient xanh nhạt - xanh ngọc nhạt
  [Colors.pinkAccent, Colors.deepPurpleAccent], // Gradient hồng nhạt - tím đậm
  [
    Colors.greenAccent,
    Colors.limeAccent
  ], // Gradient xanh nhạt - xanh chanh nhạt
  [Colors.yellowAccent, Colors.orangeAccent], // Gradient vàng nhạt - cam nhạt
  [
    Colors.lightGreenAccent,
    Colors.cyanAccent
  ], // Gradient xanh lá nhạt - xanh lam nhạt
];

final List<String> quickChatMessages = [
  "Let's set up an ambush.",
  "Clear the minion wave!",
  "Let me get the buff.",
  "Rally for a team fight!",
  "Hold them off. I'll take the towers!",
  "Attack the Abyssal Dragon!",
  "Hang on, I'm on my way!",
  "Everyone push mid!",
  "Watch the jungle!",
  "Don't overextend! Get back to farming.",
];

const List<String> listChamA = [
  ChampionsPathA.aatrox,
  ChampionsPathA.ahri,
  ChampionsPathA.akali,
  ChampionsPathA.alistar,
  ChampionsPathA.annie,
  ChampionsPathA.anivia,
  ChampionsPathA.aphelios,
  ChampionsPathA.ashe,
  ChampionsPathA.aurelionSol,
  ChampionsPathA.aurora,
  ChampionsPathA.belveth,
  ChampionsPathA.brand,
  ChampionsPathA.caitlyn,
  ChampionsPathA.camille,
  ChampionsPathA.darius,
  ChampionsPathA.diana,
  ChampionsPathA.evelynn,
  ChampionsPathA.ezreal,
  ChampionsPathA.fiora,
  ChampionsPathA.gwen,
  ChampionsPathA.jinx,
  ChampionsPathA.kalista,
  ChampionsPathA.karma,
  ChampionsPathA.katarina,
  ChampionsPathA.kayle,
  ChampionsPathA.kayn,
  ChampionsPathA.leblanc,
];

const List<String> listChamB = [
  ChampionsPathB.lillia,
  ChampionsPathB.lux,
  ChampionsPathB.masterYi,
  ChampionsPathB.missfortune,
  ChampionsPathB.nasus,
  ChampionsPathB.nautilus,
  ChampionsPathB.nunu,
  ChampionsPathB.qi,
  ChampionsPathB.quinn,
  ChampionsPathB.rengar,
  ChampionsPathB.riven,
  ChampionsPathB.seraphine,
  ChampionsPathB.sivir,
  ChampionsPathB.sona,
  ChampionsPathB.sylas,
  ChampionsPathB.talon,
  ChampionsPathB.teemo,
  ChampionsPathB.tryndamere,
  ChampionsPathB.twistedFate,
  ChampionsPathB.varus,
  ChampionsPathB.viego,
  ChampionsPathB.volibear,
  ChampionsPathB.yasuo,
  ChampionsPathB.yone,
  ChampionsPathB.zed,
  ChampionsPathB.zoe,
];

const List<String> listChampions = [
  ChampionsPathA.aatrox,
  ChampionsPathA.ahri,
  ChampionsPathA.akali,
  ChampionsPathA.alistar,
  ChampionsPathA.annie,
  ChampionsPathA.anivia,
  ChampionsPathA.aphelios,
  ChampionsPathA.ashe,
  ChampionsPathA.aurelionSol,
  ChampionsPathA.aurora,
  ChampionsPathA.belveth,
  ChampionsPathA.brand,
  ChampionsPathA.caitlyn,
  ChampionsPathA.camille,
  ChampionsPathA.darius,
  ChampionsPathA.diana,
  ChampionsPathA.evelynn,
  ChampionsPathA.ezreal,
  ChampionsPathA.fiora,
  ChampionsPathA.gwen,
  ChampionsPathA.jinx,
  ChampionsPathA.kalista,
  ChampionsPathA.karma,
  ChampionsPathA.katarina,
  ChampionsPathA.kayle,
  ChampionsPathA.kayn,
  ChampionsPathA.leblanc,
  ChampionsPathB.lillia,
  ChampionsPathB.lux,
  ChampionsPathB.masterYi,
  ChampionsPathB.missfortune,
  ChampionsPathB.nasus,
  ChampionsPathB.nautilus,
  ChampionsPathB.nunu,
  ChampionsPathB.qi,
  ChampionsPathB.quinn,
  ChampionsPathB.rengar,
  ChampionsPathB.riven,
  ChampionsPathB.seraphine,
  ChampionsPathB.sivir,
  ChampionsPathB.sona,
  ChampionsPathB.sylas,
  ChampionsPathB.talon,
  ChampionsPathB.teemo,
  ChampionsPathB.tryndamere,
  ChampionsPathB.twistedFate,
  ChampionsPathB.varus,
  ChampionsPathB.viego,
  ChampionsPathB.volibear,
  ChampionsPathB.yasuo,
  ChampionsPathB.yone,
  ChampionsPathB.zed,
  ChampionsPathB.zoe,
];

final List<ChampionModel> listChampionModels = [
  ChampionModel(image: ChampionsPathA.aatrox, name: 'Aatrox'),
  ChampionModel(image: ChampionsPathA.ahri, name: 'Ahri'),
  ChampionModel(image: ChampionsPathA.akali, name: 'Aatrox'),
  ChampionModel(image: ChampionsPathA.alistar, name: 'Aatrox'),
];

const List<String> listChampName = [
  "aatrox",
  "aatrox",
  "ahri",
  "akali",
  "alistar",
  "annie",
  "anivia",
  "aphelios",
  "ashe",
  "aurelionSol",
  "aurora",
  "belveth",
  "brand",
  "caitlyn",
  "camille",
  "darius",
  "diana",
  "evelynn",
  "ezreal",
  "fiora",
  "gwen",
  "jinx",
  "kalista",
  "karma",
  "katarina",
  "kayle",
  "kayn",
  "leblanc",
  "lillia",
  "lux",
  "masterYi",
  "missfortune",
  "nasus",
  "nautilus",
  "nunu",
  "qi",
  "quinn",
  "rengar",
  "riven",
  "seraphine",
  "sivir",
  "sona",
  "sylas",
  "talon",
  "teemo",
  "tryndamere",
  "twistedFate",
  "varus",
  "viego",
  "volibear",
  "yasuo",
  "yone",
  "zed",
  "zoe",
];
const List<String> listChamNameA = [
  "aatrox",
  "ahri",
  "akali",
  "alistar",
  "annie",
  "anivia",
  "aphelios",
  "ashe",
  "aurelionSol",
  "aurora",
  "belveth",
  "brand",
  "caitlyn",
  "camille",
  "darius",
  "diana",
  "evelynn",
  "ezreal",
  "fiora",
  "gwen",
  "jinx",
  "kalista",
  "karma",
  "katarina",
  "kayle",
  "kayn",
  "leblanc",
];
const List<String> listChamNameB = [
  "lillia",
  "lux",
  "masterYi",
  "missfortune",
  "nasus",
  "nautilus",
  "nunu",
  "qi",
  "quinn",
  "rengar",
  "riven",
  "seraphine",
  "sivir",
  "sona",
  "sylas",
  "talon",
  "teemo",
  "tryndamere",
  "twistedFate",
  "varus",
  "viego",
  "volibear",
  "yasuo",
  "yone",
  "zed",
  "zoe",
];

const List<String> imagePaths = [
  ImagePath.map1,
  ImagePath.map2,
  ImagePath.map4,
  ImagePath.map5,
  ImagePath.map6,
  ImagePath.map7,
  ImagePath.map8,
  ImagePath.map9,
  ImagePath.map10,
];

const List<String> emotes = [
  Emotes.angryKittenEmote,
  Emotes.beeHappyEmote,
  Emotes.beeMadEmote,
  Emotes.beeSadEmote,
  Emotes.cupEmote,
  Emotes.despairEmote,
  Emotes.dressedToKillEmote,
  Emotes.goodAsGoldEmote,
  Emotes.howDareEmote,
  Emotes.happyToSeeUEmote,
  Emotes.lookingForEmote,
  Emotes.penguEmote,
  Emotes.sadKittenEmote,
  Emotes.seeEmote,
  Emotes.starRikuEmote,
  Emotes.starSakiEmote,
  Emotes.starTowaEmote,
  Emotes.thumbsUpEmote,
];

```

---


### Configs\messages.dart

```dart
import 'package:flutter/material.dart';
import 'package:flutter_svg/svg.dart';
import 'package:get/get.dart';
import 'package:tictactoe_gameapp/Configs/assets_path.dart';
import 'package:tictactoe_gameapp/Configs/theme/colors.dart';
import 'package:tictactoe_gameapp/Controller/online_status_controller.dart';

void successMessage(String message) {
  Get.showSnackbar(
    GetSnackBar(
      title: 'Success',
      message: message,
      icon: Image.asset("assets/icons/check.png"),
      duration: const Duration(seconds: 3),
      backgroundColor: Colors.green,
      snackPosition: SnackPosition.TOP,
      margin: const EdgeInsets.all(10),
      borderRadius: 20,
      mainButton: TextButton(
        onPressed: () {
          Get.back(); // Dismiss the snackbar
        },
        child: const Text(
          'DISMISS',
          style: TextStyle(color: Colors.deepPurple),
        ),
      ),
      overlayBlur: 1,
      isDismissible: true,
      forwardAnimationCurve: Curves.easeInOut,
      leftBarIndicatorColor: Colors.greenAccent,
    ),
  );
}

void errorMessage(String message) {
  Get.showSnackbar(
    GetSnackBar(
      title: 'Error',
      message: message,
      icon: Image.asset(
        "assets/icons/warning.png",
      ),
      duration: const Duration(seconds: 3),
      backgroundColor: primaryColor,
      snackPosition: SnackPosition.TOP,
      margin: const EdgeInsets.all(10),
      borderRadius: 20,
      mainButton: TextButton(
        onPressed: () {
          Get.back(); // Dismiss the snackbar
        },
        child: const Text(
          'DISMISS',
          style: TextStyle(color: Colors.white),
        ),
      ),
      overlayBlur: 1,
      isDismissible: true,
      forwardAnimationCurve: Curves.easeInOutCubicEmphasized,
    ),
  );
}

void logoutMessage(
    BuildContext context, OnlineStatusController onlineStatusController) {
  Get.dialog(Dialog(
    child: Container(
      height: MediaQuery.of(context).size.height * 0.6,
      decoration: BoxDecoration(
        color: Theme.of(context).colorScheme.surface.withOpacity(0.8),
        borderRadius: const BorderRadius.all(Radius.circular(20)),
        border: Border.all(color: Colors.redAccent, width: 3.0),
        boxShadow: const [
          BoxShadow(
            color: Colors.red,
            offset: Offset(-5, 10),
            blurRadius: 2,
            spreadRadius: 2,
          ),
        ],
      ),
      child: Column(
        children: [
          ClipRRect(
            borderRadius: const BorderRadius.only(
                topLeft: Radius.circular(20), topRight: Radius.circular(20)),
            child: Image.asset(GifsPath.chatbotGif),
          ),
          const SizedBox(
            height: 10,
          ),
          Image.asset(
            "assets/icons/question-mark.png",
            width: 40,
          ),
          const SizedBox(
            height: 0,
          ),
          Text(
            "Are you sure you want to log out?",
            textAlign: TextAlign.center,
            style: Theme.of(context)
                .textTheme
                .titleLarge!
                .copyWith(color: Colors.red, fontWeight: FontWeight.w700),
          ),
          const SizedBox(
            height: 10,
          ),
          Row(
            mainAxisAlignment: MainAxisAlignment.spaceEvenly,
            children: [
              ElevatedButton(
                style: ElevatedButton.styleFrom(
                    backgroundColor: Colors.red, foregroundColor: Colors.white),
                onPressed: () {
                  Get.back();
                },
                child: const Text("Cancel"),
              ),
              ElevatedButton(
                style: ElevatedButton.styleFrom(
                    backgroundColor: Colors.green,
                    foregroundColor: Colors.white),
                onPressed: () async {
                  // await authController.auth.signOut();
                  await onlineStatusController.setOffline();
                  Get.offAllNamed("/auth");
                  successMessage("Logout successful!");
                },
                child: const Text("LogOut"),
              ),
            ],
          ),
        ],
      ),
    ),
  ));
}

void showNoConnectionDialog({required Function() onPressed}) {
  if (Get.isDialogOpen == false) {
    Get.dialog(
      AlertDialog(
        title: const Text(
          'Oops... No internet connection',
          style: TextStyle(
            fontWeight: FontWeight.bold,
            fontSize: 20,
          ),
        ),
        content: const Text(
          'You need to be connected to your network connection or Wi-Fi to make online activity.',
          style: TextStyle(
            color: Colors.blueGrey,
            fontSize: 16,
          ),
        ),
        actions: [
          TextButton(
            onPressed: onPressed,
            child: const Text(
              'Retry',
              style: TextStyle(
                fontSize: 18,
                color: Colors.blueAccent,
              ),
            ),
          ),
        ],
        icon: const Icon(
          Icons.warning,
          size: 40,
        ),
        iconColor: Colors.red,
      ),
      barrierDismissible: false,
    );
  }
}

void winnerDialog(
    {required Function()? onPlayAgain, required Function()? onExit}) {
  // musicPlayController.playSoundWinner();
  Get.defaultDialog(
    barrierDismissible: false,
    title: "VICTORY",
    backgroundColor: Colors.white,
    titleStyle: const TextStyle(
      fontWeight: FontWeight.bold,
      color: Colors.blue,
      fontSize: 30,
    ),
    content: Stack(
      children: [
        Container(
          padding: const EdgeInsets.all(10),
          decoration: BoxDecoration(
            borderRadius: BorderRadius.circular(20),
            border: Border.all(color: Colors.blueAccent, width: 5),
          ),
          child: Column(
            children: [
              SvgPicture.asset(
                IconsPath.wonIcon,
                width: 100,
              ),
              const SizedBox(height: 20),
              const Text(
                "Congratulations",
                style: TextStyle(
                  fontSize: 18,
                  color: Colors.blueAccent,
                ),
              ),
              const Text(
                "You won the match",
                style: TextStyle(
                  fontSize: 15,
                ),
              ),
              const SizedBox(height: 20),
              Row(
                mainAxisAlignment: MainAxisAlignment.spaceBetween,
                children: [
                  ElevatedButton(
                    onPressed: onPlayAgain,
                    child: const Text("Play Again"),
                  ),
                  ElevatedButton(
                    onPressed: onExit,
                    child: const Text("Exit"),
                  )
                ],
              )
            ],
          ),
        ),
        // const Center(
        //   child: ConfettiWidgetCustom(),
        // )
      ],
    ),
  );
}

Future<bool> showPermissionDeniedDialog() async {
    bool? retry;
    await Get.dialog(
      AlertDialog(
        title: const Text("Yêu Cầu Quyền Overlay"),
        content: const Text(
          "Ứng dụng cần quyền overlay để hiển thị bong bóng chat. Bạn có muốn cấp quyền không?",
        ),
        actions: [
          TextButton(
            onPressed: () {
              Get.back(); // Đóng dialog
              retry = false; // Bỏ qua
            },
            child: const Text("Bỏ Qua"),
          ),
          TextButton(
            onPressed: () async {
              Get.back(); // Đóng dialog
              retry = true; // Thử lại
            },
            child: const Text("Thử Lại"),
          ),
        ],
      ),
    );
    return retry ?? false; // Mặc định bỏ qua nếu không chọn
  }

```

---


### Configs\page_route.dart

```dart
import 'package:get/get.dart';
import 'package:tictactoe_gameapp/Components/friend_zone/friend_zone_map_page.dart';
import 'package:tictactoe_gameapp/Pages/Auth/auth_page.dart';
import 'package:tictactoe_gameapp/Pages/Friends/messenger_page.dart';
import 'package:tictactoe_gameapp/Pages/GamePage/Shop/shop_page.dart';
import 'package:tictactoe_gameapp/Pages/HomePage/home_page.dart';
import 'package:tictactoe_gameapp/Pages/MainHome/main_home.dart';
import 'package:tictactoe_gameapp/Pages/RoomPage/room_page.dart';
import 'package:tictactoe_gameapp/Pages/Setting/setting_screen_main.dart';
import 'package:tictactoe_gameapp/Pages/Splace/splace_page.dart';
import 'package:tictactoe_gameapp/Pages/UpdateProfile/update_profile_page.dart';
import 'package:tictactoe_gameapp/Pages/Welcome/welcome_page.dart';
import '../Pages/GamePage/SingleGame/play_with_bot_page.dart';

var pages = [
  GetPage(
    name: "/room",
    page: () => const RoomPage(),
    transition: Transition.leftToRightWithFade,
  ),
  GetPage(
    name: "/auth",
    page: () => const AuthPage(),
  ),
  GetPage(
    name: "/home",
    page: () => const HomePage(),
  ),
  GetPage(
    name: "/splace",
    page: () => const SplacePage(),
  ),
  GetPage(
    name: "/mainHome",
    page: () => const MainHomePage(),
  ),
  GetPage(
    name: "/updateProfile",
    page: () => const UpdateProfile(),
    transition: Transition.zoom,
  ),
  GetPage(
    name: "/welcome",
    page: () => const WelcomePage(),
  ),
  GetPage(
    name: "/singlePlayer", //Todo rename
    page: () => const PlayWithBotPage(),
    transition: Transition.zoom,
  ),
  GetPage(
    name: "/settings",
    page: () => const SettingScreen(),
    transition: Transition.upToDown,
  ),
  GetPage(
    name: "/guides",
    page: () => const FriendsPage(),
  ),

  // pages in home page
  GetPage(
    name: "/shoppage",
    page: () => const ShopPage(),
    transition: Transition.zoom,
  ),
];

```

---


### Configs\paint_draws\bubble_chat_painter.dart

```dart
import 'package:flutter/material.dart';
import 'dart:ui' as ui;

class BubbleChatPainter extends CustomPainter {
  BubbleChatPainter({
    required ScrollableState scrollable,
    required BuildContext bubbleContext,
    required List<Color> colors,
  })  : _scrollable = scrollable,
        _bubbleContext = bubbleContext,
        _colors = colors,
        super(repaint: scrollable.position);

  final ScrollableState _scrollable;
  final BuildContext _bubbleContext;
  final List<Color> _colors;

  @override
  void paint(Canvas canvas, Size size) {
    final scrollableBox = _scrollable.context.findRenderObject() as RenderBox;
    final scrollableRect = Offset.zero & scrollableBox.size;
    final bubbleBox = _bubbleContext.findRenderObject() as RenderBox;

    final origin =
        bubbleBox.localToGlobal(Offset.zero, ancestor: scrollableBox);
    final paint = Paint()
      ..shader = ui.Gradient.linear(
        scrollableRect.topCenter,
        scrollableRect.bottomCenter,
        _colors,
        [0.0, 1.0],
        TileMode.clamp,
        Matrix4.translationValues(-origin.dx, -origin.dy, 0.0).storage,
      );
    canvas.drawRect(Offset.zero & size, paint);
  }

  @override
  bool shouldRepaint(BubbleChatPainter oldDelegate) {
    return oldDelegate._scrollable != _scrollable ||
        oldDelegate._bubbleContext != _bubbleContext ||
        oldDelegate._colors != _colors;
  }
}

```

---


### Configs\paint_draws\star_confetti_draws.dart

```dart
import 'dart:math';
import 'dart:ui';

class DrawPath {
  static Path drawStarOfficial(Size size) {
    // Method to convert degree to radians
    double degToRad(double deg) => deg * (pi / 180.0);

    const numberOfPoints = 5;
    final halfWidth = size.width / 2;
    final externalRadius = halfWidth;
    final internalRadius = halfWidth / 2.5;
    final degreesPerStep = degToRad(360 / numberOfPoints);
    final halfDegreesPerStep = degreesPerStep / 2;
    final path = Path();
    final fullAngle = degToRad(360);
    path.moveTo(size.width, halfWidth);

    for (double step = 0; step < fullAngle; step += degreesPerStep) {
      path.lineTo(halfWidth + externalRadius * cos(step),
          halfWidth + externalRadius * sin(step));
      path.lineTo(halfWidth + internalRadius * cos(step + halfDegreesPerStep),
          halfWidth + internalRadius * sin(step + halfDegreesPerStep));
    }
    path.close();
    return path;
  }

  static Path drawStar(Size size) {
    // Phần code này tạo ra một hạt hình ngôi sao
    double w = size.width;
    double h = size.height;
    Path path = Path();
    path.moveTo(w / 2, 0);
    path.lineTo(w * 0.85, h * 0.35);
    path.lineTo(w, h * 0.4);
    path.lineTo(w * 0.75, h * 0.65);
    path.lineTo(w * 0.8, h);
    path.lineTo(w / 2, h * 0.85);
    path.lineTo(w * 0.2, h);
    path.lineTo(w * 0.25, h * 0.65);
    path.lineTo(0, h * 0.4);
    path.lineTo(w * 0.15, h * 0.35);
    path.close();
    return path;
  }
}

```

---


### Configs\theme\colors.dart

```dart
import 'package:flutter/material.dart';

//----------------------------------------------------------------
const bgColor = Color(0xffFDE0E8);
const fontColor = Color(0xff000000);
const primaryColor = Color(0xffFF0037);
const secondryColor = Color(0xffFF9900);
const containerColor = Color(0xffFFFFFF);
const lableColor = Color(0xffB5B5B5);
//----------------------------------------------------------------
//intergrated
const kPrimaryColor = Color(0xFFFF97B3);
const kPrimaryContainer = Color(0xFFA390FF);
const kSecondaryDarkColor = Color(0xFF6C56DD);
const kAccentLightColor = Color(0xFFB3BFD7);
const kAccentDarkColor = Color(0xFF4E4E4E);
const kBackgroundDarkColor = Color(0xFF3A3A3A);
const kSurfaceDarkColor = Color(0xFF684FFF);
// Icon Colors
const kAccentIconLightColor = Color(0xFFECEFF5);
const kAccentIconDarkColor = Color(0xFF303030);
const kPrimaryIconLightColor = Color(0xFFECEFF5);
const kPrimaryIconDarkColor = Color(0xFF232323);
// Text Colors
const kBodyTextColorLight = Color(0xFFA1B0CA);
const kBodyTextColorDark = Color(0xFF7C7C7C);
const kTitleTextLightColor = Color(0xFF101112);
const kTitleTextDarkColor = Colors.white;

const kShadowColor = Color(0xFF364564);
//----------------------------------------------------------------

const colorPalette = Color(0x007a0177);
const colorPaletteDark = Color(0x00b0f2bc);

```

---


### Configs\theme\size_config.dart

```dart
import 'package:flutter/material.dart';

class SizeConfig {
  static late MediaQueryData _mediaQueryData;
  static late double screenWidth;
  static late double screenHeight;
  static late double defaultSize;
  static late Orientation orientation;

  void init(BuildContext context) {
    _mediaQueryData = MediaQuery.of(context);
    screenWidth = _mediaQueryData.size.width;
    screenHeight = _mediaQueryData.size.height;
    orientation = _mediaQueryData.orientation;
  }
}

// Get the proportionate height as per screen size
double getProportionateScreenHeight(double inputHeight) {
  double screenHeight = SizeConfig.screenHeight;
  // Our designer use iPhone 11 , that's why we use 896.0
  return (inputHeight / 896.0) * screenHeight;
}

// Get the proportionate height as per screen size
double getProportionateScreenWidth(double inputWidth) {
  double screenWidth = SizeConfig.screenWidth;
  // 414 is the layout width that designer use or you can say iPhone 11  width
  return (inputWidth / 414.0) * screenWidth;
}

// For add free space vertically
class VerticalSpacing extends StatelessWidget {
  const VerticalSpacing({
    super.key,
    this.of = 25,
  });

  final double of;

  @override
  Widget build(BuildContext context) {
    return SizedBox(
      height: getProportionateScreenHeight(of),
    );
  }
}

```

---


### Configs\theme\theme_dark.dart

```dart
import 'package:flutter/material.dart';
import 'package:tictactoe_gameapp/Configs/theme/colors.dart';

var darktheme = ThemeData(
  brightness: Brightness.dark,
  appBarTheme: appBarDarkTheme,
  scaffoldBackgroundColor: kBackgroundDarkColor,
  inputDecorationTheme: InputDecorationTheme(
    border: OutlineInputBorder(
      borderRadius: BorderRadius.circular(20),
      borderSide: BorderSide.none,
    ),
    fillColor: containerColor,
    filled: true,
    hintStyle: const TextStyle(
      fontSize: 15,
      fontFamily: "Poppins",
      fontWeight: FontWeight.w400,
      color: Colors.white,
    ),
  ),
  // primaryColor: Color(0xff121212),
  colorScheme: const ColorScheme.dark(
    primary: kPrimaryColor,
    secondary: kSecondaryDarkColor,
    surface: kSurfaceDarkColor,
    onSurface: kSurfaceDarkColor,
    primaryContainer: kPrimaryContainer,
    onPrimaryContainer: kSecondaryDarkColor,
  ),
  iconTheme: const IconThemeData(color: kPrimaryIconLightColor),
  textTheme: const TextTheme(
    headlineLarge: TextStyle(
      color: Colors.white,
      fontSize: 30,
      fontFamily: "Poppins",
      fontWeight: FontWeight.bold,
    ),
    headlineMedium: TextStyle(
      color: Colors.white,
      fontSize: 24,
      fontFamily: "Poppins",
      fontWeight: FontWeight.w700,
    ),
    headlineSmall: TextStyle(
      fontSize: 20,
      fontFamily: "Poppins",
      fontWeight: FontWeight.w400,
      color: Colors.white,
    ),
    bodyLarge: TextStyle(
      color: Colors.white,
      fontSize: 18,
      fontFamily: "Poppins",
      fontWeight: FontWeight.w600,
    ),
    bodyMedium: TextStyle(
      color: Colors.white,
      fontSize: 15,
      fontFamily: "Poppins",
      fontWeight: FontWeight.w500,
    ),
    bodySmall: TextStyle(
      fontSize: 12,
      fontFamily: "Poppins",
      fontWeight: FontWeight.w400,
      color: Colors.white,
    ),
    labelMedium: TextStyle(
      fontSize: 15,
      fontFamily: "Poppins",
      fontWeight: FontWeight.w400,
      color: Colors.white,
    ),
  ),
);

const AppBarTheme appBarDarkTheme = AppBarTheme(
  backgroundColor: Colors.transparent,
  centerTitle: true,
  elevation: 0,
  iconTheme: IconThemeData(color: Colors.white),
  titleTextStyle: TextStyle(
    fontSize: 16,
    fontWeight: FontWeight.w500,
    color: Colors.white,
  ),
);

```

---


### Configs\theme\theme_light.dart

```dart
import 'package:flutter/material.dart';
import 'package:tictactoe_gameapp/Configs/theme/colors.dart';

var lightTheme = ThemeData(
  brightness: Brightness.light,
  appBarTheme: appBarLightTheme,
  scaffoldBackgroundColor: bgColor,
  inputDecorationTheme: InputDecorationTheme(
    border: OutlineInputBorder(
      borderRadius: BorderRadius.circular(20),
      borderSide: BorderSide.none,
    ),
    fillColor: containerColor,
    filled: true,
    hintStyle: const TextStyle(
      fontSize: 15,
      fontFamily: "Poppins",
      fontWeight: FontWeight.w400,
      color: lableColor,
    ),
  ),
  iconTheme: const IconThemeData(color: fontColor),
  colorScheme: const ColorScheme.light(
    primary: primaryColor,
    secondary: secondryColor,
    surface: bgColor,
    onSurface: fontColor,
    primaryContainer: containerColor,
    onPrimaryContainer: lableColor,
  ),
  textTheme: const TextTheme(
    headlineLarge: TextStyle(
      fontSize: 30,
      fontFamily: "Poppins",
      fontWeight: FontWeight.bold,
    ),
    headlineMedium: TextStyle(
      fontSize: 24,
      fontFamily: "Poppins",
      fontWeight: FontWeight.w700,
    ),
    headlineSmall: TextStyle(
      fontSize: 20,
      fontFamily: "Poppins",
      fontWeight: FontWeight.w400,
    ),
    bodyLarge: TextStyle(
      fontSize: 18,
      fontFamily: "Poppins",
      fontWeight: FontWeight.w600,
    ),
    bodyMedium: TextStyle(
      fontSize: 15,
      fontFamily: "Poppins",
      fontWeight: FontWeight.w500,
    ),
    bodySmall: TextStyle(
      fontSize: 12,
      fontFamily: "Poppins",
      fontWeight: FontWeight.w400,
    ),
    labelMedium: TextStyle(
      fontSize: 15,
      fontFamily: "Poppins",
      fontWeight: FontWeight.w400,
      color: lableColor,
    ),
  ),
);

const AppBarTheme appBarLightTheme = AppBarTheme(
  backgroundColor: Colors.transparent,
  centerTitle: true,
  elevation: 0,
  iconTheme: IconThemeData(color: kPrimaryIconDarkColor),
  titleTextStyle: TextStyle(
    fontSize: 16,
    fontWeight: FontWeight.w500,
    color: kPrimaryIconDarkColor,
  ),
);

```

---


### Configs\translation\en.dart

```dart
const Map<String, String> en = {
  //auth_page.dart
  'title_auth' : 'Welcome',
  'description_auth' : 'Please sign in to continue!',
  'google_auth' : 'Sign in with Google',
  'facebook_auth' : 'Sign in with Facebook',
  'github_auth' : 'Sign in with Github',
  //setting_page.dart
  'app_bar_sett' : 'SETTING',
  "common_sett" : 'Common',
  "languages_sett" : 'Languages',
  "dark_theme_sett" : 'Dark Theme',
  "description_dark_theme_sett" : 'Night Life 😴/Sunlight Life 😎',
  "account_tile_sett" : 'Account',
  "profile_tile_sett" : 'Profile',
  "edit_profile_file_sett" : 'Edit Profile',
  "change_password_sett" : 'Change Password',
  "everything_is_ok_sett" : 'Everything is ok!👌❤️',
  "logout_sett" : 'Logout',
  "logout_from_app_sett" : 'Logout from the current account',
  "sound_sett" : 'Sound',
  "play_music_sett" : 'Play Music',
  "turn _on_off_sett" : 'Turn On / Turn Off',
  "stop_sett" : 'Stop',
  "play_sett" : 'Play',
  "volume_sett" : 'Volume',
  "background_music_sett" : 'Background Music',
  "turn_off_background_music_sett" : "Turn On / Turn Off background music", 
};

```

---


### Configs\translation\translation.dart

```dart
import 'package:get/get.dart';
import 'package:tictactoe_gameapp/Configs/translation/en.dart';
import 'package:tictactoe_gameapp/Configs/translation/vi.dart';

class AppTranslations extends Translations {
  @override
  Map<String, Map<String, String>> get keys => {
    'en': en,
    'vi': vi,
  };
}

```

---


### Configs\translation\vi.dart

```dart
const Map<String, String> vi = {
  //auth_page.dart
  'title_auth': 'Xin Chào',
  'description_auth': 'Vui lòng đăng nhập!',
  'google_auth': 'Đăng nhập bằng Google',
  'facebook_auth': 'Đăng nhập bằng Facebook',
  'github_auth': 'Đăng nhập bằng Github',
  //setting_page.dart
  'app_bar_sett': 'Cài Đặt',
  "common_sett": 'Cài Đặt Chung',
  "languages_sett": 'Ngôn Ngữ',
  "dark_theme_sett": 'Chế Độ Tối',
  "description_dark_theme_sett": 'Đêm 😴/ Ngày 😎',
  "account_tile_sett": 'Tài Khoản',
  "profile_tile_sett": 'Thông Tin Cá Nhân',
  "edit_profile_file_sett": 'Chỉnh Sửa Hồ Sơ',
  "change_password_sett": 'Đổi Mật Khẩu',
  "everything_is_ok_sett": 'Mọi thứ thật tuyệt!👌❤️',
  "logout_sett": 'Đăng Xuất',
  "logout_from_app_sett": 'Đăng Xuất Tài Khoản Khỏi Ứng Dụng',
  "sound_sett": 'Âm Thanh',
  "play_music_sett": 'Phát Nhạc',
  "turn _on_off_sett": 'Bật / Tắt',
  "stop_sett": 'Dừng',
  "play_sett": 'Phát',
  "volume_sett": 'Âm Lượng',
  "background_music_sett": 'Nhạc Nền',
  "turn_off_background_music_sett": "Bật / Tắt Nhạc Nền",
};

```

---


### Controller\auth_controller.dart

```dart
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:get/get.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:google_sign_in/google_sign_in.dart';
import 'package:tictactoe_gameapp/Controller/profile_controller.dart';
import 'package:tictactoe_gameapp/Enums/firebase_exception.dart';

import '../Configs/messages.dart';

class AuthController extends GetxController {
  final auth = FirebaseAuth.instance;
  final db = FirebaseFirestore.instance;
  RxBool obscure = true.obs;

  // State for hidden and visible password fields
  void togglePasswordVisibility() {
    obscure.value = !obscure.value;
  }

  //sign in and sign up by email/password
  //register
  Future<AuthStatus> registerWithEmailPassword(
      String email, String password) async {
    try {
      await auth.createUserWithEmailAndPassword(
          email: email, password: password);
      return AuthStatus.successful;
    } on FirebaseAuthException catch (e) {
      return AuthExceptionHandler.handleAuthException(e);
    } catch (e) {
      return AuthStatus.unknown;
    }
  }

  //get the user
  String getCurrentUserEmail() {
    return auth.currentUser!.email!;
  }

  //get the user id
  String getCurrentUserId() {
    if (auth.currentUser != null) {
      return auth.currentUser!.uid;
    } else {
      return "A2ABTw0gGsPGH14XWiRU50p1u1y2";
    }
  }

  //log in
  Future<AuthStatus> signInWithEmailPassword(
      String email, String password) async {
    final FirebaseFirestore firestore = FirebaseFirestore.instance;
    try {
      await auth.signInWithEmailAndPassword(email: email, password: password);

      // Kiểm tra thông tin user sau khi đăng nhập thành công
      final userId = auth.currentUser?.uid;
      if (userId != null) {
        final userSnapshot =
            await firestore.collection('users').doc(userId).get();

        if (userSnapshot.exists) {
          final userData = userSnapshot.data() as Map<String, dynamic>;

          // Kiểm tra các trường name và image
          final name = userData['name'];
          final image = userData['image'];

          if (name == null || image == null) {
            // Chuyển hướng đến trang UpdateProfileScreen
            Get.offAllNamed('/updateProfile');
          } else {
            Get.find<ProfileController>();
            Get.offAllNamed('/mainHome');
          }
        } else {
          // Trường hợp user không tồn tại trên Firestore
          errorMessage("User document not found.");
          return AuthStatus.unknown;
        }
      }

      return AuthStatus.successful;
    } on FirebaseAuthException catch (e) {
      return AuthExceptionHandler.handleAuthException(e);
    } catch (e) {
      errorMessage("Error during sign-in: $e");
      return AuthStatus.unknown;
    }
  }

  //change password when the user loged in
  Future<AuthStatus> changePasswordWhenUser(
      String currentPassword, String newPassword, String email) async {
    try {
      User? user = auth.currentUser;

      if (user == null) {
        return AuthStatus.userNotFound;
      }
      AuthCredential credential = EmailAuthProvider.credential(
        email: email,
        password: currentPassword,
      );
      UserCredential authResult =
          await user.reauthenticateWithCredential(credential);
      await authResult.user?.updatePassword(newPassword);
      // await auth.sendPasswordResetEmail(email: email);

      return AuthStatus.successful;
    } on FirebaseAuthException catch (e) {
      return AuthExceptionHandler.handleAuthException(e);
    } catch (e) {
      return AuthStatus.unknown;
    }
  }

//change password when the user did not log in
  Future<AuthStatus> changePasswordWhenNotUser(
      String currentPassword, String newPassword, String email) async {
    try {
      // Đăng nhập bằng email và mật khẩu cũ để xác thực người dùng
      UserCredential userCredential = await auth.signInWithEmailAndPassword(
        email: email,
        password: currentPassword,
      );
      await userCredential.user?.updatePassword(newPassword);
      // await auth.sendPasswordResetEmail(email: email);

      return AuthStatus.successful;
    } on FirebaseAuthException catch (e) {
      return AuthExceptionHandler.handleAuthException(e);
    } catch (e) {
      return AuthStatus.unknown;
    }
  }

  //reset password
  Future<AuthStatus> resetPassword({required String email}) async {
    try {
      await auth.sendPasswordResetEmail(email: email);

      return AuthStatus.successful;
    } on FirebaseAuthException catch (e) {
      return AuthExceptionHandler.handleAuthException(e);
    } catch (e) {
      return AuthStatus.unknown;
    }
  }

  //log in with google
  Future<void> loginByGoogle() async {
    try {
      final GoogleSignInAccount? googleUser = await GoogleSignIn().signIn();

      final GoogleSignInAuthentication? googleAuth =
          await googleUser?.authentication;

      final credential = GoogleAuthProvider.credential(
        accessToken: googleAuth?.accessToken,
        idToken: googleAuth?.idToken,
      );
      await auth.signInWithCredential(credential);
      successMessage("Login Success");
      Get.offAllNamed("/updateProfile");
    } catch (e) {
      errorMessage("Login Failed");
      // print(e);
    }
  }
}

```

---


### Controller\check_network_controller.dart

```dart
import 'dart:async';
import 'dart:io';

import 'package:get/get.dart';
import 'package:internet_connection_checker/internet_connection_checker.dart';
import 'package:tictactoe_gameapp/Configs/messages.dart';

class CheckNetworkController extends GetxController {
  var isConnected = true.obs;
  var ping = 0.obs; // Lưu thời gian ping (ms)
  late StreamSubscription<InternetConnectionStatus> _streamSubscription;
  Timer? _pingTimer;

  @override
  void onInit() {
    super.onInit();
    _checkConnection(); // Kiểm tra kết nối ban đầu
    _listenForConnectionChanges(); // Lắng nghe thay đổi kết nối
  }

  Future<void> _checkConnection() async {
    bool result = await InternetConnectionChecker.instance.hasConnection;
    isConnected.value = result;
    if (!result) {
      showNoConnectionDialog(onPressed: () {
        if (Get.isDialogOpen == true) {
          Get.back();
        }
        _checkConnection().then((_) => errorMessage("Connection is failed..."));
      });
    }
  }

  void _listenForConnectionChanges() {
    _streamSubscription =
        InternetConnectionChecker.instance.onStatusChange.listen((status) {
      isConnected.value = status == InternetConnectionStatus.connected;
      if (!isConnected.value) {
        showNoConnectionDialog(onPressed: () {
          if (Get.isDialogOpen == true) {
            Get.back();
          }
          _checkConnection()
              .then((_) => errorMessage("Connection is failed..."));
        });
      } else {
        if (Get.isDialogOpen == true) {
          Get.back();
          successMessage("Connection is established!");
        }
      }
    });
  }

  /// Bắt đầu theo dõi ping
  void _startPingMonitoring() {
    _pingTimer = Timer.periodic(const Duration(seconds: 5), (_) async {
      await _measurePing();
    });
  }

  /// Đo thời gian ping
  Future<void> _measurePing() async {
    const String host = '8.8.8.8'; // Google DNS
    try {
      final stopwatch = Stopwatch()..start();
      final socket =
          await Socket.connect(host, 80, timeout: const Duration(seconds: 5));
      stopwatch.stop();
      ping.value = stopwatch.elapsedMilliseconds;
      socket.destroy();
    } catch (e) {
      ping.value = -1; // -1 để biểu thị lỗi khi không đo được ping
    }
  }

  @override
  void dispose() {
    _streamSubscription.cancel();
    _pingTimer?.cancel();
    super.dispose();
  }
}

```

---


### Controller\language_controller.dart

```dart
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:get_storage/get_storage.dart';

class LanguageController extends GetxController {
  var currentLanguage = 'en'.obs;
  final _storage = GetStorage();

  @override
  void onInit() {
    super.onInit();
    String? savedLanguage = _storage.read('language');
    if (savedLanguage != null) {
      currentLanguage.value = savedLanguage;
    } else {
      String systemLanguage = Get.deviceLocale?.languageCode ?? 'en';
      currentLanguage.value = systemLanguage;
    }
    _applyLanguage(currentLanguage.value);
  }

  Locale get locale => Locale(currentLanguage.value);

  // Thay đổi ngôn ngữ và lưu trạng thái
  void changeLanguage(String languageCode) {
    currentLanguage.value = languageCode;
    _applyLanguage(languageCode);
    _storage.write('language', languageCode);
  }

  // Áp dụng ngôn ngữ đã chọn
  void _applyLanguage(String languageCode) {
    var locale = Locale(languageCode);
    Get.updateLocale(locale);
  }

  // Trả về danh sách ngôn ngữ được hỗ trợ
  List<Locale> get supportedLocales => [
        const Locale('en'),
        const Locale('vi'),
        // Có thể thêm các ngôn ngữ khác tại đây
      ];

  // Lấy tên ngôn ngữ hiện tại
  String getCurrentLanguageName() {
    switch (currentLanguage.value) {
      case 'vi':
        return 'Tiếng Việt';
      case 'en':
      default:
        return 'English';
    }
  }
}

```

---


### Controller\matching_controller.dart

```dart
import 'dart:async';

import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:get/get.dart';
import 'package:tictactoe_gameapp/Configs/messages.dart';
import 'package:tictactoe_gameapp/Controller/auth_controller.dart';
import 'package:tictactoe_gameapp/Models/room_model.dart';
import 'package:tictactoe_gameapp/Models/user_model.dart';
import 'package:tictactoe_gameapp/Pages/LobbyPage/lobby_page.dart';
import 'package:tictactoe_gameapp/Models/queue_model.dart';
import 'package:uuid/uuid.dart';

class MatchingController extends GetxController {
  final FirebaseFirestore _firestore = FirebaseFirestore.instance;
  final String currentUserId = Get.find<AuthController>().getCurrentUserId();
  final String currentUserEmail =
      Get.find<AuthController>().getCurrentUserEmail();

  RxBool isSearching = false.obs;
  RxBool isFindingPlayer2 = false.obs;

  final auth = FirebaseAuth.instance;
  var uuid = const Uuid();
  RxBool isLoading = false.obs;
  Rx<UserModel> user = UserModel().obs;
  StreamSubscription? matchListener;

  @override
  void onInit() {
    super.onInit();
    getUserDetails();
  }

  // Hàm tìm đối thủ
  Future<void> startMatching() async {
    var newQueue = QueueModel(
      isSearching: true,
      createdAt: DateTime.now(),
      userId: currentUserId,
      userEmail: currentUserEmail,
    );

    isSearching.value = true;

    try {
      // Đưa người chơi vào hàng đợi tìm trận
      await _firestore
          .collection('matchings')
          .doc(currentUserId)
          .update(newQueue.toJson())
          .catchError((e) => errorMessage(e.toString()));

      // await Future.delayed(const Duration(seconds: 2));

      // Lắng nghe thay đổi trong hàng đợi
      matchListener = _firestore.collection('matchings').snapshots().listen(
          (snapshot) async {
        if (isSearching.value) {
          var availablePlayers = snapshot.docs.where((doc) =>
              doc['userId'] != currentUserId &&
              doc['isSearching'] == true &&
              doc['userEmail'] != currentUserEmail);

          if (availablePlayers.isNotEmpty) {
            var opponent = availablePlayers.first;
            // So sánh thời gian tạo để xác định ai sẽ tạo phòng

            if (opponent['createdAt'] == null) {
              await waitForOpponentRoom(opponent['userId']);
            } else {
              Timestamp opponentCreatedAt =
                  (opponent['createdAt'] as Timestamp);
              Timestamp myCreatedAt = Timestamp.fromDate(newQueue.createdAt!);
              if (myCreatedAt.compareTo(opponentCreatedAt) < 0) {
                await createMatch();
              } else {
                // Đợi người chơi khác tạo phòng
                await Future.delayed(const Duration(seconds: 3));
                await waitForOpponentRoom(opponent['userId']);
              }
            }
          } else {
            await Future.delayed(const Duration(seconds: 35));
            cancelMatching();
          }
        }
      }, onError: (error) {
        errorMessage(error.toString());
      });
    } catch (e) {
      isSearching.value = false;
      errorMessage("Failed to search for a match: $e");
    }
  }

  // Hàm tạo trận đấu
  Future<void> createMatch() async {
    isSearching.value = false;
    isLoading.value = true;
    String id = uuid.v4().substring(0, 8).toUpperCase();

    var player1 = UserModel(
      id: currentUserId,
      name: user.value.name,
      image: user.value.image,
      email: user.value.email,
      totalWins: user.value.totalWins,
      totalCoins: user.value.totalCoins,
      role: "Admin",
    );

    var newRoom = RoomModel(
      id: id,
      player1: player1,
      gameStatus: "lobby",
      player1Status: "waiting",
      player2Status: "",
      isXturn: true,
      createdAt: DateTime.now(),
    );

    try {
      await _firestore
          .collection("rooms")
          .doc(id)
          .set(newRoom.toJson())
          .catchError((e) => errorMessage(e.toString()));
      Get.to(
        LobbyPage(roomId: id),
        transition: Transition.leftToRightWithFade,
      );
      isSearching.value = false;
    } catch (e) {
      errorMessage(e.toString());
    }
    isLoading.value = false;
  }

  // Hàm đợi đối thủ tạo phòng
  Future<void> waitForOpponentRoom(String opponentId) async {
    var player2 = UserModel(
      id: opponentId,
      name: user.value.name,
      image: user.value.image,
      email: user.value.email,
      totalWins: user.value.totalWins,
      totalCoins: user.value.totalCoins,
      role: "player",
    );
    matchListener = _firestore
        .collection('rooms')
        .where('player1.id', isEqualTo: opponentId)
        .where('player2Status', isEqualTo: "")
        .orderBy('createdAt', descending: true)
        .limit(1)
        .snapshots()
        .listen((snapshot) {
      if (snapshot.docs.isNotEmpty) {
        var roomId = snapshot.docs.first.id;
        // Kiểm tra tài liệu tồn tại trước khi cập nhật
        _firestore.collection("rooms").doc(roomId).get().then((docSnapshot) {
          if (docSnapshot.exists) {
            // Tiến hành cập nhật
            _firestore.collection("rooms").doc(roomId).update({
              "player2": player2.toJson(),
              "player2Status": "waiting",
            }).catchError((e) => errorMessage(e.toString()));
            cancelMatching();
            Get.to(
              LobbyPage(roomId: roomId),
              transition: Transition.leftToRightWithFade,
            );
          }
        });
      }
    }, onError: (error) {
      errorMessage(error.toString());
    });
  }

  // Hủy tìm trận
  Future<void> cancelMatching() async {
    isSearching.value = false;
    // Hủy lắng nghe nếu tồn tại
    if (matchListener != null) {
      await matchListener?.cancel();
      matchListener = null;
    }
    var newQueue = QueueModel(
      userId: currentUserId,
      isSearching: false,
      createdAt: DateTime.now(),
      userEmail: currentUserEmail,
    );
    await _firestore
        .collection('matchings')
        .doc(currentUserId)
        .update(newQueue.toJson())
        .catchError((e) => errorMessage(e.toString()));
  }

  Future<String> updateRoomWhenPlayerLeaves(String roomId) async {
    try {
      // Lấy thông tin của room từ Firestore
      var roomSnapshot = await _firestore.collection('rooms').doc(roomId).get();
      var roomData = roomSnapshot.data() as Map<String, dynamic>;
      if (roomData['player1'] != null &&
          roomData['player1']['email'] == currentUserEmail) {
        return "Player 1 has left the room";
      } else if (roomData['player2'] != null &&
          roomData['player2']['email'] == currentUserEmail) {
        // Nếu player2 là người thoát phòng
        await _firestore.collection('rooms').doc(roomId).update({
          'player2': "",
          'player2Status': "",
        }).catchError((e) => errorMessage(e.toString()));
        return "Player 2 has left the room";
      } else {
        return "";
      }
    } catch (error) {
      return error.toString();
    }
  }

  //delete room
  Future<void> deleteRoom(String roomId) async {
    String checkedPlayerLeave = await updateRoomWhenPlayerLeaves(roomId);
    if (checkedPlayerLeave == "Player 1 has left the room") {
      await _firestore
          .collection("rooms")
          .doc(roomId)
          .delete()
          .catchError((e) => errorMessage(e.toString()));
    } else if (checkedPlayerLeave == "Player 2 has left the room") {
      errorMessage("You has left the room");
    }
    cancelMatching();
  }

  // function for updating the "matchings"
  void findingPlayer2() async {
    isFindingPlayer2.value = true;
    var newMatching = QueueModel(
      isSearching: true,
      createdAt: DateTime.now(),
      userId: currentUserId,
      userEmail: currentUserEmail,
    );
    await _firestore
        .collection('matchings')
        .doc(currentUserId)
        .update(newMatching.toJson())
        .catchError((e) => errorMessage(e.toString()));
    await Future.delayed(const Duration(seconds: 10));
    cancelFindingPlayer2();
  }

  void cancelFindingPlayer2() async {
    isFindingPlayer2.value = false;
    var newMatching = QueueModel(
      isSearching: false,
      createdAt: DateTime.now(),
      userId: currentUserId,
      userEmail: currentUserEmail,
    );
    await _firestore
        .collection('matchings')
        .doc(currentUserId)
        .update(newMatching.toJson())
        .catchError((e) => errorMessage(e.toString()));
  }

  // Lấy thông tin người chơi hiện tại
  Future<void> getUserDetails() async {
    await _firestore
        .collection("users")
        .doc(auth.currentUser?.uid)
        .get()
        .then((value) {
      user.value = UserModel.fromJson(value.data()!);
    });
  }

  //get room details
  Future<String> getOpponentIdFromRoom(String roomId) async {
    var roomSnapshot = await _firestore.collection('rooms').doc(roomId).get();
    var roomData = roomSnapshot.data() as Map<String, dynamic>;
    return roomData['player1']['id'];
  }

  @override
  void onClose() {
    cancelMatching();
    super.onClose();
  }
}

```

---


### Controller\notification_controller.dart

```dart
import 'dart:typed_data';
import 'package:flutter/services.dart' show rootBundle;
import 'package:flutter_cache_manager/flutter_cache_manager.dart';
import 'dart:ui' as ui;
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:flutter_local_notifications/flutter_local_notifications.dart';
import 'package:tictactoe_gameapp/Configs/messages.dart';
import 'package:tictactoe_gameapp/Models/user_model.dart';

class NotificationController extends GetxController {
  static NotificationController get to => Get.find();

  final FlutterLocalNotificationsPlugin flutterLocalNotificationsPlugin =
      FlutterLocalNotificationsPlugin();

  @override
  void onInit() {
    super.onInit();
    _initializeNotifications();
  }

  // Khởi tạo thông báo và yêu cầu quyền
  Future<void> _initializeNotifications() async {
    await _initializeFlutterLocalNotifications();
    await _requestPermissions();
    _listenToNotificationActions();
  }

  // Khởi tạo flutter_local_notifications
  Future<void> _initializeFlutterLocalNotifications() async {
    const AndroidInitializationSettings initializationSettingsAndroid =
        AndroidInitializationSettings('app_logo');
    const DarwinInitializationSettings initializationSettingsDarwin =
        DarwinInitializationSettings();
    const InitializationSettings initializationSettings =
        InitializationSettings(
      android: initializationSettingsAndroid,
      iOS: initializationSettingsDarwin,
    );

    await flutterLocalNotificationsPlugin.initialize(
      initializationSettings,
      onDidReceiveNotificationResponse: (NotificationResponse response) async {
        if (response.payload != null) {
          // Xử lý payload dựa trên dữ liệu
          switch (response.payload) {
            case "accept_call":
              Get.offAllNamed("/mainHome");
              break;
            case "decline_call":
              errorMessage("Hmmm...");
              break;
            case "dismiss_mess":
              errorMessage("Hmmm...");
              break;
            default:
              Get.toNamed('/mainHome');
          }
        }
      },
    );
  }

  // Yêu cầu quyền thông báo
  Future<void> _requestPermissions() async {
    if (GetPlatform.isAndroid) {
      await _requestAndroidPermissions();
    } else if (GetPlatform.isIOS) {
      await _requestIOSPermissions();
    }
  }

  Future<void> _requestAndroidPermissions() async {
    final androidPlugin =
        flutterLocalNotificationsPlugin.resolvePlatformSpecificImplementation<
            AndroidFlutterLocalNotificationsPlugin>();
    // Yêu cầu quyền thông báo (Android 13+)
    bool? notificationGranted =
        await androidPlugin?.requestNotificationsPermission();
    if (notificationGranted != null && !notificationGranted) {
      errorMessage("Quyền thông báo bị từ chối!");
    }

    // Yêu cầu quyền full-screen intent (API 34+)
    bool? fullScreenGranted =
        await androidPlugin?.requestFullScreenIntentPermission();
    if (fullScreenGranted != null && !fullScreenGranted) {
      errorMessage("Quyền full-screen intent bị từ chối!");
    }
  }

  Future<void> _requestIOSPermissions() async {
    final iosPlugin =
        flutterLocalNotificationsPlugin.resolvePlatformSpecificImplementation<
            IOSFlutterLocalNotificationsPlugin>();
    await iosPlugin?.requestPermissions(
      alert: true,
      badge: true,
      sound: true,
    );
  }

  // Lắng nghe tương tác với thông báo
  void _listenToNotificationActions() {
    // Xử lý tương tác được thực hiện trong onDidReceiveNotificationResponse
  }

  // Hiển thị thông báo chung
  Future<void> showNotification(
      String title, String body, Map<String, dynamic> data) async {
    Map<String, String?> payload =
        data.map((key, value) => MapEntry(key, value.toString()));
    const AndroidNotificationDetails androidDetails =
        AndroidNotificationDetails(
      'basic_channel_v2',
      'Basic notifications',
      channelDescription: 'Notification channel for basic notifications',
      importance: Importance.high,
      priority: Priority.high,
      color: Colors.lightBlueAccent,
      largeIcon: DrawableResourceAndroidBitmap('branding'),
      ledColor: Colors.white,
      ledOnMs: 1000, // Đèn LED bật trong 1 giây
      ledOffMs: 1000, // Đèn LED tắt trong 1 giây
      styleInformation: DefaultStyleInformation(true, true),
      playSound: true,
      sound: RawResourceAndroidNotificationSound('notification_sound'),
    );
    const NotificationDetails notificationDetails =
        NotificationDetails(android: androidDetails);
    await flutterLocalNotificationsPlugin.show(
      _createUniqueId(),
      title,
      body,
      notificationDetails,
      payload: payload.toString(), // Chuyển payload thành chuỗi
    );
  }

  // Hiển thị thông báo cuộc gọi
  Future<void> showCallNotification(
      String callerName, String callerImage) async {
    Uint8List largeIconBytes = await _loadNetworkImage(callerImage);
    final AndroidNotificationDetails androidDetails =
        AndroidNotificationDetails(
      'call_channel_v2',
      'Call notifications',
      channelDescription: 'Notification channel for call notifications',
      importance: Importance.max,
      priority: Priority.high,
      color: Colors.green,
      largeIcon: ByteArrayAndroidBitmap(largeIconBytes),
      ledColor: Colors.lightGreenAccent,
      ledOnMs: 1000, // Đèn LED bật trong 1 giây
      ledOffMs: 1000, // Đèn LED tắt trong 1 giây
      vibrationPattern: Int64List.fromList(
          [0, 1000, 500, 1000]), // Mô phỏng highVibrationPattern
      fullScreenIntent: true,
      timeoutAfter: 35000, // Hết hạn sau 30 giây
      actions: [
        const AndroidNotificationAction(
          'decline_call',
          'DECLINE',
          showsUserInterface: true,
          titleColor: Colors.redAccent,
        ),
        const AndroidNotificationAction(
          'accept_call',
          'ACCEPT',
          showsUserInterface: true,
          titleColor: Colors.greenAccent,
        ),
      ],
      playSound: true,
      sound: const RawResourceAndroidNotificationSound('call_sound'),
    );
    final NotificationDetails notificationDetails =
        NotificationDetails(android: androidDetails);

    await flutterLocalNotificationsPlugin.show(
      _createUniqueId(),
      callerName,
      '📞 You have a call from your friend: $callerName',
      notificationDetails,
      payload: 'accept_call', // Payload mặc định, có thể thay đổi theo logic
    );
  }

  // Hiển thị thông báo tin nhắn
  Future<void> showMessageNotification(
      UserModel senderModel, String message) async {
    Uint8List largeIconBytes = await _loadNetworkImage(senderModel.image!);
    final AndroidNotificationDetails androidDetails =
        AndroidNotificationDetails(
      'message_channel_v2',
      'Message notifications',
      channelDescription: 'Notification channel for message notifications',
      importance: Importance.high,
      priority: Priority.high,
      color: Colors.blue,
      largeIcon: ByteArrayAndroidBitmap(largeIconBytes),
      ledColor: Colors.lightBlueAccent,
      ledOnMs: 1000, // Đèn LED bật trong 1 giây
      ledOffMs: 1000, // Đèn LED tắt trong 1 giây
      vibrationPattern: Int64List.fromList([0, 100, 200, 100]),
      groupKey: 'message_group_${senderModel.name}', // Nhóm theo người gửi
      setAsGroupSummary: false, // Thông báo chi tiết
      actions: [
        const AndroidNotificationAction('dismiss_mess', 'DISMISS'),
        const AndroidNotificationAction('reply_mess', 'REPLY',
            showsUserInterface: true, allowGeneratedReplies: true),
      ],
      playSound: true,
      sound: const RawResourceAndroidNotificationSound('notification_sound'),
    );

    // Tạo thông báo tổng hợp cho nhóm
    final AndroidNotificationDetails groupSummaryDetails =
        AndroidNotificationDetails(
      'message_channel_v2',
      'Message notifications',
      channelDescription: 'Notification channel for message notifications',
      importance: Importance.high,
      priority: Priority.high,
      groupKey: 'message_group_${senderModel.name}',
      setAsGroupSummary: true, // Thông báo tổng hợp
    );

    final NotificationDetails notificationDetails =
        NotificationDetails(android: androidDetails);
    final NotificationDetails summaryDetails =
        NotificationDetails(android: groupSummaryDetails);

    await flutterLocalNotificationsPlugin.show(
      _createUniqueId(),
      senderModel.name,
      '📩 $message',
      notificationDetails,
      payload: 'dismiss_mess',
    );

    // Hiển thị thông báo tổng hợp
    await flutterLocalNotificationsPlugin.show(
      0, // ID cố định cho thông báo tổng hợp
      'New Messages',
      'You have new messages from ${senderModel.name}',
      summaryDetails,
    );
  }

  // Hiển thị thông báo yêu cầu kết bạn
  Future<void> showFriendRequestNotification(
      String requesterName, String requesterImage) async {
    final AndroidNotificationDetails androidDetails =
        AndroidNotificationDetails(
      'friend_channel',
      'Friend Request notifications',
      channelDescription:
          'Notification channel for friend request notifications',
      importance: Importance.high,
      priority: Priority.high,
      color: Colors.blue,
      vibrationPattern: Int64List.fromList([0, 100, 200, 100]),
      styleInformation: BigPictureStyleInformation(
        FilePathAndroidBitmap(requesterImage), // Đường dẫn ảnh đại diện
        largeIcon: FilePathAndroidBitmap(requesterImage),
      ),
      actions: [
        const AndroidNotificationAction('decline_friend', 'DECLINE',
            showsUserInterface: true),
        const AndroidNotificationAction('accept_friend', 'ACCEPT',
            showsUserInterface: true),
      ],
      playSound: true,
      sound: const RawResourceAndroidNotificationSound('friend_request_sound'),
    );

    final NotificationDetails notificationDetails =
        NotificationDetails(android: androidDetails);

    await flutterLocalNotificationsPlugin.show(
      _createUniqueId(),
      'Friend Request',
      '📨 $requesterName has sent you a friend request!',
      notificationDetails,
      payload: 'accept_friend',
    );
  }

  // Tạo ID duy nhất cho thông báo
  int _createUniqueId() {
    return DateTime.now().millisecondsSinceEpoch.remainder(100000);
  }

// Hàm tải ảnh từ assets
  Future<Uint8List> _loadAssetImage(String assetPath) async {
    final ByteData data = await rootBundle.load(assetPath);
    return data.buffer.asUint8List();
  }

  Future<Uint8List> _loadNetworkImage(String url) async {
    try {
      // Kiểm tra cache bằng DefaultCacheManager
      final fileInfo = await DefaultCacheManager().getFileFromCache(url);
      if (fileInfo != null) {
        // Nếu ảnh đã có trong cache, đọc byte từ file cache
        return await fileInfo.file.readAsBytes();
      } else {
        // Nếu không có trong cache, tải từ mạng và lưu vào cache
        final file = await DefaultCacheManager().getSingleFile(url);
        return await file.readAsBytes();
      }
    } catch (e) {
      throw Exception('Error loading network image: $e');
    }
  }

  Future<Uint8List> _processImageWithCanvas(Uint8List imageBytes,
      {int borderWidth = 2, Color borderColor = Colors.blueAccent}) async {
    final codec = await ui.instantiateImageCodec(imageBytes);
    final frame = await codec.getNextFrame();
    final uiImage = frame.image;

    final recorder = ui.PictureRecorder();
    final canvas = Canvas(recorder);
    final size = Size(uiImage.width.toDouble() + borderWidth * 2,
        uiImage.height.toDouble() + borderWidth * 2);

    // Vẽ viền
    final paintBorder = Paint()
      ..color = borderColor
      ..style = PaintingStyle.fill;
    canvas.drawCircle(
        Offset(size.width / 2, size.height / 2), size.width / 2, paintBorder);

    // Vẽ ảnh bo tròn
    canvas.save();
    canvas.clipRRect(RRect.fromRectAndRadius(
      Rect.fromLTWH(borderWidth.toDouble(), borderWidth.toDouble(),
          uiImage.width.toDouble(), uiImage.height.toDouble()),
      Radius.circular(uiImage.width / 2),
    ));
    canvas.drawImage(uiImage,
        Offset(borderWidth.toDouble(), borderWidth.toDouble()), Paint());
    canvas.restore();

    final picture = recorder.endRecording();
    final img = await picture.toImage(size.width.toInt(), size.height.toInt());
    final byteData = await img.toByteData(format: ui.ImageByteFormat.png);
    return byteData!.buffer.asUint8List();
  }
}

```

---


### Controller\online_status_controller.dart

```dart
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:tictactoe_gameapp/Controller/auth_controller.dart';

class OnlineStatusController extends GetxController
    with WidgetsBindingObserver {
  final FirebaseFirestore _firestore = FirebaseFirestore.instance;
  final String userId = Get.find<AuthController>().getCurrentUserId();

  @override
  void onInit() {
    super.onInit();
    WidgetsBinding.instance
        .addObserver(this); // Lắng nghe trạng thái app lifecycle.
    setOnline(); // Đặt trạng thái online khi khởi động app.
  }

  @override
  void onClose() {
    setOffline(); // Đặt trạng thái offline khi đóng app.
    WidgetsBinding.instance.removeObserver(this);
    super.onClose();
  }

  // Cập nhật trạng thái khi thay đổi vòng đời của app
  @override
  void didChangeAppLifecycleState(AppLifecycleState state) {
    if (state == AppLifecycleState.resumed) {
      setOnline(); // App vào foreground (online).
    } else if (state == AppLifecycleState.paused) {
      setOffline(); // App vào background (offline).
    }
  }

  // Đặt trạng thái online trong Firestore
  Future<void> setOnline() async {
    await _firestore.collection('users').doc(userId).update({
      'status': 'online',
      'lastActive': FieldValue.serverTimestamp(),
    });
  }

  // Đặt trạng thái offline trong Firestore
  Future<void> setOffline() async {
    await _firestore.collection('users').doc(userId).update({
      'status': 'offline',
      'lastActive': FieldValue.serverTimestamp(),
    });
  }
}

```

---


### Controller\profile_controller.dart

```dart
import 'dart:io';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:confetti/confetti.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:firebase_storage/firebase_storage.dart';
import 'package:get/get.dart';
import 'package:image_picker/image_picker.dart';
import 'package:tictactoe_gameapp/Controller/auth_controller.dart';
import 'package:tictactoe_gameapp/Models/user_model.dart';
import 'package:tictactoe_gameapp/Models/queue_model.dart';
import '../Configs/messages.dart';

class ProfileController extends GetxController {
  final ImagePicker picker = ImagePicker();
  final store = FirebaseStorage.instance;
  final auth = FirebaseAuth.instance;
  final db = FirebaseFirestore.instance;
  final String userId = Get.find<AuthController>().getCurrentUserId();
  late  UserModel? user;

  // @override
  // void onInit() {
  //   super.onInit();
  //   initialize();
  // }

  Future<void> initialize() async {
    user = await getUserById();
  }

  Future<UserModel?> getUserById() async {
    try {
      // Thực hiện truy vấn Firestore để lấy document của user
      DocumentSnapshot userDoc = await db.collection('users').doc(userId).get();

      // Kiểm tra xem document có tồn tại không
      if (userDoc.exists) {
        // Nếu có, trả về UserModel từ document data
        return UserModel.fromJson(userDoc.data() as Map<String, dynamic>);
      } else {
        errorMessage("User không tồn tại với id: $userId");
        return null;
      }
    } catch (e) {
      errorMessage("Lỗi khi lấy UserModel từ Firestore: $e");
      return null;
    }
  }

  Rx<UserModel?> rxUser = Rx<UserModel?>(null);
  void listenToUserByIdRealTime(String userId) {
    db
        .collection('users')
        .doc(userId)
        .snapshots() // Lắng nghe sự thay đổi theo thời gian thực
        .listen((documentSnapshot) {
      if (documentSnapshot.exists) {
        // Nếu document tồn tại, chuyển đổi dữ liệu thành UserModel và cập nhật vào Rx
        rxUser.value =
            UserModel.fromJson(documentSnapshot.data() as Map<String, dynamic>);
      } else {
        // Nếu không tồn tại, cập nhật Rx với giá trị null
        rxUser.value = null;
      }
    });
  }

  Future<void> updateProfile(
    String name,
    String imagePath,
    ConfettiController confettiController,
    List<String>? avatarFrame,
  ) async {
    try {
      bool exists = await isUserNameExists(name);
      if (imagePath != "" && name != "" && exists == false) {
        confettiController.play();
        var uploadedImageUrl = await uploadImageToFirebase(imagePath);
        var newQueue = QueueModel(
          userId: auth.currentUser!.uid,
          isSearching: false,
          createdAt: DateTime.now(),
          userEmail: auth.currentUser!.email,
        );
        var newUser = UserModel(
          id: auth.currentUser!.uid,
          name: name,
          image: uploadedImageUrl,
          email: auth.currentUser!.email,
          totalCoins: "0",
          totalWins: "0",
          status: "online",
          avatarFrame: avatarFrame,
        );
        await db
            .collection("users")
            .doc(auth.currentUser!.uid)
            .set(
              newUser.toJson(),
            )
            .catchError((e) => errorMessage(e.toString()));
        await db
            .collection('matchings')
            .doc(auth.currentUser!.uid)
            .set(newQueue.toJson())
            .catchError((e) => errorMessage(e.toString()));
      } else if (exists == true) {
        errorMessage("Username already exists");
      } else {
        errorMessage("Please fill all the fields");
      }
    } catch (e) {
      errorMessage("Profile Update Failed");
    }
  }

  Future<String> uploadImageToFirebase(String imagePath) async {
    final path = "files/$imagePath";
    final file = File(imagePath);
    if (imagePath != "") {
      try {
        final ref = store.ref().child(path).putFile(file);
        final uploadTask = await ref.whenComplete(() {});
        final downloadImageUrl = await uploadTask.ref.getDownloadURL();
        // print(downloadImageUrl);
        return downloadImageUrl;
      } catch (ex) {
        // print(ex);
        return "";
      }
    }
    return "";
  }

  Future<String> pickImage(ImageSource source) async {
    final XFile? image = await picker.pickImage(
      source: source,
    );
    if (image != null) {
      return image.path;
    } else {
      return "";
    }
  }

  Future<XFile?> pickFileX(ImageSource source) async {
    final XFile? image = await picker.pickImage(
      source: source,
      maxHeight: 240,
      maxWidth: 320,
    );
    return image;
  }

  Future<XFile?> pickImageGallery() async {
    final XFile? images = await picker.pickImage(
      maxHeight: 240,
      maxWidth: 320,
      source: ImageSource.gallery,
    );
    return images;
  }

  Future<XFile?> pickImageCamera() async {
    final XFile? image = await picker.pickImage(
      source: ImageSource.camera,
      maxHeight: 240,
      maxWidth: 320,
    );
    return image;
  }

  Future<bool> isUserNameExists(String name) async {
    try {
      final querySnapshot =
          await db.collection('users').where('name', isEqualTo: name).get();
      return querySnapshot.docs.isNotEmpty;
    } catch (e) {
      errorMessage("Error checking username: $e");
      return false;
    }
  }
}

```

---


### Controller\room_controller.dart

```dart
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:get/get.dart';
import 'package:tictactoe_gameapp/Configs/messages.dart';
import 'package:tictactoe_gameapp/Controller/auth_controller.dart';
import 'package:tictactoe_gameapp/Models/room_model.dart';
import 'package:tictactoe_gameapp/Models/user_model.dart';
import 'package:tictactoe_gameapp/Pages/LobbyPage/lobby_page.dart';
import 'package:uuid/uuid.dart';

class RoomController extends GetxController {
  final AuthController auth = Get.find();
  final db = FirebaseFirestore.instance;
  var uuid = const Uuid();
  RxBool isLoading = false.obs;
  Rx<UserModel> user = UserModel().obs;
  Rx<RoomModel?> roomData = Rx<RoomModel?>(null);

  @override
  void onInit() {
    super.onInit();
    getUserDetails();
  }

  Future<void> createRoom() async {
    isLoading.value = true;
    String id = uuid.v4().substring(0, 8).toUpperCase();
    var player1 = UserModel(
      id: user.value.id,
      name: user.value.name,
      image: user.value.image,
      email: user.value.email,
      totalWins: user.value.totalWins,
      totalCoins: user.value.totalCoins,
      role: "admin",
    );
    var newRoom = RoomModel(
      id: id,
      player1: player1,
      gameStatus: "lobby",
      player1Status: "waiting",
      player2Status: "",
      isXturn: true,
      createdAt: DateTime.now(),
    );
    try {
      await db
          .collection("rooms")
          .doc(id)
          .set(
            newRoom.toJson(),
          )
          .catchError((e) => errorMessage(e.toString()));
      Get.to(
        LobbyPage(roomId: id),
        transition: Transition.leftToRightWithFade,
      );
    } catch (e) {
      errorMessage("Error");
    }
    isLoading.value = false;
  }

  Future<void> getUserDetails() async {
    await db
        .collection("users")
        .doc(auth.getCurrentUserId())
        .get()
        .then((value) {
      user.value = UserModel.fromJson(value.data()!);
    });
    await deleteOldRoom();
  }

  void getRoomDetails(String roomId) {
    db.collection('rooms').doc(roomId).snapshots().listen((snapshot) {
      if (snapshot.exists) {
        // Update roomData when the snapshot is received
        roomData.value =
            RoomModel.fromJson(snapshot.data() as Map<String, dynamic>);
      } else {
        roomData.value = null; // Room not found
      }
    });
  }

  void listenRoomChanges(String roomId) {
    db.collection('rooms').doc(roomId).snapshots().listen(
      (snapshot) {
        if (snapshot.exists) {
          roomData.value = RoomModel.fromJson(snapshot.data()!);
        } else {
          roomData.value = null;
        }
      },
    );
  }

  Future<void> joinRoom(String roomId) async {
    isLoading.value = true;
    var player2 = UserModel(
      id: user.value.id,
      name: user.value.name,
      image: user.value.image,
      email: user.value.email,
      totalWins: user.value.totalWins,
      totalCoins: user.value.totalCoins,
      role: "player",
    );
    try {
      await db.collection("rooms").doc(roomId).update(
        {
          "player2": player2.toJson(),
          "player2Status": "waiting",
        },
      ).catchError((e) => errorMessage(e.toString()));
      Get.to(
        LobbyPage(roomId: roomId),
        transition: Transition.leftToRightWithFade,
      );
    } catch (e) {
      errorMessage(e.toString());
    }
    isLoading.value = false;
  }

  Future<void> updatePlayer2Status(String roomId, String status) async {
    await db.collection("rooms").doc(roomId).update(
      {
        "player2Status": status,
      },
    );
  }

  Future<void> deleteOldRoom() async {
    final Timestamp sevenDaysAgo = Timestamp.fromDate(
      DateTime.now().subtract(const Duration(days: 1)),
    );

    try {
      QuerySnapshot snapshot = await db
          .collection('rooms')
          .where('createdAt', isLessThan: sevenDaysAgo)
          .get();

      for (var doc in snapshot.docs) {
        await db
            .collection('rooms')
            .doc(doc.id)
            .delete()
            .catchError((e) => errorMessage('Error deleting old messages: $e'));
      }
      print('Deleted rooms yesterday');
    } catch (e) {
      errorMessage('Error deleting old messages: $e');
    }
  }
}

```

---


### Controller\speech_to_text_controller.dart

```dart
import 'package:flutter/services.dart';
import 'package:get/get.dart';
import 'package:speech_to_text/speech_recognition_error.dart';
import 'package:speech_to_text/speech_recognition_result.dart';
import 'package:speech_to_text/speech_to_text.dart' as stt;
import 'package:tictactoe_gameapp/Configs/messages.dart';
import 'package:tictactoe_gameapp/Models/Functions/permission_handle_functions.dart';

class SpeechController extends GetxController {
  final stt.SpeechToText _speechToText = stt.SpeechToText();
// state variables
  var isSpeechEnabled = false.obs;
  var lastWords = "".obs; //Hi, How is it going
  var isListening = false.obs;

// Inintial instance of speech
  Future<void> initializeSpeech() async {
    try {
      final permissionHandler = PermissionHandleFunctions();
      bool micGranted = await permissionHandler.checkMicrophonePermission();
      if (micGranted) {
        isSpeechEnabled.value = await _speechToText.initialize(
          onStatus: statusListener,
          onError: errorListener,
          debugLogging: true,
          options: [stt.SpeechToText.androidIntentLookup],
        );
      } else {
        errorMessage('Microphone permission not granted');
      }
    } catch (e) {
      if (e is PlatformException) {
        errorMessage('Speech initialization error: ${e.message}');
      } else {
        errorMessage('Unexpected error during initialization: ${e.toString()}');
      }
    }
  }

  void errorListener(SpeechRecognitionError error) {
    errorMessage('Speech error: ${error.errorMsg}');
    isListening.value = false;
  }

  void statusListener(String status) {
    if (status == 'done') {
      isListening.value = false;
    } else if (status == 'listening') {
      isListening.value = true;
    }
  }

// Listening--------------------------------
  Future<void> startListening() async {
    if (!isSpeechEnabled.value) {
    await initializeSpeech();
    } else {
    try {
      await _speechToText.listen(
        onResult: _onSpeechResult,
        listenFor: const Duration(seconds: 30),
        pauseFor: const Duration(seconds: 5),
      );
      isListening.value = _speechToText.isListening;
    } catch (e) {
      errorMessage('Error while starting listening: ${e.toString()}');
      }
    }
  }

  void _onSpeechResult(SpeechRecognitionResult result) {
    if (result.finalResult) {
      if (result.recognizedWords.isNotEmpty) {
        lastWords.value = result.recognizedWords;
      } else {
        errorMessage("No recognized words.");
      }
    }
  }

//stop listening---------------------
  Future<void> stopListening() async {
    if (isListening.value) {
      try {
        await _speechToText.stop();
        isListening.value = false;
      } catch (e) {
        errorMessage('Error while stopping listening: ${e.toString()}');
      }
    }
  }

//reset lastwords variable
  void resetLastWords() {
    lastWords.value = '';
  }

  // @override
  // void onClose() {
  //   resetLastWords();
  //   super.onClose();
  // }
}

```

---


### Controller\splace_controller.dart

```dart
import 'package:firebase_auth/firebase_auth.dart';
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:tictactoe_gameapp/Controller/online_status_controller.dart';
import 'package:tictactoe_gameapp/Controller/profile_controller.dart';

class SplaceController extends GetxController with GetSingleTickerProviderStateMixin {
  final auth = FirebaseAuth.instance;
  RxDouble progress = 0.0.obs;
  late AnimationController animationController;
  late Animation<double> progressAnimation;
  bool isLoadingComplete = false;

  @override
  void onInit() {
    super.onInit();
    // Khởi tạo AnimationController
    animationController = AnimationController(
      duration: const Duration(seconds: 3), // Thời gian tối đa để chạy từ 0-100%
      vsync: this,
    );

    progressAnimation = Tween<double>(begin: 0.0, end: 1.0).animate(animationController)
      ..addListener(() {
        progress.value = progressAnimation.value;
        // Chỉ chuyển trang khi cả loading hoàn tất và progress đạt 100%
        if (isLoadingComplete && progress.value >= 1.0) {
          _navigate();
        }
      });

    // Bắt đầu animation
    animationController.forward();
    // Chạy logic tải song song
    splaceHandle();
  }

  Future<void> splaceHandle() async {
    await Future.delayed(const Duration(seconds: 1)); // Giả lập bước đầu
    if (auth.currentUser == null) {
      isLoadingComplete = true;
      // Nếu animation chưa xong, tăng tốc để đạt 100%
      if (progress.value < 1.0) {
        animationController.duration = const Duration(milliseconds: 500); // Giảm thời gian còn lại
        animationController.forward(from: progress.value);
      }
    } else {
      final ProfileController profileController = Get.put(ProfileController());
      await profileController.initialize();
      Get.put(OnlineStatusController(), permanent: true);
      isLoadingComplete = true;
      // Nếu animation chưa xong, tăng tốc để đạt 100%
      if (progress.value < 1.0) {
        animationController.duration = const Duration(milliseconds: 500); // Giảm thời gian còn lại
        animationController.forward(from: progress.value);
      }
    }
  }

  void _navigate() {
    if (auth.currentUser == null) {
      Get.offAllNamed("/welcome");
    } else {
      Get.offAllNamed("/mainHome");
    }
  }

  @override
  void onClose() {
    animationController.dispose();
    super.onClose();
  }
}
```

---


### Controller\text_to_speech_controller.dart

```dart
import 'package:flutter/material.dart';
import 'package:flutter_tts/flutter_tts.dart';
import 'package:get/get.dart';
import 'package:tictactoe_gameapp/Configs/messages.dart';

enum TtsState { playing, stopped, paused, continued }

class TextToSpeechController extends GetxController {
  final FlutterTts flutterTts = FlutterTts();

  var language = 'en-US'.obs;
  var engine = 'default'.obs;
  var volume = 0.8.obs;
  var pitch = 1.0.obs;
  var rate = 0.5.obs;
  var isCurrentLanguageInstalled = false.obs;
  var ttsState = TtsState.stopped.obs;
  var isEchoMode = false.obs;
  var isAlexaMode = false.obs;

  bool get isPlaying => ttsState.value == TtsState.playing;
  bool get isStopped => ttsState.value == TtsState.stopped;
  bool get isPaused => ttsState.value == TtsState.paused;
  bool get isContinued => ttsState.value == TtsState.continued;

  @override
  void onInit() {
    super.onInit();
    initTts();
  }

  void initTts() {
    _setAwaitOptions();
    // flutterTts.setStartHandler(() => ttsState.value = TtsState.playing);
    // flutterTts.setCompletionHandler(() => ttsState.value = TtsState.stopped);
    // flutterTts.setCancelHandler(() => ttsState.value = TtsState.stopped);
    // flutterTts.setPauseHandler(() => ttsState.value = TtsState.paused);
    // flutterTts.setContinueHandler(() => ttsState.value = TtsState.continued);
    flutterTts.setErrorHandler((msg) {
      ttsState.value = TtsState.stopped;
      errorMessage("TTS Error: $msg");
    });
  }

  Future<void> _setAwaitOptions() async {
    await flutterTts.awaitSpeakCompletion(true);
  }

  Future<void> speak(String text) async {
    ttsState.value = TtsState.playing;
    // Adjust settings based on mode
    if (isEchoMode.value) {
      await _setEchoModeSettings();
    } else if (isAlexaMode.value) {
      await _setAlexaModeSettings();
    } else {
      await _setNormalSettings();
    }

    if (text.isNotEmpty) {
      await flutterTts.speak(text);
    }
    ttsState.value = TtsState.stopped;
  }

  Future<void> stop() async {
    ttsState.value = TtsState.stopped;
    await flutterTts.stop();
  }

  Future<void> pause() async {
    ttsState.value = TtsState.paused;
    await flutterTts.pause();
  }

  Future<void> resume() async {
    ttsState.value = TtsState.continued;
    flutterTts.continueHandler;
  }

  Future<void> setLanguage(String lang) async {
    language.value = lang;
    await flutterTts.setLanguage(lang);
    if (GetPlatform.isAndroid) {
      isCurrentLanguageInstalled.value =
          await flutterTts.isLanguageInstalled(lang) ?? false;
    }
  }

  Future<void> setVolume(double newVolume) async {
    volume.value = newVolume;
    await flutterTts.setVolume(newVolume);
  }

  Future<void> setPitch(double newPitch) async {
    pitch.value = newPitch;
    await flutterTts.setPitch(newPitch);
  }

  Future<void> setRate(double newRate) async {
    rate.value = newRate;
    await flutterTts.setSpeechRate(newRate);
  }

  // Mode settings
  Future<void> _setNormalSettings() async {
    await flutterTts.setVolume(volume.value);
    await flutterTts.setPitch(pitch.value);
    await flutterTts.setSpeechRate(rate.value);
  }

  Future<void> _setEchoModeSettings() async {
    await flutterTts.setVolume(0.7); // Echo effect volume
    await flutterTts.setPitch(0.9); // Lower pitch
    await flutterTts.setSpeechRate(0.8); // Moderate rate for echo
  }

  Future<void> _setAlexaModeSettings() async {
    await flutterTts.setVolume(0.85); // Alexa effect volume
    await flutterTts.setPitch(1.0); // Neutral pitch
    await flutterTts.setSpeechRate(0.75); // Slightly slower rate
  }

  Map<String, dynamic> getIconAndCallback(String text) {
    if (isPlaying) {
      return {
        "icon": Icons.volume_up_rounded,
        "callback": () async {
          await pause();
        }
      };
    } else if (isStopped || isContinued) {
      return {
        "icon": Icons.volume_off_rounded,
        "callback": () async {
          await speak(text);
        }
      };
    } else {
      return {
        "icon": Icons.error,
        "callback": null,
      };
    }
  }

  @override
  void onClose() {
    flutterTts.stop();
    super.onClose();
  }
}

```

---


### Controller\theme_controller.dart

```dart
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:get_storage/get_storage.dart';
import 'package:tictactoe_gameapp/Configs/theme/theme_dark.dart';
import 'package:tictactoe_gameapp/Configs/theme/theme_light.dart';

class ThemeController extends GetxController {
  final _box = GetStorage();
  final _key = 'isDarkMode';

  var isDarkMode = false.obs;

  @override
  void onInit() {
    super.onInit();
    isDarkMode.value = _loadThemeFromStorage();
    _applyTheme();
  }

  bool _loadThemeFromStorage() {
    return _box.read(_key) ?? false;
  }

  void _saveThemeToStorage(bool isDarkMode) {
    _box.write(_key, isDarkMode);
  }

  void toggleTheme() {
    isDarkMode.value = !isDarkMode.value;
    _saveThemeToStorage(isDarkMode.value);
    WidgetsBinding.instance.addPostFrameCallback((_) {
      _applyTheme();
    });
  }

  void _applyTheme() {
    Future.microtask(() {
      Get.changeTheme(isDarkMode.value ? darktheme : lightTheme);
    });
  }

  
}

```

---


### Controller\webview_controller.dart

```dart
import 'package:flutter/material.dart';
import 'package:flutter_inappwebview/flutter_inappwebview.dart';
import 'package:get/get.dart';
import 'package:tictactoe_gameapp/Controller/MainHome/notify_in_main_controller.dart';

class WebViewControllers extends GetxController {
  late InAppBrowserClassSettings settings;
  final NotifyInMainController notifyInMainController =
      Get.put(NotifyInMainController());

  @override
  void onInit() {
    super.onInit();
    notifyInMainController.listenForFriendRequests();
    notifyInMainController.listenForGameInvites();
    notifyInMainController.listenForCall();
    settings = InAppBrowserClassSettings(
      browserSettings: InAppBrowserSettings(
        hideUrlBar: false,
        toolbarTopBackgroundColor: Colors.greenAccent,
        menuButtonColor: Colors.lightBlueAccent,
      ),
      webViewSettings: InAppWebViewSettings(
        javaScriptEnabled: true,
      ),
    );
  }

  Future<void> openWebView({required String url}) async {
    await InAppBrowser().openUrlRequest(
      urlRequest: URLRequest(url: WebUri(url)),
      settings: settings,
    );
  }
}

```

---


### Controller\Animations\carousel_controller.dart

```dart
import 'dart:math';

import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:tictactoe_gameapp/Configs/constants.dart';

class CarouselController extends GetxController {
  final int realItemCount = images.length;
  late final int virtualItemCount;
  late PageController pageController;
  late var currentPage = (realItemCount * 500).toDouble().obs;

  @override
  void onInit() {
    super.onInit();
    virtualItemCount = realItemCount * 1000;
    _initializePageController();
  }

  void _initializePageController() {
    pageController =
        PageController(viewportFraction: 0.4, initialPage: realItemCount * 500);
    pageController.addListener(_pageListener);
  }

  void reinitializePageController() {
    pageController.removeListener(_pageListener);
    _initializePageController();
  }

  void _pageListener() {
    if (pageController.positions.length == 1) {
      currentPage.value = pageController.page!;
    }
  }

  int getRealIndex(int virtualIndex) {
    return virtualIndex % realItemCount;
  }

  Matrix4 build3DTransform(int index) {
    double offsetFromCenter = index - currentPage.value;
    double angle = offsetFromCenter * pi / 5;
    double scale = 1 - (offsetFromCenter.abs() * 0.3);
    double depth = -300 * cos(angle);

    return Matrix4.identity()
      ..rotateY(angle)
      ..translate(200 * sin(angle), 0.0, depth)
      ..scale(scale);
  }

  Color itemColor(int index) {
    double offsetFromCenter = (index - currentPage.value).abs();
    double opacity = 1 - offsetFromCenter * 0.5;
    opacity = opacity.clamp(0.0, 1.0);

    return Colors.red.withOpacity(opacity);
  }

  @override
  void onClose() {
    pageController.removeListener(_pageListener);
    pageController.dispose();
    super.onClose();
  }
}

```

---


### Controller\Animations\confetti_controller.dart

```dart
import 'package:confetti/confetti.dart';
import 'package:flutter/material.dart';
import 'package:get/get.dart';

class ConfettiToController extends GetxController {
  late ConfettiController confettiController;

  @override
  void onInit() {
    super.onInit();
    confettiController =
        ConfettiController(duration: const Duration(seconds: 3));
    WidgetsBinding.instance.addPostFrameCallback((_) {
      confettiController.play();
    });
  }

  void startConfetti() {
    confettiController.play();
  }

  void stopConfetti() {
    confettiController.stop();
  }

  @override
  void onClose() {
    confettiController.dispose();
    super.onClose();
  }
}

```

---


### Controller\Animations\countdown_animation_controller.dart

```dart
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:tictactoe_gameapp/Controller/Music/background_music_controller.dart';

class CountdownController extends GetxController
    with GetTickerProviderStateMixin {
  late AnimationController animationController;
  final BackgroundMusicController musicController = Get.find();
  var timeLeft = 95.obs;
  var progressColor = Colors.blue.obs;

  @override
  void onInit() {
    super.onInit();
    // Tạo AnimationController điều khiển animation cho border theo thời gian
    animationController = AnimationController(
      vsync: this,
      duration: const Duration(seconds: 95),
    );

    listenerCountdown();
    animationController.forward();
  }

  void listenerCountdown() {
    // Đăng ký listener để cập nhật timeLeft dựa trên animationController
    animationController.addListener(() {
      // Cập nhật timeLeft dựa trên tiến trình animation
      timeLeft.value = (95 - animationController.value * 95).round();

      // Thay đổi màu viền dựa trên thời gian còn lại
      if (timeLeft.value <= 30) {
        progressColor.value = Colors.red; // Dưới 30 giây: Màu đỏ
      } else if (timeLeft.value <= 60) {
        progressColor.value = Colors.orange; // Dưới 60 giây: Màu vàng
      } else {
        progressColor.value = Colors.blue; // Trên 60 giây: Màu xanh
      }

      // Kiểm tra nếu hết thời gian thì dừng animation
      if (animationController.isCompleted) {
        stopAnimation();
        Get.offAllNamed("/mainHome");
      }
    });
  }

  void stopAnimation() async {
    musicController.stopMusicOnScreen5();
    animationController.stop();
  }


  @override
  void onClose() {
    animationController.dispose();
    super.onClose();
  }
}

```

---


### Controller\Animations\dotted_border_animation_controller.dart

```dart
import 'package:flutter/material.dart';
import 'package:get/get.dart';

class DottedBorderAnimationController extends GetxController
    with GetTickerProviderStateMixin {
  late AnimationController controller;

  @override
  void onInit() {
    super.onInit();
    // Khởi tạo AnimationController để điều khiển animation
    controller = AnimationController(
      vsync: this,
      duration: const Duration(seconds: 30), // Thời gian để hoàn thành một vòng
    )..repeat(); // Lặp lại animation liên tục
  }

  @override
  void onClose() {
    controller.dispose();
    super.onClose();
  }
}

```

---


### Controller\Animations\dot_matching_animation_controller.dart

```dart
import 'dart:math';

import 'package:flutter/material.dart';
import 'package:get/get.dart';

class MatchingAnimationController extends GetxController
    with GetTickerProviderStateMixin {
  late AnimationController dotsAnimationController;

  var dotsOffset1 = 0.0.obs;
  var dotsOffset2 = 0.0.obs;
  var dotsOffset3 = 0.0.obs;

  @override
  void onInit() {
    super.onInit();
    initDotsWaveAnimation();
  }

  // Tạo animation sóng cho các dấu chấm
  void initDotsWaveAnimation() {
    dotsAnimationController = AnimationController(
      vsync: this,
      duration: const Duration(seconds: 2),
    )..repeat();

    dotsAnimationController.addListener(() {
      // Sử dụng sin() để tạo hiệu ứng sóng, với pha khác nhau cho mỗi dấu chấm
      double animationValue = dotsAnimationController.value * 2 * pi;
      dotsOffset1.value = sin(animationValue) * 10;
      dotsOffset2.value = sin(animationValue + pi / 3) * 10; // Chênh lệch pha
      dotsOffset3.value =
          sin(animationValue + 2 * pi / 3) * 10; // Chênh lệch pha
    });
  }

  // Dừng animation
  void stopDotsAnimation() {
    dotsAnimationController.stop();
  }

  @override
  void onClose() {
    stopDotsAnimation();
    dotsAnimationController.dispose();
    super.onClose();
  }
}

```

---


### Controller\Animations\Overlays\draw_tria.dart

```dart
import 'package:flutter/material.dart';

class TrianglePainter extends CustomPainter {
  final Color color;
  final Alignment alignment; // Thêm alignment để biết vị trí tam giác

  TrianglePainter({required this.color, required this.alignment});

  @override
  void paint(Canvas canvas, Size size) {
    final paint = Paint()..color = color;

    var path = Path();
    if (alignment == Alignment.topCenter) {
      // Tam giác hướng lên trên
      path.moveTo(0, 0);
      path.lineTo(size.width / 2, size.height);
      path.lineTo(size.width, 0);
    } else if (alignment == Alignment.bottomCenter) {
      // Tam giác hướng xuống dưới
      path.moveTo(0, size.height);
      path.lineTo(size.width / 2, 0);
      path.lineTo(size.width, size.height);
    } else if (alignment == Alignment.centerRight) {
      // Tam giác hướng sang phải
      path.moveTo(0, 0);
      path.lineTo(size.width, size.height / 2);
      path.lineTo(0, size.height);
    } else if (alignment == Alignment.centerLeft) {
      // Tam giác hướng sang trái
      path.moveTo(size.width, 0);
      path.lineTo(0, size.height / 2);
      path.lineTo(size.width, size.height);
    }

    path.close();
    canvas.drawPath(path, paint); // Vẽ tam giác
  }

  @override
  bool shouldRepaint(CustomPainter oldDelegate) => false;
}


// Tam giác có thể tùy chỉnh cong
class CurvedTailPainter extends CustomPainter {
  final Color color;
  final Alignment alignment;

  CurvedTailPainter({required this.color, required this.alignment});

  @override
  void paint(Canvas canvas, Size size) {
    final paint = Paint()
      ..color = color
      ..style = PaintingStyle.fill;
    
    final path = Path();

    if (alignment == Alignment.bottomCenter) {
      // Đuôi cong ở dưới widget, hướng từ dưới lên
      path.moveTo(size.width / 2, 0); // Đỉnh tam giác
      path.quadraticBezierTo(
          size.width / 2 - 20, size.height / 2, 
          size.width / 2 - 30, size.height); // Cạnh trái uốn cong xuống dưới
      path.lineTo(size.width / 2 + 30, size.height); // Cạnh phải kéo xuống dưới
      path.quadraticBezierTo(
          size.width / 2 + 20, size.height / 2, 
          size.width / 2, 0); // Cạnh phải uốn cong lại lên đỉnh
    } else if (alignment == Alignment.topCenter) {
      // Đuôi cong ở trên widget, hướng từ trên xuống
      path.moveTo(size.width / 2, size.height); // Đỉnh tam giác ở dưới
      path.quadraticBezierTo(
          size.width / 2 - 20, size.height / 2, 
          size.width / 2 - 30, 0); // Cạnh trái uốn cong lên trên
      path.lineTo(size.width / 2 + 30, 0); // Cạnh phải kéo lên trên
      path.quadraticBezierTo(
          size.width / 2 + 20, size.height / 2, 
          size.width / 2, size.height); // Cạnh phải uốn cong lại xuống dưới
    } else if (alignment == Alignment.centerLeft) {
      // Đuôi cong bên trái widget, hướng từ trái sang
      path.moveTo(size.width, size.height / 2); // Đỉnh tam giác
      path.quadraticBezierTo(
          size.width / 2, size.height / 2 - 20, 
          0, size.height / 2 - 30); // Cạnh trên uốn cong
      path.lineTo(0, size.height / 2 + 30); // Kéo xuống cạnh dưới
      path.quadraticBezierTo(
          size.width / 2, size.height / 2 + 20, 
          size.width, size.height / 2); // Cạnh dưới uốn cong lên
    } else if (alignment == Alignment.centerRight) {
      // Đuôi cong bên phải widget, hướng từ phải sang
      path.moveTo(0, size.height / 2); // Đỉnh tam giác
      path.quadraticBezierTo(
          size.width / 2, size.height / 2 - 20, 
          size.width, size.height / 2 - 30); // Cạnh trên uốn cong
      path.lineTo(size.width, size.height / 2 + 30); // Kéo xuống cạnh dưới
      path.quadraticBezierTo(
          size.width / 2, size.height / 2 + 20, 
          0, size.height / 2); // Cạnh dưới uốn cong xuống
    }

    canvas.drawPath(path, paint);
  }

  @override
  bool shouldRepaint(covariant CustomPainter oldDelegate) {
    return true;
  }
}

```

---


### Controller\Animations\Overlays\profile_tooltip.dart

```dart
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:tictactoe_gameapp/Components/profile_tooltip_widget.dart';
import 'package:tictactoe_gameapp/Controller/Animations/Overlays/draw_tria.dart';
import 'package:tictactoe_gameapp/Enums/popup_position.dart';
import 'package:tictactoe_gameapp/Models/user_model.dart';
import 'package:tictactoe_gameapp/Pages/Society/About/user_about_page.dart';

class ProfileTooltip extends GetxController
    with GetSingleTickerProviderStateMixin {
  final Rx<OverlayEntry?> _popupEntry = Rx<OverlayEntry?>(null);
  RxBool isPopupVisible = false.obs; // Để kiểm soát trạng thái của popup

  late AnimationController animationController;
  late Animation<Offset> slideAnimation; // Animation cho hiệu ứng trượt
  late Animation<double> opacityAnimation; // Animation cho độ mờ

  @override
  void onInit() {
    super.onInit();
    // Khởi tạo AnimationController cho các hiệu ứng
    animationController = AnimationController(
      duration: const Duration(milliseconds: 500), // Thời gian cho animation
      vsync: this,
    );

    // Khởi tạo các hiệu ứng cho slide và fade
    slideAnimation = Tween<Offset>(
      begin: const Offset(0, -0.1), // Điểm bắt đầu (dưới ra trên)
      end: Offset.zero, // Điểm kết thúc
    ).animate(CurvedAnimation(
      parent: animationController,
      curve: Curves.easeInOut, // Đường cong animation
    ));

    opacityAnimation = Tween<double>(
      begin: 0.0, // Bắt đầu từ độ mờ 0
      end: 1.0, // Đến độ mờ 1
    ).animate(CurvedAnimation(
      parent: animationController,
      curve: Curves.easeIn, // Đường cong animation mờ dần
    ));
  }

  // Hiển thị popup
  void showProfileTooltip(
    BuildContext context,
    GlobalKey itemKey,
    UserModel user,
    PopupPosition position,
    double? width, // Chiều rộng của popup
    double? height, // Chiều cao của popup
    Duration? autoDismissDuration, // Thời gian tự động đóng popup
  ) {
    final renderBox = itemKey.currentContext!.findRenderObject() as RenderBox;
    final widgetPosition =
        renderBox.localToGlobal(Offset.zero); // Lấy vị trí của widget bấm
    final widgetSize = renderBox.size; // Lấy kích thước của widget bấm

    if (_popupEntry.value != null) {
      // Xóa popup cũ nếu đã hiển thị
      removePopup();
    }

    // Tính toán vị trí của popup và tam giác
    final popupOffsetAndAlignment = _calculatePopupPositionAndAlignment(
      widgetPosition,
      widgetSize,
      position,
      width: width ?? 200, // Chiều rộng của popup
      height: height ?? 200, // Chiều cao của popup
    );

    // Tạo OverlayEntry cho popup
    _popupEntry.value = OverlayEntry(
      builder: (context) => Stack(
        children: [
          GestureDetector(
            behavior: HitTestBehavior.translucent,
            onTap: () => removePopup(), // Đóng popup khi bấm ra ngoài
            child: Container(
              color: Colors.transparent, // Vùng overlay trong suốt
            ),
          ),
          Positioned(
            left: popupOffsetAndAlignment.popupOffset.dx,
            top: popupOffsetAndAlignment.popupOffset.dy,
            child: FadeTransition(
              opacity: opacityAnimation,
              child: SlideTransition(
                position: slideAnimation,
                child: Column(
                  children: [
                    if (popupOffsetAndAlignment.triangleAlignment ==
                        Alignment.bottomCenter)
                      CustomPaint(
                        size: const Size(20, 20),
                        painter: TrianglePainter(
                          color: Colors.white,
                          alignment: popupOffsetAndAlignment.triangleAlignment,
                        ),
                      ),
                    Row(
                      children: [
                        if (popupOffsetAndAlignment.triangleAlignment ==
                                Alignment.centerRight ||
                            popupOffsetAndAlignment.triangleAlignment ==
                                Alignment.centerLeft)
                          CustomPaint(
                            size: const Size(20, 20),
                            painter: TrianglePainter(
                              color: Colors.white,
                              alignment:
                                  popupOffsetAndAlignment.triangleAlignment,
                            ),
                          ),
                        Material(
                          elevation: 5.0,
                          textStyle: const TextStyle(
                            color: Colors.blue,
                          ),
                          shape: RoundedRectangleBorder(
                              borderRadius: BorderRadius.circular(20)),
                          type: MaterialType.card,
                          child: ProfileTooltipCustom(
                            friend: user,
                            onTapInfo: () {
                              removePopup();
                              Get.to(
                                  UserAboutPage(
                                    unknownableUser: user,
                                  ),
                                  transition: Transition.fadeIn);
                            },
                          ),
                        ),
                      ],
                    ),
                    if (popupOffsetAndAlignment.triangleAlignment ==
                        Alignment.topCenter)
                      CustomPaint(
                        size: const Size(20, 40),
                        painter: TrianglePainter(
                          color: Colors.white,
                          alignment: popupOffsetAndAlignment.triangleAlignment,
                        ),
                      ),
                  ],
                ),
              ),
            ),
          ),
        ],
      ),
    );

    // Hiển thị popup
    Overlay.of(context).insert(_popupEntry.value!);
    animationController.forward();
    isPopupVisible.value = true; // Bật trạng thái popup đang hiển thị

    if (autoDismissDuration != null) {
      Future.delayed(autoDismissDuration, removePopup);
    }
  }

  // Xóa popup
  void removePopup() {
    if (_popupEntry.value != null) {
      animationController.reverse().then((_) {
        // Đảo ngược animation khi xóa
        _popupEntry.value?.remove();
        _popupEntry.value = null;
        isPopupVisible.value = false; // Cập nhật trạng thái popup
      });
    }
  }

  // Tính toán vị trí và alignment của popup và tam giác
  _PopupOffsetAndAlignment _calculatePopupPositionAndAlignment(
    Offset widgetPosition,
    Size widgetSize,
    PopupPosition position, {
    required double width,
    required double height,
  }) {
    Offset popupOffset;
    Alignment triangleAlignment;
    const double padding = 0.0; // Khoảng cách giữa overlay và widget

    switch (position) {
      case PopupPosition.above:
        // Popup nằm trên CircleAvatar
        popupOffset = Offset(
          widgetPosition.dx - (width / 2) + (widgetSize.width / 2),
          widgetPosition.dy - height - padding,
        );
        triangleAlignment = Alignment.topCenter;
        break;
      case PopupPosition.below:
        // Popup nằm dưới CircleAvatar
        popupOffset = Offset(
          widgetPosition.dx - (width / 2) + (widgetSize.width / 2),
          widgetPosition.dy + widgetSize.height + padding,
        );
        triangleAlignment = Alignment.bottomCenter;
        break;
      case PopupPosition.left:
        // Popup nằm bên trái CircleAvatar
        popupOffset = Offset(
          widgetPosition.dx - width - padding,
          widgetPosition.dy - (height / 2) + (widgetSize.height / 2),
        );
        triangleAlignment = Alignment.centerRight;
        break;
      case PopupPosition.right:
        // Popup nằm bên phải CircleAvatar
        popupOffset = Offset(
          widgetPosition.dx + widgetSize.width + padding,
          widgetPosition.dy - (height / 4),
          //   widgetPosition.dy - (height / 2) + (widgetSize.height / 2),
        );
        triangleAlignment = Alignment.centerLeft;
        break;
    }

    return _PopupOffsetAndAlignment(popupOffset, triangleAlignment);
  }

  @override
  void onClose() {
    animationController.dispose();
    removePopup();
    super.onClose();
  }
}

class _PopupOffsetAndAlignment {
  final Offset popupOffset;
  final Alignment triangleAlignment;

  _PopupOffsetAndAlignment(this.popupOffset, this.triangleAlignment);
}

```

---


### Controller\Bindings\check_network_binding.dart

```dart
// import 'package:get/get.dart';
// import 'package:tictactoe_gameapp/Controller/check_network_controller.dart';

// class CheckNetworkBinding extends Bindings {
//   @override
//   void dependencies() {
//     Get.put(CheckNetworkController());
//   }
// }

```

---


### Controller\Console\play_with_bot_controller.dart

```dart
import 'dart:async';
import 'dart:isolate';
import 'dart:math';
import 'package:flutter/material.dart';
import 'package:flutter_animate/flutter_animate.dart';
import 'package:flutter_svg/svg.dart';
import 'package:get/get.dart';
import 'package:tictactoe_gameapp/Components/confetti_widget_custom.dart';
import 'package:tictactoe_gameapp/Configs/assets_path.dart';
import 'package:tictactoe_gameapp/Configs/constants.dart';
import 'package:tictactoe_gameapp/Configs/messages.dart';
import 'package:tictactoe_gameapp/Controller/Animations/countdown_animation_controller.dart';
import 'package:tictactoe_gameapp/Controller/Music/background_music_controller.dart';
import 'package:tictactoe_gameapp/Controller/Music/effective_music_controller.dart';
import 'package:tictactoe_gameapp/Data/fetch_firestore_database.dart';
import 'package:tictactoe_gameapp/Models/minimax_arg.dart';
import 'package:tictactoe_gameapp/Pages/GamePage/Widgets/core/countdown_waiting_widget.dart';

class PlayWithBotController extends GetxController {
  RxList<RxList<String>> board = RxList<RxList<String>>();
  RxList<Offset> winningLineCoordinates = <Offset>[].obs;
  final BackgroundMusicController musicController = Get.find();
  RxBool isXtime = true.obs;
  RxInt xScore = 0.obs;
  RxInt oScore = 0.obs;
  RxString winner = ''.obs;

  RxInt initialSize = 3.obs;
  RxInt winLength = 5.obs;
  int advancedExpand = 2;
  int currentWin = 0;
  int currentCoin = 0;

  final EffectiveMusicController musicPlayController =
      Get.put(EffectiveMusicController());
  final FirestoreController firestoreController =
      Get.put(FirestoreController());

  void initializeBoard() {
    board.value = List.generate(initialSize.value, (_) {
      return List.generate(initialSize.value, (_) => '').obs;
    }).obs;
  }

  void makeMove(String difficulty, int row, int col) async {
    if (board[row][col] == '' && winner.value == '') {
      board[row][col] = isXtime.value ? 'X' : 'O';
      // await musicPlayController.playSoundPlayer1();
      board.refresh();
      if (checkWinner(row, col)) {
        winner.value = isXtime.value ? 'X' : 'O';
        winnerDialog(winner.value);
      } else {
        togglePlayer();
        if (isBoardFull()) {
          advancedExpand++;
          for (int i = 0; i < advancedExpand; i++) {
            expandBoard();
          }
        }
        if (winner.value == '') {
          // await musicPlayController.playSoundPlayer2();
          // await playWithAI();
          await playWithAILevels(difficulty);
        }
      }
    }
  }

  bool isBoardFull() {
    for (var row in board) {
      if (row.contains('')) {
        return false;
      }
    }
    return true;
  }

  void expandBoard() {
    int oldSize = board.length;
    int newSize = oldSize + 2;
    // Add new rows at the top and bottom
    board.insert(0, List.generate(newSize, (_) => '').obs);
    board.add(List.generate(newSize, (_) => '').obs);

    // Update existing rows to add new columns at the start and end
    for (int i = 1; i < board.length - 1; i++) {
      // Skip first and last row
      board[i].insert(0, '');
      board[i].add('');
    }

    // Refresh the board state
    board.refresh();
  }

  void togglePlayer() {
    isXtime.value = !isXtime.value;
  }

  bool checkWinner(int row, int col) {
    String currentPlayer = board[row][col];
    int n = board.length;

    // Kiểm tra hàng ngang
    for (int i = 0; i <= n - winLength.value; i++) {
      if (board[row]
          .sublist(i, i + winLength.value)
          .every((element) => element == currentPlayer)) {
        winningLineCoordinates.value = List.generate(winLength.value,
            (index) => Offset(row.toDouble(), (i + index).toDouble()));
        return true;
      }
    }

    // Kiểm tra hàng dọc
    for (int i = 0; i <= n - winLength.value; i++) {
      if (List.generate(winLength.value, (index) => board[i + index][col])
          .every((element) => element == currentPlayer)) {
        winningLineCoordinates.value = List.generate(winLength.value,
            (index) => Offset((i + index).toDouble(), col.toDouble()));
        return true;
      }
    }

    // Kiểm tra đường chéo chính
    for (int i = 0; i <= n - winLength.value; i++) {
      for (int j = 0; j <= n - winLength.value; j++) {
        if (List.generate(
                winLength.value, (index) => board[i + index][j + index])
            .every((element) => element == currentPlayer)) {
          winningLineCoordinates.value = List.generate(
              winLength.value,
              (index) =>
                  Offset((i + index).toDouble(), (j + index).toDouble()));
          return true;
        }
      }
    }

    // Kiểm tra đường chéo phụ
    for (int i = 0; i <= n - winLength.value; i++) {
      for (int j = winLength.value - 1; j < n; j++) {
        if (List.generate(
                winLength.value, (index) => board[i + index][j - index])
            .every((element) => element == currentPlayer)) {
          winningLineCoordinates.value = List.generate(
              winLength.value,
              (index) =>
                  Offset((i + index).toDouble(), (j - index).toDouble()));
          return true;
        }
      }
    }
    return false;
  }

  Future<void> winnerDialog(String winner) async {
    if (winner == 'X') {
      await musicPlayController.playSoundWinner();
    } else {
      await musicPlayController.playSoundLoser();
    }
    scoreCalculate(winner);
    await Get.defaultDialog(
      barrierDismissible: false,
      title: winner == 'X' ? "VICTORY" : "DEFEAT",
      backgroundColor: Colors.white,
      titleStyle: TextStyle(
        fontWeight: FontWeight.bold,
        color: winner == 'X' ? Colors.deepOrangeAccent : Colors.red,
        fontSize: 30,
      ),
      content: Stack(
        children: [
          Container(
            padding: const EdgeInsets.all(10),
            decoration: BoxDecoration(
              borderRadius: BorderRadius.circular(20),
              border: winner == 'X'
                  ? Border.all(color: Colors.yellow, width: 5)
                  : Border.all(color: Colors.redAccent, width: 5),
            ),
            child: Column(
              children: [
                SvgPicture.asset(
                  IconsPath.wonIcon,
                  width: 100,
                ),
                const SizedBox(height: 20),
                winner == 'X'
                    ? const Text(
                        "Congratulations",
                        style: TextStyle(
                          fontSize: 18,
                          color: Colors.yellow,
                        ),
                      )
                    : const Text(
                        "Defeat",
                        style: TextStyle(
                          fontSize: 20,
                          color: Colors.red,
                        ),
                      ),
                Text(
                  "$winner won the match",
                  style: const TextStyle(
                    fontSize: 15,
                  ),
                ),
                const SizedBox(height: 20),
                Row(
                  mainAxisAlignment: MainAxisAlignment.spaceBetween,
                  children: [
                    ElevatedButton(
                      onPressed: () {
                        resetGame();
                      },
                      child: const Text("Play Again"),
                    ),
                    ElevatedButton(
                      onPressed: () {
                        musicController.stopMusicOnScreen6();
                        Get.offAllNamed("/mainHome");
                      },
                      child: const Text("Exit"),
                    )
                  ],
                )
              ],
            ),
          ),
          winner == 'X'
              ? const Center(
                  child: ConfettiWidgetCustom(),
                )
              : const SizedBox(),
        ],
      ).animate().slide(duration: duration750),
    );
  }

  void resetGame() {
    initializeBoard();
    winner.value = '';
    if (!isXtime.value) {
      isXtime.value = !isXtime.value;
    }

    Get.back();
  }

  void resetGameAI() {
    initializeBoard();
    winner.value = '';
    isXtime.value = !isXtime.value;
    Get.back();
  }

  void scoreCalculate(String winner) {
    if (winner == "X") {
      currentWin += 1;
      currentCoin += 10;
      firestoreController.incrementCoinsAndWins(100);
      xScore.value = xScore.value + 1;
    } else if (winner == "O") {
      oScore.value = oScore.value + 1;
    }
  }

  //Medium difficulty: Default Difficulty
  Future<void> playWithAI() async {
    print("this is playWithAI()");
    // Tìm tất cả các ô trống
    var emptyCells = <List<int>>[];
    for (int row = 0; row < board.length; row++) {
      for (int col = 0; col < board[row].length; col++) {
        if (board[row][col] == '') {
          emptyCells.add([row, col]);
        }
      }
    }

    // Ưu tiên 1: Kiểm tra nếu AI có thể thắng
    for (var cell in emptyCells) {
      int row = cell[0];
      int col = cell[1];
      board[row][col] = isXtime.value ? 'X' : 'O'; // AI thử đi
      if (checkWinner(row, col)) {
        // Nếu AI có thể thắng, thực hiện nước đi này
        board.refresh();
        winner.value = isXtime.value ? 'X' : 'O';
        await winnerDialog(winner.value);
        return;
      } else {
        board[row][col] = ''; // Hoàn tác nếu không phải nước thắng
      }
    }

    // Ưu tiên 2: Ngăn chặn đối thủ nếu họ có thể thắng
    for (var cell in emptyCells) {
      int row = cell[0];
      int col = cell[1];
      board[row][col] = isXtime.value ? 'O' : 'X'; // Giả định đối thủ đi
      if (checkWinner(row, col)) {
        // Nếu đối thủ có thể thắng, ngăn chặn
        board[row][col] = isXtime.value ? 'X' : 'O'; // AI đi để ngăn chặn
        board.refresh();
        togglePlayer(); // Đổi lượt lại cho người chơi
        return;
      } else {
        board[row][col] = ''; // Hoàn tác nếu không phải nước đi ngăn chặn
      }
    }

    // Ưu tiên 3: Chọn ngẫu nhiên ô trống nếu không có nước nào đặc biệt
    if (emptyCells.isNotEmpty) {
      var randomCell = emptyCells[Random().nextInt(emptyCells.length)];
      // await Future.delayed(const Duration(milliseconds: 500));
      board[randomCell[0]][randomCell[1]] = isXtime.value ? 'X' : 'O';
      board.refresh();
      togglePlayer();
    }
  }

  // Hard difficulty: Heuristic approach (can be further refined)
  Map<String, int> memo = {};
  Future<void> playWithAIHeuristic() async {
    var emptyCells = <List<int>>[];

    // Tìm tất cả các ô trống
    for (int row = 0; row < board.length; row++) {
      for (int col = 0; col < board[row].length; col++) {
        if (board[row][col] == '') {
          emptyCells.add([row, col]);
        }
      }
    }

    // Ưu tiên 1: Kiểm tra nếu AI có thể thắng
    for (var cell in emptyCells) {
      int row = cell[0];
      int col = cell[1];
      board[row][col] = isXtime.value ? 'X' : 'O'; // AI thử đi
      if (checkWinner(row, col)) {
        board.refresh();
        winner.value = isXtime.value ? 'X' : 'O';
        await winnerDialog(winner.value);
        return;
      } else {
        board[row][col] = '';
      }
    }

    // Ưu tiên 2: Ngăn chặn đối thủ nếu họ có 2 nước có thể thắng
    for (var cell in emptyCells) {
      int row = cell[0];
      int col = cell[1];
      board[row][col] = isXtime.value ? 'O' : 'X'; // Giả định đối thủ đi
      if (checkTwoInARow(row, col)) {
        board[row][col] = isXtime.value ? 'X' : 'O'; // AI đi để ngăn chặn
        board.refresh();
        togglePlayer();
        return;
      } else {
        board[row][col] = '';
      }
    }

    //! Ưu tiên 3: Ngăn chặn đối thủ nếu họ có thể thắng
    // for (var cell in emptyCells) {
    //   int row = cell[0];
    //   int col = cell[1];
    //   board[row][col] = isXtime.value ? 'O' : 'X'; // Giả định đối thủ đi
    //   if (checkWinner(row, col)) {
    //     board[row][col] = isXtime.value ? 'X' : 'O'; // AI đi để ngăn chặn
    //     board.refresh();
    //     togglePlayer(); // Đổi lượt lại cho người chơi
    //     return;
    //   } else {
    //     board[row][col] = ''; // Hoàn tác nếu không phải nước đi ngăn chặn
    //   }
    // }

    // Tối ưu hóa tìm nước đi bằng Minimax với giới hạn thời gian 1 giây
    var bestMove = await computeBestMoveWithinTimeLimit(emptyCells);

    // Thực hiện nước đi tốt nhất nếu có
    if (bestMove[0] != -1 && bestMove[1] != -1) {
      board[bestMove[0]][bestMove[1]] = isXtime.value ? 'X' : 'O';
      board.refresh();
      togglePlayer();
    }
  }

// Hàm kiểm tra xem có 2 nước có thể thắng không
  bool checkTwoInARow(int lastRow, int lastCol) {
    // Kiểm tra hàng, cột và đường chéo
    return (checkDirection(lastRow, lastCol, 1, 0) || // Kiểm tra hàng
        checkDirection(lastRow, lastCol, 0, 1) || // Kiểm tra cột
        checkDirection(lastRow, lastCol, 1, 1) || // Kiểm tra đường chéo /
        checkDirection(lastRow, lastCol, 1, -1)); // Kiểm tra đường chéo \
  }

  bool checkDirection(int row, int col, int deltaRow, int deltaCol) {
    int count = 0;

    for (int i = -1; i <= 1; i += 2) {
      int r = row;
      int c = col;

      while (true) {
        r += deltaRow * i;
        c += deltaCol * i;

        if (r < 0 ||
            r >= board.length ||
            c < 0 ||
            c >= board[r].length ||
            board[r][c] != (isXtime.value ? 'O' : 'X')) {
          break;
        }
        count++;
      }
    }

    return count >= 2; // Trả về true nếu có 2 nước có thể thắng
  }

// Hàm này sử dụng Timer để đảm bảo tính toán trong vòng 1 giây
  Future<List<int>> computeBestMoveWithinTimeLimit(
      List<List<int>> emptyCells) async {
    List<int> bestMove = [-1, -1];
    int bestScore = -9999;

    // memo.clear();

    Completer<void> completer = Completer<void>();

    Timer timer = Timer(const Duration(seconds: 5), () {
      if (!completer.isCompleted) {
        completer.complete(); // Kết thúc nếu vượt quá 1 giây
      }
    });

    for (var cell in emptyCells) {
      int row = cell[0];
      int col = cell[1];
      board[row][col] = isXtime.value ? 'X' : 'O'; // AI thử đi
      int score = heuristic(
        0,
        true,
        row,
        col,
        DateTime.now(),
        -9999,
        9999,
      ); // Gọi minimax để tính điểm
      print("isMaximizing --> memo : $memo , bestScore : $score");
      board[row][col] = ''; // Hoàn tác nước đi

      if (score > bestScore) {
        bestScore = score;
        bestMove = [row, col]; // Lưu lại nước đi tốt nhất
      }

      if (completer.isCompleted) break; // Kiểm tra nếu timer đã hết
    }

    timer.cancel(); // Hủy timer nếu chưa hết giờ
    return bestMove;
  }

  int heuristic(int depth, bool isMaximizing, int lastRow, int lastCol,
      DateTime startTime, int alpha, int beta) {
    if (DateTime.now().difference(startTime).inMilliseconds > 1000) {
      return 0; // Trả về điểm trung lập nếu vượt quá 1 giây
    }

    String boardState = boardToString();
    if (memo.containsKey(boardState)) {
      return memo[boardState]!;
    }

    if (checkWinner(lastRow, lastCol)) {
      return isMaximizing ? 10 - depth : depth - 10;
    }
    if (isBoardFull()) {
      return 0; // Trả về 0 nếu hòa
    }

    if (isMaximizing) {
      int bestScore = -9999;
      for (int row = 0; row < board.length; row++) {
        for (int col = 0; col < board[row].length; col++) {
          if (board[row][col] == '') {
            board[row][col] = 'X'; // AI thử đi
            int score = heuristic(depth + 1, false, row, col, startTime, alpha,
                beta); // Đệ quy minimax
            board[row][col] = ''; // Hoàn tác nước đi
            bestScore = max(score, bestScore);
            alpha = max(alpha, score); // Cập nhật giá trị alpha
            if (beta <= alpha) {
              break; // Cắt tỉa nhánh này
            }
          }
        }
      }
      memo[boardState] = bestScore;
      return bestScore;
    } else {
      int bestScore = 9999;
      for (int row = 0; row < board.length; row++) {
        for (int col = 0; col < board[row].length; col++) {
          if (board[row][col] == '') {
            board[row][col] = 'O'; // Người chơi thử đi
            int score = heuristic(depth + 1, true, row, col, startTime, alpha,
                beta); // Đệ quy minimax
            board[row][col] = ''; // Hoàn tác nước đi
            bestScore = min(score, bestScore);
            beta = min(beta, score); // Cập nhật giá trị beta
            if (beta <= alpha) {
              break; // Cắt tỉa nhánh này
            }
          }
        }
      }
      memo[boardState] = bestScore;
      return bestScore;
    }
  }

// Chuyển trạng thái bàn cờ thành chuỗi để làm khóa cho memoization
  String boardToString() {
    return board.map((row) => row.join()).join();
  }

  // Easy difficulty: Random moves
  Future<void> playWithAIRandom() async {
    print("this is playWithAIRandom");
    var emptyCells = <List<int>>[];
    for (int row = 0; row < board.length; row++) {
      for (int col = 0; col < board[row].length; col++) {
        if (board[row][col] == '') {
          emptyCells.add([row, col]);
        }
      }
    }
    // Ưu tiên 1: Kiểm tra nếu AI có thể thắng
    for (var cell in emptyCells) {
      int row = cell[0];
      int col = cell[1];
      board[row][col] = isXtime.value ? 'X' : 'O'; // AI thử đi
      if (checkWinner(row, col)) {
        // Nếu AI có thể thắng, thực hiện nước đi này
        board.refresh();
        winner.value = isXtime.value ? 'X' : 'O';
        await winnerDialog(winner.value);
        return;
      } else {
        board[row][col] = ''; // Hoàn tác nếu không phải nước thắng
      }
    }
    // Ưu tiên 2: Chọn ngẫu nhiên ô trống nếu không có nước nào đặc biệt
    if (emptyCells.isNotEmpty) {
      var randomCell = emptyCells[Random().nextInt(emptyCells.length)];
      // await Future.delayed(const Duration(milliseconds: 500));
      board[randomCell[0]][randomCell[1]] = isXtime.value ? 'X' : 'O';
      board.refresh();
      togglePlayer();
    }
  }

  // Very hard difficulty: Minimax algorithm
  Rx<Offset> bestMove = const Offset(-1, -1).obs;

  // Hàm Minimax chạy trong Isolate
  Future<void> playWithAIMinimaximus() async {
    ReceivePort receivePort = ReceivePort();
    await Isolate.spawn(_minimaxIsolate, receivePort.sendPort);

    SendPort isolateSendPort = await receivePort.first;
    ReceivePort responsePort = ReceivePort();

    MinimaxArguments args = MinimaxArguments(
      board: board,
      currentPlayer: isXtime.value ? 'X' : 'O',
      depth: 0,
      alpha: -1000,
      beta: 1000,
      winLength: winLength.value,
    );

    isolateSendPort.send([args, responsePort.sendPort]);

    // Đặt giới hạn thời gian 1 giây
    Future.delayed(const Duration(seconds: 1), () {
      responsePort.close();
      receivePort.close();
    });
    try {
      // Nhận kết quả từ isolate và cập nhật bestMove
      var result = await responsePort.first;
      Offset bestMove = result; // Kết quả từ Minimax

      // Thực hiện nước đi tốt nhất
      if (bestMove.dx != -1 && bestMove.dy != -1) {
        int row = bestMove.dx.toInt();
        int col = bestMove.dy.toInt();
        board[row][col] =
            isXtime.value ? 'X' : 'O'; // Cập nhật trạng thái bàn cờ
        board.refresh();
        // togglePlayer();
        int winnerScore = checkWinnerState(board, winLength.value);
        if (winnerScore != 0) {
          winner.value = isXtime.value ? 'X' : 'O';
          winnerDialog(winner.value);
        } else {
          togglePlayer();
          if (isBoardFull()) {
            expandBoard();
          }
        }
      }

      // Đóng các cổng sau khi hoàn tất
      responsePort.close();
      receivePort.close();
    } catch (e) {
      errorMessage("$e");
    }
  }

  // Hàm xử lý Minimax trong Isolate
  static void _minimaxIsolate(SendPort sendPort) async {
    ReceivePort isolateReceivePort = ReceivePort();
    sendPort.send(isolateReceivePort.sendPort);

    await for (var message in isolateReceivePort) {
      List<dynamic> arguments = message as List<dynamic>;
      MinimaxArguments args = arguments[0];
      SendPort replyPort = arguments[1];

      // Gọi hàm minimax xử lý
      Offset bestMove = minimax(
        args.board,
        args.currentPlayer,
        args.depth,
        args.alpha,
        args.beta,
        args.winLength,
      );

      replyPort.send(bestMove);
    }
  }

  // Hàm Minimax với Alpha-Beta Pruning
  static Offset minimax(
    List<List<String>> board,
    String currentPlayer,
    int depth,
    int alpha,
    int beta,
    int winLength,
  ) {
    // Hàm kiểm tra xem trò chơi đã kết thúc hay chưa
    bool isGameOver(List<List<String>> board, int winLength) {
      return checkWinnerState(board, winLength) != 0;
    }

// Trong hàm Minimax
    if (isGameOver(board, winLength) || depth >= 4) {
      return const Offset(
          -1, -1); // Trả về move không hợp lệ nếu tìm thấy kết quả
    }

    int bestScore = (currentPlayer == 'X') ? -1000 : 1000;
    Offset bestMove = const Offset(-1, -1);

    // Duyệt qua tất cả các ô trống
    for (int row = 0; row < board.length; row++) {
      for (int col = 0; col < board[row].length; col++) {
        if (board[row][col] == '') {
          board[row][col] = currentPlayer; // Giả lập nước đi

          // Đệ quy gọi minimax
          int score = minimax(
            board,
            currentPlayer == 'X' ? 'O' : 'X',
            depth + 1,
            alpha,
            beta,
            winLength,
          ).dx.toInt();

          board[row][col] = ''; // Undo move

          // Cập nhật alpha-beta pruning
          if (currentPlayer == 'X') {
            if (score > bestScore) {
              bestScore = score;
              bestMove = Offset(row.toDouble(), col.toDouble());
              alpha = bestScore;
            }
          } else {
            if (score < bestScore) {
              bestScore = score;
              bestMove = Offset(row.toDouble(), col.toDouble());
              beta = bestScore;
            }
          }

          // Nếu alpha >= beta, cắt tỉa
          if (alpha >= beta) {
            return bestMove;
          }
        }
      }
    }

    return bestMove;
  }

  static int checkWinnerState(List<List<String>> board, int winLength) {
    int n = board.length;

    // Kiểm tra từng ô trên bảng
    for (int row = 0; row < n; row++) {
      for (int col = 0; col < n; col++) {
        String currentPlayer = board[row][col];

        // Bỏ qua ô trống
        if (currentPlayer == '') continue;

        // Kiểm tra hàng ngang
        if (col + winLength <= n) {
          if (List.generate(winLength, (index) => board[row][col + index])
              .every((element) => element == currentPlayer)) {
            return currentPlayer == 'X'
                ? 10
                : -10; // X thắng trả về +10, O thắng trả về -10
          }
        }

        // Kiểm tra hàng dọc
        if (row + winLength <= n) {
          if (List.generate(winLength, (index) => board[row + index][col])
              .every((element) => element == currentPlayer)) {
            return currentPlayer == 'X' ? 10 : -10;
          }
        }

        // Kiểm tra đường chéo chính (top-left đến bottom-right)
        if (row + winLength <= n && col + winLength <= n) {
          if (List.generate(
                  winLength, (index) => board[row + index][col + index])
              .every((element) => element == currentPlayer)) {
            return currentPlayer == 'X' ? 10 : -10;
          }
        }

        // Kiểm tra đường chéo phụ (top-right đến bottom-left)
        if (row + winLength <= n && col - winLength >= -1) {
          if (List.generate(
                  winLength, (index) => board[row + index][col - index])
              .every((element) => element == currentPlayer)) {
            return currentPlayer == 'X' ? 10 : -10;
          }
        }
      }
    }
    return 0;
  }

  Future<void> playWithAILevels(String difficulty) async {
    switch (difficulty) {
      case 'Easy':
        await playWithAIRandom();
        break;
      case 'Medium':
        await playWithAI();
        break;
      case 'Hard':
        await playWithAIHeuristic();
        break;
      case 'Extreme':
        await playWithAIMinimaximus();
        break;
      default:
        await playWithAI();
    }
  }

  var isImagePicked = false.obs;
  var selectedImagePath = "".obs;
  var selectedImageX = "".obs;
  var selectedImageXHeroIndex = (-1).obs;
  var selectedImageO = "".obs;
  var selectedDifficultyText = "".obs;
  var selectedImageOHeroIndex = (-1).obs;
  var selectedImageIndex = (-1).obs;
  var selectedModeIndex = (-1).obs;
  var selectedDifficultyIndex = (-1).obs;

  final List<String> imagePaths = [
    ImagePath.map1,
    ImagePath.map2,
    ImagePath.map4,
    ImagePath.map5,
    ImagePath.map6,
    ImagePath.map7,
    ImagePath.map8,
    ImagePath.map9,
    ImagePath.map10,
  ];
  List<String> modeImages = [
    ImagePath.board_3x3,
    ImagePath.board_6x6,
    ImagePath.board_9x9,
    ImagePath.board_11x11,
    ImagePath.board_11x11,
  ];
  List<String> modeTexts = ['3 x 3', '6 x 6', '9 x 9', '11 x 11', '15 x 15'];
  List<int> initialMode = [3, 6, 9, 11, 15];
  List<int> winLengthMode = [3, 5, 7, 9, 10];
  List<String> difficultyTexts = ['Easy', 'Medium', 'Hard', 'Extreme'];

  void selectImage(String path, int index) {
    selectedImagePath.value = path;
    selectedImageIndex.value = index;
  }

  void selectMode(int initial, int winL, int index) {
    initialSize.value = initial;
    winLength.value = winL;
    selectedModeIndex.value = index;
  }

  void selectForX(String X, int index) {
    selectedImageX.value = X;
    selectedImageXHeroIndex.value = index;
  }

  void selectForO(String O, int index) {
    selectedImageO.value = O;
    selectedImageOHeroIndex.value = index;
  }

  void selectDifficulty(String difficulty, int index) {
    selectedDifficultyText.value = difficulty;
    selectedDifficultyIndex.value = index;
  }

  void showMapPicker() {
    final CountdownController countdownController =
        Get.put(CountdownController());
    final BackgroundMusicController musicController = Get.find();
    WidgetsBinding.instance.addPostFrameCallback((_) {
      musicController.playMusicOnScreen5();
    });
    Get.dialog(
      barrierDismissible: false,
      Dialog(
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(20),
        ),
        child: Stack(
          clipBehavior: Clip.none,
          children: [
            Container(
              height: 500,
              padding: const EdgeInsets.all(10),
              child: Scrollbar(
                child: CustomScrollView(
                  slivers: [
                    const SliverToBoxAdapter(
                      child: SizedBox(
                        height: 100,
                      ),
                    ),
                    const SliverToBoxAdapter(
                      child: Column(
                        children: [
                          Padding(
                            padding: EdgeInsets.all(8.0),
                            child: Text(
                              'Pick a Map',
                              style: TextStyle(
                                  fontSize: 18, fontWeight: FontWeight.bold),
                            ),
                          ),
                          Divider(),
                        ],
                      ),
                    ),
                    SliverToBoxAdapter(
                      child: SingleChildScrollView(
                        scrollDirection: Axis.horizontal,
                        child: Row(
                          children: List.generate(imagePaths.length, (index) {
                            return GestureDetector(
                              onTap: () {
                                selectImage(imagePaths[index], index);
                              },
                              child: Obx(() {
                                return Container(
                                  margin: const EdgeInsets.symmetric(
                                      horizontal: 10),
                                  decoration: BoxDecoration(
                                    border: Border.all(
                                      color: selectedImageIndex.value == index
                                          ? Colors.blue
                                          : Colors.transparent,
                                      width: 5,
                                    ),
                                  ),
                                  child: Image.asset(
                                    imagePaths[index],
                                    width: 100,
                                    height: 100,
                                    fit: BoxFit.cover,
                                  ),
                                );
                              }),
                            );
                          }),
                        ),
                      ),
                    ),

                    // Phần chọn chế độ
                    const SliverToBoxAdapter(
                      child: Column(
                        children: [
                          Padding(
                            padding: EdgeInsets.all(8.0),
                            child: Text(
                              'Pick a Mode',
                              style: TextStyle(
                                  fontSize: 18, fontWeight: FontWeight.bold),
                            ),
                          ),
                          Divider(),
                        ],
                      ),
                    ),
                    SliverToBoxAdapter(
                      child: SingleChildScrollView(
                        scrollDirection: Axis.horizontal,
                        child: Row(
                          children: List.generate(modeTexts.length, (index) {
                            return GestureDetector(
                              onTap: () {
                                selectMode(initialMode[index],
                                    winLengthMode[index], index);
                              },
                              child: Obx(() {
                                return Column(
                                  children: [
                                    Container(
                                      margin: const EdgeInsets.all(10),
                                      decoration: BoxDecoration(
                                        border: Border.all(
                                          color:
                                              selectedModeIndex.value == index
                                                  ? Colors.blue
                                                  : Colors.transparent,
                                          width: 5,
                                        ),
                                      ),
                                      child: Image.asset(
                                        modeImages[index],
                                        width: 100,
                                        height: 100,
                                        fit: BoxFit.cover,
                                      ),
                                    ),
                                    Container(
                                      margin: const EdgeInsets.symmetric(
                                          horizontal: 10),
                                      padding: const EdgeInsets.all(8.0),
                                      decoration: BoxDecoration(
                                        color: selectedModeIndex.value == index
                                            ? Colors.blue
                                            : Colors.grey[300],
                                        borderRadius: BorderRadius.circular(10),
                                      ),
                                      child: Text(
                                        modeTexts[index],
                                        style: const TextStyle(fontSize: 16),
                                      ),
                                    ),
                                  ],
                                );
                              }),
                            );
                          }),
                        ),
                      ),
                    ),
                    const SliverToBoxAdapter(
                      child: Column(
                        children: [
                          Padding(
                            padding: EdgeInsets.all(8.0),
                            child: Text(
                              'Pick a hero for you',
                              style: TextStyle(
                                  fontSize: 18, fontWeight: FontWeight.bold),
                            ),
                          ),
                          Divider(),
                        ],
                      ),
                    ),
                    SliverToBoxAdapter(
                      child: SizedBox(
                        height: 400,
                        child: GridView.builder(
                          scrollDirection: Axis.vertical,
                          physics: const BouncingScrollPhysics(),
                          gridDelegate:
                              const SliverGridDelegateWithFixedCrossAxisCount(
                            crossAxisCount: 4,
                            mainAxisSpacing: 10,
                            crossAxisSpacing: 10,
                          ),
                          itemCount: listChamA.length,
                          itemBuilder: (context, index) {
                            return GestureDetector(
                              onTap: () {
                                selectForX(listChamA[index], index);
                              },
                              child: Obx(() {
                                return Container(
                                  decoration: BoxDecoration(
                                    border: Border.all(
                                      color:
                                          selectedImageXHeroIndex.value == index
                                              ? Colors.blue
                                              : Colors.transparent,
                                      width: 5,
                                    ),
                                  ),
                                  child: Image.asset(
                                    listChamA[index],
                                    fit: BoxFit.cover,
                                    width: 100,
                                    height: 100,
                                  ),
                                );
                              }),
                            );
                          },
                        ),
                      ),
                    ),

                    const SliverToBoxAdapter(
                      child: Column(
                        children: [
                          Padding(
                            padding: EdgeInsets.all(8.0),
                            child: Text(
                              'Pick a hero for Bot',
                              style: TextStyle(
                                  fontSize: 18, fontWeight: FontWeight.bold),
                            ),
                          ),
                          Divider(),
                        ],
                      ),
                    ),
                    SliverToBoxAdapter(
                      child: SizedBox(
                        height: 400,
                        child: GridView.builder(
                          scrollDirection: Axis.vertical,
                          physics: const BouncingScrollPhysics(),
                          gridDelegate:
                              const SliverGridDelegateWithFixedCrossAxisCount(
                            crossAxisCount: 4,
                            mainAxisSpacing: 10,
                          ),
                          itemCount: listChamB.length,
                          itemBuilder: (context, index) {
                            return GestureDetector(
                              onTap: () {
                                selectForO(listChamB[index], index);
                              },
                              child: Obx(() {
                                return Container(
                                  decoration: BoxDecoration(
                                    border: Border.all(
                                      color:
                                          selectedImageOHeroIndex.value == index
                                              ? Colors.blue
                                              : Colors.transparent,
                                      width: 5,
                                    ),
                                  ),
                                  child: Image.asset(
                                    listChamB[index],
                                    fit: BoxFit.cover,
                                    width: 100,
                                    height: 100,
                                  ),
                                );
                              }),
                            );
                          },
                        ),
                      ),
                    ),

                    // Phần chọn độ khó
                    const SliverToBoxAdapter(
                      child: Column(
                        children: [
                          Padding(
                            padding: EdgeInsets.all(8.0),
                            child: Text(
                              'Pick a Level',
                              style: TextStyle(
                                  fontSize: 18, fontWeight: FontWeight.bold),
                            ),
                          ),
                          Divider(),
                        ],
                      ),
                    ),
                    SliverToBoxAdapter(
                      child: CircleAvatar(
                        radius: 50,
                        child: Image.asset(
                          GifsPath.androidGif,
                        ),
                      ),
                    ),
                    SliverToBoxAdapter(
                      child: SingleChildScrollView(
                        scrollDirection: Axis.horizontal,
                        child: Row(
                          children:
                              List.generate(difficultyTexts.length, (index) {
                            return GestureDetector(
                              onTap: () {
                                selectDifficulty(difficultyTexts[index], index);
                              },
                              child: Obx(() {
                                return Container(
                                  alignment: Alignment.center,
                                  margin: const EdgeInsets.all(10),
                                  padding: const EdgeInsets.all(15),
                                  decoration: BoxDecoration(
                                    color:
                                        selectedDifficultyIndex.value == index
                                            ? index == 0
                                                ? Colors.green
                                                : index == 1
                                                    ? Colors.yellow
                                                    : index == 2
                                                        ? Colors.orange
                                                        : index == 3
                                                            ? Colors.red
                                                            : Colors.grey[300]
                                            : Colors.grey[300],
                                    borderRadius: BorderRadius.circular(10),
                                  ),
                                  child: Text(
                                    difficultyTexts[index].toUpperCase(),
                                    style: const TextStyle(
                                        fontSize: 16,
                                        fontWeight: FontWeight.bold),
                                  ),
                                );
                              }),
                            );
                          }),
                        ),
                      ),
                    ),
                  ],
                ),
              ),
            ),
            Positioned(
              top: -50,
              right: -10,
              left: -10,
              child: Container(
                decoration: BoxDecoration(
                  color: Colors.lightBlueAccent,
                  borderRadius: BorderRadius.circular(20),
                  boxShadow: const [
                    BoxShadow(
                      color: Colors.blueAccent,
                      offset: Offset(0, 5),
                      spreadRadius: 3.0,
                    )
                  ],
                ),
                child: Row(
                  mainAxisAlignment: MainAxisAlignment.spaceBetween,
                  children: [
                    Row(
                      children: [
                        IconButton(
                          onPressed: () {
                            countdownController.stopAnimation();
                            Get.offAllNamed("/mainHome");
                          },
                          icon: const Icon(Icons.arrow_back_ios),
                        ),
                        const Text("Back"),
                      ],
                    ),
                    const CountdownWaitingWidget(),
                    Row(
                      children: [
                        const Text("Play"),
                        IconButton(
                          onPressed: () {
                            if (selectedImageIndex.value == -1) {
                              errorMessage("Please select a map.");
                            } else if (selectedModeIndex.value == -1) {
                              errorMessage("Please select a mode.");
                            } else if (selectedDifficultyIndex.value == -1) {
                              errorMessage("Please select a level.");
                            } else if (selectedImageXHeroIndex.value == -1) {
                              errorMessage(
                                  "Please select a hero for yourself.");
                            } else if (selectedImageOHeroIndex.value == -1) {
                              errorMessage("Please select a hero for bot.");
                            } else {
                              countdownController.stopAnimation();
                              initializeBoard();
                              Get.toNamed("/singlePlayer");
                            }
                          },
                          icon: const Icon(
                              Icons.keyboard_double_arrow_right_outlined),
                        ),
                      ],
                    ),
                  ],
                ),
              ),
            ),
          ],
        ),
      ).animate().scale(),
    );
  }
}

```

---


### Controller\Console\play_with_player_controller.dart

```dart
import 'dart:async';
import 'dart:math';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:flutter/material.dart';
import 'package:flutter_svg/svg.dart';
import 'package:get/get.dart';
import 'package:tictactoe_gameapp/Configs/assets_path.dart';
import 'package:tictactoe_gameapp/Configs/constants.dart';
import 'package:tictactoe_gameapp/Configs/messages.dart';
import 'package:tictactoe_gameapp/Controller/Animations/countdown_animation_controller.dart';
import 'package:tictactoe_gameapp/Controller/Music/background_music_controller.dart';
import 'package:tictactoe_gameapp/Controller/Music/effective_music_controller.dart';
import 'package:tictactoe_gameapp/Controller/auth_controller.dart';
import 'package:tictactoe_gameapp/Models/room_model.dart';
import 'package:tictactoe_gameapp/Pages/GamePage/Widgets/core/countdown_waiting_widget.dart';

class PlayWithPlayerController extends GetxController {
  RxList<RxList<String>> board = RxList<RxList<String>>();
  RxList<Offset> winningLineCoordinates = <Offset>[].obs;
  RxBool isXtime = true.obs;
  RxString winner = ''.obs;
  var roomModel = Rx<RoomModel?>(null);
  RxInt initialSize = 3.obs;
  RxInt winLength = 5.obs;

  int advancedExpand = 2;
  int currentWin = 0;
  int currentCoin = 0;
  StreamSubscription<DocumentSnapshot>? roomSubscription;
  late int? currentCoinPlayer1;
  late int? winningPrize;
  late int? currentCoinPlayer2;
  late int? currentWinPlayer1;
  late int? currentWinPlayer2;

  final db = FirebaseFirestore.instance;
  final String currentUserEmail =
      Get.find<AuthController>().getCurrentUserEmail();
  final EffectiveMusicController musicPlayController =
      Get.put(EffectiveMusicController());
  final BackgroundMusicController musicController = Get.find();

  void getRoomDetails(String roomId) async {
    try {
      // Lấy dữ liệu ban đầu với get()
      DocumentSnapshot initialSnapshot =
          await db.collection("rooms").doc(roomId).get();
      roomModel.value =
          RoomModel.fromJson(initialSnapshot.data()! as Map<String, dynamic>);

      initialSize.value = roomModel.value!.initialMode!;
      winLength.value = roomModel.value!.winLengthMode!;

      board.value = List.generate(initialSize.value, (_) {
        return List.generate(initialSize.value, (_) => '').obs;
      }).obs;

      await db.collection("rooms").doc(roomId).update({
        "gameValue": board.expand((row) => row).toList(),
      });

      winningPrize = int.tryParse(roomModel.value!.winningPrize!);
      currentCoinPlayer1 =
          int.tryParse(roomModel.value!.player1!.totalCoins ?? "0");
      currentWinPlayer1 =
          int.tryParse(roomModel.value!.player1!.totalWins ?? "0");
      currentCoinPlayer2 =
          int.tryParse(roomModel.value!.player2!.totalCoins ?? "0");
      currentWinPlayer2 =
          int.tryParse(roomModel.value!.player2!.totalWins ?? "0");

      roomSubscription =
          db.collection("rooms").doc(roomId).snapshots().listen((event) async {
        RoomModel updatedRoomModel = RoomModel.fromJson(event.data()!);

        // Kiểm tra nếu gameValue có sự thay đổi
        if (updatedRoomModel.gameValue != roomModel.value!.gameValue) {
          roomModel.value = updatedRoomModel;
          isXtime.value = roomModel.value!.isXturn!;
          winner.value = roomModel.value!.winnerVariable!;

          // Cập nhật lại board từ gameValue mới
          List<String> updatedGameValue = roomModel.value!.gameValue ?? [];
          initialSize.value = sqrt(updatedGameValue.length).toInt();

          board.value = List.generate(initialSize.value, (rowIndex) {
            return RxList<String>.from(
              updatedGameValue.sublist(
                rowIndex * initialSize.value,
                (rowIndex + 1) * initialSize.value,
              ),
            );
          }).obs;
          // board.value = List.generate(
          //   sqrt(updatedGameValue.length)
          //       .toInt(), // Tạo bảng có kích thước dựa trên độ dài của gameValue
          //   (rowIndex) {
          //     return RxList<String>.from(
          //       updatedGameValue.sublist(
          //         rowIndex * sqrt(updatedGameValue.length).toInt(),
          //         (rowIndex + 1) * sqrt(updatedGameValue.length).toInt(),
          //       ),
          //     );
          //   },
          // ).obs;
          // board.refresh();
        }
        // if (updatedRoomModel.isXturn!) {
        //   await musicPlayController.playSoundPlayer1();
        // } else {
        //   await musicPlayController.playSoundPlayer2();
        // }
        // if (updatedRoomModel.player1 != null || updatedRoomModel.player2 != null) {
        //   if (updatedRoomModel.player1!.quickMess != null ||
        //       updatedRoomModel.player2!.quickMess != null) {
        //     removeMessage(updatedRoomModel);
        //   }
        // }
        // if (updatedRoomModel.player1 != null || updatedRoomModel.player2 != null) {
        //   if (updatedRoomModel.player1!.quickEmote != null ||
        //       updatedRoomModel.player2!.quickEmote != null) {
        //     removeEmote(updatedRoomModel);
        //   }
        // }
      }, onError: (error) {
        errorMessage("Error fetching room details: $error");
      });
    } catch (e) {
      errorMessage("Error fetching room details: $e");
    }
  }

  Future<void> updateData(
    RoomModel roomData,
    int row,
    int col,
  ) async {
    if (board[row][col] == '' && winner.value == '') {
      board[row][col] = isXtime.value ? 'X' : 'O';
      await db.collection("rooms").doc(roomData.id!).update({
        "gameValue": board.expand((row) => row).toList(),
        "isXturn": !isXtime.value,
      });
      board.refresh();
      if (checkWinner(row, col)) {
        winner.value = !isXtime.value ? 'X' : 'O';
        await db.collection("rooms").doc(roomData.id!).update({
          "winnerVariable": winner.value,
        });
      } else {
        if (isBoardFull()) {
          advancedExpand++;
          for (int i = 0; i < advancedExpand; i++) {
            await expandBoard(roomData);
          }
        }
      }
    }
  }

  bool isBoardFull() {
    for (var row in board) {
      if (row.contains('')) {
        return false;
      }
    }
    return true;
  }

  Future<void> expandBoard(RoomModel roomData) async {
    int oldSize = board.length;
    int newSize = oldSize + 2;
    // Add new rows at the top and bottom
    board.insert(0, List.generate(newSize, (_) => '').obs);
    board.add(List.generate(newSize, (_) => '').obs);

    // Update existing rows to add new columns at the start and end
    for (int i = 1; i < board.length - 1; i++) {
      // Skip first and last row
      board[i].insert(0, '');
      board[i].add('');
    }

    await db.collection("rooms").doc(roomData.id!).update({
      "gameValue": board.expand((row) => row).toList(),
    });

    board.refresh();
  }

  bool checkWinner(int row, int col) {
    String currentPlayer = board[row][col];
    int n = board.length;

    // Kiểm tra hàng ngang
    for (int i = 0; i <= n - winLength.value; i++) {
      if (board[row]
          .sublist(i, i + winLength.value)
          .every((element) => element == currentPlayer)) {
        winningLineCoordinates.value = List.generate(winLength.value,
            (index) => Offset(row.toDouble(), (i + index).toDouble()));
        return true;
      }
    }

    // Kiểm tra hàng dọc
    for (int i = 0; i <= n - winLength.value; i++) {
      if (List.generate(winLength.value, (index) => board[i + index][col])
          .every((element) => element == currentPlayer)) {
        winningLineCoordinates.value = List.generate(winLength.value,
            (index) => Offset((i + index).toDouble(), col.toDouble()));
        return true;
      }
    }

    // Kiểm tra đường chéo chính
    for (int i = 0; i <= n - winLength.value; i++) {
      for (int j = 0; j <= n - winLength.value; j++) {
        if (List.generate(
                winLength.value, (index) => board[i + index][j + index])
            .every((element) => element == currentPlayer)) {
          winningLineCoordinates.value = List.generate(
              winLength.value,
              (index) =>
                  Offset((i + index).toDouble(), (j + index).toDouble()));
          return true;
        }
      }
    }

    // Kiểm tra đường chéo phụ
    for (int i = 0; i <= n - winLength.value; i++) {
      for (int j = winLength.value - 1; j < n; j++) {
        if (List.generate(
                winLength.value, (index) => board[i + index][j - index])
            .every((element) => element == currentPlayer)) {
          winningLineCoordinates.value = List.generate(
              winLength.value,
              (index) =>
                  Offset((i + index).toDouble(), (j - index).toDouble()));
          return true;
        }
      }
    }
    return false;
  }

  void winnerDialog(String winner, RoomModel roomData) {
    // musicPlayController.playSoundWinner();
    Get.defaultDialog(
      barrierDismissible: false,
      title: "VICTORY",
      backgroundColor: Colors.white,
      titleStyle: const TextStyle(
        fontWeight: FontWeight.bold,
        color: Colors.blue,
        fontSize: 30,
      ),
      content: Stack(
        children: [
          Container(
            padding: const EdgeInsets.all(10),
            decoration: BoxDecoration(
              borderRadius: BorderRadius.circular(20),
              border: Border.all(color: Colors.blueAccent, width: 5),
            ),
            child: Column(
              children: [
                SvgPicture.asset(
                  IconsPath.wonIcon,
                  width: 100,
                ),
                const SizedBox(height: 20),
                const Text(
                  "Congratulations",
                  style: TextStyle(
                    fontSize: 18,
                    color: Colors.blueAccent,
                  ),
                ),
                const Text(
                  "You won the match",
                  style: TextStyle(
                    fontSize: 15,
                  ),
                ),
                const SizedBox(height: 20),
                Row(
                  mainAxisAlignment: MainAxisAlignment.spaceBetween,
                  children: [
                    ElevatedButton(
                      onPressed: () async {
                        await Get.showOverlay(
                          asyncFunction: () async {
                            await scoreCalculateWinner(
                                winner: winner, roomData: roomData);
                            await resetPlayValue(roomData.id!);
                          },
                          loadingWidget: Container(
                            width: double.infinity,
                            height: double.infinity,
                            decoration: const BoxDecoration(
                              image: DecorationImage(
                                image: AssetImage(
                                  GifsPath.transitionGif,
                                ),
                                fit: BoxFit.cover,
                              ),
                            ),
                          ),
                        ).then((_) => Get.back());
                      },
                      child: const Text("Play Again"),
                    ),
                    ElevatedButton(
                      onPressed: () async {
                        await scoreCalculateWinner(
                            winner: winner, roomData: roomData);
                        await deleteRoom(roomData.id!);
                        Get.offAllNamed("/mainHome");
                      },
                      child: const Text("Exit"),
                    )
                  ],
                )
              ],
            ),
          ),
          // const Center(
          //   child: ConfettiWidgetCustom(),
          // )
        ],
      ),
    );
  }

  void defeatDialog(String winner, RoomModel roomData) {
    // musicPlayController.playSoundLoser();
    Get.defaultDialog(
      barrierDismissible: false,
      title: "DEFEAT",
      backgroundColor: Colors.white,
      titleStyle: const TextStyle(
        fontWeight: FontWeight.bold,
        color: Colors.red,
        fontSize: 30,
      ),
      content: Stack(
        children: [
          Container(
            padding: const EdgeInsets.all(10),
            decoration: BoxDecoration(
              borderRadius: BorderRadius.circular(20),
              border: Border.all(color: Colors.redAccent, width: 5),
            ),
            child: Column(
              children: [
                SvgPicture.asset(
                  IconsPath.wonIcon,
                  width: 100,
                ),
                const SizedBox(height: 20),
                const Text(
                  "Defeat",
                  style: TextStyle(
                    fontSize: 20,
                    color: Colors.red,
                  ),
                ),
                const Text(
                  "Enemy won the match",
                  style: TextStyle(
                    fontSize: 15,
                  ),
                ),
                const SizedBox(height: 20),
                Row(
                  mainAxisAlignment: MainAxisAlignment.spaceBetween,
                  children: [
                    ElevatedButton(
                      onPressed: () async {
                        await Get.showOverlay(
                          asyncFunction: () async {
                            await scoreCalculateLoser(
                                winner: winner, roomData: roomData);
                            await resetPlayValue(roomData.id!);
                          },
                          loadingWidget: Container(
                            width: double.infinity,
                            height: double.infinity,
                            decoration: const BoxDecoration(
                              image: DecorationImage(
                                image: AssetImage(
                                  GifsPath.transitionGif,
                                ),
                                fit: BoxFit.cover,
                              ),
                            ),
                          ),
                        ).then((_) => Get.back());
                        // Get.until((route) => route.isFirst);
                      },
                      child: const Text("Play Again"),
                    ),
                    ElevatedButton(
                      onPressed: () async {
                        await scoreCalculateLoser(
                            winner: winner, roomData: roomData);
                        await deleteRoom(roomData.id!);
                        Get.offAllNamed("/mainHome");
                      },
                      child: const Text("Exit"),
                    )
                  ],
                )
              ],
            ),
          ),
        ],
      ),
    );
  }

  Future<void> initializeBoard(String roomId) async {
    initialSize.value = roomModel.value!.initialMode!;
    final List<String> emptyBoard =
        List.filled(initialSize.value * initialSize.value, '');

    await db.collection("rooms").doc(roomId).update({
      "gameValue": emptyBoard, // Reset game values to empty
      "winnerVariable": '', // Reset winner
    });

    // Update local board state
    board.value = List.generate(initialSize.value, (rowIndex) {
      return RxList<String>.from(emptyBoard.sublist(
          rowIndex * initialSize.value, (rowIndex + 1) * initialSize.value));
    }).obs;
  }

  Future<void> resetPlayValue(String roomId) async {
    await initializeBoard(roomId);
    roomModel.update((room) {
      room!.gameValue = List.filled(initialSize.value * initialSize.value, '');
      room.winnerVariable = '';
    });
    board.refresh();
  }

  Future<void> scoreCalculateWinner({
    required String winner,
    required RoomModel roomData,
  }) async {
    if (winner == "X") {
      int? newCoinsPlayer1 = currentCoinPlayer1! + winningPrize!;
      int? newWinsPlayer1 = currentWinPlayer1! + 1;
      await db.collection('users').doc(roomData.player1!.id!).update({
        'totalCoins': newCoinsPlayer1.toString(),
        'totalWins': newWinsPlayer1.toString(),
      }).catchError((e) => errorMessage(e.toString()));
      await db.collection("rooms").doc(roomData.id!).update({
        "player1.totalCoins": newCoinsPlayer1.toString(),
        "player1.totalWins": newWinsPlayer1.toString(),
      }).catchError((e) => errorMessage(e.toString()));
    } else {
      int? newCoinsPlayer2 = currentCoinPlayer2! + winningPrize!;
      int? newWinsPlayer2 = currentWinPlayer2! + 1;
      await db.collection('users').doc(roomData.player2!.id!).update({
        'totalCoins': newCoinsPlayer2.toString(),
        'totalWins': newWinsPlayer2.toString(),
      }).catchError((e) => errorMessage(e.toString()));
      await db.collection("rooms").doc(roomData.id!).update({
        "player2.totalCoins": newCoinsPlayer2.toString(),
        "player2.totalWins": newWinsPlayer2.toString(),
      }).catchError((e) => errorMessage(e.toString()));
    }
  }

  Future<void> scoreCalculateLoser({
    required String winner,
    required RoomModel roomData,
  }) async {
    if (winner == "X") {
      int? newCoinsPlayer2 = currentCoinPlayer2! - winningPrize!;
      int? newWinsPlayer2 = currentWinPlayer2! - 1;
      await db.collection('users').doc(roomData.player2!.id!).update({
        'totalCoins': newCoinsPlayer2.toString(),
        'totalWins': newWinsPlayer2.toString(),
      }).catchError((e) => errorMessage(e.toString()));
      await db.collection("rooms").doc(roomData.id!).update({
        "player2.totalCoins": newCoinsPlayer2.toString(),
        "player2.totalWins": newWinsPlayer2.toString(),
      }).catchError((e) => errorMessage(e.toString()));
    } else {
      int? newCoinsPlayer1 = currentCoinPlayer1! - winningPrize!;
      int? newWinsPlayer1 = currentWinPlayer1! - 1;
      await db.collection('users').doc(roomData.player1!.id!).update({
        'totalCoins': newCoinsPlayer1.toString(),
        'totalWins': newWinsPlayer1.toString(),
      }).catchError((e) => errorMessage(e.toString()));
      await db.collection("rooms").doc(roomData.id!).update({
        "player1.totalCoins": newCoinsPlayer1.toString(),
        "player1.totalWins": newWinsPlayer1.toString(),
      }).catchError((e) => errorMessage(e.toString()));
    }
  }

  Future<String> updateRoomWhenPlayerLeaves(String roomId) async {
    try {
      // Lấy thông tin của room từ Firestore
      var roomSnapshot = await db.collection('rooms').doc(roomId).get();
      var roomData = roomSnapshot.data() as Map<String, dynamic>;
      if (roomData['player1'] != null &&
          roomData['player1']['email'] == currentUserEmail) {
        return "Player 1 has left the room";
      } else if (roomData['player2'] != null &&
          roomData['player2']['email'] == currentUserEmail) {
        await db.collection('rooms').doc(roomId).update({
          'player2': null,
          'player2Status': "",
        }).catchError((e) => errorMessage(e.toString()));
        return "Player 2 has left the room";
      } else {
        return "";
      }
    } catch (error) {
      return error.toString();
    }
  }

  //delete room
  Future<void> deleteRoom(String roomId) async {
    String checkedPlayerLeave = await updateRoomWhenPlayerLeaves(roomId);
    if (checkedPlayerLeave == "Player 1 has left the room") {
      await db
          .collection("rooms")
          .doc(roomId)
          .delete()
          .catchError((e) => errorMessage(e.toString()));
    } else if (checkedPlayerLeave == "Player 2 has left the room") {
      errorMessage("You has left the room");
    }
  }

  void chatFeature(BuildContext context) {
    final TextEditingController textController = TextEditingController();
    Get.dialog(
      Dialog(
        backgroundColor: Colors.transparent,
        child: Container(
          width: 100,
          height: 300,
          padding: const EdgeInsets.symmetric(horizontal: 10, vertical: 10),
          decoration: BoxDecoration(
            color: Colors.lightBlueAccent.withOpacity(0.4),
            borderRadius: BorderRadius.circular(20),
          ),
          child: DefaultTabController(
            length: 2,
            child: Column(
              children: [
                Row(
                  children: [
                    Expanded(
                      child: TextField(
                        controller: textController,
                        decoration: InputDecoration(
                            border: OutlineInputBorder(
                              borderRadius: BorderRadius.circular(20),
                              borderSide: const BorderSide(color: Colors.black),
                            ),
                            labelText: 'Type your message...',
                            labelStyle: const TextStyle(
                              fontSize: 13.0,
                            )),
                      ),
                    ),
                    IconButton(
                      icon: const Icon(
                        Icons.send,
                        color: Colors.white,
                      ),
                      onPressed: () {
                        sendMessage(textController.text, roomModel.value!);
                        FocusScope.of(context).unfocus();
                        textController.clear();
                        Get.back();
                      },
                    ),
                  ],
                ),
                const TabBar(
                  labelColor: Colors.white,
                  indicatorColor: Colors.blueAccent,
                  indicatorSize: TabBarIndicatorSize.tab,
                  unselectedLabelColor: Colors.grey,
                  tabs: [
                    Tab(icon: Icon(Icons.message)),
                    Tab(icon: Icon(Icons.history)),
                  ],
                ),
                Expanded(
                  child: TabBarView(
                    children: [
                      ListView.builder(
                        itemCount: quickChatMessages.length,
                        itemBuilder: (context, index) {
                          return Padding(
                            padding: const EdgeInsets.symmetric(vertical: 8.0),
                            child: Text(
                              quickChatMessages[index],
                              style: const TextStyle(
                                  fontSize: 13.0, color: Colors.white),
                            ),
                          );
                        },
                      ),
                      ListView.builder(
                        itemCount: quickChatMessages.length,
                        itemBuilder: (context, index) {
                          return Padding(
                            padding: const EdgeInsets.symmetric(vertical: 8.0),
                            child: Text(
                              quickChatMessages[index],
                              style: const TextStyle(
                                  fontSize: 13.0, color: Colors.white),
                            ),
                          );
                        },
                      ),
                    ],
                  ),
                )
               
              ],
            ),
          ),
        ),
      ),
    );
  }

  Future<void> sendMessage(String text, RoomModel roomData) async {
    if (roomData.player1!.email == currentUserEmail) {
      await db.collection("rooms").doc(roomData.id!).update({
        "player1.quickMess": text,
      }).catchError((e) => errorMessage(e.toString()));
    } else if (roomData.player2!.email == currentUserEmail) {
      await db.collection("rooms").doc(roomData.id!).update({
        "player2.quickMess": text,
      }).catchError((e) => errorMessage(e.toString()));
    }
  }

  Future<void> removeMessage(RoomModel roomData) async {
    await Future.delayed(const Duration(seconds: 5));
    if (roomData.player1!.email == currentUserEmail) {
      await db.collection("rooms").doc(roomData.id!).update({
        "player1.quickMess": null,
      }).catchError((e) => errorMessage(e.toString()));
    } else if (roomData.player2!.email == currentUserEmail) {
      await db.collection("rooms").doc(roomData.id!).update({
        "player2.quickMess": null,
      }).catchError((e) => errorMessage(e.toString()));
    }
  }

  void emoteFeature(BuildContext context, RoomModel roomData) {
    Get.dialog(
      Dialog(
        backgroundColor: Colors.transparent,
        child: Container(
          width: 100,
          height: 200,
          padding: const EdgeInsets.symmetric(horizontal: 10, vertical: 10),
          decoration: BoxDecoration(
            color: Colors.lightBlueAccent.withOpacity(0.4),
            borderRadius: BorderRadius.circular(20),
          ),
          child: SizedBox(
            height: 200,
            child: GridView.builder(
              scrollDirection: Axis.vertical,
              physics: const BouncingScrollPhysics(),
              gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(
                crossAxisCount: 4,
                mainAxisSpacing: 10,
                crossAxisSpacing: 10,
              ),
              itemCount: emotes.length,
              itemBuilder: (context, index) {
                return GestureDetector(
                  onTap: () {
                    sendEmote(emotes[index], roomData);
                    Get.back();
                  },
                  child: Image.asset(
                    emotes[index],
                    fit: BoxFit.cover,
                    width: 100,
                    height: 100,
                  ),
                );
              },
            ),
          ),
        ),
      ),
    );
  }

  Future<void> sendEmote(String imagePath, RoomModel roomData) async {
    if (roomData.player1!.email == currentUserEmail) {
      await db.collection("rooms").doc(roomData.id!).update({
        "player1.quickEmote": imagePath,
      }).catchError((e) => errorMessage(e.toString()));
    } else if (roomData.player2!.email == currentUserEmail) {
      await db.collection("rooms").doc(roomData.id!).update({
        "player2.quickEmote": imagePath,
      }).catchError((e) => errorMessage(e.toString()));
    }
  }

  Future<void> removeEmote(RoomModel roomData) async {
    await Future.delayed(const Duration(seconds: 5));
    if (roomData.player1!.email == currentUserEmail) {
      await db.collection("rooms").doc(roomData.id!).update({
        "player1.quickEmote": null,
      }).catchError((e) => errorMessage(e.toString()));
    } else if (roomData.player2!.email == currentUserEmail) {
      await db.collection("rooms").doc(roomData.id!).update({
        "player2.quickEmote": null,
      }).catchError((e) => errorMessage(e.toString()));
    }
  }

  var isImagePicked = false.obs;
  var selectedImagePath = "".obs;
  var selectedImageX = "".obs;
  var selectedImageXHeroIndex = (-1).obs;
  var selectedImageO = "".obs;
  var selectedImageOHeroIndex = (-1).obs;
  var selectedImageIndex = (-1).obs;
  var selectedModeIndex = (-1).obs;
  var selectedDifficultyIndex = (-1).obs;
  var selectedWinningPrize = "".obs;
  var selectedImageModes = "".obs;

  List<String> imagePaths = [
    ImagePath.map1,
    ImagePath.map2,
    ImagePath.map4,
    ImagePath.map5,
    ImagePath.map6,
    ImagePath.map7,
    ImagePath.map8,
    ImagePath.map9,
    ImagePath.map10,
  ];
  List<String> modeImages = [
    ImagePath.board_3x3,
    ImagePath.board_6x6,
    ImagePath.board_9x9,
    ImagePath.board_11x11,
    ImagePath.board_11x11,
  ];
  List<String> modeTexts = ['3 x 3', '6 x 6', '9 x 9', '11 x 11', '15 x 15'];
  List<int> initialMode = [3, 6, 9, 11, 15];
  List<int> winLengthMode = [3, 4, 5, 6, 7];
  List<String> winningPrizeTexts = [
    '1 Coins',
    '10 Coins',
    '20 Coins',
    '50 Coins',
    '100 Coins',
    '200 Coins',
  ];
  List<String> winningFee = [
    '1',
    '10',
    '20',
    '50',
    '100',
    '200',
  ];

  void selectImage(String path, int index) {
    selectedImagePath.value = path;
    selectedImageIndex.value = index;
  }

  void selectMode(String imageMode, int initial, int winL, int index) {
    initialSize.value = initial;
    winLength.value = winL;
    selectedModeIndex.value = index;
    selectedImageModes.value = imageMode;
  }

  void selectForX(String X, int index) {
    selectedImageX.value = X;
    selectedImageXHeroIndex.value = index;
  }

  void selectForO(String O, int index) {
    selectedImageO.value = O;
    selectedImageOHeroIndex.value = index;
  }

  void selectDifficulty(String winningPrize, int index) {
    selectedDifficultyIndex.value = index;
    selectedWinningPrize.value = winningPrize;
  }

  void showPickerMultiPlayer({required String roomId}) {
    final CountdownController countdownController =
        Get.put(CountdownController());
    // final MusicController musicController = Get.find();
    // WidgetsBinding.instance.addPostFrameCallback((_) {
    //   musicController.playMusicOnScreen5();
    // });
    Get.dialog(
      barrierDismissible: false,
      Dialog(
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(20),
        ),
        child: Stack(
          clipBehavior: Clip.none,
          children: [
            Container(
              height: 500,
              padding: const EdgeInsets.all(10),
              child: Scrollbar(
                child: CustomScrollView(
                  slivers: [
                    const SliverToBoxAdapter(
                      child: SizedBox(
                        height: 100,
                      ),
                    ),
                    const SliverToBoxAdapter(
                      child: Column(
                        children: [
                          Padding(
                            padding: EdgeInsets.all(8.0),
                            child: Text(
                              'Pick a Map',
                              style: TextStyle(
                                  fontSize: 18, fontWeight: FontWeight.bold),
                            ),
                          ),
                          Divider(),
                        ],
                      ),
                    ),
                    SliverToBoxAdapter(
                      child: SingleChildScrollView(
                        scrollDirection: Axis.horizontal,
                        child: Row(
                          children: List.generate(imagePaths.length, (index) {
                            return GestureDetector(
                              onTap: () {
                                selectImage(imagePaths[index], index);
                              },
                              child: Obx(() {
                                return Container(
                                  margin: const EdgeInsets.symmetric(
                                      horizontal: 10),
                                  decoration: BoxDecoration(
                                    border: Border.all(
                                      color: selectedImageIndex.value == index
                                          ? Colors.blue
                                          : Colors.transparent,
                                      width: 5,
                                    ),
                                  ),
                                  child: Image.asset(
                                    imagePaths[index],
                                    width: 100,
                                    height: 100,
                                    fit: BoxFit.cover,
                                  ),
                                );
                              }),
                            );
                          }),
                        ),
                      ),
                    ),

                    // Phần chọn chế độ
                    const SliverToBoxAdapter(
                      child: Column(
                        children: [
                          Padding(
                            padding: EdgeInsets.all(8.0),
                            child: Text(
                              'Pick a Mode',
                              style: TextStyle(
                                  fontSize: 18, fontWeight: FontWeight.bold),
                            ),
                          ),
                          Divider(),
                        ],
                      ),
                    ),
                    SliverToBoxAdapter(
                      child: SingleChildScrollView(
                        scrollDirection: Axis.horizontal,
                        child: Row(
                          children: List.generate(modeTexts.length, (index) {
                            return GestureDetector(
                              onTap: () {
                                selectMode(
                                  modeImages[index],
                                  initialMode[index],
                                  winLengthMode[index],
                                  index,
                                );
                              },
                              child: Obx(() {
                                return Column(
                                  children: [
                                    Container(
                                      margin: const EdgeInsets.all(10),
                                      decoration: BoxDecoration(
                                        border: Border.all(
                                          color:
                                              selectedModeIndex.value == index
                                                  ? Colors.blue
                                                  : Colors.transparent,
                                          width: 5,
                                        ),
                                      ),
                                      child: Image.asset(
                                        modeImages[index],
                                        width: 100,
                                        height: 100,
                                        fit: BoxFit.cover,
                                      ),
                                    ),
                                    Container(
                                      margin: const EdgeInsets.symmetric(
                                          horizontal: 10),
                                      padding: const EdgeInsets.all(8.0),
                                      decoration: BoxDecoration(
                                        color: selectedModeIndex.value == index
                                            ? Colors.blue
                                            : Colors.grey[300],
                                        borderRadius: BorderRadius.circular(10),
                                      ),
                                      child: Text(
                                        modeTexts[index],
                                        style: const TextStyle(fontSize: 16),
                                      ),
                                    ),
                                  ],
                                );
                              }),
                            );
                          }),
                        ),
                      ),
                    ),
                    const SliverToBoxAdapter(
                      child: Column(
                        children: [
                          Padding(
                            padding: EdgeInsets.all(8.0),
                            child: Text(
                              'Pick a hero for you',
                              style: TextStyle(
                                  fontSize: 18, fontWeight: FontWeight.bold),
                            ),
                          ),
                          Divider(),
                        ],
                      ),
                    ),
                    SliverToBoxAdapter(
                      child: SizedBox(
                        height: 400,
                        child: GridView.builder(
                          scrollDirection: Axis.vertical,
                          physics: const BouncingScrollPhysics(),
                          gridDelegate:
                              const SliverGridDelegateWithFixedCrossAxisCount(
                            crossAxisCount: 4,
                            mainAxisSpacing: 10,
                            crossAxisSpacing: 10,
                          ),
                          itemCount: listChamA.length,
                          itemBuilder: (context, index) {
                            return GestureDetector(
                              onTap: () {
                                selectForX(listChamA[index], index);
                              },
                              child: Obx(() {
                                return Container(
                                  decoration: BoxDecoration(
                                    border: Border.all(
                                      color:
                                          selectedImageXHeroIndex.value == index
                                              ? Colors.blue
                                              : Colors.transparent,
                                      width: 5,
                                    ),
                                  ),
                                  child: Image.asset(
                                    listChamA[index],
                                    fit: BoxFit.cover,
                                    width: 100,
                                    height: 100,
                                  ),
                                );
                              }),
                            );
                          },
                        ),
                      ),
                    ),

                    const SliverToBoxAdapter(
                      child: Column(
                        children: [
                          Padding(
                            padding: EdgeInsets.all(8.0),
                            child: Text(
                              'Pick a hero for Enemy',
                              style: TextStyle(
                                  fontSize: 18, fontWeight: FontWeight.bold),
                            ),
                          ),
                          Divider(),
                        ],
                      ),
                    ),
                    SliverToBoxAdapter(
                      child: SizedBox(
                        height: 400,
                        child: GridView.builder(
                          scrollDirection: Axis.vertical,
                          physics: const BouncingScrollPhysics(),
                          gridDelegate:
                              const SliverGridDelegateWithFixedCrossAxisCount(
                            crossAxisCount: 4,
                            mainAxisSpacing: 10,
                          ),
                          itemCount: listChamB.length,
                          itemBuilder: (context, index) {
                            return GestureDetector(
                              onTap: () {
                                selectForO(listChamB[index], index);
                              },
                              child: Obx(() {
                                return Container(
                                  decoration: BoxDecoration(
                                    border: Border.all(
                                      color:
                                          selectedImageOHeroIndex.value == index
                                              ? Colors.blue
                                              : Colors.transparent,
                                      width: 5,
                                    ),
                                  ),
                                  child: Image.asset(
                                    listChamB[index],
                                    fit: BoxFit.cover,
                                    width: 100,
                                    height: 100,
                                  ),
                                );
                              }),
                            );
                          },
                        ),
                      ),
                    ),
                    const SliverToBoxAdapter(
                      child: Column(
                        children: [
                          Padding(
                            padding: EdgeInsets.all(8.0),
                            child: Text(
                              'Pick Coin Prize',
                              style: TextStyle(
                                  fontSize: 18, fontWeight: FontWeight.bold),
                            ),
                          ),
                          Divider(),
                        ],
                      ),
                    ),
                    SliverToBoxAdapter(
                      child: Image.asset(
                        ImagePath.welcome3,
                        width: 50,
                      ),
                    ),
                    SliverToBoxAdapter(
                      child: SingleChildScrollView(
                        scrollDirection: Axis.horizontal,
                        child: Row(
                          children:
                              List.generate(winningPrizeTexts.length, (index) {
                            return GestureDetector(
                              onTap: () {
                                selectDifficulty(winningFee[index], index);
                              },
                              child: Obx(() {
                                return Container(
                                  alignment: Alignment.center,
                                  margin: const EdgeInsets.symmetric(
                                      horizontal: 10),
                                  padding: const EdgeInsets.all(8.0),
                                  decoration: BoxDecoration(
                                    color:
                                        selectedDifficultyIndex.value == index
                                            ? Colors.blue
                                            : Colors.grey[300],
                                    borderRadius: BorderRadius.circular(10),
                                  ),
                                  child: Text(
                                    winningPrizeTexts[index],
                                    style: const TextStyle(
                                      fontSize: 20,
                                      color: Colors.yellowAccent,
                                    ),
                                  ),
                                );
                              }),
                            );
                          }),
                        ),
                      ),
                    ),
                  ],
                ),
              ),
            ),
            Positioned(
              top: -50,
              right: -10,
              left: -10,
              child: Container(
                decoration: BoxDecoration(
                  color: Colors.lightBlueAccent,
                  borderRadius: BorderRadius.circular(20),
                  boxShadow: const [
                    BoxShadow(
                      color: Colors.blueAccent,
                      offset: Offset(0, 5),
                      spreadRadius: 3.0,
                    )
                  ],
                ),
                child: Row(
                  mainAxisAlignment: MainAxisAlignment.spaceBetween,
                  children: [
                    Row(
                      children: [
                        IconButton(
                          onPressed: () {
                            countdownController.stopAnimation();
                            Get.offAllNamed("/mainHome");
                          },
                          icon: const Icon(Icons.arrow_back_ios),
                        ),
                        const Text("Back"),
                      ],
                    ),
                    const CountdownWaitingWidget(),
                    Row(
                      children: [
                        const Text("Ok"),
                        IconButton(
                          onPressed: () async {
                            if (selectedImageIndex.value == -1) {
                              errorMessage("Please select a map.");
                            } else if (selectedModeIndex.value == -1) {
                              errorMessage("Please select a mode.");
                            } else if (selectedDifficultyIndex.value == -1) {
                              errorMessage("Please select a level.");
                            } else if (selectedImageXHeroIndex.value == -1) {
                              errorMessage(
                                  "Please select a hero for yourself.");
                            } else if (selectedImageOHeroIndex.value == -1) {
                              errorMessage("Please select a hero for bot.");
                            } else {
                              countdownController.stopAnimation();
                              await db.collection("rooms").doc(roomId).update({
                                "pickedMap": selectedImagePath.value,
                                "winnerVariable": "",
                                "champX": selectedImageX.value,
                                "champO": selectedImageO.value,
                                "initialMode": initialSize.value,
                                "winLengthMode": winLength.value,
                                "player1Status": "ready",
                                "winningPrize": selectedWinningPrize.value,
                                "imageMode": selectedImageModes.value,
                              });
                              Get.back();
                            }
                          },
                          icon: const Icon(
                              Icons.keyboard_double_arrow_right_outlined),
                        ),
                      ],
                    ),
                  ],
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }
}

```

---


### Controller\MainHome\main_home_controller.dart

```dart
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:tictactoe_gameapp/Pages/Chat/chat_screen.dart';
import 'package:tictactoe_gameapp/Pages/Friends/messenger_page.dart';
import 'package:tictactoe_gameapp/Pages/HomePage/home_page.dart';
import 'package:tictactoe_gameapp/Pages/Society/Reels/reel_page.dart';
import 'package:tictactoe_gameapp/Pages/Society/social_media_page.dart';

class MainHomeController extends GetxController {
  RxInt currentIndex = 2.obs;
  RxInt previousIndex = 2.obs;
  var pages = <Widget>[
    const ChatBotPage(),
    const FriendsPage(),
    const HomePage(),
    const ReelPage(),
    const SocialMediaPage(),
  ];
}

```

---


### Controller\MainHome\notify_in_main_controller.dart

```dart
import 'dart:async';
import 'dart:ui';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:tictactoe_gameapp/Components/invite_request_dialog.dart';
import 'package:tictactoe_gameapp/Configs/assets_path.dart';
import 'package:tictactoe_gameapp/Configs/messages.dart';
import 'package:tictactoe_gameapp/Controller/auth_controller.dart';
import 'package:tictactoe_gameapp/Controller/matching_controller.dart';
import 'package:tictactoe_gameapp/Controller/notification_controller.dart';
import 'package:tictactoe_gameapp/Controller/profile_controller.dart';
import 'package:tictactoe_gameapp/Controller/room_controller.dart';
import 'package:tictactoe_gameapp/Models/Functions/permission_handle_functions.dart';
import 'package:tictactoe_gameapp/Models/general_notifications_model.dart';
import 'package:tictactoe_gameapp/Models/user_model.dart';
import 'package:tictactoe_gameapp/Pages/Friends/Widgets/agora_call_page.dart';
import 'package:tictactoe_gameapp/main.dart';
import 'package:uuid/uuid.dart';

class NotifyInMainController extends GetxController {
  var friendRequests =
      <GeneralNotificationsModel>[].obs; // Lời mời kết bạn lưu trữ
  var filteredFriendRequests =
      <GeneralNotificationsModel>[].obs; // Lời mời kết bạn đã lọc
  var searchText = ''.obs; // Text tìm kiếm từ người dùng
  var isWaitingForOk = false.obs;
  final Rx<OverlayEntry?> _popupEntry = Rx<OverlayEntry?>(null);
  RxBool isPopupVisible = false.obs; // Để kiểm soát trạng thái của popup

  final FirebaseFirestore db = FirebaseFirestore.instance;
  final String currentUserId = Get.find<AuthController>().getCurrentUserId();
  var uuid = const Uuid();
  final RoomController roomController = Get.put(RoomController());

  late StreamSubscription listenForFriendRequestsSub;
  late StreamSubscription listenForGameInvitesSub;
  late StreamSubscription listenForCallSub;

  @override
  void onInit() {
    super.onInit();
    deleteOldNotifications();
    setupSearchListener();
  }

  // Lắng nghe các lời mời kết bạn (Lưu lại trong Firestore)
  void listenForFriendRequests() {
    listenForFriendRequestsSub = db
        .collection('notifications')
        .where('receiverId', isEqualTo: currentUserId)
        .where('type', isEqualTo: 'friendRequest')
        .snapshots(includeMetadataChanges: true)
        .listen((QuerySnapshot snapshot) {
      // Xử lý từng thay đổi trong snapshot
      for (var change in snapshot.docChanges) {
        var request = GeneralNotificationsModel.fromJson(
            change.doc.data() as Map<String, dynamic>);
        request.id = change.doc.id; // Lưu ID từ Firestore vào model

        if (change.type == DocumentChangeType.added) {
          // Kiểm tra nếu lời mời chưa tồn tại, thêm vào đầu danh sách
          if (!friendRequests.any((req) => req.id == request.id)) {
            friendRequests.insert(0, request); // Thêm mới lời mời kết bạn
          }
        } else if (change.type == DocumentChangeType.modified) {
          // Tìm lời mời đã tồn tại và cập nhật
          final index =
              friendRequests.indexWhere((req) => req.id == request.id);
          if (index != -1) {
            friendRequests[index] = request; // Cập nhật lời mời đã sửa
          }
        } else if (change.type == DocumentChangeType.removed) {
          // Xóa lời mời khỏi danh sách
          friendRequests.removeWhere((req) => req.id == request.id);
        }
      }
      // Sau khi cập nhật danh sách, lọc lại dữ liệu theo searchText
      filterFriendRequests();
    });
  }

  // Hàm thiết lập lắng nghe sự thay đổi của searchText
  void setupSearchListener() {
    debounce(searchText, (_) => filterFriendRequests(),
        time: const Duration(milliseconds: 300));
  }

  // Hàm lọc friendRequests dựa trên searchText
  void filterFriendRequests() {
    // Nếu không có nội dung tìm kiếm, hiển thị toàn bộ friendRequests
    if (searchText.isEmpty) {
      filteredFriendRequests.assignAll(friendRequests);
    } else {
      final searchLower = searchText.value.toLowerCase();

      // Lọc danh sách theo nội dung tìm kiếm
      filteredFriendRequests.assignAll(friendRequests.where((request) {
        final senderName = request.senderModel!.name!.toLowerCase();
        final email = request.senderModel!.email!.toLowerCase();
        // Kiểm tra nếu senderName hoặc message chứa nội dung tìm kiếm
        return senderName.contains(searchLower) || email.contains(searchLower);
      }).toList());
    }
  }

  // Hàm cập nhật nội dung tìm kiếm khi người dùng nhập text
  void updateSearchText(String text) {
    searchText.value =
        text.toLowerCase(); // Chuyển sang chữ thường khi cập nhật
  }

  // Lắng nghe các lời mời chơi game (Tự động xóa sau 30 giây)
  void listenForGameInvites() {
    listenForGameInvitesSub = db
        .collection('notifications')
        .where('receiverId', isEqualTo: currentUserId)
        .where('type', isEqualTo: 'gameInvite')
        .snapshots()
        .listen((snapshot) {
      var gameInvites = snapshot.docs.map((doc) {
        var notification = GeneralNotificationsModel.fromJson(doc.data());
        notification.id = doc.id;
        return notification;
      }).toList();

      // Hiển thị lời mời chơi game và xóa sau 30 giây
      for (var invite in gameInvites) {
        showGameInviteRequest(invite);
        // Xóa lời mời chơi game từ Firestore sau 30 giây
        Future.delayed(const Duration(seconds: 10), () {
          if (invite.id != null) {
            db.collection('notifications').doc(invite.id).delete();
          }
          removePopup();
        });
      }
    });
  }

  void listenForCall() {
    listenForCallSub = db
        .collection('notifications')
        .where('receiverId', isEqualTo: currentUserId)
        .where('type', isEqualTo: 'call')
        .snapshots()
        .listen((snapshot) {
      var callInvites = snapshot.docs.map((doc) {
        var notification = GeneralNotificationsModel.fromJson(doc.data());
        notification.id = doc.id;
        return notification;
      }).toList();

      // Hiển thị lời mời call và xóa sau 30 giây
      for (var call in callInvites) {
        showCallInviteRequest(call);
        // final NotificationController notificationController =
        //     Get.put(NotificationController());
        // notificationController.showCallNotification(
        //     call.senderModel!.name!, call.senderModel!.image!);

        // Xóa lời mời call từ Firestore sau 30 giây
        Future.delayed(const Duration(seconds: 10), () async {
          if (call.id != null) {
            await db.collection('notifications').doc(call.id).delete();
          }
          removePopup();
        });
      }
    });
  }

  // Gửi lời mời kết bạn (Lưu lại)
  Future<void> sendFriendRequest(
    String receiverId,
    UserModel senderUser,
  ) async {
    String id = uuid.v4().substring(0, 12);
    var senderModel = UserModel(
      id: senderUser.id,
      name: senderUser.name,
      email: senderUser.email,
      image: senderUser.image,
    );
    GeneralNotificationsModel request = GeneralNotificationsModel(
      id: id,
      senderId: currentUserId,
      senderModel: senderModel,
      receiverId: receiverId,
      message: ' ${senderUser.name} have sent a friend request',
      type: 'friendRequest',
      timestamp: Timestamp.now(),
    );
    await db.collection('notifications').doc(id).set(request.toJson());
  }

  // Gửi lời mời chơi game (Tự động xóa sau 30 giây)
  Future<void> sendGameInvite(
      String receiverId, String roomId, UserModel senderUser) async {
    try {
      isWaitingForOk.value = true;
      var senderModel = UserModel(
        id: senderUser.id,
        name: senderUser.name,
        email: senderUser.email,
        image: senderUser.image,
      );
      GeneralNotificationsModel invite = GeneralNotificationsModel(
        senderId: currentUserId,
        senderModel: senderModel,
        receiverId: receiverId,
        message: 'Bạn có lời mời chơi game từ $currentUserId',
        type: 'gameInvite',
        roomId: roomId,
        timestamp: Timestamp.now(),
      );
      await db.collection('notifications').add(invite.toJson());
      await Future.delayed(const Duration(seconds: 5));
    } catch (e) {
      errorMessage(e.toString());
    } finally {
      isWaitingForOk.value = false;
    }
  }

  Future<void> sendCallInvite({
    required String receiverId,
    required UserModel senderUser,
    required String channelId,
    required bool isVideoCall,
  }) async {
    try {
      var senderModel = UserModel(
        id: senderUser.id,
        name: senderUser.name,
        email: senderUser.email,
        image: senderUser.image,
      );
      GeneralNotificationsModel call = GeneralNotificationsModel(
        senderId: currentUserId,
        senderModel: senderModel,
        receiverId: receiverId,
        roomId: channelId,
        isVideoCall: isVideoCall,
        type: 'call',
        timestamp: Timestamp.now(),
      );
      await db.collection('notifications').add(call.toJson());
    } catch (e) {
      errorMessage(e.toString());
    }
  }

  Future<void> deleteFriendRequest(String id) async {
    await db
        .collection('notifications')
        .doc(id)
        .delete()
        .catchError((e) => errorMessage(e.toString()));
  }

  void deleteOldNotifications() {
    final Timestamp sevenDaysAgo = Timestamp.fromDate(
      DateTime.now().subtract(const Duration(days: 7)),
    );

    db
        .collection('notifications')
        .where('timestamp', isLessThan: sevenDaysAgo)
        .get()
        .then((snapshot) {
      for (var doc in snapshot.docs) {
        db.collection('notifications').doc(doc.id).delete();
      }
    });
  }

  void showGameInviteRequest(
    GeneralNotificationsModel invite,
  ) {
    if (_popupEntry.value != null) {
      // Xóa popup cũ nếu đã hiển thị
      removePopup();
    }

    _popupEntry.value = OverlayEntry(
      builder: (context) => Center(
        child: Material(
          elevation: 5.0,
          shape:
              RoundedRectangleBorder(borderRadius: BorderRadius.circular(20)),
          child: GameInviteRequestDialog(
            friend: invite.senderModel!,
            onPressedAccept: () {
              Get.showOverlay(
                asyncFunction: () async {
                  try {
                    await db
                        .collection('notifications')
                        .doc(invite.id)
                        .delete();
                    Get.put(MatchingController());
                    removePopup();
                    await roomController.joinRoom(invite.roomId!);
                  } catch (e) {
                    errorMessage(e.toString());
                  }
                },
                loadingWidget: Stack(
                  children: [
                    Positioned.fill(
                      child: BackdropFilter(
                        filter: ImageFilter.blur(sigmaX: 5.0, sigmaY: 5.0),
                        child: const SizedBox(),
                      ),
                    ),
                    Center(
                      child: ClipRRect(
                        borderRadius: BorderRadius.circular(100),
                        child: Image.asset(
                          GifsPath.loadingGif,
                          width: 200,
                          height: 200,
                        ),
                      ),
                    )
                  ],
                ),
              );
            },
            onPressedRefuse: () async {
              removePopup();
            },
          ),
        ),
      ),
    );

    // Hiển thị popup
    navigatorKey.currentState!.overlay!.insert(_popupEntry.value!);
    // animationController.forward();
    isPopupVisible.value = true;
  }

  void showCallInviteRequest(GeneralNotificationsModel call) {
    if (_popupEntry.value != null) {
      // Xóa popup cũ nếu đã hiển thị
      removePopup();
    }
    _popupEntry.value = OverlayEntry(
      builder: (context) => Center(
        child: Material(
          elevation: 5.0,
          shape:
              RoundedRectangleBorder(borderRadius: BorderRadius.circular(20)),
          child: CallInviteRequestDialog(
            friend: call.senderModel!,
            onPressedRefuse: () {
              removePopup();
            },
            onPressedAccept: () async {
              removePopup();
              final permissionHandler = PermissionHandleFunctions();
              bool micGranted =
                  await permissionHandler.checkMicrophonePermission();
              bool camGranted = await permissionHandler.checkCameraPermission();
              if (micGranted == true && camGranted == true) {
                final ProfileController profileController = Get.find();
                Get.to(() => AgoraCallPage(
                      userFriend: call.senderModel!,
                      userCurrent: profileController.user!,
                      channelId: call.roomId!,
                      initialMicState: true,
                      initialVideoState: call.isVideoCall ?? false,
                    ));
              } else {}
            },
            isVideoCall: call.isVideoCall ?? false,
          ),
        ),
      ),
    );

    // Hiển thị popup
    navigatorKey.currentState!.overlay!.insert(_popupEntry.value!);
    // animationController.forward();
    isPopupVisible.value = true;
  }

  void removePopup() {
    if (_popupEntry.value != null) {
      _popupEntry.value?.remove();
      _popupEntry.value = null;
      isPopupVisible.value = false;
    }
  }

  @override
  void onClose() {
    listenForFriendRequestsSub.cancel();
    listenForGameInvitesSub.cancel();
    listenForCallSub.cancel();
    removePopup();
    super.onClose();
  }
}

```

---


### Controller\Music\background_music_controller.dart

```dart
import 'package:get/get.dart';
import 'package:just_audio/just_audio.dart';
import 'package:tictactoe_gameapp/Configs/assets_path.dart';

class BackgroundMusicController extends GetxController {
  late AudioPlayer _audioPlayer; // Player cho màn hình 1-4
  late AudioPlayer _audioPlayerScreen5; // Player cho màn hình 5
  late AudioPlayer _audioPlayerScreen6; // Player cho màn hình 6
  late AudioPlayer _audioPlayerScreen7; // Player cho màn hình 7
  late AudioPlayer _audioPlayerScreen8; // Player cho màn hình 8
  late AudioPlayer _player;

  var isPlaying = false.obs;
  var currentTrackIndex = 0.obs;
  var isOnScreen5 = false.obs;
  var isOnScreen6 = false.obs;
  var isOnScreen7 = false.obs;
  var isOnScreen8 = false.obs;

  // Danh sách bài hát cho các màn hình 1-4
  final List<String> playlist = [AudioSPath.infinityCastle];

  var volume = 1.0.obs; // Âm lượng

  @override
  void onInit() {
    super.onInit();

    _audioPlayer = AudioPlayer(); // Khởi tạo player cho màn hình 1-4
    _audioPlayerScreen5 = AudioPlayer(); // Khởi tạo player cho màn hình 5
    _audioPlayerScreen6 = AudioPlayer(); // Khởi tạo player cho màn hình 6
    _audioPlayerScreen7 = AudioPlayer(); // Khởi tạo player cho màn hình 7
    _audioPlayerScreen8 = AudioPlayer(); // Khởi tạo player cho màn hình 8
    _player = AudioPlayer();

    _audioPlayer.playerStateStream.listen((state) {
      if (state.processingState == ProcessingState.completed) {
        _playNextTrack();
      }
    });

    _audioPlayer.setVolume(volume.value); // Cài đặt âm lượng ban đầu
  }

  // Thiết lập danh sách phát cho các màn hình 1-4
  Future<void> _setupPlaylist(List<String> playlist) async {
    List<AudioSource> audioSourceList = playlist.map((track) {
      return AudioSource.asset(track);
    }).toList();
    await _audioPlayer.setAudioSource(
      ConcatenatingAudioSource(children: audioSourceList),
      initialIndex: currentTrackIndex.value,
    );
  }

  // Phát nhạc cho màn hình 1-4
  void playMusic(List<String> playlist) async {
    if (!isOnScreen5.value &&
        !isOnScreen6.value &&
        !isOnScreen7.value &&
        !isOnScreen8.value) {
      // await _audioPlayerScreen5.setLoopMode(LoopMode.all);
      await _setupPlaylist(playlist);
      await _audioPlayer.play();
      isPlaying.value = true;
    }
  }

  // Dừng nhạc cho màn hình 1-4
  void pauseMusic() async {
    if (!isOnScreen5.value &&
        !isOnScreen6.value &&
        !isOnScreen7.value &&
        !isOnScreen8.value) {
      await _audioPlayer.pause();
      isPlaying.value = false;
    }
  }

  // Dừng nhạc hoàn toàn cho màn hình 1-4
  void stopMusic() async {
    await _audioPlayer.stop();
    isPlaying.value = false;
  }

  // Cài đặt âm lượng
  void setVolume(double newVolume) async {
    volume.value = newVolume;
    await _audioPlayer.setVolume(newVolume);
  }

  // Phát bài tiếp theo trong danh sách (màn hình 1-4)
  void _playNextTrack() async {
    if (currentTrackIndex.value < playlist.length - 1) {
      currentTrackIndex.value++;
    } else {
      currentTrackIndex.value = 0; // Lặp lại từ đầu nếu hết danh sách
    }
    await _audioPlayer.seek(Duration.zero, index: currentTrackIndex.value);
    // playMusic();
  }

  // Phát nhạc cho màn hình 5
  void playMusicOnScreen5() async {
    isOnScreen5.value = true;
    setVolume(0.0);
    await _audioPlayerScreen5.setAsset(AudioSPath.blindPick);
    await _audioPlayerScreen5.setLoopMode(LoopMode.off);
    await _audioPlayerScreen5.play();
  }

  // Dừng nhạc ở màn hình 5 và quay lại màn hình 1-4
  void stopMusicOnScreen5() async {
    await _audioPlayerScreen5.stop(); // Dừng nhạc màn hình 5
    isOnScreen5.value = false;
    setVolume(1.0);
  }

  // Phát nhạc cho màn hình 6
  void playMusicOnScreen6() async {
    isOnScreen6.value = true;
    setVolume(0.0);
    await _audioPlayerScreen6.setAsset(AudioSPath.welcomeSound);
    await _audioPlayerScreen6.setLoopMode(LoopMode.off);
    await _audioPlayerScreen6.play();
    await Future.delayed(const Duration(seconds: 5));
    stopMusicOnScreen6();
  }

  // Dừng nhạc ở màn hình 6 và quay lại màn hình 1-4
  void stopMusicOnScreen6() async {
    await _audioPlayerScreen6.stop(); // Dừng nhạc màn hình 6
    isOnScreen6.value = false;
    setVolume(1.0);
  }

  // Phát nhạc cho màn hình 7
  void playMusicOnScreen7() async {
    stopMusicOnScreen8(0.0);
    isOnScreen7.value = true;
    await _audioPlayerScreen7.setAsset(AudioSPath.infinityCastle);
    await _audioPlayerScreen7.setLoopMode(LoopMode.all);
    await _audioPlayerScreen7.play();
  }

  // Dừng nhạc ở màn hình 7 và quay lại màn hình 1-4
  void stopMusicOnScreen7() async {
    await _audioPlayerScreen7.stop(); // Dừng nhạc màn hình 7
    isOnScreen7.value = false;
    setVolume(1.0);
  }

  void playMusicOnScreen8() async {
    isOnScreen8.value = true;
    setVolume(0.0);
    await _audioPlayerScreen8.setAsset(AudioSPath.matchingSound);
    await _audioPlayerScreen8.setLoopMode(LoopMode.off);
    await _audioPlayerScreen8.play();
  }

  void stopMusicOnScreen8(double volume) async {
    await _audioPlayerScreen8.stop();
    isOnScreen8.value = false;
    setVolume(volume);
  }

  //setup sound effect for button press in app
  Future<void> _playSound(String assetPath) async {
    await _player.setAsset(assetPath);
    _player.setLoopMode(LoopMode.off);
    _player.play();
  }

  Future<void> buttonSoundEffect() async {
    await _playSound(
      EffectingsPath.rippleEffect,
    );
  }

  Future<void> boosterSoundEffect() async {
    await _playSound(
      EffectingsPath.boosterEffect,
    );
  }

  Future<void> futuricSoundEffect() async {
    await _playSound(
      EffectingsPath.futuricEffect,
    );
  }

  Future<void> digitalSoundEffect() async {
    await _playSound(
      EffectingsPath.digitalEffect,
    );
  }

  Future<void> swordSoundEffect() async {
    await _playSound(AudioSPath.swordEffect);
  }

  @override
  void onClose() {
    // _audioPlayer.dispose();
    _player.dispose();
    _audioPlayerScreen5.dispose();
    _audioPlayerScreen6.dispose();
    _audioPlayerScreen7.dispose();
    _audioPlayerScreen8.dispose();

    super.onClose();
  }
}

```

---


### Controller\Music\effective_music_controller.dart

```dart
import 'package:get/get.dart';
import 'package:just_audio/just_audio.dart';
import 'package:tictactoe_gameapp/Configs/assets_path.dart';
import 'package:tictactoe_gameapp/Configs/messages.dart';

class EffectiveMusicController extends GetxController {
  late AudioPlayer _player;
  bool isPlaying = false;

  @override
  void onInit() {
    super.onInit();
    _player = AudioPlayer();
    _player.setLoopMode(LoopMode.off);
  }

  @override
  void onClose() {
    _player.dispose();
    super.onClose();
  }

  // Hàm chung để phát âm thanh
  Future<void> _playSound(String assetPath, Duration duration) async {
    if (isPlaying) return; // Nếu đang phát nhạc thì không phát lại
    try {
      isPlaying = true;

      await _player.setAsset(assetPath); // Load file nhạc
      _player.play(); // Phát nhạc

      await Future.delayed(duration);
      await _player.stop();
    } catch (e) {
      errorMessage(e.toString());
    } finally {
      isPlaying = false; // Đặt lại trạng thái sau khi phát xong
    }
  }

  // Hàm phát nhạc 1
  Future<void> playSoundPlayer1() async {
    await _playSound(
      AudioSPath.coins,
      const Duration(milliseconds: 500),
    );
  }

  // Hàm phát nhạc 2
  Future<void> playSoundPlayer2() async {
    await _playSound(
      AudioSPath.nakime,
      const Duration(milliseconds: 700),
    );
  }

  // Hàm phát nhạc 3
  Future<void> playSoundWinner() async {
    await _playSound(
      AudioSPath.victory,
      const Duration(seconds: 1),
    );
  }

  Future<void> playSoundLoser() async {
    await _playSound(
      AudioSPath.defeat,
      const Duration(seconds: 1),
    );
  }
}

```

---


### Data\chat_friend_controller.dart

```dart
import 'dart:async';
import 'dart:convert';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:share_plus/share_plus.dart';
import 'package:tictactoe_gameapp/Configs/messages.dart';
import 'package:tictactoe_gameapp/Models/Functions/compress_image_function.dart';
import 'package:tictactoe_gameapp/Models/chat_friend_settings_model.dart';
import 'package:tictactoe_gameapp/Models/message_friend_model.dart';
import 'package:uuid/uuid.dart';

class ChatFriendController extends GetxController {
  var messages = <MessageFriendModel>[].obs;
  var searchText = ''.obs; // Text tìm kiếm từ người dùng
  var filtermessages = <MessageFriendModel>[].obs;
  StreamSubscription? messageSubscription;
  final FirebaseFirestore _firestore = FirebaseFirestore.instance;
  var uuid = const Uuid();
  final ScrollController scrollController = ScrollController();
  FocusNode focusNode = FocusNode();
  var isFocused = false.obs;
  var isLoadingMore = false.obs;
  var hasMoreMessages = true.obs;
  var isEmptyMessage = false.obs;
  var isSearching = false.obs;
  final int pageSize = 20;
  DocumentSnapshot? lastDocument;

  final String currentUserId;
  final String friendId;
  ChatFriendController(this.currentUserId, this.friendId);

  @override
  void onInit() {
    super.onInit();
    // deleteOldMessages();
    listenToMessages();
    setupSearchListener();
    focusNode.addListener(() {
      isFocused.value = focusNode.hasFocus;
    });
    listenToChatSettings();
    // scrollController.addListener(() {
    //   _onScroll();
    // });
  }

  // Hàm lắng nghe tin nhắn theo thời gian thực cho tin nhắn mới
  void listenToMessages() {
    messageSubscription = _firestore
        .collection('chats')
        .doc(_getChatRoomId())
        .collection('messages')
        .orderBy('timestamp', descending: false)
        .snapshots(includeMetadataChanges: true)
        .listen((QuerySnapshot snapshot) {
      // Xử lý từng thay đổi trong snapshot
      if (snapshot.docs.isNotEmpty) {
        isEmptyMessage.value = false;
        for (var change in snapshot.docChanges) {
          if (change.type == DocumentChangeType.added) {
            // Khi có tin nhắn mới
            var newMessage = MessageFriendModel.fromJson(
              change.doc.data() as Map<String, dynamic>,
            );

            // Kiểm tra xem tin nhắn này đã tồn tại chưa, nếu chưa thì thêm vào đầu danh sách
            if (!messages.any((msg) => msg.messageId == newMessage.messageId)) {
              messages.insert(
                  0, newMessage); // Thêm tin nhắn mới vào đầu danh sách
            }
          } else if (change.type == DocumentChangeType.modified) {
            // Khi có tin nhắn được chỉnh sửa
            var updatedMessage = MessageFriendModel.fromJson(
              change.doc.data() as Map<String, dynamic>,
            );

            // Tìm tin nhắn đã tồn tại và cập nhật
            final index = messages
                .indexWhere((msg) => msg.messageId == updatedMessage.messageId);
            if (index != -1) {
              messages[index] = updatedMessage; // Cập nhật tin nhắn đã sửa
            }
          } else if (change.type == DocumentChangeType.removed) {
            // Khi có tin nhắn bị xóa
            final messageId = change.doc.id;

            // Xóa tin nhắn khỏi danh sách
            messages.removeWhere((msg) => msg.messageId == messageId);
          }
        }
        filterMessages();
      } else {
        isEmptyMessage.value = true;
      }
    });
  }

  // Hàm thiết lập lắng nghe sự thay đổi của searchText
  void setupSearchListener() {
    debounce(searchText, (_) => filterMessages(),
        time: const Duration(milliseconds: 300));
  }

  // Hàm lọc friendRequests dựa trên searchText
  void filterMessages() {
    // Nếu không có nội dung tìm kiếm, hiển thị toàn bộ friendRequests
    if (searchText.isEmpty) {
      filtermessages.assignAll(messages);
    } else {
      final searchLower = searchText.value.toLowerCase();

      // Lọc danh sách theo nội dung tìm kiếm
      filtermessages.assignAll(messages.where((message) {
        final content = message.content ?? ".".toLowerCase();
        return content.contains(searchLower);
      }).toList());
    }
  }

  // Hàm cập nhật nội dung tìm kiếm khi người dùng nhập text
  void updateSearchText(String text) {
    searchText.value =
        text.toLowerCase(); // Chuyển sang chữ thường khi cập nhật
  }

  void loadMessages() async {
    if (isLoadingMore.value || !hasMoreMessages.value) return;
    isLoadingMore.value = true;
    try {
      QuerySnapshot snapshot;

      if (lastDocument != null) {
        snapshot = await _firestore
            .collection('chats')
            .doc(_getChatRoomId())
            .collection('messages')
            .orderBy('timestamp', descending: true)
            .startAfterDocument(lastDocument!)
            .limit(pageSize)
            .get();
      } else {
        snapshot = await _firestore
            .collection('chats')
            .doc(_getChatRoomId())
            .collection('messages')
            .orderBy('timestamp', descending: true)
            .limit(pageSize)
            .get();
      }

      if (snapshot.docs.isNotEmpty) {
        lastDocument = snapshot.docs.last;

        // Tối ưu hóa kiểm tra trùng lặp bằng Set
        Set<String?> existingMessageIds =
            messages.map((msg) => msg.messageId).toSet();

        // Lọc và thêm các tin nhắn mới vào danh sách, tránh trùng lặp
        var newMessages = snapshot.docs
            .map((doc) =>
                MessageFriendModel.fromJson(doc.data() as Map<String, dynamic>))
            .where((newMessage) =>
                !existingMessageIds.contains(newMessage.messageId))
            .toList();

        if (newMessages.isNotEmpty) {
          messages
              .addAll(newMessages); // Thêm tất cả tin nhắn mới vào danh sách
        }
      }

      if (snapshot.docs.length < pageSize) {
        hasMoreMessages.value = false;
      }
    } catch (e) {
      errorMessage(e.toString());
    } finally {
      isLoadingMore.value = false;
    }
  }

  // Hàm gửi tin nhắn lên Firestore
  Future<void> sendMessage(
    String content,
    String? gifUrl,
  ) async {
    if (content.trim().isEmpty) {
      errorMessage("Please enter a message");
    }
    String id = _getChatRoomId() + uuid.v4().substring(0, 8);
    final message = MessageFriendModel(
      messageId: id,
      senderId: currentUserId,
      receiverId: friendId,
      content: content,
      gif: gifUrl,
      timestamp: Timestamp.now(),
      status: 'unseen',
    );

    await _firestore
        .collection('chats')
        .doc(_getChatRoomId())
        .collection('messages')
        .doc(id)
        .set(message.toJson())
        .catchError(
            (e) => errorMessage("Please enter a message with lighter content"));
  }

  // Hàm gửi tin nhắn lên Firestore
  Future<void> sendImageMessage(
    String? content,
    XFile imageFile,
  ) async {
    List<int> imageBytes = await imageFile.readAsBytes();
    String? base64String = base64Encode(imageBytes);

    // Kiểm tra kích thước của chuỗi Base64
    int base64Size = CompressImageFunction.calculateBase64Size(base64String);
    if (base64Size > 999999) {
      errorMessage("Please pick a image which is lighter than 1 mega byte");
    }

    String id = _getChatRoomId() + uuid.v4().substring(0, 8);
    final message = MessageFriendModel(
      messageId: id,
      senderId: currentUserId,
      receiverId: friendId,
      content: content,
      imagePath: base64String,
      timestamp: Timestamp.now(),
      status: 'unseen',
    );

    await _firestore
        .collection('chats')
        .doc(_getChatRoomId())
        .collection('messages')
        .doc(id)
        .set(message.toJson())
        .catchError((e) => errorMessage("Please, pick another image"));
  }

  Future<void> deleteMessage(String messageId) async {
    await _firestore
        .collection('chats')
        .doc(_getChatRoomId())
        .collection('messages')
        .doc(messageId)
        .delete()
        .catchError((e) => errorMessage(e));
  }

  //todo function for reply message
  Future<void> shareMessage(String content, String targetUserId) async {
    String id = _getChatRoomId() + uuid.v4().substring(0, 8);
    final message = MessageFriendModel(
      messageId: id,
      senderId: currentUserId,
      receiverId: targetUserId,
      content: content,
      timestamp: Timestamp.now(),
      status: 'unseen',
    );

    await FirebaseFirestore.instance
        .collection('chats')
        .doc(_getChatRoomId())
        .collection('messages')
        .doc(id)
        .set(message.toJson())
        .catchError((e) => errorMessage("Please, pick another image"));
  }

  //auto delete message after time out
  Future<void> deleteOldMessages() async {
    final Timestamp sevenDaysAgo = Timestamp.fromDate(
      DateTime.now().subtract(const Duration(days: 365)),
    );

    try {
      QuerySnapshot snapshot = await _firestore
          .collection('chats')
          .doc(_getChatRoomId())
          .collection('messages')
          .where('timestamp', isLessThan: sevenDaysAgo)
          .get();

      for (var doc in snapshot.docs) {
        await _firestore
            .collection('chats')
            .doc(_getChatRoomId())
            .collection('messages')
            .doc(doc.id)
            .delete()
            .catchError((e) => errorMessage('Error deleting old messages: $e'));
      }
    } catch (e) {
      errorMessage('Error deleting old messages: $e');
    }
  }

  Future<void> setThemeForChatRoom({required List<String>? colors}) async {
    ChatFriendSettingsModel chatFriendSettingsModel = ChatFriendSettingsModel(
      id: currentUserId,
      themeColors: colors,
      isNotified: true,
    );
    await _firestore
        .collection('chats')
        .doc(_getChatRoomId())
        .set(chatFriendSettingsModel.toJson())
        .catchError((e) => errorMessage(e));
  }

  Future<void> setDefaultThemeForChatRoom() async {
    await _firestore
        .collection('chats')
        .doc(_getChatRoomId())
        .update({'themeColors': FieldValue.delete()}).catchError(
            (e) => errorMessage(e));
  }

  Rx<ChatFriendSettingsModel> chatSettings = ChatFriendSettingsModel().obs;
  void listenToChatSettings() {
    _firestore
        .collection('chats')
        .doc(_getChatRoomId())
        .snapshots()
        .listen((snapshot) {
      if (snapshot.exists) {
        final data = snapshot.data();
        if (data != null) {
          chatSettings.value = ChatFriendSettingsModel.fromJson(data);
        }
      }
    });
  }

  // Tạo ID phòng chat dựa trên userId và friendId
  String _getChatRoomId() {
    return currentUserId.hashCode <= friendId.hashCode
        ? '$currentUserId-$friendId'
        : '$friendId-$currentUserId';
  }

  Timer? _scrollStopTimer;
  // Hàm xử lý khi có sự kiện cuộn
  void _onScroll() {
    // Khi người dùng cuộn, đặt isSearching thành true
    isSearching.value = true;

    // Nếu Timer đang chạy thì hủy bỏ
    _scrollStopTimer?.cancel();

    // Tạo Timer mới: chờ 3 giây sau khi ngừng cuộn
    _scrollStopTimer = Timer(const Duration(seconds: 30), () {
      isSearching.value = false;
    });
  }

  @override
  void onClose() {
    messageSubscription?.cancel();
    scrollController.dispose();
    focusNode.dispose();
    super.onClose();
  }
}

  // Hàm lắng nghe tin nhắn theo thời gian thực
  // void listenToMessages() {
  //   messageSubscription = _firestore
  //       .collection('chats')
  //       .doc(_getChatRoomId())
  //       .collection('messages')
  //       .orderBy('timestamp', descending: true)
  //       .snapshots()
  //       .listen((QuerySnapshot snapshot) {
  //     messages.value = snapshot.docs
  //         .map((doc) =>
  //             MessageFriendModel.fromJson(doc.data() as Map<String, dynamic>))
  //         .toList();
  //   });
  // }

  // for (var doc in snapshot.docs) {
  //         MessageFriendModel newMessage =
  //             MessageFriendModel.fromJson(doc.data() as Map<String, dynamic>);

  //         // Kiểm tra xem messageId đã tồn tại trong danh sách chưa
  //         if (!messages.any((msg) => msg.messageId == newMessage.messageId)) {
  //           messages.add(newMessage); // Thêm tin nhắn vào danh sách
  //         }
  //       }


// Future<List<int>> compressImageIfNecessary(XFile imageFile) async {
//   File file = File(imageFile.path);
//   int fileSize = await file.length(); // Kích thước file ban đầu
  
//   // Kiểm tra nếu file quá 1MB
//   if (fileSize > 1048576) {
//     int quality = getQualityBasedOnSize(fileSize); // Tính quality dựa vào kích thước file

//     List<int>? compressedImage = await FlutterImageCompress.compressWithFile(
//       imageFile.path,
//       quality: quality, // Nén với mức chất lượng thích hợp
//     );
//     if (compressedImage != null) {
//       print("Compressed from ${fileSize / 1024} KB to ${compressedImage.length / 1024} KB");
//       return compressedImage;
//     } else {
//       print("Compression failed. Returning original image bytes.");
//       return await imageFile.readAsBytes(); // Trả về file gốc nếu nén thất bại
//     }
//   } else {
//     print("Image size is under 1MB, no compression needed.");
//     return await imageFile.readAsBytes(); // Không cần nén
//   }
// }

// // Hàm tính toán quality dựa vào kích thước file
// int getQualityBasedOnSize(int fileSize) {
//   // Ví dụ logic: càng lớn thì quality càng thấp
//   if (fileSize > 5000000) {
//     return 30; // Nếu > 5MB thì nén với chất lượng 30%
//   } else if (fileSize > 3000000) {
//     return 50; // Nếu > 3MB thì nén với chất lượng 50%
//   } else if (fileSize > 2000000) {
//     return 70; // Nếu > 2MB thì nén với chất lượng 70%
//   } else {
//     return 85; // Nếu > 1MB thì nén với chất lượng 85%
//   }
// }

```

---


### Data\fetch_firestore_database.dart

```dart
import 'dart:async';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:get/get.dart';
import 'package:latlong2/latlong.dart';
import 'package:tictactoe_gameapp/Configs/messages.dart';
import 'package:tictactoe_gameapp/Controller/auth_controller.dart';
import 'package:tictactoe_gameapp/Models/user_model.dart';

class FirestoreController extends GetxController {
  // Tạo một observable để lưu trữ danh sách người dùng
  var usersList = <UserModel>[].obs;
  // Danh sách bạn bè của user
  var friendsList = <UserModel>[].obs;
  var filterfriendsList = <UserModel>[].obs;
  var searchText = ''.obs;
  var isLoadingFriends = false.obs;

  final FirebaseFirestore _firestore = FirebaseFirestore.instance;
  final String userId = Get.find<AuthController>().getCurrentUserId();

  // Đăng ký subscription cho dữ liệu thời gian thực
  late StreamSubscription usersSubscription;
  late StreamSubscription friendsSubscription;

  @override
  void onInit() {
    super.onInit();
    fetchUsers();
    loadFriendsLive();
    setupSearchListener();
  }

  // Fetch dữ liệu từ Firestore theo thời gian thực
  void fetchUsers() {
    try {
      usersSubscription =
          _firestore.collection('users').snapshots().listen((snapshot) {
        usersList.value =
            snapshot.docs.map((doc) => UserModel.fromJson(doc.data())).toList();
      }, onError: (e) {
        errorMessage(e.toString());
      });
    } catch (e) {
      errorMessage('Failed to fetch users: $e');
    }
  }

  // Thêm bạn vào danh sách
  Future<void> addFriend(String friendId, String userId) async {
    try {
      await _firestore.collection('users').doc(userId).update({
        'friendsList': FieldValue.arrayUnion([friendId])
      }).catchError((e) => errorMessage(e.toString()));
      // await loadFriends();
    } catch (e) {
      errorMessage('Failed to add friend: $e');
    }
  }

  Future<void> removeFriend(String friendId) async {
    try {
      await _firestore.collection('users').doc(userId).update({
        'friendsList': FieldValue.arrayRemove([friendId])
      }).catchError((e) => errorMessage(e.toString()));
      // await loadFriends();
    } catch (e) {
      errorMessage('Failed to remove friend: $e');
    }
  }

  Future<void> loadFriendsLive() async {
    if (isLoadingFriends.value) return;
    isLoadingFriends.value = true;
    try {
      friendsSubscription = _firestore
          .collection('users')
          .doc(userId)
          .snapshots()
          .listen((DocumentSnapshot userSnapshot) async {
        if (userSnapshot.exists) {
          friendsList.clear(); // Xóa danh sách bạn bè hiện tại để cập nhật
          List<dynamic> friendsIds = userSnapshot['friendsList'] ?? [];

          // Nếu có bạn bè, tải thông tin bạn bè
          if (friendsIds.isNotEmpty) {
            List<UserModel> updatedFriends = [];
            for (String friendId in friendsIds) {
              DocumentSnapshot friendSnapshot = await FirebaseFirestore.instance
                  .collection('users')
                  .doc(friendId)
                  .get();

              if (friendSnapshot.exists) {
                UserModel friend = UserModel.fromJson(
                    friendSnapshot.data() as Map<String, dynamic>);
                updatedFriends.add(friend);
              }
            }
            friendsList.value = updatedFriends; // Cập nhật danh sách bạn bè
          } else {
            friendsList.clear(); // Nếu không có bạn bè, danh sách sẽ rỗng
          }
        }
        filterFriends();
      }, onError: (e) {
        errorMessage(e.toString());
      });
    } catch (e) {
      errorMessage(e.toString());
    } finally {
      isLoadingFriends.value = false;
    }
  }

  RxBool isFriend(String friendId) {
    return RxBool(friendsList.any((friend) => friend.id == friendId));
  }

  // Hàm thiết lập lắng nghe sự thay đổi của searchText
  void setupSearchListener() {
    debounce(searchText, (_) => filterFriends(),
        time: const Duration(milliseconds: 300));
  }

  // Hàm lọc friendRequests dựa trên searchText
  void filterFriends() {
    // Nếu không có nội dung tìm kiếm, hiển thị toàn bộ friendRequests
    if (searchText.isEmpty) {
      filterfriendsList.assignAll(friendsList);
    } else {
      final searchLower = searchText.value.toLowerCase();

      // Lọc danh sách theo nội dung tìm kiếm
      filterfriendsList.assignAll(friendsList.where((friends) {
        final name = friends.name!.toLowerCase();
        return name.contains(searchLower);
      }).toList());
    }
  }

  // Hàm cập nhật nội dung tìm kiếm khi người dùng nhập text
  void updateSearchText(String text) {
    searchText.value =
        text.toLowerCase(); // Chuyển sang chữ thường khi cập nhật
  }

  // Hàm cập nhật totalCoins và totalWins
  Future<void> incrementCoinsAndWins(int coinEarned) async {
    try {
      int userIndex = usersList.indexWhere((user) => user.id == userId);

      // Tăng totalCoins lên 10 và totalWins lên 1
      int newCoins = int.parse(usersList[userIndex].totalCoins ?? "0") + coinEarned;
      int newWins = int.parse(usersList[userIndex].totalWins ?? "0") + 1;

      // Cập nhật dữ liệu trong Firestore
      await _firestore.collection('users').doc(userId).update({
        'totalCoins': newCoins.toString(),
        'totalWins': newWins.toString(),
      }).catchError((e) => errorMessage(e.toString()));

      // Cập nhật danh sách người dùng trong ứng dụng
      if (userIndex != -1) {
        usersList[userIndex].totalCoins = newCoins.toString();
        usersList[userIndex].totalWins = newWins.toString();
        usersList.refresh(); // Cập nhật giao diện
      }
    } catch (e) {
      errorMessage(e.toString());
    }
  }

  late LatLng latlng;
  Future<void> fetchUserLocation() async {
    await _firestore.collection('users').doc(userId).get().then((value) {
      UserModel user = UserModel.fromJson(value.data()!);
      if (user.location != null) {
        latlng = LatLng(user.location!.latitude, user.location!.longitude);
      } else {
        latlng = const LatLng(21.0000992, 105.8399243);
      }
    });
  }

  @override
  void onClose() {
    usersSubscription.cancel();
    friendsSubscription.cancel();
    super.onClose();
  }

}

```

---


### Data\gemini_api_controller.dart

```dart
import 'dart:async';

import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:google_generative_ai/google_generative_ai.dart';
import 'package:image_picker/image_picker.dart';
import 'package:tictactoe_gameapp/Components/extensions.dart';
import 'package:tictactoe_gameapp/Configs/constants.dart';
import 'package:tictactoe_gameapp/Configs/messages.dart';
import 'package:tictactoe_gameapp/Models/gemini_model.dart';

class ChatController extends GetxController {
  var messages = <Message>[].obs;
  var isLoading = false.obs;
  late GenerativeModel flashModel;
  late GenerativeModel proModel;
  late final ScrollController scrollController;

  @override
  void onInit() {
    super.onInit();
    flashModel = GenerativeModel(
      model: 'gemini-1.5-flash-latest', //"gemini-2.0-flash-latest",
      apiKey: apiGemini,
    );
    proModel = GenerativeModel(
      model: 'gemini-1.5-pro-latest',
      apiKey: apiGemini,
    );
    scrollController = ScrollController();
    scrollDown();
  }

  Future<void> sendPrompt(String userInput) async {
    if (userInput.trim().isEmpty) return;

    final userMessage = Message(
      content: userInput,
      isUser: true,
      timestamp: DateTime.now(),
    );
    messages.add(userMessage);

    isLoading.value = true;

    try {
      final prompt = [Content.text(userInput)];
      final response = await flashModel.generateContent(prompt);

      final botMessage = Message(
        content: response.text ?? 'No response',
        isUser: false,
        timestamp: DateTime.now(),
      );

      messages.add(botMessage);
      displayMessage(botMessage);

      if (response.text != null) {
        scrollDown();
      }
    } catch (e) {
      generalCatcheFunction(e);
    } finally {
      isLoading.value = false;
    }
  }

  Future<void> sendPromptWithImage(String userInput, XFile? image) async {
    if (userInput.trim().isEmpty) return;

    final userMessage = Message(
      content: userInput,
      isUser: true,
      timestamp: DateTime.now(),
      imagePath: image!.path,
    );
    messages.add(userMessage);

    isLoading.value = true;

    try {
      // convert it to Uint8List
      final imageBytes = await image.readAsBytes();

      // Define your parts
      final promptText = TextPart(userInput);
      final mimeType = image.getMimeTypeFromExtension();
      final imagePart = DataPart(mimeType, imageBytes);

      // Make a mutli-model request to Gemini API
      final prompt = [
        Content.multi([
          promptText,
          imagePart,
        ])
      ];

      final response = await proModel.generateContent(prompt);

      final botMessage = Message(
        content: response.text ?? 'No response',
        isUser: false,
        timestamp: DateTime.now(),
      );
      messages.add(botMessage);
      displayMessage(botMessage);
      if (response.text != null) {
        scrollDown();
      }
    } catch (e) {
      generalCatcheFunction(e);
    } finally {
      isLoading.value = false;
    }
  }

  void generalCatcheFunction(Object e) {
    errorMessage(e.toString());
    final alertFromBot = Message(
      content: contentAlertChatBot,
      isUser: false,
      timestamp: DateTime.now(),
    );
    messages.add(alertFromBot);
    displayMessage(alertFromBot);
  }

  void scrollDown() {
    WidgetsBinding.instance.addPostFrameCallback((_) {
      if (scrollController.hasClients) {
        scrollController.animateTo(
          scrollController.position.maxScrollExtent,
          duration: const Duration(milliseconds: 750),
          curve: Curves.easeOut,
        );
      }
    });
  }

  Timer? _hideButtonTimer;
  RxBool isOpenedJumpButton = false.obs;
  void resetHideButtonTimer() {
    _hideButtonTimer?.cancel();
    _hideButtonTimer = Timer(const Duration(seconds: 3), () {
      isOpenedJumpButton.value = false;
    });
  }

  Future<void> refreshChat() async {
    await Future.delayed(const Duration(milliseconds: 500));
    messages.clear();
  }

  void displayMessage(Message botMessage) {
    // Reset danh sách từ hiển thị của tin nhắn
    botMessage.displayedWords.clear();

    // Tách câu trả lời thành các từ
    final allWords = botMessage.content.split(' ');

    // Khởi chạy timer để hiển thị từng từ
    int index = 0;
    Timer.periodic(const Duration(milliseconds: 100), (timer) {
      if (index < allWords.length) {
        botMessage.displayedWords.add(allWords[index]);
        index++;
      } else {
        timer.cancel(); // Dừng khi đã hiển thị xong
      }
    });
  }

  @override
  void onClose() {
    scrollController.dispose();
    super.onClose();
  }
}

```

---


### Enums\firebase_exception.dart

```dart
import 'package:firebase_auth/firebase_auth.dart';

enum AuthStatus {
  successful,
  wrongPassword,
  emailAlreadyExists,
  invalidEmail,
  weakPassword,
  userNotFound,
  userDisabled,
  tooManyRequests,
  operationNotAllowed,
  networkRequestFailed,
  invalidCredential,
  unknown,
}

class AuthExceptionHandler {
  static AuthStatus handleAuthException(FirebaseAuthException e) {
    switch (e.code) {
      case "invalid-email":
        return AuthStatus.invalidEmail;
      case "wrong-password":
        return AuthStatus.wrongPassword;
      case "weak-password":
        return AuthStatus.weakPassword;
      case "email-already-in-use":
        return AuthStatus.emailAlreadyExists;
      case "user-not-found":
        return AuthStatus.userNotFound;
      case "user-disabled":
        return AuthStatus.userDisabled;
      case "too-many-requests":
        return AuthStatus.tooManyRequests;
      case "operation-not-allowed":
        return AuthStatus.operationNotAllowed;
      case "network-request-failed":
        return AuthStatus.networkRequestFailed;
      case "invalid-credential":
        return AuthStatus.invalidCredential;
      default:
        return AuthStatus.unknown;
    }
  }

  static String generateErrorMessage(AuthStatus status) {
    switch (status) {
      case AuthStatus.invalidEmail:
        return "Your email address appears to be malformed.";
      case AuthStatus.weakPassword:
        return "Your password should be at least 6 characters.";
      case AuthStatus.wrongPassword:
        return "Your email or password is wrong.";
      case AuthStatus.emailAlreadyExists:
        return "The email address is already in use by another account.";
      case AuthStatus.userNotFound:
        return "No user found with this email.";
      case AuthStatus.userDisabled:
        return "This user has been disabled.";
      case AuthStatus.tooManyRequests:
        return "Too many requests. Try again later.";
      case AuthStatus.operationNotAllowed:
        return "Operation not allowed. Please contact support.";
      case AuthStatus.networkRequestFailed:
        return "Network error. Please check your connection.";
      case AuthStatus.invalidCredential:
        return "The supplied auth credential is incorrect, malformed, or has expired.";
      default:
        return "An unknown error occurred. Please try again.";
    }
  }
}

```

---


### Enums\popup_position.dart

```dart
enum PopupPosition {
  above,  // Overlay nằm phía trên widget và tam giác nằm dưới
  below,  // Overlay nằm phía dưới widget và tam giác nằm trên
  left,   // Overlay nằm bên trái widget và tam giác nằm bên phải
  right,  // Overlay nằm bên phải widget và tam giác nằm bên trái
}

```

---


### Models\call_model.dart

```dart
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:tictactoe_gameapp/Models/user_model.dart';

class CallModel {
  String? id;
  UserModel? callerUser;
  UserModel? receiverUser;
  String? status;
  DateTime? createdAt;

  CallModel({
    this.id,
    this.callerUser,
    this.receiverUser,
    this.status,
    this.createdAt,
  });

  CallModel.fromJson(Map<String, dynamic> json) {
    if (json["id"] is String) {
      id = json["id"];
    }
    if (json["callerUser"] is Map) {
      callerUser = json["callerUser"] == null
          ? null
          : UserModel.fromJson(json["callerUser"]);
    }
    if (json["receiverUser"] is Map) {
      receiverUser = json["receiverUser"] == null
          ? null
          : UserModel.fromJson(json["receiverUser"]);
    }
    if (json["status"] is String) {
      status = json["status"];
    }
    if (json['createdAt'] is Timestamp) {
      createdAt = (json['createdAt'] as Timestamp).toDate();
    }
  }

  Map<String, dynamic> toJson() {
    final Map<String, dynamic> data = <String, dynamic>{};
    data["id"] = id;
    if (callerUser != null) {
      data["callerUser"] = callerUser?.toJson();
    }
    if (receiverUser != null) {
      data["receiverUser"] = receiverUser?.toJson();
    }
    if (status != null) {
      data["status"] = status;
    }
    if (createdAt != null) {
      data['createdAt'] = createdAt?.toUtc();
    }
    return data;
  }
}

```

---


### Models\champion_model.dart

```dart
class ChampionModel {
  final String? image;
  final String? name;

  ChampionModel({this.image, this.name});

  static String capitalize(String s) {
    if (s.isEmpty) return s; // Kiểm tra chuỗi rỗng
    return s[0].toUpperCase() + s.substring(1);
  }

  static String capitalizeEachWord(String s) {
    if (s.isEmpty) return s;
    return s
        .split(' ')
        .map((word) => word[0].toUpperCase() + word.substring(1))
        .join(' ');
  }
}

```

---


### Models\chat_friend_settings_model.dart

```dart
class ChatFriendSettingsModel {
  String? id;
  List<String>? themeColors;
  bool? isNotified;

  ChatFriendSettingsModel({
    this.id,
    this.themeColors,
    this.isNotified,
  });

  ChatFriendSettingsModel.fromJson(Map<String, dynamic> json) {
    if (json["id"] is String) {
      id = json["id"];
    }
    if (json["themeColors"] is List) {
      themeColors = List<String>.from(json["themeColors"]);
    }
    if (json["isNotified"] is bool) {
      isNotified = json["isNotified"];
    }
  }

  Map<String, dynamic> toJson() {
    final Map<String, dynamic> data = <String, dynamic>{};
    data["id"] = id;
    data["themeColors"] = themeColors;
    data["isNotified"] = isNotified;
    return data;
  }
}

```

---


### Models\gemini_model.dart

```dart
import 'package:get/get_rx/src/rx_types/rx_types.dart';

class Message {
  final String content;
  final String? imagePath;
  final bool isUser;
  final DateTime timestamp;
   final RxList<String> displayedWords;

  Message({
    required this.content,
    required this.isUser,
    required this.timestamp,
    this.imagePath,
  }) : displayedWords = <String>[].obs;
}

```

---


### Models\general_notifications_model.dart

```dart
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:tictactoe_gameapp/Models/user_model.dart';

class GeneralNotificationsModel {
  String? id;
  String? senderId;
  UserModel? senderModel;
  String? receiverId;
  String? message;
  String? type;
  Timestamp? timestamp;
  bool? isReaded;
  bool? isVideoCall;
  String? roomId;
  String? postId;
  String? commentId;
  int count = 1;

  GeneralNotificationsModel({
    this.id,
    this.senderId,
    this.senderModel,
    this.receiverId,
    this.message,
    this.type,
    this.timestamp,
    this.isReaded,
    this.isVideoCall,
    this.roomId,
    this.postId,
    this.commentId,
    this.count = 1,
  });

  GeneralNotificationsModel.fromJson(Map<String, dynamic> json) {
    if (json["id"] is String) {
      id = json["id"];
    }
    if (json["senderId"] is String) {
      senderId = json["senderId"];
    }
    if (json["senderModel"] is Map) {
      senderModel = json["senderModel"] == null
          ? null
          : UserModel.fromJson(json["senderModel"]);
    }
    if (json["receiverId"] is String) {
      receiverId = json["receiverId"];
    }
    if (json["message"] is String) {
      message = json["message"];
    }
    if (json["type"] is String) {
      type = json["type"];
    }
    if (json["timestamp"] is Timestamp) {
      timestamp = json["timestamp"];
    }
    if (json["isReaded"] is bool) {
      isReaded = json["isReaded"];
    }
    if (json["isVideoCall"] is bool) {
      isVideoCall = json["isVideoCall"];
    }
    if (json["roomId"] is String) {
      roomId = json["roomId"];
    }
    if (json["postId"] is String) {
      postId = json["postId"];
    }
    if (json["commentId"] is String) {
      commentId = json["commentId"];
    }
    count = json["count"] ?? 1;
  }

  Map<String, dynamic> toJson() {
    final Map<String, dynamic> data = <String, dynamic>{};
    data["id"] = id;
    data["senderId"] = senderId;
    if (senderModel != null) {
      data["senderModel"] = senderModel?.toJson();
    }
    data["receiverId"] = receiverId;
    data["message"] = message;
    data["type"] = type;
    data["timestamp"] = timestamp;
    data["isReaded"] = isReaded;
    data["isVideoCall"] = isVideoCall;
    data["roomId"] = roomId;
    data["postId"] = postId;
    data["commentId"] = commentId;
    data["count"] = count;
    return data;
  }
}

```

---


### Models\live_sream_model.dart

```dart
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:tictactoe_gameapp/Models/user_model.dart';

class LiveStreamModel {
  String? streamId; // ID của livestream
  String? channelId; // ID channel
  UserModel? streamer; // Người tạo livestream
  String? title; // Tiêu đề livestream
  String? description; // Mô tả livestream
  String? thumbnailUrl; // Ảnh đại diện của livestream
  String? category;
  int? viewerCount; // Số lượng người xem hiện tại
  int? likeCount; // Tổng số lượt thích
  Map<String, Map<String, String>>? comments;
  List<String>? emotes;
  DateTime? createdAt; // Thời gian bắt đầu live

  LiveStreamModel({
    this.streamId,
    this.channelId,
    this.streamer,
    this.title,
    this.description,
    this.thumbnailUrl,
    this.category, // Thể loại livestream
    this.viewerCount,
    this.likeCount,
    this.comments,
    this.emotes,
    this.createdAt,
  });

  // Constructor để chuyển từ JSON sang LiveStreamModel
  LiveStreamModel.fromJson(Map<String, dynamic> json) {
    streamId = json['streamId'] as String?;
    channelId = json['channelId'] as String?;
    if (json["streamer"] is Map) {
      streamer = json["streamer"] == null
          ? null
          : UserModel.fromJson(json["streamer"]);
    }
    title = json['title'] as String?;
    description = json['description'] as String?;
    thumbnailUrl = json['thumbnailUrl'] as String?;
    category = json['category'] as String?; // Thể loại livestream
    viewerCount = json['viewerCount'] as int? ?? 0;
    likeCount = json['likeCount'] as int? ?? 0;
    if (json['comments'] is Map) {
      comments = (json['comments'] as Map<String, dynamic>).map(
        (key, value) => MapEntry(
          key,
          Map<String, String>.from(value),
        ),
      );
    }
    if (json['emotes'] is List) {
      emotes = List<String>.from(json['emotes']);
    }
    if (json['createdAt'] is Timestamp) {
      createdAt = (json['createdAt'] as Timestamp).toDate();
    }
  }

  // Phương thức để chuyển LiveStreamModel thành JSON
  Map<String, dynamic> toJson() {
    final Map<String, dynamic> data = <String, dynamic>{};
    data['streamId'] = streamId;
    data['channelId'] = channelId;
    if (streamer != null) {
      data["streamer"] = streamer?.toJson();
    }
    data['title'] = title;
    data['description'] = description;
    data['thumbnailUrl'] = thumbnailUrl;
    data['category'] = category; // Thể loại livestream
    data['viewerCount'] = viewerCount;
    data['likeCount'] = likeCount;
    if (comments != null) {
      data['comments'] = comments;
    }
    if (emotes!= null) {
      data['emotes'] = emotes;
    }
    if (createdAt != null) {
      data['createdAt'] = createdAt?.toUtc();
    }

    return data;
  }
}

```

---


### Models\message_friend_model.dart

```dart
import 'package:cloud_firestore/cloud_firestore.dart';

class MessageFriendModel {
  String? messageId;
  String? senderId;
  String? receiverId;
  String? content;
  String? imagePath;
  String? gif;
  Timestamp? timestamp;
  String? status;
  String? replyTo;

  MessageFriendModel({
    this.messageId,
    this.senderId,
    this.receiverId,
    this.content,
    this.imagePath,
    this.gif,
    this.timestamp,
    this.status,
    this.replyTo,
  });

  MessageFriendModel.fromJson(Map<String, dynamic> json) {
    if (json['messageId'] is String) {
      messageId = json['messageId'];
    }
    if (json['senderId'] is String) {
      senderId = json['senderId'];
    }
    if (json['receiverId'] is String) {
      receiverId = json['receiverId'];
    }
    if (json['content'] is String) {
      content = json['content'];
    }
    if (json['imagePath'] is String) {
      imagePath = json['imagePath'];
    }
    if (json['gif'] is String) {
      gif = json['gif'];
    }
    if (json['timestamp'] is Timestamp) {
      timestamp = json['timestamp'];
    }
    if (json['status'] is String) {
      status = json['status'];
    }
    if (json['replyTo'] is String) {
      replyTo = json['replyTo'];
    }
  }

  Map<String, dynamic> toJson() {
    final Map<String, dynamic> data = <String, dynamic>{};
    data['messageId'] = messageId;
    data['senderId'] = senderId;
    data['receiverId'] = receiverId;
    data['content'] = content;
    data['imagePath'] = imagePath;
    data['gif'] = gif;
    data['timestamp'] = timestamp;
    data['status'] = status;
    data['replyTo'] = replyTo;
    return data;
  }
}

```

---


### Models\minimax_arg.dart

```dart
class MinimaxArguments {
  final List<List<String>> board;
  final String currentPlayer;
  final int depth;
  final int alpha;
  final int beta;
  final int winLength;

  MinimaxArguments({
    required this.board,
    required this.currentPlayer,
    required this.depth,
    required this.alpha,
    required this.beta,
    required this.winLength,
  });
}

```

---


### Models\queue_model.dart

```dart
import 'package:cloud_firestore/cloud_firestore.dart';

class QueueModel {
  String? userId;
  bool? isSearching;
  DateTime? createdAt;
  String? userEmail;

  QueueModel({
    this.userId,
    this.isSearching,
    required this.createdAt,
    this.userEmail,
  });

  QueueModel.fromJson(Map<String, dynamic> json) {
    userId = json['userId'];
    isSearching = json['isSearching'];
    createdAt = (json['createdAt'] as Timestamp).toDate();
    userEmail = json['userEmail'];
  }

  Map<String, dynamic> toJson() {
    return {
      'userId': userId,
      'isSearching': isSearching,
      'createdAt': createdAt != null ? Timestamp.fromDate(createdAt!) : null,
      'userEmail': userEmail,
    };
  }
}

```

---


### Models\room_model.dart

```dart
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:tictactoe_gameapp/Models/user_model.dart';

class RoomModel {
  String? id;
  String? winningPrize;
  UserModel? player1;
  UserModel? player2;
  String? gameStatus;
  String? player1Status;
  String? player2Status;
  List<String>? gameValue;
  bool? isXturn;
  DateTime? createdAt;
  String? pickedMap;
  String? winnerVariable;
  String? champX;
  String? champO;
  int? initialMode;
  int? winLengthMode;
  String? imageMode;
  String? mess;
  RoomModel({
    this.id,
    this.winningPrize,
    this.player1,
    this.player2,
    this.gameStatus,
    this.player1Status,
    this.player2Status,
    this.gameValue,
    this.isXturn,
    required this.createdAt,
    this.pickedMap,
    this.winnerVariable,
    this.champX,
    this.champO,
    this.initialMode,
    this.winLengthMode,
    this.imageMode,
    this.mess,
  });

  RoomModel.fromJson(Map<String, dynamic> json) {
    if (json["id"] is String) {
      id = json["id"];
    }
    if (json["winningPrize"] is String) {
      winningPrize = json["winningPrize"];
    }
    if (json["player1"] is Map) {
      player1 =
          json["player1"] == null ? null : UserModel.fromJson(json["player1"]);
    }
    if (json["player2"] is Map) {
      player2 =
          json["player2"] == null ? null : UserModel.fromJson(json["player2"]);
    }
    if (json["gameStatus"] is String) {
      gameStatus = json["gameStatus"];
    }
    if (json["player1Status"] is String) {
      player1Status = json["player1Status"];
    }
    if (json["player2Status"] is String) {
      player2Status = json["player2Status"];
    }
    if (json["gameValue"] != null) {
      gameValue = List<String>.from(json["gameValue"]);
    }
    if (json["isXturn"] is bool) {
      isXturn = json["isXturn"];
    }
    createdAt = json['createdAt'] != null
        ? (json['createdAt'] as Timestamp).toDate()
        : null;
    if (json["pickedMap"] is String) {
      pickedMap = json["pickedMap"];
    }
    if (json["winnerVariable"] is String) {
      winnerVariable = json["winnerVariable"];
    }
    if (json["champX"] is String) {
      champX = json["champX"];
    }
    if (json["champO"] is String) {
      champO = json["champO"];
    }
    if (json["initialMode"] is int) {
      initialMode = json["initialMode"];
    }
    if (json["winLengthMode"] is int) {
      winLengthMode = json["winLengthMode"];
    }
    if (json["imageMode"] is String) {
      imageMode = json["imageMode"];
    }
    if (json["mess"] is String) {
      mess = json["mess"];
    }
  }

  Map<String, dynamic> toJson() {
    final Map<String, dynamic> data = <String, dynamic>{};
    data["id"] = id;
    data["winningPrize"] = winningPrize;
    if (player1 != null) {
      data["player1"] = player1?.toJson();
    }
    if (player2 != null) {
      data["player2"] = player2?.toJson();
    }
    data["gameStatus"] = gameStatus;
    data["player1Status"] = player1Status;
    data["player2Status"] = player2Status;
    if (gameValue != null) {
      data["gameValue"] = gameValue;
    }
    data["isXturn"] = isXturn;
    if (createdAt != null) {
      data['createdAt'] = Timestamp.fromDate(createdAt!);
    }
    data["pickedMap"] = pickedMap;
    data["winnerVariable"] = winnerVariable;
    data["champX"] = champX;
    data["champO"] = champO;
    data["initialMode"] = initialMode;
    data["winLengthMode"] = winLengthMode;
    data["imageMode"] = imageMode;
    data["mess"] = mess;
    return data;
  }
}

```

---


### Models\user_model.dart

```dart
import 'package:cloud_firestore/cloud_firestore.dart';

class UserModel {
  String? id;
  String? name;
  String? email;
  String? image;
  String? totalWins;
  String? role;
  String? totalCoins;
  String? quickMess;
  String? quickEmote;
  List<String>? friendsList;
  String? status;
  Timestamp? lastActive;
  GeoPoint? location;
  List<String>? avatarFrame;

  UserModel({
    this.role,
    this.id,
    this.name,
    this.email,
    this.image,
    this.totalWins,
    this.totalCoins,
    this.quickMess,
    this.quickEmote,
    this.friendsList,
    this.status,
    this.lastActive,
    this.location,
    this.avatarFrame,
  });

  UserModel.fromJson(Map<String, dynamic> json) {
    if (json["id"] is String) {
      id = json["id"];
    }
    if (json["name"] is String) {
      name = json["name"];
    }
    if (json["email"] is String) {
      email = json["email"];
    }
    if (json["image"] is String) {
      image = json["image"];
    }
    if (json["totalWins"] is String) {
      totalWins = json["totalWins"];
    }
    if (json["role"] is String) {
      role = json["role"];
    }
    if (json["totalCoins"] is String) {
      totalCoins = json["totalCoins"];
    }
    if (json["quickMess"] is String) {
      quickMess = json["quickMess"];
    }
    if (json["quickEmote"] is String) {
      quickEmote = json["quickEmote"];
    }
    if (json["friendsList"] is List) {
      friendsList = List<String>.from(json["friendsList"]);
    }
    if (json["status"] is String) {
      status = json["status"];
    }
    if (json["lastActive"] is Timestamp) {
      lastActive = json["lastActive"];
    }
    location = json["location"] as GeoPoint?;
    if (json["avatarFrame"] is List) {
      avatarFrame = List<String>.from(json["avatarFrame"]);
    }
  }

  Map<String, dynamic> toJson() {
    final Map<String, dynamic> data = <String, dynamic>{};
    data["id"] = id;
    data["name"] = name;
    data["email"] = email;
    data["image"] = image;
    data["totalWins"] = totalWins;
    data["role"] = role;
    data["totalCoins"] = totalCoins;
    data["quickMess"] = quickMess;
    data["quickEmote"] = quickEmote;
    data["friendsList"] = friendsList;
    data["status"] = status;
    data["lastActive"] = lastActive;
    data["location"] = location;
    data["avatarFrame"] = avatarFrame;
    return data;
  }
}

```

---


### Models\Functions\color_string_reverse_function.dart

```dart
import 'dart:ui';

class ColorStringReverseFunction {
  static String colorToHex(Color color) {
    return '#${color.value.toRadixString(16).padLeft(8, '0').toUpperCase()}';
  }

  static Color hexToColor(String hex) {
    hex = hex.replaceAll('#', ''); // Loại bỏ dấu #
    if (hex.length == 6) {
      hex = 'FF$hex'; // Thêm alpha nếu thiếu
    }
    return Color(int.parse(hex, radix: 16));
  }
}

```

---


### Models\Functions\compress_image_function.dart

```dart
import 'dart:convert';
import 'dart:typed_data';
import 'package:image_picker/image_picker.dart';
import 'package:tictactoe_gameapp/Configs/messages.dart';
import 'package:tictactoe_gameapp/Pages/Society/Reels/api/video_thumbnail.dart';

class CompressImageFunction {
  static Future<List<String>> processImages(List<XFile>? imageFiles) async {
    List<String> base64ImageList = [];
    int totalBase64Size = 0;

    if (imageFiles == null || imageFiles.isEmpty) {
      return base64ImageList;
    }

    try {
      for (XFile imageFile in imageFiles) {
        List<int> imageBytes = await imageFile.readAsBytes();
        String base64String = base64Encode(imageBytes);

        // Tính kích thước Base64 của ảnh hiện tại
        int base64Size = calculateBase64Size(base64String);
        totalBase64Size += base64Size;

        // Kiểm tra nếu tổng kích thước ảnh vượt quá 1MB
        if (totalBase64Size > 999999) {
          errorMessage(
              "Total size of selected images exceeds 1 MB. Please select smaller images.");
          return []; // Trả về danh sách rỗng nếu kích thước vượt quá 1MB
        }

        base64ImageList.add(base64String);
      }
    } catch (e) {
      errorMessage("Error reading images: ${e.toString()}");
      return []; // Trả về danh sách rỗng nếu gặp lỗi
    }

    return base64ImageList;
  }

  static Future<String> processImage(XFile imageFile) async {
    try {
      List<int> imageBytes = await imageFile.readAsBytes();
      String? base64String = base64Encode(imageBytes);

      // Kiểm tra kích thước của chuỗi Base64
      int base64Size = CompressImageFunction.calculateBase64Size(base64String);
      if (base64Size > 999999) {
        errorMessage("Please pick a image which is lighter than 1 mega byte");
        return "";
      }
      return base64String;
    } catch (e) {
      errorMessage("Error reading image: ${e.toString()}");
      return "";
    }
  }

  static int calculateBase64Size(String base64String) {
    int padding = base64String.endsWith('==')
        ? 2
        : base64String.endsWith('=')
            ? 1
            : 0;
    int size = (base64String.length * 3 / 4).floor() - padding;
    return size; // Kích thước tính bằng byte
  }

  static Future<String?> generateThumbnailBase64(String videoUrl) async {
    try {
      // Tạo thumbnail từ video URL
      Uint8List? thumbnailData = await VideoThumbnail.thumbnailData(
        video: videoUrl,
        imageFormat: ImageFormat.WEBP, // Dùng JPEG để nén tốt hơn
        maxHeight: 480, // Chiều cao tối đa phù hợp mobile (720p/2)
        maxWidth: 270, // Chiều rộng tỉ lệ 9:16
        timeMs: 0, // Lấy khung hình đầu tiên
        quality: 75, // Chất lượng ban đầu
      );

      if (thumbnailData == null) {
        errorMessage("Failed to generate thumbnail from video");
        return null;
      }

      // Kiểm tra kích thước dữ liệu
      int sizeInBytes = thumbnailData.lengthInBytes;
      if (sizeInBytes > 500 * 1024) {
        // Nếu lớn hơn 500KB, nén thêm
        int quality = 75;
        while (sizeInBytes > 500 * 1024 && quality > 10) {
          quality -= 10;
          thumbnailData = await VideoThumbnail.thumbnailData(
            video: videoUrl,
            imageFormat: ImageFormat.WEBP,
            maxHeight: 480,
            maxWidth: 270,
            timeMs: 0,
            quality: quality,
          );
          sizeInBytes = thumbnailData!.lengthInBytes;
        }
      }

      // Chuyển thành base64
      String base64String = base64Encode(thumbnailData!);
      double base64Size =
          base64String.length * 0.75; // Ước tính kích thước bytes
      if (base64Size > 500 * 1024) {
        // Đảm bảo dưới 500KB để an toàn trong 1MB Firestore
        errorMessage("Thumbnail size exceeds limit after compression");
        return null;
      }

      return base64String;
    } catch (e) {
      errorMessage("Error generating thumbnail: $e");
      return null;
    }
  }
}

```

---


### Models\Functions\fetch_firestore_data_functions.dart

```dart
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:tictactoe_gameapp/Configs/messages.dart';
import 'package:tictactoe_gameapp/Models/user_model.dart';

class FetchFirestoreDataFunctions{
   final FirebaseFirestore _firestore = FirebaseFirestore.instance;
   Future<UserModel?> fetchUserByName(String name) async {
    try {
      // Tìm kiếm trong collection "users" với field "name"
      final QuerySnapshot<Map<String, dynamic>> querySnapshot = await _firestore
          .collection('users')
          .where('name', isEqualTo: name)
          .limit(1) // Giới hạn kết quả để chỉ lấy 1 user
          .get();

      // Nếu có kết quả, chuyển đổi document đầu tiên thành UserModel
      if (querySnapshot.docs.isNotEmpty) {
        final Map<String, dynamic> userData = querySnapshot.docs.first.data();
        return UserModel.fromJson(userData);
      }
    } catch (e) {
      // Xử lý lỗi (nếu có)
      errorMessage('Error fetching user by name: $e');
    }
    return null; // Trả về null nếu không tìm thấy hoặc xảy ra lỗi
  }
   Future<List<UserModel>> fetchPostLikeUsers(List<String> likeUserIds) async {
    try {
      // Tạo danh sách các futures để tải dữ liệu của từng user ID
      List<Future<DocumentSnapshot>> userSnapshotsFutures = likeUserIds
          .map(
            (userId) => _firestore.collection('users').doc(userId).get(),
          )
          .toList();

      // Chờ tất cả futures hoàn thành
      List<DocumentSnapshot> userSnapshots =
          await Future.wait(userSnapshotsFutures);

      // Lọc ra các user đã tồn tại và chuyển thành UserModel
      List<UserModel> likeUsers = userSnapshots
          .where((snapshot) => snapshot.exists)
          .map((snapshot) =>
              UserModel.fromJson(snapshot.data() as Map<String, dynamic>))
          .toList();

      return likeUsers;
    } catch (e) {
      errorMessage("Error fetching post like users: $e");
      return [];
    }
  }
}
```

---


### Models\Functions\general_bottomsheet_show_function.dart

```dart
import 'package:bottom_sheet/bottom_sheet.dart';
import 'package:flutter/material.dart';

class GeneralBottomsheetShowFunction {
  static Future<void> showScrollableGeneralBottomsheet({
    required Widget Function(BuildContext, ScrollController) widgetBuilder,
    required BuildContext context,
    required double initHeight,
    Color color = Colors.white,
  }) async {
    await showFlexibleBottomSheet(
      minHeight: 0,
      initHeight: initHeight,
      maxHeight: 1,
      context: context,
      builder: (context, scrollController, bottomSheet) =>
          widgetBuilder(context, scrollController),
      duration: const Duration(milliseconds: 500),
      bottomSheetColor: color,
      bottomSheetBorderRadius: const BorderRadius.only(
        topLeft: Radius.circular(20),
        topRight: Radius.circular(20),
      ),
      isSafeArea: true,
    );
  }
}

```

---


### Models\Functions\gradient_generator_functions.dart

```dart
import 'dart:math';
import 'package:flutter/material.dart';

class GradientGeneratorFunctions {
  // Hàm sinh gradient ngẫu nhiên
  static LinearGradient generateRandomGradient({required bool isDarkMode}) {
    // Tạo đối tượng Random
    final random = Random();

    // Hàm sinh màu ngẫu nhiên
    Color randomColor() {
      int r = random.nextInt(256);
      int g = random.nextInt(256);
      int b = random.nextInt(256);
      return Color.fromRGBO(r, g, b, 1);
    }

    // Sinh màu dựa trên mode
    Color startColor;
    Color endColor;

    if (isDarkMode) {
      // Tạo màu tối cho dark mode
      startColor = randomColor().withOpacity(0.8);
      endColor = randomColor().withOpacity(0.8);
    } else {
      // Tạo màu sáng cho light mode
      startColor = randomColor().withOpacity(0.6);
      endColor = randomColor().withOpacity(0.6);
    }

    // Trả về gradient ngẫu nhiên
    return LinearGradient(
      colors: [startColor, endColor],
      begin: Alignment.topLeft,
      end: Alignment.bottomRight,
    );
  }

  static List<Color> getDynamicRandomGradientColors({
    int colorCount = 5,
    bool isDarkMode = false,
  }) {
    final Random random = Random();
    final List<Color> colors = [];

    for (int i = 0; i < colorCount; i++) {
      // Sinh màu ngẫu nhiên
      Color randomColor = Color.fromARGB(
        255,
        random.nextInt(256),
        random.nextInt(256),
        random.nextInt(256),
      );

      // Điều chỉnh độ sáng tối cho isDarkMode
      if (isDarkMode) {
        randomColor = randomColor.withOpacity(0.8); // Màu tối hơn cho dark mode
      } else {
        randomColor =
            randomColor.withOpacity(0.6); // Màu sáng hơn cho light mode
      }

      colors.add(randomColor);
    }
    return colors;
  }

// Generate a random color
  static Color generateRandomColor() {
    final random = Random();
    return Color.fromARGB(
      255, // Always use full opacity
      random.nextInt(256), // Red
      random.nextInt(256), // Green
      random.nextInt(256), // Blue
    );
  }

  static String _getColorName(Color color) {
    if (color.red > color.green && color.red > color.blue) {
      return "Red";
    } else if (color.green > color.red && color.green > color.blue) {
      return "Green";
    } else if (color.blue > color.red && color.blue > color.green) {
      return "Blue";
    } else if (color.red == color.green && color.red > color.blue) {
      return "Yellow";
    } else if (color.red == color.blue && color.red > color.green) {
      return "Purple";
    } else {
      return "Gray";
    }
  }

  static String generateGradientName({required List<Color> colors}) {
    final Random random = Random();
    const adjectives = ["Vibrant", "Calm", "Energetic", "Peaceful", "Lively"];
    String primaryColorName = _getColorName(colors.first);
    const themes = ["Sunset", "Ocean", "Forest", "Rainbow", "Dusk"];

    return "${adjectives[random.nextInt(adjectives.length)]} "
        "$primaryColorName "
        "${themes[random.nextInt(themes.length)]}";
  }

  static List<Widget> generateGradientContainers({
    int length = 5,
    required bool isDarkMode,
  }) {
    return List.generate(length, (index) {
      // Sinh gradient mới cho mỗi container
      List<Color> colors = getDynamicRandomGradientColors(
        colorCount: 2, // Sử dụng 2 màu cho mỗi gradient
        isDarkMode: isDarkMode,
      );

      return Container(
        margin: const EdgeInsets.all(8.0),
        decoration: BoxDecoration(
          gradient: LinearGradient(
            colors: colors,
            begin: Alignment.topLeft,
            end: Alignment.bottomRight,
          ),
          borderRadius: BorderRadius.circular(10),
        ),
        height: 100, // Chiều cao của mỗi Container
        width: 200, // Để Container có thể giãn đầy đủ theo chiều ngang
      );
    });
  }
}

```

---


### Models\Functions\hyperlink_text_function.dart

```dart
import 'package:any_link_preview/any_link_preview.dart';
import 'package:flutter/gestures.dart';
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:tictactoe_gameapp/Components/placeholder_custom_widget.dart';
import 'package:tictactoe_gameapp/Configs/messages.dart';
import 'package:tictactoe_gameapp/Models/Functions/fetch_firestore_data_functions.dart';
import 'package:tictactoe_gameapp/Models/user_model.dart';
import 'package:tictactoe_gameapp/Pages/Society/About/user_about_page.dart';
import 'package:tictactoe_gameapp/Pages/Web/web_view_open.dart';

class HyperlinkTextFunction {
  // Mẫu biểu thức chính quy cho liên kết URL và tag người dùng
  static final RegExp combinedRegExp = RegExp(
    r'(http|https)://[\w-]+(\.[\w-]+)+([\w.,@?^=%&:/~+#-]*[\w@?^=%&/~+#-])?|@([a-zA-Z0-9_]+)',
  );

  // Hàm để xây dựng `TextSpan` với định dạng cho các liên kết và tag

// Hàm để xây dựng `TextSpan` với định dạng cho các liên kết và tag
  static List<InlineSpan> buildMessageText(
    BuildContext context, {
    required String text,
    required Color color,
    bool previewUrlMode = false,
    List<Color> colors = const [Colors.grey, Colors.grey],
  }) {
    final List<InlineSpan> spans = [];
    final Iterable<RegExpMatch> matches = combinedRegExp.allMatches(text);

    int lastMatchEnd = 0;

    for (final match in matches) {
      // Thêm đoạn text trước liên kết hoặc tag
      if (match.start > lastMatchEnd) {
        spans.add(TextSpan(text: text.substring(lastMatchEnd, match.start)));
      }

      // Xác định loại phát hiện (URL hoặc tag)
      final String matchedText = match.group(0)!;

      if (matchedText.startsWith('@')) {
        // Tag người dùng
        final String username = matchedText.substring(1); // Bỏ dấu @
        spans.add(
          TextSpan(
            text: matchedText,
            style: TextStyle(
              color: color,
              fontWeight: FontWeight.bold,
              decorationColor: color,
              fontSize: 18,
            ),
            recognizer: TapGestureRecognizer()
              ..onTap = () async => await openUserProfile(username),
          ),
        );
      } else {
        if (previewUrlMode) {
          spans.add(
            WidgetSpan(
              child: AnyLinkPreview(
                onTap: () => openLinkInWebView(matchedText),
                link: matchedText,
                displayDirection: UIDirection.uiDirectionHorizontal,
                cache: const Duration(hours: 1),
                backgroundColor: colors.last,
                titleStyle: const TextStyle(
                  color: Colors.white,
                  fontWeight: FontWeight.bold,
                  fontSize: 15,
                ),
                bodyStyle: const TextStyle(color: Colors.white54, fontSize: 13),
                placeholderWidget: const PlaceholderImageCustomWidget(),
                errorWidget: const ColoredBox(
                  color: Colors.red,
                  child: Padding(
                    padding: EdgeInsets.all(8.0),
                    child: Text(
                      'Oops???',
                      style: TextStyle(
                        color: Colors.white,
                        fontStyle: FontStyle.italic,
                      ),
                    ),
                  ),
                ),
                errorBody: 'Show my custom error body',
                errorTitle: 'Next one is youtube link, error title',
              ),
            ),
          );
        } else {
          spans.add(
            TextSpan(
              text: matchedText,
              style: TextStyle(
                color: color,
                decoration: TextDecoration.underline,
                decorationColor: color,
                decorationThickness: 2,
                fontStyle: FontStyle.italic,
              ),
              recognizer: TapGestureRecognizer()
                ..onTap = () => openLinkInWebView(matchedText),
            ),
          );
        }
      }

      lastMatchEnd = match.end;
    }

    // Thêm đoạn text sau liên kết hoặc tag cuối cùng
    if (lastMatchEnd < text.length) {
      spans.add(TextSpan(text: text.substring(lastMatchEnd)));
    }

    return spans;
  }

// Hàm để xây dựng TextSpan với định dạng cho các liên kết và tag
  // static TextSpan buildMessageText(
  //   return TextSpan(children: spans);
  // }

  // Mở liên kết trong WebView
  static void openLinkInWebView(String url) {
    final String formattedUrl = url.contains('http') ? url : 'https://$url';
    Get.to(() => WebViewOpen(url: formattedUrl), transition: Transition.zoom);
  }

  // Điều hướng đến trang hồ sơ của người dùng
  static Future<void> openUserProfile(String username) async {
    final FetchFirestoreDataFunctions fetchFirestoreDataFunctions =
        FetchFirestoreDataFunctions();
    final UserModel? tagUser =
        await fetchFirestoreDataFunctions.fetchUserByName(username);
    if (tagUser != null) {
      Get.to(
          () => UserAboutPage(
                unknownableUser: tagUser,
              ),
          transition: Transition.zoom);
    } else {
      errorMessage("This player profile is not exist");
    }
    // Thay thế bằng logic điều hướng đến trang hồ sơ của bạn
  }

  static TextSpan parseContent({
    required String content,
    required TextStyle defaultStyle,
    required Color linkColor,
    required Color tagColor,
  }) {
    final List<TextSpan> spans = [];
    final matches = combinedRegExp.allMatches(content);

    int lastMatchEnd = 0;

    for (final match in matches) {
      // Thêm đoạn text trước link hoặc tag
      if (match.start > lastMatchEnd) {
        spans.add(TextSpan(
          text: content.substring(lastMatchEnd, match.start),
          style: defaultStyle,
        ));
      }

      final matchedText = match.group(0)!;

      if (matchedText.startsWith('@')) {
        // Phát hiện tag @username
        final username = matchedText.substring(1);
        spans.add(
          TextSpan(
            text: matchedText,
            style: defaultStyle.copyWith(
              color: tagColor,
              fontWeight: FontWeight.bold,
            ),
            recognizer: TapGestureRecognizer()
              ..onTap = () async => await openUserProfile(username),
          ),
        );
      } else {
        // Phát hiện link URL
        spans.add(
          TextSpan(
            text: matchedText,
            style: defaultStyle.copyWith(
              color: linkColor,
              decoration: TextDecoration.underline,
              decorationColor: linkColor.withOpacity(0.5),
              decorationThickness: 2,
              fontStyle: FontStyle.italic,
            ),
            recognizer: TapGestureRecognizer()
              ..onTap = () => openLinkInWebView(matchedText),
          ),
        );
      }

      lastMatchEnd = match.end;
    }

    // Thêm đoạn text sau link hoặc tag cuối cùng
    if (lastMatchEnd < content.length) {
      spans.add(TextSpan(
        text: content.substring(lastMatchEnd),
        style: defaultStyle,
      ));
    }

    return TextSpan(children: spans);
  }
}

```

---


### Models\Functions\notification_add_functions.dart

```dart
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:tictactoe_gameapp/Configs/messages.dart';
import 'package:tictactoe_gameapp/Models/user_model.dart';
import 'package:tictactoe_gameapp/Models/general_notifications_model.dart';
import 'package:uuid/uuid.dart';

class NotificationAddFunctions {
  final FirebaseFirestore firestore;
  NotificationAddFunctions({required this.firestore});

  // Hàm tạo thông báo tổng quát
  Future<void> _createNotification({
    required String senderId,
    required UserModel senderModel,
    required String receiverId,
    required String message,
    required String type,
    String? roomId,
    String? postId,
    String? commentId,
  }) async {
    try {
      var uuid = const Uuid();
      String notifyId = uuid.v4();
      final docRef = firestore.collection('notifications').doc(notifyId);

      final notification = GeneralNotificationsModel(
        id: notifyId,
        senderId: senderId,
        senderModel: senderModel,
        receiverId: receiverId,
        message: message,
        type: type,
        timestamp: Timestamp.now(),
        isReaded: false,
        roomId: roomId,
        postId: postId,
        commentId: commentId,
      );

      await docRef
          .set(notification.toJson())
          .catchError((e) => errorMessage(e));
    } catch (e) {
      errorMessage('Error creating notification: $e');
    }
  }

  // Hàm tạo thông báo like
  Future<void> createLikeNotification({
    required String senderId,
    required UserModel senderModel,
    required String receiverId,
    required String postId,
  }) async {
    await _createNotification(
      senderId: senderId,
      senderModel: senderModel,
      receiverId: receiverId,
      message: "${senderModel.name} liked your post.",
      type: "like",
      postId: postId,
    );
  }

  // Hàm tạo thông báo comment
  Future<void> createCommentNotification({
    required String senderId,
    required UserModel senderModel,
    required String receiverId,
    required String postId,
    required String commentId,
    required String comment,
  }) async {
    await _createNotification(
      senderId: senderId,
      senderModel: senderModel,
      receiverId: receiverId,
      message: "${senderModel.name} commented on your post '$comment'",
      type: "comment",
      postId: postId,
      commentId: commentId,
    );
  }

  Future<void> createReelCommentNotification({
    required String senderId,
    required UserModel senderModel,
    required String receiverId,
    required String reelId,
    required String commentId,
    required String comment,
  }) async {
    await _createNotification(
      senderId: senderId,
      senderModel: senderModel,
      receiverId: receiverId,
      message: "${senderModel.name} commented on your reel '$comment'",
      type: "comment",
      postId: reelId,
      commentId: commentId,
    );
  }

  // Hàm tạo thông báo follow
  Future<void> createFollowNotification({
    required String senderId,
    required UserModel senderModel,
    required String receiverId,
  }) async {
    await _createNotification(
      senderId: senderId,
      senderModel: senderModel,
      receiverId: receiverId,
      message: "${senderModel.name} đã theo dõi bạn.",
      type: "follow",
    );
  }

  // Hàm tạo thông báo tin nhắn
  Future<void> createShareNotification({
    required String senderId,
    required UserModel senderModel,
    required String receiverId,
    required String postId,
  }) async {
    await _createNotification(
      senderId: senderId,
      senderModel: senderModel,
      receiverId: receiverId,
      message: "${senderModel.name} shared on a your post.",
      type: "share",
      postId: postId,
    );
  }

  Future<dynamic> getFieldDataFromCollection ({
    required String collectionPath,
    required String docId,
    required String fieldName,
  }) async {
    try {
      final docSnapshot =
          await firestore.collection(collectionPath).doc(docId).get();

      if (docSnapshot.exists) {
        return docSnapshot.data()![fieldName];
      } else {
        errorMessage("Document is not available");
        return null;
      }
    } catch (e) {
      errorMessage("Error fetching field data: $e");
      return null;
    }
  }
}

```

---


### Models\Functions\permission_handle_functions.dart

```dart
import 'package:permission_handler/permission_handler.dart';

class PermissionHandleFunctions {
  /// Kiểm tra và yêu cầu quyền Microphone
  Future<bool> checkMicrophonePermission() async {
    return await _checkAndRequestPermission(Permission.microphone);
  }

  /// Kiểm tra và yêu cầu quyền Camera
  Future<bool> checkCameraPermission() async {
    return await _checkAndRequestPermission(Permission.camera);
  }

  /// Kiểm tra và yêu cầu quyền Thông báo
  Future<bool> checkNotificationPermission() async {
    return await _checkAndRequestPermission(Permission.notification);
  }

  /// Kiểm tra và yêu cầu quyền Địa chỉ (Location)
  Future<bool> checkLocationPermission() async {
    return await _checkAndRequestPermission(Permission.location);
  }

  /// Kiểm tra tất cả các quyền cần thiết và trả về kết quả
  Future<Map<String, bool>> checkAllPermissions() async {
    return {
      "microphone": await checkMicrophonePermission(),
      "camera": await checkCameraPermission(),
      "notification": await checkNotificationPermission(),
      "location": await checkLocationPermission(),
    };
  }

  /// Hàm chung để kiểm tra và yêu cầu quyền
  Future<bool> _checkAndRequestPermission(Permission permission) async {
    var status = await permission.status;

    // Nếu quyền bị từ chối hoặc chưa xác định, yêu cầu lại
    if (status.isDenied || status.isRestricted || status.isPermanentlyDenied) {
      var result = await permission.request();
      return result.isGranted;
    }

    // Trả về `true` nếu đã có quyền
    return status.isGranted;
  }

  /// Kiểm tra xem quyền có bị từ chối vĩnh viễn hay không
  Future<bool> isPermissionPermanentlyDenied(Permission permission) async {
    return await permission.isPermanentlyDenied;
  }

  /// Chuyển hướng người dùng đến cài đặt ứng dụng nếu quyền bị từ chối vĩnh viễn
  Future<void> openAppSettingsIfDenied(Permission permission) async {
    if (await isPermissionPermanentlyDenied(permission)) {
      await openAppSettings();
    }
  }

}

```

---


### Models\Functions\time_functions.dart

```dart
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:flutter/material.dart';
import 'package:get/get_rx/src/rx_types/rx_types.dart';
import 'package:tictactoe_gameapp/Configs/messages.dart';

class TimeFunctions {
  static String timeAgo({required DateTime now, required DateTime createdAt}) {
    Duration difference = now.difference(createdAt);

    if (difference.inSeconds < 60) {
      return 'a few seconds ago'; // Dưới 1 phút
    }
    if (difference.inMinutes < 60) {
      return '${difference.inMinutes} minute${difference.inMinutes > 1 ? "s" : ""} ago'; // Dưới 1 giờ
    }
    if (difference.inHours < 24) {
      return '${difference.inHours} hour${difference.inHours > 1 ? "s" : ""} ago'; // Dưới 1 ngày
    }
    if (difference.inDays < 7) {
      return '${difference.inDays} day${difference.inDays > 1 ? "s" : ""} ago'; // Dưới 1 tuần
    }
    if (difference.inDays < 30) {
      int weeks = (difference.inDays / 7).floor();
      return '$weeks week${weeks > 1 ? "s" : ""} ago'; // Dưới 1 tháng
    }
    if (difference.inDays < 365) {
      int months = (difference.inDays / 30).floor();
      return '$months month${months > 1 ? "s" : ""} ago'; // Dưới 1 năm
    }

    int years = (difference.inDays / 365).floor();
    return '$years year${years > 1 ? "s" : ""} ago'; // Lâu hơn 1 năm
  }

  static String displayTimeDefault(Timestamp timestamp) {
    DateTime dateTime = timestamp.toDate();
    String hours = dateTime.hour.toString().padLeft(2, '0');
    String minutes = dateTime.minute.toString().padLeft(2, '0');
    return "$hours:$minutes";
  }

  static String displayTime(Timestamp timestamp) {
    DateTime dateTime = timestamp.toDate();

    // Lấy giờ theo định dạng 12 giờ
    int hour = dateTime.hour % 12 == 0 ? 12 : dateTime.hour % 12;
    String minutes = dateTime.minute.toString().padLeft(2, '0');

    // Xác định AM hay PM
    String period = dateTime.hour >= 12 ? 'PM' : 'AM';

    return "$hour:$minutes $period";
  }

  static String displayDate(Timestamp timestamp) {
    DateTime dateTime = timestamp.toDate();
    String day = dateTime.day.toString().padLeft(2, '0');
    String month = dateTime.month.toString().padLeft(2, '0');
    String year = dateTime.year.toString();
    return "$day/$month/$year";
  }

  static String displayTimeCount(int totalSeconds) {
    int minutes = totalSeconds ~/ 60;
    int seconds = totalSeconds % 60;
    return '${minutes.toString().padLeft(2, '0')} : ${seconds.toString().padLeft(2, '0')}';
  }

  static String formatDateTime(DateTime dateTime) {
    return "${_padZero(dateTime.day)}/${_padZero(dateTime.month)}/${dateTime.year} - "
        "${_padZero(dateTime.hour)}:${_padZero(dateTime.minute)}";
  }

  static String getFormattedTime(RxInt timeLeft) {
    // Định dạng thời gian phút:giây
    int minutes = timeLeft.value ~/ 60;
    int seconds = timeLeft.value % 60;
    // Nếu còn nhiều hơn 60 giây, hiển thị phút:giây
    return timeLeft.value >= 60
        ? '$minutes:${seconds.toString().padLeft(2, '0')}'
        : '$seconds';
  }

  /// Hàm thêm số 0 phía trước nếu số nhỏ hơn 10
  static String _padZero(int value) {
    return value < 10 ? "0$value" : value.toString();
  }

  // Hiển thị DatePicker với điều kiện thời gian chọn phải lớn hơn hiện tại
  static Future<DateTime?> pickDate({
    required BuildContext context,
    DateTime? initialDate,
  }) async {
    final currentDate = DateTime.now();
    initialDate ??= currentDate;

    if (initialDate.isBefore(
        DateTime(currentDate.year, currentDate.month, currentDate.day))) {
      initialDate = currentDate;
    }

    return showDatePicker(
      context: context,
      initialDate: initialDate,
      firstDate: DateTime(currentDate.year - 5),
      lastDate: DateTime(currentDate.year + 5),
      selectableDayPredicate: (DateTime day) {
        // Chỉ cho phép chọn các ngày hôm nay hoặc sau đó
        return !day.isBefore(
            DateTime(currentDate.year, currentDate.month, currentDate.day));
      },
    );
  }

  /// Hiển thị TimePicker
  static Future<TimeOfDay?> pickTime(
      {required BuildContext context, TimeOfDay? initialTime}) async {
    initialTime ??= TimeOfDay.now();

    return showTimePicker(
      context: context,
      initialTime: initialTime,
    );
  }

  /// Hiển thị DateTime Picker với điều kiện thời gian lớn hơn hiện tại
  static Future<DateTime?> pickDateTime(BuildContext context,
      {DateTime? initialDateTime}) async {
    DateTime now = DateTime.now();
    initialDateTime ??= now;

    // Chọn ngày
    DateTime? selectedDate = await pickDate(
      context: context,
      initialDate: initialDateTime,
    );
    if (selectedDate == null) return null; // Người dùng hủy chọn ngày

    // Chọn giờ
    TimeOfDay? selectedTime = await pickTime(
      context: context,
      initialTime: TimeOfDay.fromDateTime(initialDateTime),
    );
    if (selectedTime == null) return null; // Người dùng hủy chọn thời gian

    // Kết hợp ngày và giờ
    DateTime selectedDateTime = DateTime(
      selectedDate.year,
      selectedDate.month,
      selectedDate.day,
      selectedTime.hour,
      selectedTime.minute,
    );

    // Kiểm tra nếu thời gian chọn nhỏ hơn hiện tại
    if (selectedDateTime.isBefore(now)) {
      errorMessage("Please select a deadline before the current");
      return null;
    }

    return selectedDateTime;
  }
}

```

---


### Pages\Admin\app_routes.dart

```dart
import 'package:get/get.dart';
import 'package:tictactoe_gameapp/Pages/Admin/middlewares/admin_middleware.dart';
import 'package:tictactoe_gameapp/Pages/Admin/Pages/admin_setting_page.dart';
import 'package:tictactoe_gameapp/Pages/Admin/Pages/admin_home_page.dart';

class AdminRoutes {
  static List<GetPage> routes = [
    GetPage(
      name: '/admin',
      page: () => const AdminDashboardPage(),
      middlewares: [AdminMiddleware()],
    ),
    GetPage(
      name: '/admin/settings',
      page: () => const AdminSettingsPage(),
      middlewares: [AdminMiddleware()],
    ),
    GetPage(
      name: '/admin/home',
      page: () => const AdminDashboardPage(),
      middlewares: [AdminMiddleware()],
    ),
  ];

  static void setupAdminRoutes() {
    // Đăng ký các routes cho phần admin
    Get.addPages(routes);
  }
}
```

---


### Pages\Admin\controllers\admin_controller.dart

```dart
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:tictactoe_gameapp/Configs/messages.dart';
import 'package:tictactoe_gameapp/Pages/Admin/models/user_model.dart';
import 'package:tictactoe_gameapp/Pages/Admin/services/admin_service.dart';

class AdminController extends GetxController with GetSingleTickerProviderStateMixin {
  final AdminService _adminService = AdminService();
  
  // Tab controller for admin dashboard
  late final TabController tabController;
  
  // User management variables
  final RxList<UserModel> users = <UserModel>[].obs;
  final RxBool isLoadingUsers = false.obs;
  DocumentSnapshot? lastUserDocument;
  final RxString userSearchQuery = ''.obs;
  final RxString selectedRoleFilter = 'all'.obs;
  final Rx<UserModel?> selectedUser = Rx<UserModel?>(null);
  
  // Content moderation variables
  final RxList<Map<String, dynamic>> reportedContent = <Map<String, dynamic>>[].obs;
  final RxBool isLoadingReports = false.obs;
  DocumentSnapshot? lastReportDocument;
  final RxString contentTypeFilter = 'all'.obs;
  
  // Analytics variables
  final Rx<Map<String, dynamic>> analytics = Rx<Map<String, dynamic>>({});
  final RxBool isLoadingAnalytics = false.obs;
  final Rx<DateTime> analyticsStartDate = DateTime.now().subtract(const Duration(days: 30)).obs;
  final Rx<DateTime> analyticsEndDate = DateTime.now().obs;
  
  // Announcements variables
  final RxList<Map<String, dynamic>> announcements = <Map<String, dynamic>>[].obs;
  final RxBool isLoadingAnnouncements = false.obs;
  DocumentSnapshot? lastAnnouncementDocument;
  final RxString announcementTypeFilter = 'all'.obs;
  final Rx<Map<String, dynamic>> currentEditAnnouncement = Rx<Map<String, dynamic>>({});
  
  // Game management variables
  final RxMap<String, List<Map<String, dynamic>>> gameLeaderboards = <String, List<Map<String, dynamic>>>{}.obs;
  final RxBool isLoadingLeaderboards = false.obs;
  final RxString selectedGame = 'tictactoe'.obs;
  final RxMap<String, dynamic> gameConfig = <String, dynamic>{}.obs;
  
  // Selected users for batch operations
  final RxList<String> selectedUserIds = <String>[].obs;
  
  @override
  void onInit() {
    super.onInit();
    tabController = TabController(length: 5, vsync: this);
    
    // Initialize data
    fetchUsers();
    fetchReportedContent();
    fetchAnalytics();
    fetchAnnouncements();
    fetchGameLeaderboard('tictactoe');
    
    // Set up listeners for filters
    ever(userSearchQuery, (_) => debounce(
      () => fetchUsers(refresh: true),
      const Duration(milliseconds: 500),
    ));
    
    ever(selectedRoleFilter, (_) => fetchUsers(refresh: true));
    ever(contentTypeFilter, (_) => fetchReportedContent(refresh: true));
    ever(announcementTypeFilter, (_) => fetchAnnouncements(refresh: true));
    ever(selectedGame, (_) => fetchGameLeaderboard(selectedGame.value));
  }
  
  // Helper for search debounce
  void debounce(VoidCallback action, Duration duration) {
    Future.delayed(duration, action);
  }
  
  // User Management Functions
  
  Future<void> fetchUsers({bool refresh = false}) async {
    if (isLoadingUsers.value) return;
    isLoadingUsers.value = true;
    
    try {
      if (refresh) {
        lastUserDocument = null;
      }
      
      String? roleFilter;
      if (selectedRoleFilter.value != 'all') {
        roleFilter = selectedRoleFilter.value;
      }
      
      final fetchedUsers = await _adminService.getAllUsers(
        searchQuery: userSearchQuery.value.isEmpty ? null : userSearchQuery.value,
        role: roleFilter,
        startAfter: lastUserDocument,
      );
      
      if (refresh) {
        users.clear();
      }
      
      if (fetchedUsers.isNotEmpty) {
        users.addAll(fetchedUsers);
        // Update the last document for pagination
        // This is approximate - ideally we'd pass back the DocumentSnapshot directly from the service
        if (fetchedUsers.isNotEmpty) {
          final lastUserId = fetchedUsers.last.id;
          if (lastUserId != null) {
            final doc = await FirebaseFirestore.instance.collection('users').doc(lastUserId).get();
            lastUserDocument = doc;
          }
        }
      }
    } catch (e) {
      errorMessage("Error fetching users: $e");
    } finally {
      isLoadingUsers.value = false;
    }
  }
  
  Future<void> selectUser(String userId) async {
    try {
      final user = await _adminService.getUserById(userId);
      selectedUser.value = user;
    } catch (e) {
      errorMessage("Error fetching user details: $e");
    }
  }
  
  Future<bool> updateUserRole(String userId, String newRole) async {
    try {
      final success = await _adminService.updateUserRole(userId, newRole);
      if (success) {
        // Update local user in the list
        final index = users.indexWhere((user) => user.id == userId);
        if (index != -1) {
          final updatedUser = users[index].copyWith(role: newRole);
          users[index] = updatedUser;
          
          // Update selected user if this is the one being viewed
          if (selectedUser.value?.id == userId) {
            selectedUser.value = updatedUser;
          }
        }
      }
      return success;
    } catch (e) {
      errorMessage("Error updating user role: $e");
      return false;
    }
  }
  
  Future<bool> performBatchOperation(String operation) async {
    if (selectedUserIds.isEmpty) {
      errorMessage("No users selected");
      return false;
    }
    
    try {
      final success = await _adminService.batchUserOperation(
        selectedUserIds.toList(),
        operation,
      );
      
      if (success) {
        // Refresh user list after batch operation
        fetchUsers(refresh: true);
        // Clear selection
        selectedUserIds.clear();
      }
      
      return success;
    } catch (e) {
      errorMessage("Error performing batch operation: $e");
      return false;
    }
  }
  
  void toggleUserSelection(String userId) {
    if (selectedUserIds.contains(userId)) {
      selectedUserIds.remove(userId);
    } else {
      selectedUserIds.add(userId);
    }
  }
  
  void clearUserSelection() {
    selectedUserIds.clear();
  }
  
  // Content Moderation Functions
  
  Future<void> fetchReportedContent({bool refresh = false}) async {
    if (isLoadingReports.value) return;
    isLoadingReports.value = true;
    
    try {
      if (refresh) {
        lastReportDocument = null;
      }
      
      String? typeFilter;
      if (contentTypeFilter.value != 'all') {
        typeFilter = contentTypeFilter.value;
      }
      
      final reports = await _adminService.getReportedContent(
        contentType: typeFilter,
        startAfter: lastReportDocument,
      );
      
      if (refresh) {
        reportedContent.clear();
      }
      
      if (reports.isNotEmpty) {
        reportedContent.addAll(reports);
        
        // Update the last document for pagination
        if (reports.isNotEmpty) {
          final lastReportId = reports.last['id'] as String;
          final doc = await FirebaseFirestore.instance
              .collection('reported_content')
              .doc(lastReportId)
              .get();
          lastReportDocument = doc;
        }
      }
    } catch (e) {
      errorMessage("Error fetching reported content: $e");
    } finally {
      isLoadingReports.value = false;
    }
  }
  
  Future<bool> moderateContent(String contentType, String contentId, String action, {String? reason}) async {
    try {
      final success = await _adminService.moderateContent(
        contentType: contentType,
        contentId: contentId,
        action: action,
        reason: reason,
      );
      
      if (success) {
        // Refresh reported content after moderation
        fetchReportedContent(refresh: true);
      }
      
      return success;
    } catch (e) {
      errorMessage("Error moderating content: $e");
      return false;
    }
  }
  
  // Analytics Functions
  
  Future<void> fetchAnalytics() async {
    if (isLoadingAnalytics.value) return;
    isLoadingAnalytics.value = true;
    
    try {
      final data = await _adminService.getAnalytics();
      analytics.value = data;
    } catch (e) {
      errorMessage("Error fetching analytics: $e");
    } finally {
      isLoadingAnalytics.value = false;
    }
  }
  
  Future<void> fetchCustomAnalytics() async {
    if (isLoadingAnalytics.value) return;
    isLoadingAnalytics.value = true;
    
    try {
      final data = await _adminService.getCustomAnalyticsRange(
        analyticsStartDate.value,
        analyticsEndDate.value,
      );
      
      // Merge with existing analytics
      analytics.value = {
        ...analytics.value,
        'customRange': data,
      };
    } catch (e) {
      errorMessage("Error fetching custom analytics: $e");
    } finally {
      isLoadingAnalytics.value = false;
    }
  }
  
  void setAnalyticsDateRange(DateTime start, DateTime end) {
    analyticsStartDate.value = start;
    analyticsEndDate.value = end;
    fetchCustomAnalytics();
  }
  
  // Announcements Functions
  
  Future<void> fetchAnnouncements({bool refresh = false}) async {
    if (isLoadingAnnouncements.value) return;
    isLoadingAnnouncements.value = true;
    
    try {
      if (refresh) {
        lastAnnouncementDocument = null;
      }
      
      String? typeFilter;
      if (announcementTypeFilter.value != 'all') {
        typeFilter = announcementTypeFilter.value;
      }
      
      final fetchedAnnouncements = await _adminService.getAnnouncements(
        activeOnly: false,  // Admin should see all announcements
        type: typeFilter,
        startAfter: lastAnnouncementDocument,
      );
      
      if (refresh) {
        announcements.clear();
      }
      
      if (fetchedAnnouncements.isNotEmpty) {
        announcements.addAll(fetchedAnnouncements);
        
        // Update the last document for pagination
        if (fetchedAnnouncements.isNotEmpty) {
          final lastId = fetchedAnnouncements.last['id'] as String;
          final doc = await FirebaseFirestore.instance
              .collection('announcements')
              .doc(lastId)
              .get();
          lastAnnouncementDocument = doc;
        }
      }
    } catch (e) {
      errorMessage("Error fetching announcements: $e");
    } finally {
      isLoadingAnnouncements.value = false;
    }
  }
  
  Future<bool> createAnnouncement({
    required String title,
    required String message,
    required String type,
    String? targetAudience,
    DateTime? startDate,
    DateTime? endDate,
  }) async {
    try {
      final success = await _adminService.createAnnouncement(
        title: title,
        message: message,
        type: type,
        targetAudience: targetAudience,
        startDate: startDate,
        endDate: endDate,
      );
      
      if (success) {
        // Refresh announcements after creation
        fetchAnnouncements(refresh: true);
      }
      
      return success;
    } catch (e) {
      errorMessage("Error creating announcement: $e");
      return false;
    }
  }
  
  Future<bool> updateAnnouncement(String announcementId, Map<String, dynamic> updateData) async {
    try {
      final success = await _adminService.updateAnnouncement(announcementId, updateData);
      
      if (success) {
        // Refresh announcements after update
        fetchAnnouncements(refresh: true);
      }
      
      return success;
    } catch (e) {
      errorMessage("Error updating announcement: $e");
      return false;
    }
  }
  
  Future<bool> deleteAnnouncement(String announcementId) async {
    try {
      final success = await _adminService.deleteAnnouncement(announcementId);
      
      if (success) {
        // Refresh announcements after deletion
        fetchAnnouncements(refresh: true);
      }
      
      return success;
    } catch (e) {
      errorMessage("Error deleting announcement: $e");
      return false;
    }
  }
  
  void editAnnouncement(Map<String, dynamic> announcement) {
    currentEditAnnouncement.value = announcement;
  }
  
  // Game Management Functions
  
  Future<void> fetchGameLeaderboard(String gameId) async {
    if (isLoadingLeaderboards.value) return;
    isLoadingLeaderboards.value = true;
    
    try {
      final leaderboard = await _adminService.getGameLeaderboard(gameId);
      gameLeaderboards[gameId] = leaderboard;
    } catch (e) {
      errorMessage("Error fetching game leaderboard: $e");
    } finally {
      isLoadingLeaderboards.value = false;
    }
  }
  
  Future<void> fetchGameConfig(String gameId) async {
    try {
      // Fetch game configuration from Firestore
      final doc = await FirebaseFirestore.instance
          .collection('game_configs')
          .doc(gameId)
          .get();
          
      if (doc.exists) {
        gameConfig.value = doc.data() as Map<String, dynamic>;
      } else {
        gameConfig.value = {};
      }
    } catch (e) {
      errorMessage("Error fetching game config: $e");
      gameConfig.value = {};
    }
  }
  
  Future<bool> updateGameConfig(String gameId, Map<String, dynamic> config) async {
    try {
      final success = await _adminService.updateGameConfig(gameId, config);
      
      if (success) {
        // Update local state
        gameConfig.value = {
          ...gameConfig.value,
          ...config,
        };
      }
      
      return success;
    } catch (e) {
      errorMessage("Error updating game config: $e");
      return false;
    }
  }
  
  // Authentication check
  Future<bool> checkAdminAccess() async {
    return await _adminService.isCurrentUserAdmin();
  }
  
  @override
  void onClose() {
    tabController.dispose();
    super.onClose();
  }
}
```

---


### Pages\Admin\controllers\dashboard_overview_controller.dart

```dart
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:get/get.dart';
import 'package:tictactoe_gameapp/Pages/Admin/models/user_model.dart';
import 'package:tictactoe_gameapp/Configs/messages.dart';

class DashboardController extends GetxController {
  final FirebaseFirestore _firestore = FirebaseFirestore.instance;
  final FirebaseAuth _auth = FirebaseAuth.instance;

  // Loading state
  final RxBool isLoading = true.obs;

  // Dashboard data
  final Rx<Map<String, dynamic>> summaryStats = Rx<Map<String, dynamic>>({});
  final Rx<Map<String, dynamic>> systemHealth = Rx<Map<String, dynamic>>({});
  final RxList<Map<String, dynamic>> userActivityData = <Map<String, dynamic>>[].obs;
  final RxList<Map<String, dynamic>> recentReports = <Map<String, dynamic>>[].obs;
  final RxList<Map<String, dynamic>> activeAnnouncements = <Map<String, dynamic>>[].obs;
  final RxList<UserModel> topUsers = <UserModel>[].obs;
  final RxList<Map<String, dynamic>> topGames = <Map<String, dynamic>>[].obs;
  final RxList<Map<String, dynamic>> systemLogs = <Map<String, dynamic>>[].obs;

  // Filters and settings
  final RxString activityTimeRange = 'week'.obs;
  final RxString userSortCriteria = 'coins'.obs;
  final RxString gameSortCriteria = 'plays'.obs;
  final RxInt maxUserActivity = 1000.obs;

  @override
  void onInit() {
    super.onInit();
    loadAllData();
  }

  Future<void> loadAllData() async {
    isLoading.value = true;
    try {
      await Future.wait([
        loadSummaryStats(),
        loadUserActivityData(),
        loadRecentReports(),
        loadActiveAnnouncements(),
        loadTopUsers(),
        loadTopGames(),
        loadSystemHealth(),
        loadSystemLogs(),
      ]);
    } catch (e) {
      errorMessage('Error loading dashboard data: $e');
    } finally {
      isLoading.value = false;
    }
  }

  Future<void> refreshAllData() async {
    try {
      isLoading.value = true;
      await loadAllData();
      successMessage('Dashboard refreshed');
    } catch (e) {
      errorMessage('Error refreshing dashboard: $e');
    } finally {
      isLoading.value = false;
    }
  }

  Future<void> loadSummaryStats() async {
    try {
      // Get total users count
      final userCount = await _firestore.collection('users').count().get();
      
      // Get new users today
      final today = DateTime.now();
      final startOfDay = DateTime(today.year, today.month, today.day);
      final newUsersToday = await _firestore
          .collection('users')
          .where('createdAt', isGreaterThanOrEqualTo: Timestamp.fromDate(startOfDay))
          .count()
          .get();
      
      // Get pending reports count
      final pendingReports = await _firestore
          .collection('reported_content')
          .where('status', isEqualTo: 'pending')
          .count()
          .get();
      
      // Get critical reports count (reports with high severity)
      final criticalReports = await _firestore
          .collection('reported_content')
          .where('status', isEqualTo: 'pending')
          .where('severity', isEqualTo: 'high')
          .count()
          .get();
      
      // Get active games count
      final activeGames = await _firestore
          .collection('game_data')
          .where('status', isEqualTo: 'active')
          .count()
          .get();
      
      // Get new games started today
      final newGamesToday = await _firestore
          .collection('game_data')
          .where('createdAt', isGreaterThanOrEqualTo: Timestamp.fromDate(startOfDay))
          .count()
          .get();
      
      // Mock revenue data (in a real app, you'd get this from a payments collection)
      const revenue = 2450;
      const revenueChange = 12.5; // Percentage change from last week
      
      // Update summaryStats
      summaryStats.value = {
        'totalUsers': userCount.count,
        'newUsers': newUsersToday.count,
        'pendingReports': pendingReports.count,
        'criticalReports': criticalReports.count,
        'activeGames': activeGames.count,
        'newGames': newGamesToday.count,
        'revenue': revenue,
        'revenueChange': revenueChange,
      };
    } catch (e) {
      print('Error loading summary stats: $e');
      // Provide fallback data if there's an error
      summaryStats.value = {
        'totalUsers': 0,
        'newUsers': 0,
        'pendingReports': 0,
        'criticalReports': 0,
        'activeGames': 0,
        'newGames': 0,
        'revenue': 0,
        'revenueChange': 0,
      };
    }
  }

  Future<void> loadUserActivityData({String? timeRange}) async {
    try {
      if (timeRange != null) {
        activityTimeRange.value = timeRange;
      }
      
      // Generate mock data for user activity (in a real app, you'd get this from analytics)
      final List<Map<String, dynamic>> mockData = [];
      
      DateTime now = DateTime.now();
      int dataPoints;
      String labelFormat;
      
      switch (activityTimeRange.value) {
        case 'day':
          dataPoints = 24; // Hours in a day
          labelFormat = 'HH:00'; // Hour format
          for (int i = 0; i < dataPoints; i++) {
            final hour = now.hour - (dataPoints - 1 - i);
            final dateTime = DateTime(now.year, now.month, now.day, hour >= 0 ? hour : hour + 24);
            mockData.add({
              'timestamp': dateTime,
              'label': '${dateTime.hour}:00',
              'activeUsers': 100 + (i * 10) + (dateTime.hour * 5),
              'newUsers': 10 + (i * 2),
              'gameSessions': 50 + (i * 15) + (dateTime.hour * 3),
            });
          }
          break;
          
        case 'week':
          dataPoints = 7; // Days in a week
          labelFormat = 'E'; // Day of week format
          for (int i = 0; i < dataPoints; i++) {
            final day = now.day - (dataPoints - 1 - i);
            final dateTime = DateTime(now.year, now.month, day);
            mockData.add({
              'timestamp': dateTime,
              'label': dateTime.weekday.toString(),
              'activeUsers': 500 + (i * 100) + (dateTime.weekday * 50),
              'newUsers': 50 + (i * 10) + (dateTime.weekday * 5),
              'gameSessions': 300 + (i * 80) + (dateTime.weekday * 30),
            });
          }
          break;
          
        case 'month':
          dataPoints = 30; // Days in a month (approximately)
          labelFormat = 'MM/dd'; // Month/day format
          for (int i = 0; i < dataPoints; i++) {
            final day = now.day - (dataPoints - 1 - i);
            final dateTime = DateTime(now.year, now.month, day);
            mockData.add({
              'timestamp': dateTime,
              'label': '${dateTime.month}/${dateTime.day}',
              'activeUsers': 1000 + (i * 50) + (dateTime.day * 20),
              'newUsers': 100 + (i * 5) + (dateTime.day * 2),
              'gameSessions': 600 + (i * 30) + (dateTime.day * 15),
            });
          }
          break;
          
        default:
          dataPoints = 7; // Default to week
          labelFormat = 'E';
          for (int i = 0; i < dataPoints; i++) {
            final day = now.day - (dataPoints - 1 - i);
            final dateTime = DateTime(now.year, now.month, day);
            mockData.add({
              'timestamp': dateTime,
              'label': dateTime.weekday.toString(),
              'activeUsers': 500 + (i * 100),
              'newUsers': 50 + (i * 10),
              'gameSessions': 300 + (i * 80),
            });
          }
      }
      
      // Update UI data
      userActivityData.assignAll(mockData);
      
      // Calculate maximum value for chart scaling
      int maxValue = 0;
      for (final data in mockData) {
        final activeUsers = data['activeUsers'] as int;
        final newUsers = data['newUsers'] as int;
        final gameSessions = data['gameSessions'] as int;
        
        maxValue = [maxValue, activeUsers, newUsers, gameSessions].reduce((a, b) => a > b ? a : b);
      }
      
      // Add 10% margin to max value for better chart visualization
      maxUserActivity.value = (maxValue * 1.1).round();
    } catch (e) {
      print('Error loading user activity data: $e');
      userActivityData.clear();
      maxUserActivity.value = 1000;
    }
  }

  Future<void> loadRecentReports() async {
    try {
      final snapshot = await _firestore
          .collection('reported_content')
          .orderBy('reportedAt', descending: true)
          .limit(10)
          .get();
      
      List<Map<String, dynamic>> reports = [];
      
      for (final doc in snapshot.docs) {
        Map<String, dynamic> report = doc.data();
        report['id'] = doc.id;
        
        // Convert Timestamp to DateTime for easier handling
        if (report['reportedAt'] != null) {
          report['reportedAt'] = (report['reportedAt'] as Timestamp).toDate();
        }
        
        // Fetch reporter data
        if (report['reporterId'] != null) {
          final reporterDoc = await _firestore
              .collection('users')
              .doc(report['reporterId'] as String)
              .get();
          
          if (reporterDoc.exists) {
            final reporterData = reporterDoc.data();
            report['reporter'] = {
              'id': reporterDoc.id,
              'name': reporterData?['name'] ?? 'Unknown',
              'image': reporterData?['image'] ?? '',
            };
          } else {
            report['reporter'] = {
              'id': report['reporterId'],
              'name': 'Unknown',
              'image': '',
            };
          }
        } else {
          report['reporter'] = {
            'id': '',
            'name': 'System',
            'image': '',
          };
        }
        
        reports.add(report);
      }
      
      recentReports.assignAll(reports);
    } catch (e) {
      print('Error loading recent reports: $e');
      recentReports.clear();
    }
  }

  Future<void> loadActiveAnnouncements() async {
    try {
      final now = Timestamp.fromDate(DateTime.now());
      
      final snapshot = await _firestore
          .collection('announcements')
          .where('active', isEqualTo: true)
          .where('startDate', isLessThanOrEqualTo: now)
          .orderBy('startDate', descending: true)
          .limit(10)
          .get();
      
      List<Map<String, dynamic>> announcements = [];
      
      for (final doc in snapshot.docs) {
        Map<String, dynamic> announcement = doc.data();
        announcement['id'] = doc.id;
        
        // Convert Timestamps to DateTimes for easier handling
        if (announcement['startDate'] != null) {
          announcement['startDate'] = (announcement['startDate'] as Timestamp).toDate();
        }
        
        if (announcement['endDate'] != null) {
          announcement['endDate'] = (announcement['endDate'] as Timestamp).toDate();
          
          // Skip announcements that have ended
          if ((announcement['endDate'] as DateTime).isBefore(DateTime.now())) {
            continue;
          }
        }
        
        announcements.add(announcement);
      }
      
      activeAnnouncements.assignAll(announcements);
    } catch (e) {
      print('Error loading active announcements: $e');
      activeAnnouncements.clear();
    }
  }

  Future<void> loadTopUsers({String? sortBy}) async {
    try {
      if (sortBy != null) {
        userSortCriteria.value = sortBy;
      }
      
      String fieldToSort;
      bool isNumeric = true;
      
      switch (userSortCriteria.value) {
        case 'coins':
          fieldToSort = 'totalCoins';
          break;
        case 'wins':
          fieldToSort = 'totalWins';
          break;
        case 'activity':
          fieldToSort = 'lastActive';
          isNumeric = false;
          break;
        default:
          fieldToSort = 'totalCoins';
      }
      
      Query query = _firestore.collection('users');
      
      if (isNumeric) {
        // For numeric fields, we need to do some special handling since they're stored as strings
        // In a real app, you'd store these as numbers or convert them to numbers in a Cloud Function
        query = query.orderBy(fieldToSort, descending: true);
      } else {
        // For date fields
        query = query.orderBy(fieldToSort, descending: true);
      }
      
      final snapshot = await query.limit(10).get();
      
      List<UserModel> users = snapshot.docs.map((doc) {
        Map<String, dynamic> data = doc.data() as Map<String, dynamic>;
        data['id'] = doc.id;
        return UserModel.fromJson(data);
      }).toList();
      
      topUsers.assignAll(users);
    } catch (e) {
      print('Error loading top users: $e');
      topUsers.clear();
    }
  }

  Future<void> loadTopGames({String? sortBy}) async {
    try {
      if (sortBy != null) {
        gameSortCriteria.value = sortBy;
      }
      
      // Mock game data (in a real app, you'd get this from Firestore)
      final List<Map<String, dynamic>> mockGames = [
        {
          'id': 'tictactoe',
          'name': 'Tic Tac Toe',
          'image': '',
          'plays': 12500,
          'active': 850,
          'revenue': 2300,
          'growth': 15,
        },
        {
          'id': 'sudoku',
          'name': 'Sudoku',
          'image': '',
          'plays': 8200,
          'active': 620,
          'revenue': 1200,
          'growth': 8,
        },
        {
          'id': 'minesweeper',
          'name': 'Minesweeper',
          'image': '',
          'plays': 6400,
          'active': 410,
          'revenue': 850,
          'growth': -3,
        },
        {
          'id': 'match3',
          'name': 'Match 3',
          'image': '',
          'plays': 15800,
          'active': 1050,
          'revenue': 3600,
          'growth': 22,
        },
        {
          'id': '2048',
          'name': '2048',
          'image': '',
          'plays': 9300,
          'active': 580,
          'revenue': 1500,
          'growth': 5,
        },
      ];
      
      // Sort the games based on the selected criteria
      mockGames.sort((a, b) {
        final aValue = a[gameSortCriteria.value] as int;
        final bValue = b[gameSortCriteria.value] as int;
        return bValue.compareTo(aValue); // Descending order
      });
      
      topGames.assignAll(mockGames);
    } catch (e) {
      print('Error loading top games: $e');
      topGames.clear();
    }
  }

  Future<void> loadSystemHealth() async {
    try {
      // Mock system health data (in a real app, you'd get this from a monitoring service)
      final Map<String, dynamic> mockHealth = {
        'apiStatus': 'good',
        'apiResponseTime': 42,
        'dbStatus': 'good',
        'dbConnections': 28,
        'storageStatus': 'good',
        'storageUsage': 67,
        'cacheStatus': 'good',
        'cacheHitRate': 92,
        'lastChecked': DateTime.now(),
      };
      
      systemHealth.value = mockHealth;
    } catch (e) {
      print('Error loading system health: $e');
      systemHealth.value = {
        'apiStatus': 'unknown',
        'dbStatus': 'unknown',
        'storageStatus': 'unknown',
        'cacheStatus': 'unknown',
      };
    }
  }

  Future<void> loadSystemLogs() async {
    try {
      // Mock system logs (in a real app, you'd get this from Firestore or a logging service)
      final List<Map<String, dynamic>> mockLogs = [
        {
          'level': 'info',
          'message': 'User authentication successful',
          'timestamp': DateTime.now().subtract(const Duration(minutes: 5)),
        },
        {
          'level': 'warning',
          'message': 'High database load detected',
          'timestamp': DateTime.now().subtract(const Duration(minutes: 15)),
        },
        {
          'level': 'error',
          'message': 'Failed to process payment for user xyz123',
          'timestamp': DateTime.now().subtract(const Duration(minutes: 25)),
        },
        {
          'level': 'info',
          'message': 'Daily backup completed successfully',
          'timestamp': DateTime.now().subtract(const Duration(hours: 1)),
        },
        {
          'level': 'info',
          'message': 'New user registration: user123@example.com',
          'timestamp': DateTime.now().subtract(const Duration(hours: 2)),
        },
      ];
      
      systemLogs.assignAll(mockLogs);
    } catch (e) {
      print('Error loading system logs: $e');
      systemLogs.clear();
    }
  }
}
```

---


### Pages\Admin\controllers\support_system_controller.dart

```dart
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:tictactoe_gameapp/Configs/messages.dart';

class SupportSystemController extends GetxController {
  final FirebaseFirestore _firestore = FirebaseFirestore.instance;
  final FirebaseAuth _auth = FirebaseAuth.instance;

  // Loading state
  final RxBool isLoading = true.obs;

  // Form controllers
  final TextEditingController searchController = TextEditingController();
  final TextEditingController replyController = TextEditingController();

  // Search and filter state
  final RxString searchQuery = ''.obs;
  final RxString selectedStatusFilter = 'all'.obs;
  final RxString selectedPriorityFilter = 'all'.obs;
  final RxString sortCriteria = 'date'.obs;

  // Selected ticket
  final RxString selectedTicketId = ''.obs;

  // Ticket data
  final RxList<Map<String, dynamic>> allTickets = <Map<String, dynamic>>[].obs;

  // Knowledge base data
  final RxList<Map<String, dynamic>> knowledgeBaseArticles =
      <Map<String, dynamic>>[].obs;

  @override
  void onInit() {
    super.onInit();
    loadData();

    // Set up reactive search
    searchController.addListener(() {
      searchQuery.value = searchController.text.trim();
    });
  }

  @override
  void onClose() {
    searchController.dispose();
    replyController.dispose();
    super.onClose();
  }

  Future<void> refreshData() async {
    isLoading.value = true;
    await loadData();
  }

  Future<void> loadData() async {
    try {
      await Future.wait([
        loadTickets(),
        loadKnowledgeBase(),
      ]);
    } catch (e) {
      print('Error loading support data: $e');
      errorMessage('Failed to load support data: $e');
    } finally {
      isLoading.value = false;
    }
  }

  Future<void> loadTickets() async {
    try {
      // In a real app, this would fetch tickets from Firestore
      // For this example, we'll generate mock data

      final List<Map<String, dynamic>> tickets = [];
      final now = DateTime.now();

      // Mock ticket statuses
      final List<String> statuses = ['open', 'pending', 'resolved'];

      // Mock ticket priorities
      final List<String> priorities = ['low', 'medium', 'high'];

      // Mock ticket categories
      final List<String> categories = [
        'Account',
        'Billing',
        'Game Play',
        'Technical',
        'Feature Request',
        'Bug Report',
        'Other',
      ];

      // Generate mock tickets
      for (int i = 0; i < 20; i++) {
        final status = statuses[i % statuses.length];
        final priority = priorities[i % priorities.length];
        final category = categories[i % categories.length];
        final createdAt = now.subtract(Duration(days: i * 2));
        final lastUpdated = now.subtract(Duration(days: i));

        // Generate messages if status is not resolved
        final List<Map<String, dynamic>> messages = [];

        if (status != 'resolved') {
          // Add some mock messages
          final messageCount = 1 + (i % 3);

          for (int j = 0; j < messageCount; j++) {
            final isUserMessage = j % 2 == 0;

            messages.add({
              'sender': isUserMessage ? 'User ${i + 1}' : 'Support Agent',
              'senderImage': '',
              'content': isUserMessage
                  ? 'I\'m still experiencing the issue. Can you provide more information?'
                  : 'Thank you for the update. We\'ll look into this further.',
              'timestamp': now.subtract(Duration(days: i, hours: j * 6)),
              'isUser': isUserMessage,
            });
          }
        }

        tickets.add({
          'id': 'ticket${1000 + i}',
          'subject': getTicketSubject(category, i),
          'description': getTicketDescription(category, i),
          'userId': 'user${1000 + i}',
          'userName': 'User ${i + 1}',
          'userEmail': 'user${i + 1}@example.com',
          'userImage': '',
          'status': status,
          'priority': priority,
          'category': category,
          'assignedTo': i % 4 == 0 ? 'Agent ${i % 3 + 1}' : null,
          'createdAt': createdAt,
          'lastUpdated': lastUpdated,
          'messages': messages,
          'hasNewMessage': i % 5 == 0,
          'tags': getTags(category, i),
          'platform': i % 2 == 0 ? 'iOS' : 'Android',
          'deviceInfo': i % 2 == 0 ? 'iPhone 13' : 'Samsung Galaxy S21',
          'appVersion': '1.${5 + (i % 3)}.0',
        });
      }

      allTickets.assignAll(tickets);

      // If a ticket was selected, update it with the latest data
      if (selectedTicketId.isNotEmpty) {
        final ticketIndex = tickets
            .indexWhere((ticket) => ticket['id'] == selectedTicketId.value);
        if (ticketIndex == -1) {
          // Selected ticket no longer exists
          selectedTicketId.value = '';
        }
      }
    } catch (e) {
      print('Error loading tickets: $e');
      errorMessage('Failed to load tickets: $e');
    }
  }

  Future<void> loadKnowledgeBase() async {
    try {
      // In a real app, this would fetch articles from Firestore
      // For this example, we'll generate mock data

      final List<Map<String, dynamic>> articles = [];
      final now = DateTime.now();

      // Mock categories
      final List<String> categories = [
        'Account',
        'Billing',
        'Game Play',
        'Technical',
        'Feature Request',
        'Bug Report',
        'Other',
      ];

      // Generate mock articles
      for (int i = 0; i < 15; i++) {
        final category = categories[i % categories.length];

        articles.add({
          'id': 'article${1000 + i}',
          'title': getArticleTitle(category, i),
          'content': getArticleContent(category, i),
          'summary': getArticleSummary(category, i),
          'category': category,
          'author': 'Admin',
          'createdAt': now.subtract(Duration(days: i * 10)),
          'updatedAt': now.subtract(Duration(days: i * 5)),
          'views': 100 - (i * 5),
          'helpful': 50 - (i * 3),
        });
      }

      knowledgeBaseArticles.assignAll(articles);
    } catch (e) {
      print('Error loading knowledge base: $e');
      errorMessage('Failed to load knowledge base: $e');
    }
  }

  List<Map<String, dynamic>> getFilteredTickets() {
    // Apply filters to the tickets
    return allTickets.where((ticket) {
      // Apply search filter
      if (searchQuery.value.isNotEmpty) {
        final query = searchQuery.value.toLowerCase();
        final subject = (ticket['subject'] as String).toLowerCase();
        final description = (ticket['description'] as String).toLowerCase();
        final userName = (ticket['userName'] as String).toLowerCase();
        final ticketId = (ticket['id'] as String).toLowerCase();

        if (!subject.contains(query) &&
            !description.contains(query) &&
            !userName.contains(query) &&
            !ticketId.contains(query)) {
          return false;
        }
      }

      // Apply status filter
      if (selectedStatusFilter.value != 'all' &&
          ticket['status'] != selectedStatusFilter.value) {
        return false;
      }

      // Apply priority filter
      if (selectedPriorityFilter.value != 'all' &&
          ticket['priority'] != selectedPriorityFilter.value) {
        return false;
      }

      return true;
    }).toList()
      ..sort((a, b) {
        // Apply sorting
        switch (sortCriteria.value) {
          case 'date':
            return (b['lastUpdated'] as DateTime)
                .compareTo(a['lastUpdated'] as DateTime);
          case 'priority':
            final priorityOrder = {'high': 0, 'medium': 1, 'low': 2};
            return priorityOrder[a['priority']]!
                .compareTo(priorityOrder[b['priority']]!);
          case 'status':
            final statusOrder = {'open': 0, 'pending': 1, 'resolved': 2};
            return statusOrder[a['status']]!
                .compareTo(statusOrder[b['status']]!);
          default:
            return (b['lastUpdated'] as DateTime)
                .compareTo(a['lastUpdated'] as DateTime);
        }
      });
  }

  List<Map<String, dynamic>> getAllTickets() {
    return allTickets;
  }

  Map<String, dynamic>? getSelectedTicket() {
    if (selectedTicketId.isEmpty) return null;

    final ticketIndex = allTickets
        .indexWhere((ticket) => ticket['id'] == selectedTicketId.value);
    if (ticketIndex == -1) return null;

    return allTickets[ticketIndex];
  }

  void selectTicket(String ticketId) {
    selectedTicketId.value = ticketId;

    // Mark any new messages as read
    final ticketIndex =
        allTickets.indexWhere((ticket) => ticket['id'] == ticketId);
    if (ticketIndex != -1) {
      final ticket = Map<String, dynamic>.from(allTickets[ticketIndex]);
      if (ticket['hasNewMessage'] == true) {
        ticket['hasNewMessage'] = false;
        allTickets[ticketIndex] = ticket;
      }
    }
  }

  List<Map<String, dynamic>> getRelatedArticles(String category) {
    return knowledgeBaseArticles
        .where((article) => article['category'] == category)
        .toList();
  }

  List<Map<String, dynamic>> getFilteredKnowledgeBaseArticles(
      String query, String? category) {
    return knowledgeBaseArticles.where((article) {
      // Apply search filter
      if (query.isNotEmpty) {
        final lowercaseQuery = query.toLowerCase();
        final title = (article['title'] as String).toLowerCase();
        final content = (article['content'] as String).toLowerCase();
        final summary = (article['summary'] as String).toLowerCase();

        if (!title.contains(lowercaseQuery) &&
            !content.contains(lowercaseQuery) &&
            !summary.contains(lowercaseQuery)) {
          return false;
        }
      }

      // Apply category filter
      if (category != null && article['category'] != category) {
        return false;
      }

      return true;
    }).toList();
  }

  void resetFilters() {
    searchController.clear();
    searchQuery.value = '';
    selectedStatusFilter.value = 'all';
    selectedPriorityFilter.value = 'all';
    sortCriteria.value = 'date';
  }

  // Ticket management methods
  Future<bool> sendReply(String ticketId, String message) async {
    try {
      final ticketIndex =
          allTickets.indexWhere((ticket) => ticket['id'] == ticketId);
      if (ticketIndex == -1) return false;

      final ticket = Map<String, dynamic>.from(allTickets[ticketIndex]);
      final messages = List<Map<String, dynamic>>.from(
          ticket['messages'] as List<dynamic>? ?? []);

      // Add new message
      messages.add({
        'sender': 'Support Agent',
        'senderImage': '',
        'content': message,
        'timestamp': DateTime.now(),
        'isUser': false,
      });

      // Update ticket
      ticket['messages'] = messages;
      ticket['lastUpdated'] = DateTime.now();
      ticket['status'] =
          'pending'; // Change status to pending when agent replies

      // Update ticket in list
      allTickets[ticketIndex] = ticket;

      return true;
    } catch (e) {
      print('Error sending reply: $e');
      errorMessage('Failed to send reply: $e');
      return false;
    }
  }

  Future<bool> resolveTicket(String ticketId, String resolution) async {
    try {
      final ticketIndex =
          allTickets.indexWhere((ticket) => ticket['id'] == ticketId);
      if (ticketIndex == -1) return false;

      final ticket = Map<String, dynamic>.from(allTickets[ticketIndex]);
      final messages = List<Map<String, dynamic>>.from(
          ticket['messages'] as List<dynamic>? ?? []);

      // Add resolution message
      messages.add({
        'sender': 'Support Agent',
        'senderImage': '',
        'content': resolution,
        'timestamp': DateTime.now(),
        'isUser': false,
        'isResolution': true,
      });

      // Update ticket
      ticket['messages'] = messages;
      ticket['lastUpdated'] = DateTime.now();
      ticket['status'] = 'resolved';
      ticket['resolution'] = resolution;

      // Update ticket in list
      allTickets[ticketIndex] = ticket;

      return true;
    } catch (e) {
      print('Error resolving ticket: $e');
      errorMessage('Failed to resolve ticket: $e');
      return false;
    }
  }

  Future<bool> reopenTicket(String ticketId, String reason) async {
    try {
      final ticketIndex =
          allTickets.indexWhere((ticket) => ticket['id'] == ticketId);
      if (ticketIndex == -1) return false;

      final ticket = Map<String, dynamic>.from(allTickets[ticketIndex]);
      final messages = List<Map<String, dynamic>>.from(
          ticket['messages'] as List<dynamic>? ?? []);

      // Add reopen message
      messages.add({
        'sender': 'Support Agent',
        'senderImage': '',
        'content': 'Ticket reopened: $reason',
        'timestamp': DateTime.now(),
        'isUser': false,
        'isReopen': true,
      });

      // Update ticket
      ticket['messages'] = messages;
      ticket['lastUpdated'] = DateTime.now();
      ticket['status'] = 'open';
      ticket.remove('resolution');

      // Update ticket in list
      allTickets[ticketIndex] = ticket;

      return true;
    } catch (e) {
      print('Error reopening ticket: $e');
      errorMessage('Failed to reopen ticket: $e');
      return false;
    }
  }

  Future<bool> assignTicket(
      String ticketId, String agentId, String agentName) async {
    try {
      final ticketIndex =
          allTickets.indexWhere((ticket) => ticket['id'] == ticketId);
      if (ticketIndex == -1) return false;

      final ticket = Map<String, dynamic>.from(allTickets[ticketIndex]);

      // Update ticket
      ticket['assignedTo'] = agentName;
      ticket['assignedToId'] = agentId;
      ticket['lastUpdated'] = DateTime.now();

      // Update ticket in list
      allTickets[ticketIndex] = ticket;

      return true;
    } catch (e) {
      print('Error assigning ticket: $e');
      errorMessage('Failed to assign ticket: $e');
      return false;
    }
  }

  Future<bool> unassignTicket(String ticketId) async {
    try {
      final ticketIndex =
          allTickets.indexWhere((ticket) => ticket['id'] == ticketId);
      if (ticketIndex == -1) return false;

      final ticket = Map<String, dynamic>.from(allTickets[ticketIndex]);

      // Update ticket
      ticket.remove('assignedTo');
      ticket.remove('assignedToId');
      ticket['lastUpdated'] = DateTime.now();

      // Update ticket in list
      allTickets[ticketIndex] = ticket;

      return true;
    } catch (e) {
      print('Error unassigning ticket: $e');
      errorMessage('Failed to unassign ticket: $e');
      return false;
    }
  }

  Future<bool> changeTicketPriority(String ticketId, String priority) async {
    try {
      final ticketIndex =
          allTickets.indexWhere((ticket) => ticket['id'] == ticketId);
      if (ticketIndex == -1) return false;

      final ticket = Map<String, dynamic>.from(allTickets[ticketIndex]);

      // Update ticket
      ticket['priority'] = priority;
      ticket['lastUpdated'] = DateTime.now();

      // Update ticket in list
      allTickets[ticketIndex] = ticket;

      return true;
    } catch (e) {
      print('Error changing ticket priority: $e');
      errorMessage('Failed to change ticket priority: $e');
      return false;
    }
  }

  Future<bool> changeTicketCategory(String ticketId, String category) async {
    try {
      final ticketIndex =
          allTickets.indexWhere((ticket) => ticket['id'] == ticketId);
      if (ticketIndex == -1) return false;

      final ticket = Map<String, dynamic>.from(allTickets[ticketIndex]);

      // Update ticket
      ticket['category'] = category;
      ticket['lastUpdated'] = DateTime.now();

      // Update ticket in list
      allTickets[ticketIndex] = ticket;

      return true;
    } catch (e) {
      print('Error changing ticket category: $e');
      errorMessage('Failed to change ticket category: $e');
      return false;
    }
  }

  Future<bool> addTagToTicket(String ticketId, String tag) async {
    try {
      final ticketIndex =
          allTickets.indexWhere((ticket) => ticket['id'] == ticketId);
      if (ticketIndex == -1) return false;

      final ticket = Map<String, dynamic>.from(allTickets[ticketIndex]);
      final tags = List<String>.from(ticket['tags'] as List<dynamic>? ?? []);

      // Add tag if it doesn't already exist
      if (!tags.contains(tag)) {
        tags.add(tag);
        ticket['tags'] = tags;
        ticket['lastUpdated'] = DateTime.now();

        // Update ticket in list
        allTickets[ticketIndex] = ticket;
      }

      return true;
    } catch (e) {
      print('Error adding tag to ticket: $e');
      errorMessage('Failed to add tag to ticket: $e');
      return false;
    }
  }

  Future<bool> removeTagFromTicket(String ticketId, String tag) async {
    try {
      final ticketIndex =
          allTickets.indexWhere((ticket) => ticket['id'] == ticketId);
      if (ticketIndex == -1) return false;

      final ticket = Map<String, dynamic>.from(allTickets[ticketIndex]);
      final tags = List<String>.from(ticket['tags'] as List<dynamic>? ?? []);

      // Remove tag if it exists
      if (tags.contains(tag)) {
        tags.remove(tag);
        ticket['tags'] = tags;
        ticket['lastUpdated'] = DateTime.now();

        // Update ticket in list
        allTickets[ticketIndex] = ticket;
      }

      return true;
    } catch (e) {
      print('Error removing tag from ticket: $e');
      errorMessage('Failed to remove tag from ticket: $e');
      return false;
    }
  }

  Future<bool> addInternalNote(String ticketId, String note) async {
    try {
      final ticketIndex =
          allTickets.indexWhere((ticket) => ticket['id'] == ticketId);
      if (ticketIndex == -1) return false;

      final ticket = Map<String, dynamic>.from(allTickets[ticketIndex]);
      final notes = List<Map<String, dynamic>>.from(
          ticket['internalNotes'] as List<dynamic>? ?? []);

      // Add note
      notes.add({
        'note': note,
        'author': 'Support Agent',
        'timestamp': DateTime.now(),
      });

      // Update ticket
      ticket['internalNotes'] = notes;
      ticket['lastUpdated'] = DateTime.now();

      // Update ticket in list
      allTickets[ticketIndex] = ticket;

      return true;
    } catch (e) {
      print('Error adding internal note: $e');
      errorMessage('Failed to add internal note: $e');
      return false;
    }
  }

  Future<bool> mergeTickets(
      String sourceTicketId, String targetTicketId) async {
    try {
      final sourceIndex =
          allTickets.indexWhere((ticket) => ticket['id'] == sourceTicketId);
      final targetIndex =
          allTickets.indexWhere((ticket) => ticket['id'] == targetTicketId);

      if (sourceIndex == -1 || targetIndex == -1) return false;

      final sourceTicket = allTickets[sourceIndex];
      final targetTicket = Map<String, dynamic>.from(allTickets[targetIndex]);

      // Merge messages
      final sourceMessages = List<Map<String, dynamic>>.from(
          sourceTicket['messages'] as List<dynamic>? ?? []);
      final targetMessages = List<Map<String, dynamic>>.from(
          targetTicket['messages'] as List<dynamic>? ?? []);

      // Add a merge note to the beginning of source messages
      sourceMessages.insert(0, {
        'sender': 'System',
        'content':
            'The following messages were merged from ticket #${sourceTicketId.substring(0, 8)}',
        'timestamp': DateTime.now(),
        'isUser': false,
        'isMergeNote': true,
      });

      // Combine messages (target + source)
      targetMessages.addAll(sourceMessages);
      targetTicket['messages'] = targetMessages;

      // Update target ticket
      targetTicket['lastUpdated'] = DateTime.now();

      // Add a note about the merge
      final notes = List<Map<String, dynamic>>.from(
          targetTicket['internalNotes'] as List<dynamic>? ?? []);
      notes.add({
        'note': 'Merged with ticket #${sourceTicketId.substring(0, 8)}',
        'author': 'Support Agent',
        'timestamp': DateTime.now(),
      });
      targetTicket['internalNotes'] = notes;

      // Update target ticket in list
      allTickets[targetIndex] = targetTicket;

      // Remove source ticket
      allTickets.removeAt(sourceIndex);

      // If the source ticket was selected, select the target ticket instead
      if (selectedTicketId.value == sourceTicketId) {
        selectedTicketId.value = targetTicketId;
      }

      return true;
    } catch (e) {
      print('Error merging tickets: $e');
      errorMessage('Failed to merge tickets: $e');
      return false;
    }
  }

  // Knowledge base methods
  Future<bool> createKnowledgeBaseArticle({
    required String title,
    required String content,
    required String summary,
    required String category,
  }) async {
    try {
      final now = DateTime.now();

      // Create new article
      final article = {
        'id': 'article${knowledgeBaseArticles.length + 1000}',
        'title': title,
        'content': content,
        'summary': summary,
        'category': category,
        'author': 'Admin',
        'createdAt': now,
        'updatedAt': now,
        'views': 0,
        'helpful': 0,
      };

      // Add to list
      knowledgeBaseArticles.add(article);

      return true;
    } catch (e) {
      print('Error creating knowledge base article: $e');
      errorMessage('Failed to create article: $e');
      return false;
    }
  }

  // Helper methods to generate mock data
  String getTicketSubject(String category, int index) {
    switch (category) {
      case 'Account':
        return 'Cannot log in to my account';
      case 'Billing':
        return 'Payment failed for recent purchase';
      case 'Game Play':
        return 'Game freezes during multiplayer match';
      case 'Technical':
        return 'App crashes after the latest update';
      case 'Feature Request':
        return 'Suggestion for new game mode';
      case 'Bug Report':
        return 'Found a bug in the tournament system';
      default:
        return 'Question about the game';
    }
  }

  String getTicketDescription(String category, int index) {
    switch (category) {
      case 'Account':
        return 'I\'m trying to log in to my account but it keeps saying "Invalid credentials" even though I\'m sure my password is correct. I\'ve tried resetting my password but I\'m not receiving the reset email.';
      case 'Billing':
        return 'I tried to purchase 1000 coins yesterday but the payment failed. My card was charged but I didn\'t receive the coins in my account. The transaction ID is TRX${10000 + index}.';
      case 'Game Play':
        return 'Every time I play a multiplayer match, the game freezes after about 2 minutes. I have to force close the app and restart it, which counts as a loss for me. This is really frustrating!';
      case 'Technical':
        return 'Since updating to version 1.5.0, the app crashes immediately after launching. I\'ve tried reinstalling but the problem persists. I\'m using an iPhone 13 with iOS 15.4.';
      case 'Feature Request':
        return 'I think it would be great if you could add a team mode where players can form teams and compete against other teams. This would add a new dimension to the game and encourage more social play.';
      case 'Bug Report':
        return 'I\'ve found a bug in the tournament system. When I join a tournament and then leave, I can rejoin the same tournament multiple times and get matched against myself, which shouldn\'t be possible.';
      default:
        return 'I have a question about the game that isn\'t covered in the FAQ. Can you please provide more information about how the ranking system works?';
    }
  }

  List<String> getTags(String category, int index) {
    switch (category) {
      case 'Account':
        return ['login-issue', 'account-access'];
      case 'Billing':
        return ['payment-failed', 'transaction-issue'];
      case 'Game Play':
        return ['game-freeze', 'multiplayer-issue'];
      case 'Technical':
        return ['app-crash', 'update-issue'];
      case 'Feature Request':
        return ['new-feature', 'enhancement'];
      case 'Bug Report':
        return ['bug', 'tournament-issue'];
      default:
        return ['question', 'game-mechanics'];
    }
  }

  String getArticleTitle(String category, int index) {
    switch (category) {
      case 'Account':
        return 'How to Recover Your Account';
      case 'Billing':
        return 'Troubleshooting Payment Issues';
      case 'Game Play':
        return 'Tips for Winning Multiplayer Matches';
      case 'Technical':
        return 'Fixing App Crashes After Updates';
      case 'Feature Request':
        return 'Upcoming Features in Next Release';
      case 'Bug Report':
        return 'Known Issues and Workarounds';
      default:
        return 'Frequently Asked Questions';
    }
  }

  String getArticleSummary(String category, int index) {
    switch (category) {
      case 'Account':
        return 'Learn how to recover your account if you\'ve forgotten your password or can\'t access your email.';
      case 'Billing':
        return 'Steps to resolve common payment issues and get help with failed transactions.';
      case 'Game Play':
        return 'Expert strategies and tips to improve your skills in multiplayer matches.';
      case 'Technical':
        return 'Solutions for common app crashes and performance issues after updating.';
      case 'Feature Request':
        return 'Preview of exciting new features coming in our next app update.';
      case 'Bug Report':
        return 'List of known issues in the current version and temporary solutions.';
      default:
        return 'Answers to the most common questions about gameplay, accounts, and more.';
    }
  }

  String getArticleContent(String category, int index) {
    switch (category) {
      case 'Account':
        return '''
# How to Recover Your Account

If you're having trouble accessing your account, follow these steps to recover it:

## Password Reset

1. Go to the login screen and tap "Forgot Password"
2. Enter the email address associated with your account
3. Check your email for a password reset link
4. Click the link and follow the instructions to set a new password

## Not Receiving Reset Emails

If you're not receiving password reset emails:

1. Check your spam folder
2. Make sure you're using the correct email address
3. Add our domain to your safe senders list
4. Contact support if you still don't receive the email

## Account Locked

If your account is locked due to too many failed login attempts:

1. Wait 30 minutes before trying again
2. Use the password reset function to set a new password
3. Make sure you're not using a VPN that might trigger security measures

## Still Can't Access Your Account?

If you've tried the steps above and still can't access your account, please contact our support team with the following information:

1. Username or display name
2. Email address associated with the account
3. Approximate date when you created the account
4. Any transaction IDs from purchases you've made
''';
      case 'Billing':
        return '''
# Troubleshooting Payment Issues

Common payment problems and how to solve them:

## Failed Payments

If your payment fails, check the following:

1. Verify that your card details are entered correctly
2. Ensure you have sufficient funds in your account
3. Check if your bank is blocking the transaction
4. Try a different payment method

## Charged But No Items Received

If you were charged but didn't receive your purchase:

1. Wait 15 minutes as sometimes there's a delay in processing
2. Check your in-game mail for the items
3. Restart the app to refresh your inventory
4. Contact support with your transaction ID and purchase receipt

## Subscription Issues

For problems with recurring subscriptions:

1. Check your subscription status in your account settings
2. Verify your payment method is up to date
3. Cancel and resubscribe if needed
4. Contact support for assistance with specific subscription issues

## Refunds

Our refund policy:

1. Accidental purchases may be eligible for a refund if requested within 48 hours
2. Subscription cancellations do not automatically trigger refunds for unused time
3. To request a refund, contact support with your transaction ID and reason for the refund
''';
      case 'Game Play':
        return '''
# Tips for Winning Multiplayer Matches

Improve your skills and increase your win rate with these expert tips:

## Basic Strategies

1. Focus on controlling the center of the board
2. Don't make moves reactively - plan ahead
3. Watch your opponent's patterns and adapt your strategy
4. Save power-ups for critical moments rather than using them immediately

## Advanced Techniques

1. Use the "corner trap" technique to force your opponent into making mistakes
2. Practice the "double threat" move to create two winning opportunities
3. Learn to recognize and counter common opening strategies
4. Develop a flexible playstyle that can adapt to different opponents

## Managing Your Resources

1. Use coins efficiently to upgrade your most-used items
2. Focus on upgrading a core set of items rather than spreading resources too thin
3. Save premium currency for limited-time special items
4. Complete daily missions to maximize resource acquisition

## Tournament Play

1. Rest between matches to maintain focus
2. Study the meta and popular strategies before participating
3. Practice against friends in friendly matches to prepare
4. Keep track of top players and learn from their techniques
''';
      default:
        return '''
# ${getArticleTitle(category, index)}

This is a comprehensive guide about ${category.toLowerCase()}-related issues and solutions.

## Common Problems

Users often encounter these issues:

1. Problem one description and details
2. Problem two with more specific information
3. Third common issue that users face

## Solutions

Here are the recommended solutions:

1. Step-by-step guidance for first problem
2. Detailed instructions for solving the second issue
3. Multiple approaches for addressing the third problem

## Prevention

To avoid these issues in the future:

1. Preventative measure one
2. Second tip for avoiding problems
3. Best practices for optimal experience

## Contact Support

If you're still experiencing issues after trying these solutions, please contact our support team with the following information:

1. Your device model and operating system
2. App version
3. Detailed description of the issue
4. Screenshots if applicable
''';
    }
  }
}

```

---


### Pages\Admin\middlewares\admin_middleware.dart

```dart
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:tictactoe_gameapp/Configs/messages.dart';

class AdminMiddleware extends GetMiddleware {
  @override
  int? get priority => 2;

  // Cache để lưu trữ quyền truy cập admin để tránh truy vấn lặp lại
  static final Map<String, bool> _adminAccessCache = {};
  static DateTime _lastCacheClear = DateTime.now();

  @override
  RouteSettings? redirect(String? route) {
    // Kiểm tra quyền truy cập admin - sử dụng FutureBuilder trong UI thay vì async ở đây
    _checkAdminAccess().then((hasAccess) {
      if (!hasAccess) {
        // Hiển thị thông báo lỗi
        errorMessage('Bạn không có quyền truy cập vào trang quản trị');

        // Chuyển hướng về trang chính
        Get.offAllNamed('/mainHome');
      }
    }).catchError((error) {
      errorMessage('Lỗi khi kiểm tra quyền truy cập: $error');
      Get.offAllNamed('/mainHome');
    });

    // Trả về null để ngăn chặn chuyển hướng nếu người dùng đã có quyền truy cập
    // Chúng ta sẽ thực hiện chuyển hướng thủ công trong hàm _checkAdminAccess nếu cần
    return null;
  }

  Future<bool> _checkAdminAccess() async {
    try {
      final user = FirebaseAuth.instance.currentUser;
      if (user == null) return false;

      // Kiểm tra cache để tránh truy vấn quá nhiều vào Firestore
      final userId = user.uid;

      // Xóa cache mỗi 15 phút để cập nhật quyền
      _clearCacheIfNeeded();

      // Nếu đã có trong cache, trả về kết quả
      if (_adminAccessCache.containsKey(userId)) {
        return _adminAccessCache[userId]!;
      }

      // Truy vấn Firestore để lấy thông tin người dùng
      final userDoc = await FirebaseFirestore.instance
          .collection('users')
          .doc(userId)
          .get();

      if (!userDoc.exists) return false;

      final userData = userDoc.data() as Map<String, dynamic>;
      final isAdmin = userData['role'] == 'admin';

      // Lưu kết quả vào cache
      _adminAccessCache[userId] = isAdmin;

      return isAdmin;
    } catch (e) {
      print('Error checking admin access: $e');
      return false;
    }
  }

  // Xóa cache mỗi 15 phút để cập nhật quyền
  void _clearCacheIfNeeded() {
    final now = DateTime.now();
    if (now.difference(_lastCacheClear).inMinutes >= 15) {
      _adminAccessCache.clear();
      _lastCacheClear = now;
    }
  }

  @override
  GetPage? onPageCalled(GetPage? page) {
    if (page != null) {
      _logAccess(page.name);
    }
    return page;
  }

  // Ghi log khi có người truy cập trang admin
  void _logAccess(String route) {
    final user = FirebaseAuth.instance.currentUser;
    if (user != null) {
      try {
        FirebaseFirestore.instance.collection('admin_access_logs').add({
          'userId': user.uid,
          'email': user.email,
          'displayName': user.displayName,
          'route': route,
          'timestamp': FieldValue.serverTimestamp(),
        });
      } catch (e) {
        // Chỉ ghi log, không ảnh hưởng đến luồng chính
        print('Error logging admin access: $e');
      }
    }
  }
}

```

---


### Pages\Admin\models\user_model.dart

```dart
import 'package:cloud_firestore/cloud_firestore.dart';

class UserModel {
  String? id;
  String? name;
  String? email;
  String? image;
  String? totalWins;
  String? role;
  String? totalCoins;
  String? quickMess;
  String? quickEmote;
  List<String>? friendsList;
  String? status;
  Timestamp? lastActive;
  GeoPoint? location;
  List<String>? avatarFrame;
  bool? suspended;
  bool? verified;
  String? bio;
  Timestamp? createdAt;
  bool? isOnline;
  int? warningCount;

  UserModel({
    this.role,
    this.id,
    this.name,
    this.email,
    this.image,
    this.totalWins,
    this.totalCoins,
    this.quickMess,
    this.quickEmote,
    this.friendsList,
    this.status,
    this.lastActive,
    this.location,
    this.avatarFrame,
    this.suspended,
    this.verified,
    this.bio,
    this.createdAt,
    this.isOnline,
    this.warningCount,
  });

  UserModel.fromJson(Map<String, dynamic> json) {
    if (json["id"] is String) {
      id = json["id"];
    }
    if (json["name"] is String) {
      name = json["name"];
    }
    if (json["email"] is String) {
      email = json["email"];
    }
    if (json["image"] is String) {
      image = json["image"];
    }
    if (json["totalWins"] is String) {
      totalWins = json["totalWins"];
    }
    if (json["role"] is String) {
      role = json["role"];
    }
    if (json["totalCoins"] is String) {
      totalCoins = json["totalCoins"];
    }
    if (json["quickMess"] is String) {
      quickMess = json["quickMess"];
    }
    if (json["quickEmote"] is String) {
      quickEmote = json["quickEmote"];
    }
    if (json["friendsList"] is List) {
      friendsList = List<String>.from(json["friendsList"]);
    }
    if (json["status"] is String) {
      status = json["status"];
    }
    if (json["lastActive"] is Timestamp) {
      lastActive = json["lastActive"];
    }
    location = json["location"] as GeoPoint?;
    if (json["avatarFrame"] is List) {
      avatarFrame = List<String>.from(json["avatarFrame"]);
    }
    if (json["suspended"] is bool) {
      suspended = json["suspended"];
    }
    if (json["verified"] is bool) {
      verified = json["verified"];
    }
    if (json["bio"] is String) {
      bio = json["bio"];
    }
    if (json["createdAt"] is Timestamp) {
      createdAt = json["createdAt"];
    }
    if (json["isOnline"] is bool) {
      isOnline = json["isOnline"];
    }
    if (json["warningCount"] is int) {
      warningCount = json["warningCount"];
    }
  }

  Map<String, dynamic> toJson() {
    final Map<String, dynamic> data = <String, dynamic>{};
    data["id"] = id;
    data["name"] = name;
    data["email"] = email;
    data["image"] = image;
    data["totalWins"] = totalWins;
    data["role"] = role;
    data["totalCoins"] = totalCoins;
    data["quickMess"] = quickMess;
    data["quickEmote"] = quickEmote;
    data["friendsList"] = friendsList;
    data["status"] = status;
    data["lastActive"] = lastActive;
    data["location"] = location;
    data["avatarFrame"] = avatarFrame;
    data["suspended"] = suspended;
    data["verified"] = verified;
    data["bio"] = bio;
    data["createdAt"] = createdAt;
    data["isOnline"] = isOnline;
    data["warningCount"] = warningCount;
    return data;
  }

  // Add the copyWith method to fix the 'copyWith' isn't defined for the type 'UserModel' error
  UserModel copyWith({
    String? id,
    String? name,
    String? email,
    String? image,
    String? totalWins,
    String? role,
    String? totalCoins,
    String? quickMess,
    String? quickEmote,
    List<String>? friendsList,
    String? status,
    Timestamp? lastActive,
    GeoPoint? location,
    List<String>? avatarFrame,
    bool? suspended,
    bool? verified,
    String? bio,
    Timestamp? createdAt,
    bool? isOnline,
    int? warningCount,
  }) {
    return UserModel(
      id: id ?? this.id,
      name: name ?? this.name,
      email: email ?? this.email,
      image: image ?? this.image,
      totalWins: totalWins ?? this.totalWins,
      role: role ?? this.role,
      totalCoins: totalCoins ?? this.totalCoins,
      quickMess: quickMess ?? this.quickMess,
      quickEmote: quickEmote ?? this.quickEmote,
      friendsList: friendsList ?? this.friendsList,
      status: status ?? this.status,
      lastActive: lastActive ?? this.lastActive,
      location: location ?? this.location,
      avatarFrame: avatarFrame ?? this.avatarFrame,
      suspended: suspended ?? this.suspended,
      verified: verified ?? this.verified,
      bio: bio ?? this.bio,
      createdAt: createdAt ?? this.createdAt,
      isOnline: isOnline ?? this.isOnline,
      warningCount: warningCount ?? this.warningCount,
    );
  }
}

```

---


### Pages\Admin\Pages\admin_home_page.dart

```dart
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:tictactoe_gameapp/Pages/Admin/Pages/dashboard_overview.dart';
import 'package:tictactoe_gameapp/Pages/Admin/Pages/tabs/user_support_system_tab.dart';
import 'package:tictactoe_gameapp/Pages/Splace/splace_page.dart';
import 'package:tictactoe_gameapp/Pages/Admin/controllers/admin_controller.dart';
import 'package:tictactoe_gameapp/Pages/Admin/Pages/tabs/user_management_tab.dart';
import 'package:tictactoe_gameapp/Pages/Admin/Pages/tabs/content_moderation_tab.dart';
import 'package:tictactoe_gameapp/Pages/Admin/Pages/tabs/analytics_tab.dart';
import 'package:tictactoe_gameapp/Pages/Admin/Pages/tabs/announcements_tab.dart';
import 'package:tictactoe_gameapp/Pages/Admin/Pages/tabs/game_management_tab.dart';

class AdminDashboardPage extends StatefulWidget {
  const AdminDashboardPage({super.key});

  @override
  State<AdminDashboardPage> createState() => _AdminDashboardPageState();
}

class _AdminDashboardPageState extends State<AdminDashboardPage>
    with SingleTickerProviderStateMixin {
  late AdminController controller;
  final RxInt currentTabIndex = 0.obs;

  @override
  void initState() {
    super.initState();
    // Make sure the controller is injected
    controller = Get.put(AdminController());

    // Listen to tab changes and update our reactive variable
    controller.tabController.addListener(() {
      if (controller.tabController.indexIsChanging) {
        currentTabIndex.value = controller.tabController.index;
      }
    });
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Admin Dashboard'),
        backgroundColor: Colors.deepPurple.withOpacity(0.5),
        bottom: TabBar(
          controller: controller.tabController,
          isScrollable: true,
          labelColor: Colors.blueAccent,
          unselectedLabelColor: Colors.blueGrey,
          indicatorSize: TabBarIndicatorSize.tab,
          splashBorderRadius: const BorderRadius.only(
            topLeft: Radius.circular(20),
            topRight: Radius.circular(20),
          ),
          indicatorWeight: 5,
          indicatorColor: Colors.white,
          tabs: const [
            Tab(
              icon: Icon(Icons.people),
              text: 'Users',
            ),
            Tab(
              icon: Icon(Icons.report),
              text: 'Moderation',
            ),
            Tab(
              icon: Icon(Icons.analytics),
              text: 'Analytics',
            ),
            Tab(
              icon: Icon(Icons.announcement),
              text: 'Announcements',
            ),
            Tab(
              icon: Icon(Icons.games),
              text: 'Games',
            ),
          ],
        ),
        actions: [
          IconButton(
            icon: const Icon(Icons.settings),
            tooltip: 'Settings',
            onPressed: () {
              Get.toNamed('/admin/settings');
            },
          ),
          IconButton(
            icon: const Icon(Icons.help_outline),
            tooltip: 'Help',
            onPressed: () {
              _showHelpDialog(context);
            },
          ),
        ],
      ),
      drawer: _buildAdminDrawer(context),
      body: TabBarView(
        controller: controller.tabController,
        children: const [
          UserManagementTab(),
          ContentModerationTab(),
          AnalyticsTab(),
          AnnouncementsTab(),
          GameManagementTab(),
        ],
      ),
      floatingActionButton: Obx(() {
        // Show different FAB based on the current tab
        // Now using our reactive variable
        switch (currentTabIndex.value) {
          case 0: // Users tab
            return FloatingActionButton(
              onPressed: () => _showAddUserDialog(context),
              backgroundColor: Colors.deepPurpleAccent,
              child: const Icon(Icons.person_add),
            );
          case 1: // Moderation tab
            return FloatingActionButton(
              onPressed: () => controller.fetchReportedContent(refresh: true),
              backgroundColor: Colors.deepPurpleAccent,
              child: const Icon(Icons.refresh),
            );
          case 3: // Announcements tab
            return FloatingActionButton(
              onPressed: () => _showCreateAnnouncementDialog(),
              backgroundColor: Colors.deepPurpleAccent,
              child: const Icon(Icons.add),
            );
          default:
            return const SizedBox.shrink(); // No FAB for other tabs
        }
      }),
    );
  }

  Widget _buildAdminDrawer(BuildContext context) {
    return Drawer(
      child: ListView(
        padding: EdgeInsets.zero,
        children: [
          DrawerHeader(
            decoration: const BoxDecoration(
              color: Colors.deepPurpleAccent,
            ),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                const CircleAvatar(
                  radius: 30,
                  backgroundColor: Colors.white,
                  child: Icon(
                    Icons.admin_panel_settings,
                    size: 30,
                    color: Colors.deepPurpleAccent,
                  ),
                ),
                const SizedBox(height: 10),
                const Text(
                  'Admin Dashboard',
                  style: TextStyle(
                    color: Colors.white,
                    fontSize: 20,
                  ),
                ),
                FutureBuilder<bool>(
                  future: controller.checkAdminAccess(),
                  builder: (context, snapshot) {
                    if (snapshot.hasData && snapshot.data == true) {
                      return const Text(
                        'You have full access',
                        style: TextStyle(
                          color: Colors.white70,
                        ),
                      );
                    }
                    return const Text(
                      'Loading permissions...',
                      style: TextStyle(
                        color: Colors.white70,
                      ),
                    );
                  },
                ),
              ],
            ),
          ),
          ListTile(
            leading: const Icon(Icons.dashboard),
            title: const Text('Dashboard'),
            onTap: () {
              Get.to(() => const DashboardOverviewPage());
            },
          ),
          ListTile(
            leading: const Icon(Icons.people),
            title: const Text('Support System'),
            onTap: () {
              Get.to(() => const SupportSystemPage());
            },
          ),
          ListTile(
            leading: const Icon(Icons.report),
            title: const Text('Content Moderation'),
            onTap: () {
              Get.back();
              controller.tabController.animateTo(1);
            },
          ),
          ListTile(
            leading: const Icon(Icons.analytics),
            title: const Text('Analytics'),
            onTap: () {
              Get.back();
              controller.tabController.animateTo(2);
            },
          ),
          ListTile(
            leading: const Icon(Icons.announcement),
            title: const Text('Announcements'),
            onTap: () {
              Get.back();
              controller.tabController.animateTo(3);
            },
          ),
          ListTile(
            leading: const Icon(Icons.games),
            title: const Text('Game Management'),
            onTap: () {
              Get.back();
              controller.tabController.animateTo(4);
            },
          ),
          const Divider(),
          ListTile(
            leading: const Icon(Icons.settings),
            title: const Text('Admin Settings'),
            onTap: () {
              Get.back();
              Get.toNamed('/admin/settings');
            },
          ),
          ListTile(
            leading: const Icon(Icons.help),
            title: const Text('Help & Documentation'),
            onTap: () {
              Get.back();
              _showHelpDialog(context);
            },
          ),
          const Divider(),
          ListTile(
            leading: const Icon(Icons.exit_to_app),
            title: const Text('Back to App'),
            onTap: () {
              Get.to(const SplacePage());
            },
          ),
        ],
      ),
    );
  }

  void _showHelpDialog(BuildContext context) {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Admin Dashboard Help'),
        content: const SingleChildScrollView(
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            mainAxisSize: MainAxisSize.min,
            children: [
              Text(
                'Welcome to the Admin Dashboard!',
                style: TextStyle(fontWeight: FontWeight.bold),
              ),
              SizedBox(height: 8),
              Text(
                  'This dashboard allows you to manage all aspects of your app:'),
              SizedBox(height: 8),
              Text(
                  '• User Management: Manage user accounts, roles, and permissions'),
              Text(
                  '• Content Moderation: Review and moderate reported content'),
              Text('• Analytics: View app usage statistics and reports'),
              Text('• Announcements: Create and manage system announcements'),
              Text(
                  '• Game Management: Configure game settings and leaderboards'),
              SizedBox(height: 16),
              Text(
                'Need more help?',
                style: TextStyle(fontWeight: FontWeight.bold),
              ),
              Text('Contact the development team at support@example.com'),
            ],
          ),
        ),
        actions: [
          TextButton(
            onPressed: () => Get.back(),
            child: const Text('CLOSE'),
          ),
        ],
      ),
    );
  }

  void _showAddUserDialog(BuildContext context) {
    // Show dialog to add a new user
    // This would be implemented in a real application
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Add New User'),
        content: const Text(
          'This feature would allow you to manually add a new user to the system. In a real application, this would include a form for user details.',
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(),
            child: const Text('CLOSE'),
          ),
        ],
      ),
    );
  }

  void _showCreateAnnouncementDialog() {
    // This is a helper method to show the announcement creation dialog
    // In a real implementation, we'd call a method in the AnnouncementsTab
    // or implement the dialog here
    Get.dialog(
      AlertDialog(
        title: const Text('Create Announcement'),
        content: const Text('Announcement creation form would go here'),
        actions: [
          TextButton(
            onPressed: () => Get.back(),
            child: const Text('CANCEL'),
          ),
          ElevatedButton(
            onPressed: () {
              // Create announcement logic
              Get.back();
            },
            child: const Text('CREATE'),
          ),
        ],
      ),
    );
  }
}

```

---


### Pages\Admin\Pages\admin_setting_page.dart

```dart
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:tictactoe_gameapp/Configs/messages.dart';
import 'package:tictactoe_gameapp/Pages/Admin/services/admin_service.dart';

class AdminSettingsPage extends StatefulWidget {
  const AdminSettingsPage({super.key});

  @override
  State<AdminSettingsPage> createState() => _AdminSettingsPageState();
}

class _AdminSettingsPageState extends State<AdminSettingsPage> {
  final AdminService _adminService = AdminService();
  bool _maintenance = false;
  bool _enableRealTimeReports = true;
  bool _enableBackupDaily = true;
  bool _notifyAdminsOnReport = true;
  int _autoDeleteReportsAfterDays = 30;

  @override
  void initState() {
    super.initState();
    _loadSettings();
  }

  Future<void> _loadSettings() async {
    try {
      final settings = await _adminService.getAdminSettings();
      setState(() {
        _maintenance = settings['maintenanceMode'] ?? false;
        _enableRealTimeReports = settings['enableRealTimeReports'] ?? true;
        _enableBackupDaily = settings['enableBackupDaily'] ?? true;
        _notifyAdminsOnReport = settings['notifyAdminsOnReport'] ?? true;
        _autoDeleteReportsAfterDays =
            settings['autoDeleteReportsAfterDays'] ?? 30;
      });
    } catch (e) {
      errorMessage('Không thể tải cài đặt: $e');
    }
  }

  Future<void> _saveSettings() async {
    try {
      await _adminService.updateAdminSettings({
        'maintenanceMode': _maintenance,
        'enableRealTimeReports': _enableRealTimeReports,
        'enableBackupDaily': _enableBackupDaily,
        'notifyAdminsOnReport': _notifyAdminsOnReport,
        'autoDeleteReportsAfterDays': _autoDeleteReportsAfterDays,
      });

      successMessage('Cài đặt đã được lưu');
    } catch (e) {
      errorMessage('Lỗi khi lưu cài đặt: $e');
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Cài Đặt Quản Trị'),
        backgroundColor: Colors.deepPurpleAccent,
        actions: [
          IconButton(
            icon: const Icon(Icons.save),
            onPressed: _saveSettings,
            tooltip: 'Lưu cài đặt',
          ),
        ],
      ),
      body: SingleChildScrollView(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            _buildGeneralSettings(),
            const SizedBox(height: 24),
            _buildReportSettings(),
            const SizedBox(height: 24),
            _buildBackupSettings(),
            const SizedBox(height: 24),
            _buildDangerZone(),
          ],
        ),
      ),
    );
  }

  Widget _buildGeneralSettings() {
    return Card(
      elevation: 2,
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            const Text(
              'Cài đặt chung',
              style: TextStyle(
                fontSize: 18,
                fontWeight: FontWeight.bold,
              ),
            ),
            const SizedBox(height: 16),
            SwitchListTile(
              title: const Text('Chế độ bảo trì'),
              subtitle: const Text(
                'Khi bật, người dùng không thể truy cập ứng dụng ngoại trừ admin',
              ),
              value: _maintenance,
              onChanged: (value) {
                setState(() {
                  _maintenance = value;
                });
              },
            ),
            const Divider(),
            ListTile(
              title: const Text('Phiên bản ứng dụng'),
              subtitle: const Text('1.0.0'),
              trailing: ElevatedButton(
                onPressed: () => _showForceUpdateDialog(),
                child: const Text('Cập nhật'),
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildReportSettings() {
    return Card(
      elevation: 2,
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            const Text(
              'Cài đặt báo cáo & kiểm duyệt',
              style: TextStyle(
                fontSize: 18,
                fontWeight: FontWeight.bold,
              ),
            ),
            const SizedBox(height: 16),
            SwitchListTile(
              title: const Text('Báo cáo thời gian thực'),
              subtitle: const Text(
                'Nhận thông báo khi có báo cáo mới từ người dùng',
              ),
              value: _enableRealTimeReports,
              onChanged: (value) {
                setState(() {
                  _enableRealTimeReports = value;
                });
              },
            ),
            SwitchListTile(
              title: const Text('Thông báo cho admin'),
              subtitle: const Text(
                'Gửi email cho tất cả admin khi có báo cáo mới',
              ),
              value: _notifyAdminsOnReport,
              onChanged: (value) {
                setState(() {
                  _notifyAdminsOnReport = value;
                });
              },
            ),
            ListTile(
              title: const Text('Tự động xóa báo cáo cũ sau'),
              subtitle: Slider(
                min: 7,
                max: 90,
                divisions: 11,
                value: _autoDeleteReportsAfterDays.toDouble(),
                label: '$_autoDeleteReportsAfterDays ngày',
                onChanged: (value) {
                  setState(() {
                    _autoDeleteReportsAfterDays = value.round();
                  });
                },
              ),
              trailing: Text(
                '$_autoDeleteReportsAfterDays ngày',
                style: const TextStyle(
                  fontWeight: FontWeight.bold,
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildBackupSettings() {
    return Card(
      elevation: 2,
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            const Text(
              'Cài đặt sao lưu & khôi phục',
              style: TextStyle(
                fontSize: 18,
                fontWeight: FontWeight.bold,
              ),
            ),
            const SizedBox(height: 16),
            SwitchListTile(
              title: const Text('Tự động sao lưu hàng ngày'),
              subtitle: const Text(
                'Tạo bản sao lưu dữ liệu tự động mỗi ngày',
              ),
              value: _enableBackupDaily,
              onChanged: (value) {
                setState(() {
                  _enableBackupDaily = value;
                });
              },
            ),
            ListTile(
              title: const Text('Sao lưu thủ công'),
              subtitle: const Text('Tạo bản sao lưu ngay bây giờ'),
              trailing: ElevatedButton.icon(
                onPressed: () => _createBackup(),
                icon: const Icon(Icons.backup),
                label: const Text('Sao lưu'),
              ),
            ),
            ListTile(
              title: const Text('Khôi phục dữ liệu'),
              subtitle: const Text('Khôi phục từ bản sao lưu đã chọn'),
              trailing: ElevatedButton.icon(
                onPressed: () => _showRestoreDialog(),
                icon: const Icon(Icons.restore),
                label: const Text('Khôi phục'),
                style: ElevatedButton.styleFrom(
                  backgroundColor: Colors.amber,
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildDangerZone() {
    return Card(
      elevation: 2,
      color: Colors.red.withOpacity(0.05),
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(8),
        side: const BorderSide(color: Colors.red, width: 1),
      ),
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            const Text(
              'Vùng nguy hiểm',
              style: TextStyle(
                fontSize: 18,
                fontWeight: FontWeight.bold,
                color: Colors.red,
              ),
            ),
            const SizedBox(height: 16),
            ListTile(
              title: const Text('Xóa tất cả báo cáo'),
              subtitle: const Text(
                'Xóa tất cả báo cáo nội dung từ người dùng',
              ),
              trailing: ElevatedButton(
                onPressed: () => _showDeleteAllReportsDialog(),
                style: ElevatedButton.styleFrom(
                  backgroundColor: Colors.red,
                ),
                child: const Text('Xóa tất cả'),
              ),
            ),
            ListTile(
              title: const Text('Đặt lại cài đặt mặc định'),
              subtitle: const Text(
                'Khôi phục tất cả cài đặt quản trị về mặc định',
              ),
              trailing: ElevatedButton(
                onPressed: () => _showResetSettingsDialog(),
                style: ElevatedButton.styleFrom(
                  backgroundColor: Colors.red,
                ),
                child: const Text('Đặt lại'),
              ),
            ),
          ],
        ),
      ),
    );
  }

  void _showForceUpdateDialog() {
    final versionController = TextEditingController(text: '1.0.1');
    final messageController = TextEditingController(
      text:
          'Chúng tôi đã cập nhật tính năng mới và sửa một số lỗi. Vui lòng cập nhật để có trải nghiệm tốt nhất.',
    );
    bool forceUpdate = true;

    Get.dialog(
      StatefulBuilder(
        builder: (context, setState) => AlertDialog(
          title: const Text('Thông báo cập nhật ứng dụng'),
          content: SingleChildScrollView(
            child: Column(
              mainAxisSize: MainAxisSize.min,
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                TextField(
                  controller: versionController,
                  decoration: const InputDecoration(
                    labelText: 'Phiên bản mới',
                    border: OutlineInputBorder(),
                  ),
                ),
                const SizedBox(height: 16),
                TextField(
                  controller: messageController,
                  decoration: const InputDecoration(
                    labelText: 'Thông báo cập nhật',
                    border: OutlineInputBorder(),
                  ),
                  maxLines: 3,
                ),
                const SizedBox(height: 16),
                SwitchListTile(
                  title: const Text('Bắt buộc cập nhật'),
                  subtitle: const Text(
                    'Người dùng phải cập nhật để tiếp tục sử dụng ứng dụng',
                  ),
                  value: forceUpdate,
                  contentPadding: EdgeInsets.zero,
                  onChanged: (value) {
                    setState(() {
                      forceUpdate = value;
                    });
                  },
                ),
              ],
            ),
          ),
          actions: [
            TextButton(
              onPressed: () => Get.back(),
              child: const Text('HỦY'),
            ),
            ElevatedButton(
              onPressed: () {
                // Implement update notification logic
                Get.back();
                successMessage('Đã gửi thông báo cập nhật cho người dùng');
              },
              style: ElevatedButton.styleFrom(
                backgroundColor: Colors.deepPurpleAccent,
              ),
              child: const Text('GỬI THÔNG BÁO'),
            ),
          ],
        ),
      ),
    );
  }

  Future<void> _createBackup() async {
    try {
      Get.dialog(
        const Center(
          child: CircularProgressIndicator(),
        ),
        barrierDismissible: false,
      );

      // Simulate backup creation
      await Future.delayed(const Duration(seconds: 2));

      Get.back();
      successMessage('Đã tạo bản sao lưu thành công');
    } catch (e) {
      Get.back();
      errorMessage('Lỗi khi tạo bản sao lưu: $e');
    }
  }

  void _showRestoreDialog() {
    // Mock backup data
    final backups = [
      {'date': '23/03/2025', 'size': '124 MB', 'id': 'backup1'},
      {'date': '22/03/2025', 'size': '123 MB', 'id': 'backup2'},
      {'date': '21/03/2025', 'size': '122 MB', 'id': 'backup3'},
    ];

    String? selectedBackupId;

    Get.dialog(
      StatefulBuilder(
        builder: (context, setState) => AlertDialog(
          title: const Text('Khôi phục dữ liệu'),
          content: SizedBox(
            width: double.maxFinite,
            child: Column(
              mainAxisSize: MainAxisSize.min,
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                const Text(
                  'Chọn bản sao lưu để khôi phục:',
                  style: TextStyle(fontWeight: FontWeight.bold),
                ),
                const SizedBox(height: 8),
                const Text(
                  'Cảnh báo: Khôi phục sẽ ghi đè lên dữ liệu hiện tại. Quá trình này không thể hoàn tác.',
                  style: TextStyle(color: Colors.red),
                ),
                const SizedBox(height: 16),
                Flexible(
                  child: ListView.builder(
                    shrinkWrap: true,
                    itemCount: backups.length,
                    itemBuilder: (context, index) {
                      final backup = backups[index];
                      final isSelected = backup['id'] == selectedBackupId;

                      return RadioListTile<String>(
                        title: Text('Sao lưu ngày ${backup['date']}'),
                        subtitle: Text('Kích thước: ${backup['size']}'),
                        value: backup['id'] as String,
                        groupValue: selectedBackupId,
                        onChanged: (value) {
                          setState(() {
                            selectedBackupId = value;
                          });
                        },
                      );
                    },
                  ),
                ),
              ],
            ),
          ),
          actions: [
            TextButton(
              onPressed: () => Get.back(),
              child: const Text('HỦY'),
            ),
            ElevatedButton(
              onPressed: selectedBackupId != null
                  ? () {
                      Get.back();
                      _confirmRestore(selectedBackupId!);
                    }
                  : null,
              style: ElevatedButton.styleFrom(
                backgroundColor: Colors.amber,
              ),
              child: const Text('KHÔI PHỤC'),
            ),
          ],
        ),
      ),
    );
  }

  void _confirmRestore(String backupId) {
    Get.dialog(
      AlertDialog(
        title: const Text('Xác nhận khôi phục'),
        content: const Text(
          'Bạn có chắc chắn muốn khôi phục dữ liệu từ bản sao lưu này? Dữ liệu hiện tại sẽ bị mất.',
        ),
        actions: [
          TextButton(
            onPressed: () => Get.back(),
            child: const Text('HỦY'),
          ),
          ElevatedButton(
            onPressed: () async {
              Get.back();

              Get.dialog(
                const Center(
                  child: CircularProgressIndicator(),
                ),
                barrierDismissible: false,
              );

              // Simulate restore process
              await Future.delayed(const Duration(seconds: 3));

              Get.back();
              successMessage('Khôi phục dữ liệu thành công');
            },
            style: ElevatedButton.styleFrom(
              backgroundColor: Colors.red,
            ),
            child: const Text('XÁC NHẬN'),
          ),
        ],
      ),
    );
  }

  void _showDeleteAllReportsDialog() {
    Get.dialog(
      AlertDialog(
        title: const Text('Xóa tất cả báo cáo'),
        content: const Text(
          'Bạn có chắc chắn muốn xóa tất cả báo cáo? Hành động này không thể hoàn tác.',
        ),
        actions: [
          TextButton(
            onPressed: () => Get.back(),
            child: const Text('HỦY'),
          ),
          ElevatedButton(
            onPressed: () async {
              Get.back();

              Get.dialog(
                const Center(
                  child: CircularProgressIndicator(),
                ),
                barrierDismissible: false,
              );

              // Simulate deletion process
              await Future.delayed(const Duration(seconds: 2));

              Get.back();
              successMessage('Đã xóa tất cả báo cáo thành công');
            },
            style: ElevatedButton.styleFrom(
              backgroundColor: Colors.red,
            ),
            child: const Text('XÓA TẤT CẢ'),
          ),
        ],
      ),
    );
  }

  void _showResetSettingsDialog() {
    Get.dialog(
      AlertDialog(
        title: const Text('Đặt lại cài đặt'),
        content: const Text(
          'Bạn có chắc chắn muốn đặt lại tất cả cài đặt quản trị về mặc định?',
        ),
        actions: [
          TextButton(
            onPressed: () => Get.back(),
            child: const Text('HỦY'),
          ),
          ElevatedButton(
            onPressed: () async {
              Get.back();

              setState(() {
                _maintenance = false;
                _enableRealTimeReports = true;
                _enableBackupDaily = true;
                _notifyAdminsOnReport = true;
                _autoDeleteReportsAfterDays = 30;
              });

              await _saveSettings();
              successMessage('Đã đặt lại cài đặt thành công');
            },
            style: ElevatedButton.styleFrom(
              backgroundColor: Colors.red,
            ),
            child: const Text('ĐẶT LẠI'),
          ),
        ],
      ),
    );
  }
}

```

---


### Pages\Admin\Pages\dashboard_overview.dart

```dart
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:fl_chart/fl_chart.dart';
import 'package:intl/intl.dart';
import 'package:tictactoe_gameapp/Configs/assets_path.dart';
import 'package:tictactoe_gameapp/Pages/Admin/controllers/admin_controller.dart';
import 'package:tictactoe_gameapp/Components/belong_to_users/avatar_user_widget.dart';
import 'package:tictactoe_gameapp/Configs/messages.dart';
import 'package:tictactoe_gameapp/Pages/Admin/controllers/dashboard_overview_controller.dart';
import 'package:tictactoe_gameapp/Pages/Admin/models/user_model.dart';

class DashboardOverviewPage extends StatelessWidget {
  const DashboardOverviewPage({super.key});

  @override
  Widget build(BuildContext context) {
    // Make sure controllers are injected
    Get.find<AdminController>();
    final dashboardController = Get.put(DashboardController());

    return Scaffold(
      body: RefreshIndicator(
        onRefresh: () => dashboardController.refreshAllData(),
        child: Obx(() {
          if (dashboardController.isLoading.value) {
            return Container(
              width: double.infinity,
              height: double.infinity,
              decoration: const BoxDecoration(
                image: DecorationImage(
                  image: AssetImage(
                    GifsPath.transitionGif,
                  ),
                  fit: BoxFit.cover,
                ),
              ),
            );
          }

          return LayoutBuilder(builder: (context, constraints) {
            // Determine if we're on a small screen
            final isSmallScreen = constraints.maxWidth < 600;

            return SingleChildScrollView(
              padding: const EdgeInsets.all(16.0),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  _buildBreadcrumbs(constraints),
                  const SizedBox(height: 16),
                  _buildStatsSummary(dashboardController, constraints),
                  const SizedBox(height: 24),
                  _buildUserActivityChart(dashboardController),
                  const SizedBox(height: 24),

                  // Responsive layout for reports and announcements
                  if (isSmallScreen)
                    Column(
                      children: [
                        _buildRecentReports(dashboardController),
                        const SizedBox(height: 16),
                        _buildActiveAnnouncements(dashboardController),
                      ],
                    )
                  else
                    Row(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Expanded(
                          flex: 3,
                          child: _buildRecentReports(dashboardController),
                        ),
                        const SizedBox(width: 16),
                        Expanded(
                          flex: 2,
                          child: _buildActiveAnnouncements(dashboardController),
                        ),
                      ],
                    ),

                  const SizedBox(height: 24),

                  // Responsive layout for users and games
                  if (isSmallScreen)
                    Column(
                      children: [
                        _buildTopUsers(dashboardController),
                        const SizedBox(height: 16),
                        _buildTopGames(dashboardController),
                      ],
                    )
                  else
                    Row(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Expanded(
                          child: _buildTopUsers(dashboardController),
                        ),
                        const SizedBox(width: 16),
                        Expanded(
                          child: _buildTopGames(dashboardController),
                        ),
                      ],
                    ),

                  const SizedBox(height: 24),
                  _buildSystemHealth(dashboardController),
                ],
              ),
            );
          });
        }),
      ),
      floatingActionButton: FloatingActionButton(
        onPressed: () => _showQuickActionsMenu(context, dashboardController),
        backgroundColor: Colors.deepPurpleAccent,
        child: const Icon(Icons.bolt),
        tooltip: 'Quick Actions',
      ),
    );
  }

  Widget _buildBreadcrumbs(BoxConstraints constraints) {
    final isSmallScreen = constraints.maxWidth < 600;

    return Container(
      padding: const EdgeInsets.symmetric(vertical: 8, horizontal: 16),
      decoration: BoxDecoration(
        color: Colors.grey[100],
        borderRadius: BorderRadius.circular(8),
      ),
      child: Row(
        children: [
          const Icon(Icons.dashboard, size: 16, color: Colors.grey),
          const SizedBox(width: 8),
          const Text(
            'Dashboard',
            style: TextStyle(color: Colors.grey),
          ),
          const SizedBox(width: 8),
          const Icon(Icons.chevron_right, size: 16, color: Colors.grey),
          const SizedBox(width: 8),
          const Text(
            'Overview',
            style: TextStyle(fontWeight: FontWeight.bold),
          ),
          const Spacer(),
          // Wrap in Flexible to handle potential overflow
          Flexible(
            child: Container(
              padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 4),
              decoration: BoxDecoration(
                color: Colors.green,
                borderRadius: BorderRadius.circular(12),
              ),
              child: Row(
                mainAxisSize: MainAxisSize.min,
                children: [
                  const Icon(
                    Icons.check_circle,
                    color: Colors.white,
                    size: 14,
                  ),
                  const SizedBox(width: 4),
                  // Limit text size on small screens
                  Flexible(
                    child: Text(
                      'All Systems Operational',
                      style: TextStyle(
                        color: Colors.white,
                        fontSize: isSmallScreen ? 10 : 12,
                        fontWeight: FontWeight.bold,
                      ),
                      overflow: TextOverflow.ellipsis,
                    ),
                  ),
                ],
              ),
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildStatsSummary(
      DashboardController controller, BoxConstraints constraints) {
    final stats = controller.summaryStats.value;
    final isSmallScreen = constraints.maxWidth < 600;
    final isMediumScreen =
        constraints.maxWidth < 1000 && constraints.maxWidth >= 600;

    // Determine grid columns based on screen width
    int crossAxisCount = 4;
    if (isSmallScreen) {
      crossAxisCount = 1;
    } else if (isMediumScreen) {
      crossAxisCount = 2;
    }

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Row(
          mainAxisAlignment: MainAxisAlignment.spaceBetween,
          children: [
            const Flexible(
              child: Text(
                'Dashboard Overview',
                style: TextStyle(
                  fontSize: 20,
                  fontWeight: FontWeight.bold,
                ),
                overflow: TextOverflow.ellipsis,
              ),
            ),
            Flexible(
              child: OutlinedButton.icon(
                onPressed: () => controller.refreshAllData(),
                icon: const Icon(Icons.refresh, size: 16),
                label: Text(
                  'Last updated: ${_getFormattedTime()}',
                  style: TextStyle(fontSize: isSmallScreen ? 10 : 12),
                  overflow: TextOverflow.ellipsis,
                ),
              ),
            ),
          ],
        ),
        const SizedBox(height: 16),
        GridView.count(
          crossAxisCount: crossAxisCount,
          crossAxisSpacing: 16,
          mainAxisSpacing: 16,
          shrinkWrap: true,
          childAspectRatio:
              isSmallScreen ? 2.5 : 1.5, // Adjust card aspect ratio
          physics: const NeverScrollableScrollPhysics(),
          children: [
            _buildStatCard(
              title: 'Total Users',
              value: '${stats['totalUsers'] ?? 0}',
              change: '+${stats['newUsers'] ?? 0} today',
              isPositive: true,
              icon: Icons.people,
              color: Colors.blue,
              onTap: () =>
                  Get.find<AdminController>().tabController.animateTo(0),
            ),
            _buildStatCard(
              title: 'Pending Reports',
              value: '${stats['pendingReports'] ?? 0}',
              change: '${stats['criticalReports'] ?? 0} critical',
              isPositive: false,
              icon: Icons.report_problem,
              color: Colors.orange,
              onTap: () =>
                  Get.find<AdminController>().tabController.animateTo(1),
            ),
            _buildStatCard(
              title: 'Active Games',
              value: '${stats['activeGames'] ?? 0}',
              change: '+${stats['newGames'] ?? 0} today',
              isPositive: true,
              icon: Icons.sports_esports,
              color: Colors.purple,
              onTap: () =>
                  Get.find<AdminController>().tabController.animateTo(4),
            ),
            _buildStatCard(
              title: 'Revenue',
              value: '\$${stats['revenue'] ?? 0}',
              change: '${stats['revenueChange'] ?? 0}% vs last week',
              isPositive: (stats['revenueChange'] ?? 0) >= 0,
              icon: Icons.attach_money,
              color: Colors.green,
              onTap: () => _showRevenueDetails(controller),
            ),
          ],
        ),
      ],
    );
  }

  Widget _buildStatCard({
    required String title,
    required String value,
    required String change,
    required bool isPositive,
    required IconData icon,
    required Color color,
    required VoidCallback onTap,
  }) {
    return InkWell(
      onTap: onTap,
      borderRadius: BorderRadius.circular(8),
      child: Container(
        padding: const EdgeInsets.all(16),
        decoration: BoxDecoration(
          color: Colors.white,
          borderRadius: BorderRadius.circular(8),
          boxShadow: [
            BoxShadow(
              color: Colors.grey.withOpacity(0.1),
              blurRadius: 10,
              spreadRadius: 1,
            ),
          ],
        ),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          mainAxisSize: MainAxisSize.min, // Prevent vertical expansion
          children: [
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                Flexible(
                  child: Text(
                    title,
                    style: TextStyle(
                      color: Colors.grey[700],
                      fontWeight: FontWeight.bold,
                    ),
                    overflow: TextOverflow.ellipsis,
                  ),
                ),
                Container(
                  padding: const EdgeInsets.all(8),
                  decoration: BoxDecoration(
                    color: color.withOpacity(0.1),
                    borderRadius: BorderRadius.circular(8),
                  ),
                  child: Icon(
                    icon,
                    color: color,
                    size: 20,
                  ),
                ),
              ],
            ),
            const Spacer(),
            FittedBox(
              fit: BoxFit.scaleDown,
              alignment: Alignment.centerLeft,
              child: Text(
                value,
                style: TextStyle(
                  fontSize: 24,
                  fontWeight: FontWeight.bold,
                  color: Colors.grey[900],
                ),
              ),
            ),
            const SizedBox(height: 4),
            Row(
              children: [
                Icon(
                  isPositive ? Icons.arrow_upward : Icons.arrow_downward,
                  color: isPositive ? Colors.green : Colors.red,
                  size: 16,
                ),
                const SizedBox(width: 4),
                Flexible(
                  child: Text(
                    change,
                    style: TextStyle(
                      color: isPositive ? Colors.green : Colors.red,
                      fontSize: 12,
                    ),
                    overflow: TextOverflow.ellipsis,
                  ),
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildUserActivityChart(DashboardController controller) {
    final userActivityData = controller.userActivityData;

    return Container(
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(8),
        boxShadow: [
          BoxShadow(
            color: Colors.grey.withOpacity(0.1),
            blurRadius: 10,
            spreadRadius: 1,
          ),
        ],
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            children: [
              const Flexible(
                child: Text(
                  'User Activity',
                  style: TextStyle(
                    fontSize: 16,
                    fontWeight: FontWeight.bold,
                  ),
                  overflow: TextOverflow.ellipsis,
                ),
              ),
              DropdownButton<String>(
                value: controller.activityTimeRange.value,
                underline: const SizedBox.shrink(),
                items: const [
                  DropdownMenuItem(value: 'day', child: Text('Today')),
                  DropdownMenuItem(value: 'week', child: Text('This Week')),
                  DropdownMenuItem(value: 'month', child: Text('This Month')),
                ],
                onChanged: (value) {
                  if (value != null) {
                    controller.activityTimeRange.value = value;
                    controller.loadUserActivityData(timeRange: value);
                  }
                },
              ),
            ],
          ),
          const SizedBox(height: 16),
          // Wrap chart in a LimitedBox to prevent height issues when data is loading
          LimitedBox(
            maxHeight: 250,
            child: userActivityData.isEmpty
                ? const Center(child: Text('No activity data available'))
                : _buildActivityChart(
                    userActivityData, controller.maxUserActivity.value),
          ),
          const SizedBox(height: 16),
          // Use Wrap instead of Row for better handling of small screens
          Wrap(
            spacing: 16,
            runSpacing: 8,
            alignment: WrapAlignment.center,
            children: [
              _buildLegendItem('Active Users', Colors.blue),
              _buildLegendItem('New Registrations', Colors.green),
              _buildLegendItem('Game Sessions', Colors.purple),
            ],
          ),
        ],
      ),
    );
  }

  // Extracted chart building logic to separate method for clarity
  Widget _buildActivityChart(
      List<Map<String, dynamic>> userActivityData, int maxValue) {
    return LineChart(
      LineChartData(
        gridData: FlGridData(
          show: true,
          drawVerticalLine: false,
          horizontalInterval: 1,
          getDrawingHorizontalLine: (value) {
            return FlLine(
              color: Colors.grey.withOpacity(0.2),
              strokeWidth: 1,
            );
          },
        ),
        titlesData: FlTitlesData(
          show: true,
          bottomTitles: AxisTitles(
            sideTitles: SideTitles(
              showTitles: true,
              reservedSize: 30,
              getTitlesWidget: (value, meta) {
                final index = value.toInt();
                if (index >= 0 && index < userActivityData.length) {
                  return SideTitleWidget(
                    axisSide: meta.axisSide,
                    child: Text(
                      userActivityData[index]['label'] as String,
                      style: const TextStyle(
                        color: Colors.grey,
                        fontSize: 12,
                      ),
                      overflow: TextOverflow.ellipsis,
                      maxLines: 1,
                    ),
                  );
                }
                return const SizedBox.shrink();
              },
            ),
          ),
          leftTitles: AxisTitles(
            sideTitles: SideTitles(
              showTitles: true,
              reservedSize: 40,
              getTitlesWidget: (value, meta) {
                return SideTitleWidget(
                  axisSide: meta.axisSide,
                  child: Text(
                    value.toInt().toString(),
                    style: const TextStyle(
                      color: Colors.grey,
                      fontSize: 12,
                    ),
                  ),
                );
              },
            ),
          ),
          rightTitles: const AxisTitles(
            sideTitles: SideTitles(showTitles: false),
          ),
          topTitles: const AxisTitles(
            sideTitles: SideTitles(showTitles: false),
          ),
        ),
        borderData: FlBorderData(
          show: true,
          border: Border(
            bottom: BorderSide(color: Colors.grey.withOpacity(0.2)),
            left: BorderSide(color: Colors.grey.withOpacity(0.2)),
          ),
        ),
        minX: 0,
        maxX: userActivityData.length - 1.0,
        minY: 0,
        maxY: maxValue.toDouble(),
        lineBarsData: [
          // Active Users
          LineChartBarData(
            spots: List.generate(userActivityData.length, (index) {
              return FlSpot(
                index.toDouble(),
                (userActivityData[index]['activeUsers'] as int).toDouble(),
              );
            }),
            isCurved: true,
            color: Colors.blue,
            barWidth: 3,
            isStrokeCapRound: true,
            dotData: const FlDotData(show: false),
            belowBarData: BarAreaData(
              show: true,
              color: Colors.blue.withOpacity(0.1),
            ),
          ),
          // New Users
          LineChartBarData(
            spots: List.generate(userActivityData.length, (index) {
              return FlSpot(
                index.toDouble(),
                (userActivityData[index]['newUsers'] as int).toDouble(),
              );
            }),
            isCurved: true,
            color: Colors.green,
            barWidth: 3,
            isStrokeCapRound: true,
            dotData: const FlDotData(show: false),
            belowBarData: BarAreaData(
              show: true,
              color: Colors.green.withOpacity(0.1),
            ),
          ),
          // Game Sessions
          LineChartBarData(
            spots: List.generate(userActivityData.length, (index) {
              return FlSpot(
                index.toDouble(),
                (userActivityData[index]['gameSessions'] as int).toDouble(),
              );
            }),
            isCurved: true,
            color: Colors.purple,
            barWidth: 3,
            isStrokeCapRound: true,
            dotData: const FlDotData(show: false),
            belowBarData: BarAreaData(
              show: true,
              color: Colors.purple.withOpacity(0.1),
            ),
          ),
        ],
        lineTouchData: LineTouchData(
          handleBuiltInTouches: true,
          touchTooltipData: LineTouchTooltipData(
            getTooltipItems: (List<LineBarSpot> touchedSpots) {
              return touchedSpots.map((LineBarSpot touchedSpot) {
                final index = touchedSpot.x.toInt();
                if (index < 0 || index >= userActivityData.length) {
                  return null;
                }

                final dataPoint = userActivityData[index];
                final String dataLabel = dataPoint['label'] as String;

                String title;
                String value;

                if (touchedSpot.barIndex == 0) {
                  title = 'Active Users';
                  value = dataPoint['activeUsers'].toString();
                } else if (touchedSpot.barIndex == 1) {
                  title = 'New Users';
                  value = dataPoint['newUsers'].toString();
                } else {
                  title = 'Game Sessions';
                  value = dataPoint['gameSessions'].toString();
                }

                return LineTooltipItem(
                  '$dataLabel\n$title: $value',
                  const TextStyle(
                    color: Colors.white,
                    fontWeight: FontWeight.bold,
                  ),
                );
              }).toList();
            },
          ),
        ),
      ),
    );
  }

  Widget _buildLegendItem(String label, Color color) {
    return Row(
      mainAxisSize:
          MainAxisSize.min, // Important to prevent Row from taking full width
      children: [
        Container(
          width: 12,
          height: 12,
          decoration: BoxDecoration(
            color: color,
            borderRadius: BorderRadius.circular(2),
          ),
        ),
        const SizedBox(width: 4),
        Text(
          label,
          style: const TextStyle(
            fontSize: 12,
            color: Colors.grey,
          ),
        ),
      ],
    );
  }

  Widget _buildRecentReports(DashboardController controller) {
    final reports = controller.recentReports;

    return Container(
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(8),
        boxShadow: [
          BoxShadow(
            color: Colors.grey.withOpacity(0.1),
            blurRadius: 10,
            spreadRadius: 1,
          ),
        ],
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            children: [
              const Flexible(
                child: Text(
                  'Recent Reports',
                  style: TextStyle(
                    fontSize: 16,
                    fontWeight: FontWeight.bold,
                  ),
                  overflow: TextOverflow.ellipsis,
                ),
              ),
              TextButton(
                onPressed: () =>
                    Get.find<AdminController>().tabController.animateTo(1),
                child: const Text('View All'),
              ),
            ],
          ),
          const SizedBox(height: 8),

          LayoutBuilder(builder: (context, constraints) {
            final isNarrow = constraints.maxWidth < 400;

            return reports.isEmpty
                ? const Center(
                    child: Padding(
                      padding: EdgeInsets.all(16.0),
                      child: Text(
                        'No recent reports',
                        style: TextStyle(color: Colors.grey),
                      ),
                    ),
                  )
                : ListView.separated(
                    shrinkWrap: true,
                    physics: const NeverScrollableScrollPhysics(),
                    itemCount: reports.length > 5 ? 5 : reports.length,
                    separatorBuilder: (context, index) => const Divider(),
                    itemBuilder: (context, index) {
                      final report = reports[index];
                      final contentType =
                          report['contentType'] as String? ?? '';
                      final reportReason =
                          report['reason'] as String? ?? 'Not specified';
                      final reportedAt =
                          report['reportedAt'] as DateTime? ?? DateTime.now();
                      final reporterName =
                          report['reporter']['name'] as String? ?? 'Unknown';

                      IconData iconData;
                      Color iconColor;

                      switch (contentType) {
                        case 'post':
                          iconData = Icons.article;
                          iconColor = Colors.blue;
                          break;
                        case 'comment':
                          iconData = Icons.comment;
                          iconColor = Colors.green;
                          break;
                        case 'user':
                          iconData = Icons.person;
                          iconColor = Colors.orange;
                          break;
                        default:
                          iconData = Icons.report_problem;
                          iconColor = Colors.red;
                      }

                      return ListTile(
                        contentPadding: isNarrow
                            ? const EdgeInsets.symmetric(
                                horizontal: 8.0, vertical: 4.0)
                            : null,
                        leading: Container(
                          padding: const EdgeInsets.all(8),
                          decoration: BoxDecoration(
                            color: iconColor.withOpacity(0.1),
                            borderRadius: BorderRadius.circular(8),
                          ),
                          child: Icon(
                            iconData,
                            color: iconColor,
                            size: isNarrow ? 16 : 24,
                          ),
                        ),
                        title: Row(
                          children: [
                            Flexible(
                              child: Text(
                                'Reported ${contentType.capitalizeFirst}',
                                style: const TextStyle(
                                  fontWeight: FontWeight.bold,
                                ),
                                overflow: TextOverflow.ellipsis,
                              ),
                            ),
                            const SizedBox(width: 8),
                            Container(
                              padding: const EdgeInsets.symmetric(
                                  horizontal: 8, vertical: 2),
                              decoration: BoxDecoration(
                                color: Colors.red.withOpacity(0.1),
                                borderRadius: BorderRadius.circular(12),
                              ),
                              child: const Text(
                                'New',
                                style: TextStyle(
                                  color: Colors.red,
                                  fontSize: 10,
                                  fontWeight: FontWeight.bold,
                                ),
                              ),
                            ),
                          ],
                        ),
                        subtitle: Column(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          children: [
                            Text(
                              'Reason: $reportReason',
                              maxLines: 1,
                              overflow: TextOverflow.ellipsis,
                              style: TextStyle(fontSize: isNarrow ? 11 : 12),
                            ),
                            Text(
                              'By $reporterName • ${_timeAgo(reportedAt)}',
                              style: TextStyle(
                                fontSize: isNarrow ? 10 : 12,
                                color: Colors.grey,
                              ),
                              maxLines: 1,
                              overflow: TextOverflow.ellipsis,
                            ),
                          ],
                        ),
                        trailing: IconButton(
                          icon: const Icon(Icons.chevron_right),
                          iconSize: isNarrow ? 16 : 24,
                          constraints: const BoxConstraints(),
                          padding: EdgeInsets.zero,
                          onPressed: () => _showReportDetails(report),
                        ),
                        onTap: () => _showReportDetails(report),
                      );
                    },
                  );
          }),

          // Gap added to ensure consistent spacing
          const SizedBox(height: 8),
        ],
      ),
    );
  }

  Widget _buildActiveAnnouncements(DashboardController controller) {
    final announcements = controller.activeAnnouncements;

    return Container(
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(8),
        boxShadow: [
          BoxShadow(
            color: Colors.grey.withOpacity(0.1),
            blurRadius: 10,
            spreadRadius: 1,
          ),
        ],
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            children: [
              const Text(
                'Active Announcements',
                style: TextStyle(
                  fontSize: 16,
                  fontWeight: FontWeight.bold,
                ),
              ),
              TextButton(
                onPressed: () =>
                    Get.find<AdminController>().tabController.animateTo(3),
                child: const Text('View All'),
              ),
            ],
          ),
          const SizedBox(height: 8),
          ListView.separated(
            shrinkWrap: true,
            physics: const NeverScrollableScrollPhysics(),
            itemCount: announcements.length > 3 ? 3 : announcements.length,
            separatorBuilder: (context, index) => const Divider(),
            itemBuilder: (context, index) {
              final announcement = announcements[index];
              final title = announcement['title'] as String? ?? 'No title';
              final type = announcement['type'] as String? ?? 'system';
              final startDate =
                  announcement['startDate'] as DateTime? ?? DateTime.now();
              final endDate = announcement['endDate'] as DateTime?;

              IconData iconData;
              Color iconColor;

              switch (type) {
                case 'system':
                  iconData = Icons.announcement;
                  iconColor = Colors.blue;
                  break;
                case 'maintenance':
                  iconData = Icons.build;
                  iconColor = Colors.orange;
                  break;
                case 'event':
                  iconData = Icons.event;
                  iconColor = Colors.green;
                  break;
                default:
                  iconData = Icons.info;
                  iconColor = Colors.grey;
              }

              return ListTile(
                leading: Container(
                  padding: const EdgeInsets.all(8),
                  decoration: BoxDecoration(
                    color: iconColor.withOpacity(0.1),
                    borderRadius: BorderRadius.circular(8),
                  ),
                  child: Icon(
                    iconData,
                    color: iconColor,
                  ),
                ),
                title: Text(
                  title,
                  maxLines: 1,
                  overflow: TextOverflow.ellipsis,
                  style: const TextStyle(
                    fontWeight: FontWeight.bold,
                  ),
                ),
                subtitle: Text(
                  endDate != null
                      ? 'Active until ${DateFormat('MMM dd').format(endDate)}'
                      : 'Started on ${DateFormat('MMM dd').format(startDate)}',
                  style: const TextStyle(
                    fontSize: 12,
                    color: Colors.grey,
                  ),
                ),
                trailing: IconButton(
                  icon: const Icon(Icons.chevron_right),
                  onPressed: () => _showAnnouncementDetails(announcement),
                ),
                onTap: () => _showAnnouncementDetails(announcement),
              );
            },
          ),
          if (announcements.isEmpty)
            const Center(
              child: Padding(
                padding: EdgeInsets.all(16.0),
                child: Text(
                  'No active announcements',
                  style: TextStyle(color: Colors.grey),
                ),
              ),
            ),
          const SizedBox(height: 8),
          SizedBox(
            width: double.infinity,
            child: ElevatedButton.icon(
              onPressed: () => _showCreateAnnouncementDialog(),
              icon: const Icon(Icons.add),
              label: const Text('New Announcement'),
              style: ElevatedButton.styleFrom(
                backgroundColor: Colors.deepPurpleAccent,
              ),
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildTopUsers(DashboardController controller) {
    final users = controller.topUsers;

    return Container(
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(8),
        boxShadow: [
          BoxShadow(
            color: Colors.grey.withOpacity(0.1),
            blurRadius: 10,
            spreadRadius: 1,
          ),
        ],
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            children: [
              const Flexible(
                child: Text(
                  'Top Users',
                  style: TextStyle(
                    fontSize: 16,
                    fontWeight: FontWeight.bold,
                  ),
                  overflow: TextOverflow.ellipsis,
                ),
              ),
              // Dropdown with overflow protection
              DropdownButtonHideUnderline(
                child: DropdownButton<String>(
                  value: controller.userSortCriteria.value,
                  isDense: true, // Make dropdown more compact
                  items: const [
                    DropdownMenuItem(value: 'coins', child: Text('By Coins')),
                    DropdownMenuItem(value: 'wins', child: Text('By Wins')),
                    DropdownMenuItem(
                        value: 'activity', child: Text('By Activity')),
                  ],
                  onChanged: (value) {
                    if (value != null) {
                      controller.userSortCriteria.value = value;
                      controller.loadTopUsers(sortBy: value);
                    }
                  },
                ),
              ),
            ],
          ),
          const SizedBox(height: 8),

          LayoutBuilder(builder: (context, constraints) {
            final isNarrow = constraints.maxWidth < 400;

            return users.isEmpty
                ? const Center(
                    child: Padding(
                      padding: EdgeInsets.all(16.0),
                      child: Text(
                        'No user data available',
                        style: TextStyle(color: Colors.grey),
                      ),
                    ),
                  )
                : ListView.separated(
                    shrinkWrap: true,
                    physics: const NeverScrollableScrollPhysics(),
                    itemCount: users.length > 5 ? 5 : users.length,
                    separatorBuilder: (context, index) => const Divider(),
                    itemBuilder: (context, index) {
                      final user = users[index];
                      return ListTile(
                        contentPadding: isNarrow
                            ? const EdgeInsets.symmetric(
                                horizontal: 8.0, vertical: 4.0)
                            : null,
                        leading: Stack(
                          children: [
                            AvatarUserWidget(
                              radius: isNarrow ? 16 : 20,
                              imagePath: user.image ?? '',
                            ),
                            Positioned(
                              right: 0,
                              bottom: 0,
                              child: Container(
                                padding: const EdgeInsets.all(2),
                                decoration: BoxDecoration(
                                  color: Colors.white,
                                  border:
                                      Border.all(color: Colors.white, width: 2),
                                  borderRadius: BorderRadius.circular(8),
                                ),
                                child: Text(
                                  '${index + 1}',
                                  style: TextStyle(
                                    fontSize: 10,
                                    fontWeight: FontWeight.bold,
                                    color: _getRankColor(index),
                                  ),
                                ),
                              ),
                            ),
                          ],
                        ),
                        title: Text(
                          user.name ?? 'Unknown',
                          style: TextStyle(
                            fontWeight: FontWeight.bold,
                            fontSize: isNarrow ? 13 : 14,
                          ),
                          overflow: TextOverflow.ellipsis,
                        ),
                        subtitle: Text(
                          controller.userSortCriteria.value == 'coins'
                              ? '${user.totalCoins ?? "0"} coins'
                              : controller.userSortCriteria.value == 'wins'
                                  ? '${user.totalWins ?? "0"} wins'
                                  : 'Last: ${_timeAgo(user.lastActive?.toDate() ?? DateTime.now())}',
                          overflow: TextOverflow.ellipsis,
                          style: TextStyle(fontSize: isNarrow ? 11 : 12),
                        ),
                        trailing: Chip(
                          label: Text(
                            user.role ?? 'user',
                            style: TextStyle(
                                color: Colors.white,
                                fontSize: isNarrow ? 9 : 10),
                          ),
                          backgroundColor: _getRoleColor(user.role),
                          labelStyle: const TextStyle(color: Colors.white),
                          padding: EdgeInsets.zero,
                          materialTapTargetSize:
                              MaterialTapTargetSize.shrinkWrap,
                          visualDensity: VisualDensity.compact,
                        ),
                        onTap: () => _showUserDetails(user),
                      );
                    },
                  );
          }),

          const SizedBox(height: 8),

          // View all button
          Center(
            child: TextButton(
              onPressed: () =>
                  Get.find<AdminController>().tabController.animateTo(0),
              child: const Text('View All Users'),
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildTopGames(DashboardController controller) {
    final games = controller.topGames;

    return Container(
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(8),
        boxShadow: [
          BoxShadow(
            color: Colors.grey.withOpacity(0.1),
            blurRadius: 10,
            spreadRadius: 1,
          ),
        ],
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            children: [
              const Flexible(
                child: Text(
                  'Top Games',
                  style: TextStyle(
                    fontSize: 16,
                    fontWeight: FontWeight.bold,
                  ),
                  overflow: TextOverflow.ellipsis,
                ),
              ),
              DropdownButtonHideUnderline(
                child: DropdownButton<String>(
                  value: controller.gameSortCriteria.value,
                  isDense: true,
                  items: const [
                    DropdownMenuItem(value: 'plays', child: Text('By Plays')),
                    DropdownMenuItem(
                        value: 'active', child: Text('By Active Users')),
                    DropdownMenuItem(
                        value: 'revenue', child: Text('By Revenue')),
                  ],
                  onChanged: (value) {
                    if (value != null) {
                      controller.gameSortCriteria.value = value;
                      controller.loadTopGames(sortBy: value);
                    }
                  },
                ),
              ),
            ],
          ),
          const SizedBox(height: 8),
          LayoutBuilder(builder: (context, constraints) {
            final isNarrow = constraints.maxWidth < 400;

            return games.isEmpty
                ? const Center(
                    child: Padding(
                      padding: EdgeInsets.all(16.0),
                      child: Text(
                        'No game data available',
                        style: TextStyle(color: Colors.grey),
                      ),
                    ),
                  )
                : ListView.separated(
                    shrinkWrap: true,
                    physics: const NeverScrollableScrollPhysics(),
                    itemCount: games.length,
                    separatorBuilder: (context, index) => const Divider(),
                    itemBuilder: (context, index) {
                      final game = games[index];
                      final gameId = game['id'] as String;
                      final gameName = game['name'] as String;
                      final gameImage = game['image'] as String?;
                      final value =
                          game[controller.gameSortCriteria.value] as int? ?? 0;
                      final growth = game['growth'] as int? ?? 0;
                      final isPositive = growth >= 0;

                      return ListTile(
                        contentPadding: isNarrow
                            ? const EdgeInsets.symmetric(
                                horizontal: 8.0, vertical: 4.0)
                            : null,
                        leading: Container(
                          width: isNarrow ? 30 : 40,
                          height: isNarrow ? 30 : 40,
                          decoration: BoxDecoration(
                            color: _getGameColor(gameId).withOpacity(0.1),
                            borderRadius: BorderRadius.circular(8),
                          ),
                          child: gameImage != null && gameImage.isNotEmpty
                              ? ClipRRect(
                                  borderRadius: BorderRadius.circular(8),
                                  child: Image.network(
                                    gameImage,
                                    fit: BoxFit.cover,
                                    errorBuilder: (context, error, stackTrace) {
                                      return Icon(
                                        Icons.sports_esports,
                                        color: _getGameColor(gameId),
                                        size: isNarrow ? 16 : 24,
                                      );
                                    },
                                  ),
                                )
                              : Icon(
                                  Icons.sports_esports,
                                  color: _getGameColor(gameId),
                                  size: isNarrow ? 16 : 24,
                                ),
                        ),
                        title: Text(
                          gameName,
                          style: TextStyle(
                            fontWeight: FontWeight.bold,
                            fontSize: isNarrow ? 13 : 14,
                          ),
                          overflow: TextOverflow.ellipsis,
                        ),
                        subtitle: Row(
                          children: [
                            Flexible(
                              child: Text(
                                controller.gameSortCriteria.value == 'plays'
                                    ? '$value plays'
                                    : controller.gameSortCriteria.value ==
                                            'active'
                                        ? '$value active users'
                                        : '\$$value revenue',
                                style: TextStyle(fontSize: isNarrow ? 11 : 12),
                                overflow: TextOverflow.ellipsis,
                              ),
                            ),
                            const SizedBox(width: 8),
                            Icon(
                              isPositive
                                  ? Icons.arrow_upward
                                  : Icons.arrow_downward,
                              color: isPositive ? Colors.green : Colors.red,
                              size: isNarrow ? 10 : 12,
                            ),
                            Text(
                              '$growth%',
                              style: TextStyle(
                                color: isPositive ? Colors.green : Colors.red,
                                fontSize: isNarrow ? 10 : 12,
                              ),
                            ),
                          ],
                        ),
                        trailing: IconButton(
                          icon: const Icon(Icons.chevron_right),
                          iconSize: isNarrow ? 16 : 24,
                          constraints: const BoxConstraints(),
                          padding: EdgeInsets.zero,
                          onPressed: () => _showGameDetails(game),
                        ),
                        onTap: () => _showGameDetails(game),
                      );
                    },
                  );
          }),
          const SizedBox(height: 8),
          Center(
            child: TextButton(
              onPressed: () =>
                  Get.find<AdminController>().tabController.animateTo(4),
              child: const Text('View All Games'),
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildSystemHealth(DashboardController controller) {
    final systemHealth = controller.systemHealth.value;

    return Container(
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(8),
        boxShadow: [
          BoxShadow(
            color: Colors.grey.withOpacity(0.1),
            blurRadius: 10,
            spreadRadius: 1,
          ),
        ],
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            children: [
              const Text(
                'System Health',
                style: TextStyle(
                  fontSize: 16,
                  fontWeight: FontWeight.bold,
                ),
              ),
              OutlinedButton.icon(
                onPressed: () => controller.loadSystemHealth(),
                icon: const Icon(Icons.refresh, size: 16),
                label: const Text('Refresh'),
              ),
            ],
          ),
          const SizedBox(height: 16),
          Row(
            children: [
              Expanded(
                child: _buildHealthCard(
                  title: 'API',
                  status: systemHealth['apiStatus'] ?? 'unknown',
                  value: '${systemHealth['apiResponseTime'] ?? 0} ms',
                ),
              ),
              const SizedBox(width: 16),
              Expanded(
                child: _buildHealthCard(
                  title: 'Database',
                  status: systemHealth['dbStatus'] ?? 'unknown',
                  value: '${systemHealth['dbConnections'] ?? 0} connections',
                ),
              ),
              const SizedBox(width: 16),
              Expanded(
                child: _buildHealthCard(
                  title: 'Storage',
                  status: systemHealth['storageStatus'] ?? 'unknown',
                  value: '${systemHealth['storageUsage'] ?? 0}% used',
                ),
              ),
              const SizedBox(width: 16),
              Expanded(
                child: _buildHealthCard(
                  title: 'Caching',
                  status: systemHealth['cacheStatus'] ?? 'unknown',
                  value: '${systemHealth['cacheHitRate'] ?? 0}% hit rate',
                ),
              ),
            ],
          ),
          const SizedBox(height: 16),
          const Text(
            'Recent System Logs',
            style: TextStyle(
              fontWeight: FontWeight.bold,
            ),
          ),
          const SizedBox(height: 8),
          Container(
            height: 120,
            padding: const EdgeInsets.all(8),
            decoration: BoxDecoration(
              color: Colors.grey[100],
              borderRadius: BorderRadius.circular(8),
              border: Border.all(color: Colors.grey.withOpacity(0.2)),
            ),
            child: ListView.builder(
              itemCount: controller.systemLogs.length,
              itemBuilder: (context, index) {
                final log = controller.systemLogs[index];
                final level = log['level'] as String? ?? 'info';
                final message = log['message'] as String? ?? '';
                final timestamp =
                    log['timestamp'] as DateTime? ?? DateTime.now();

                Color levelColor;
                switch (level.toLowerCase()) {
                  case 'error':
                    levelColor = Colors.red;
                    break;
                  case 'warning':
                    levelColor = Colors.orange;
                    break;
                  case 'info':
                    levelColor = Colors.blue;
                    break;
                  default:
                    levelColor = Colors.grey;
                }

                return Padding(
                  padding: const EdgeInsets.symmetric(vertical: 2),
                  child: Row(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text(
                        '[${level.toUpperCase()}]',
                        style: TextStyle(
                          color: levelColor,
                          fontWeight: FontWeight.bold,
                          fontSize: 12,
                        ),
                      ),
                      const SizedBox(width: 8),
                      Text(
                        DateFormat('HH:mm:ss').format(timestamp),
                        style: const TextStyle(
                          color: Colors.grey,
                          fontSize: 12,
                        ),
                      ),
                      const SizedBox(width: 8),
                      Expanded(
                        child: Text(
                          message,
                          style: const TextStyle(fontSize: 12),
                          overflow: TextOverflow.ellipsis,
                        ),
                      ),
                    ],
                  ),
                );
              },
            ),
          ),
          const SizedBox(height: 16),
          SingleChildScrollView(
            scrollDirection: Axis.horizontal,
            child: Row(
              mainAxisAlignment: MainAxisAlignment.end,
              children: [
                OutlinedButton.icon(
                  onPressed: () => _showSystemLogs(),
                  icon: const Icon(Icons.list_alt),
                  label: const Text('View All Logs'),
                ),
                const SizedBox(width: 16),
                ElevatedButton.icon(
                  onPressed: () => _showMaintenanceDialog(),
                  icon: const Icon(Icons.settings),
                  label: const Text('Maintenance Settings'),
                  style: ElevatedButton.styleFrom(
                    backgroundColor: Colors.deepPurpleAccent,
                  ),
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildHealthCard({
    required String title,
    required String status,
    required String value,
  }) {
    Color statusColor;
    IconData statusIcon;

    switch (status.toLowerCase()) {
      case 'good':
        statusColor = Colors.green;
        statusIcon = Icons.check_circle;
        break;
      case 'warning':
        statusColor = Colors.orange;
        statusIcon = Icons.warning;
        break;
      case 'error':
        statusColor = Colors.red;
        statusIcon = Icons.error;
        break;
      default:
        statusColor = Colors.grey;
        statusIcon = Icons.help;
    }

    return Container(
      padding: const EdgeInsets.all(12),
      decoration: BoxDecoration(
        color: statusColor.withOpacity(0.05),
        borderRadius: BorderRadius.circular(8),
        border: Border.all(color: statusColor.withOpacity(0.3)),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          SingleChildScrollView(
            scrollDirection: Axis.horizontal,
            child: Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                Text(
                  title,
                  style: const TextStyle(
                    fontWeight: FontWeight.bold,
                  ),
                ),
                Icon(
                  statusIcon,
                  color: statusColor,
                  size: 16,
                ),
              ],
            ),
          ),
          const SizedBox(height: 4),
          Text(
            value,
            style: TextStyle(
              color: Colors.grey[800],
              fontSize: 12,
            ),
          ),
          const SizedBox(height: 2),
          Text(
            status.toUpperCase(),
            style: TextStyle(
              color: statusColor,
              fontSize: 10,
              fontWeight: FontWeight.bold,
            ),
          ),
        ],
      ),
    );
  }

  // Helper methods
  String _getFormattedTime() {
    return DateFormat('MMM dd, HH:mm').format(DateTime.now());
  }

  String _timeAgo(DateTime dateTime) {
    final now = DateTime.now();
    final difference = now.difference(dateTime);

    if (difference.inDays > 365) {
      return '${(difference.inDays / 365).floor()} years ago';
    } else if (difference.inDays > 30) {
      return '${(difference.inDays / 30).floor()} months ago';
    } else if (difference.inDays > 7) {
      return '${(difference.inDays / 7).floor()} weeks ago';
    } else if (difference.inDays > 0) {
      return '${difference.inDays} days ago';
    } else if (difference.inHours > 0) {
      return '${difference.inHours} hours ago';
    } else if (difference.inMinutes > 0) {
      return '${difference.inMinutes} minutes ago';
    } else {
      return 'Just now';
    }
  }

  Color _getRankColor(int rank) {
    switch (rank) {
      case 0:
        return Colors.amber; // Gold
      case 1:
        return Colors.grey.shade400; // Silver
      case 2:
        return Colors.brown.shade300; // Bronze
      default:
        return Colors.grey.shade800; // Regular
    }
  }

  Color _getRoleColor(String? role) {
    switch (role) {
      case 'admin':
        return Colors.red;
      case 'moderator':
        return Colors.green;
      case 'user':
      default:
        return Colors.blue;
    }
  }

  Color _getGameColor(String gameId) {
    switch (gameId.toLowerCase()) {
      case 'tictactoe':
        return Colors.blue;
      case 'sudoku':
        return Colors.green;
      case 'minesweeper':
        return Colors.red;
      case 'match3':
        return Colors.purple;
      case '2048':
        return Colors.orange;
      default:
        return Colors.grey;
    }
  }

  // Dialog and popup actions
  void _showRevenueDetails(DashboardController controller) {
    Get.dialog(
      Dialog(
        child: Container(
          width: Get.width * 0.8,
          padding: const EdgeInsets.all(16),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              const Text(
                'Revenue Details',
                style: TextStyle(
                  fontSize: 20,
                  fontWeight: FontWeight.bold,
                ),
              ),
              const SizedBox(height: 16),
              // Revenue details would go here
              const Text(
                  'Detailed revenue information will be displayed here.'),
              const SizedBox(height: 16),
              Align(
                alignment: Alignment.centerRight,
                child: TextButton(
                  onPressed: () => Get.back(),
                  child: const Text('CLOSE'),
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }

  void _showQuickActionsMenu(
      BuildContext context, DashboardController controller) {
    final RenderBox button = context.findRenderObject() as RenderBox;
    final RenderBox overlay =
        Overlay.of(context).context.findRenderObject() as RenderBox;
    final RelativeRect position = RelativeRect.fromRect(
      Rect.fromPoints(
        button.localToGlobal(Offset.zero, ancestor: overlay),
        button.localToGlobal(button.size.bottomRight(Offset.zero),
            ancestor: overlay),
      ),
      Offset.zero & overlay.size,
    );

    showMenu(
      context: context,
      position: position,
      items: [
        PopupMenuItem(
          child: const ListTile(
            leading: Icon(Icons.add_circle, color: Colors.green),
            title: Text('Create Announcement'),
            dense: true,
          ),
          onTap: () {
            Future.delayed(
              const Duration(milliseconds: 100),
              () => _showCreateAnnouncementDialog(),
            );
          },
        ),
        PopupMenuItem(
          child: const ListTile(
            leading: Icon(Icons.people, color: Colors.blue),
            title: Text('Manage Users'),
            dense: true,
          ),
          onTap: () {
            Future.delayed(
              const Duration(milliseconds: 100),
              () => Get.find<AdminController>().tabController.animateTo(0),
            );
          },
        ),
        PopupMenuItem(
          child: const ListTile(
            leading: Icon(Icons.report_problem, color: Colors.orange),
            title: Text('Review Reports'),
            dense: true,
          ),
          onTap: () {
            Future.delayed(
              const Duration(milliseconds: 100),
              () => Get.find<AdminController>().tabController.animateTo(1),
            );
          },
        ),
        PopupMenuItem(
          child: const ListTile(
            leading: Icon(Icons.settings, color: Colors.red),
            title: Text('System Settings'),
            dense: true,
          ),
          onTap: () {
            Future.delayed(
              const Duration(milliseconds: 100),
              () => Get.toNamed('/admin/settings'),
            );
          },
        ),
        PopupMenuItem(
          child: const ListTile(
            leading: Icon(Icons.logout, color: Colors.red),
            title: Text('Turn back'),
            dense: true,
          ),
          onTap: () {
            Future.delayed(
              const Duration(milliseconds: 100),
              () => Get.back(),
            );
          },
        ),
      ],
    );
  }

  void _showReportDetails(Map<String, dynamic> report) {
    // Show report details dialog
    Get.dialog(
      Dialog(
        child: Container(
          width: Get.width * 0.8,
          padding: const EdgeInsets.all(16),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              const Text(
                'Report Details',
                style: TextStyle(
                  fontSize: 20,
                  fontWeight: FontWeight.bold,
                ),
              ),
              const SizedBox(height: 16),
              // Report details would go here
              Text('Content Type: ${report['contentType']}'),
              Text('Reason: ${report['reason']}'),
              Text('Reported by: ${report['reporter']['name']}'),
              const SizedBox(height: 16),
              Row(
                mainAxisAlignment: MainAxisAlignment.end,
                children: [
                  TextButton(
                    onPressed: () => Get.back(),
                    child: const Text('CLOSE'),
                  ),
                  const SizedBox(width: 8),
                  ElevatedButton(
                    onPressed: () {
                      Get.back();
                      Get.find<AdminController>().tabController.animateTo(1);
                    },
                    style: ElevatedButton.styleFrom(
                      backgroundColor: Colors.deepPurpleAccent,
                    ),
                    child: const Text('MODERATE'),
                  ),
                ],
              ),
            ],
          ),
        ),
      ),
    );
  }

  void _showAnnouncementDetails(Map<String, dynamic> announcement) {
    // Show announcement details dialog
    Get.dialog(
      Dialog(
        child: Container(
          width: Get.width * 0.8,
          padding: const EdgeInsets.all(16),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text(
                announcement['title'] ?? 'Announcement',
                style: const TextStyle(
                  fontSize: 20,
                  fontWeight: FontWeight.bold,
                ),
              ),
              const SizedBox(height: 8),
              Text(
                'Type: ${announcement['type']?.toString().capitalizeFirst}',
                style: TextStyle(
                  color: Colors.grey[600],
                ),
              ),
              const SizedBox(height: 16),
              Text(announcement['message'] ?? 'No message'),
              const SizedBox(height: 16),
              Row(
                mainAxisAlignment: MainAxisAlignment.end,
                children: [
                  TextButton(
                    onPressed: () => Get.back(),
                    child: const Text('CLOSE'),
                  ),
                  const SizedBox(width: 8),
                  ElevatedButton(
                    onPressed: () {
                      Get.back();
                      Get.find<AdminController>().tabController.animateTo(3);
                    },
                    style: ElevatedButton.styleFrom(
                      backgroundColor: Colors.deepPurpleAccent,
                    ),
                    child: const Text('EDIT'),
                  ),
                ],
              ),
            ],
          ),
        ),
      ),
    );
  }

  void _showUserDetails(UserModel user) {
    // Show user details dialog
    Get.dialog(
      Dialog(
        child: Container(
          width: Get.width * 0.8,
          padding: const EdgeInsets.all(16),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Center(
                child: AvatarUserWidget(
                  radius: 40,
                  imagePath: user.image ?? '',
                ),
              ),
              const SizedBox(height: 16),
              Center(
                child: Text(
                  user.name ?? 'Unknown',
                  style: const TextStyle(
                    fontSize: 20,
                    fontWeight: FontWeight.bold,
                  ),
                ),
              ),
              Center(
                child: Text(
                  user.email ?? '',
                  style: TextStyle(
                    color: Colors.grey[600],
                  ),
                ),
              ),
              const SizedBox(height: 8),
              Center(
                child: Chip(
                  label: Text(user.role ?? 'user'),
                  backgroundColor: _getRoleColor(user.role),
                  labelStyle: const TextStyle(color: Colors.white),
                ),
              ),
              const SizedBox(height: 16),
              const Divider(),
              const SizedBox(height: 8),
              Row(
                mainAxisAlignment: MainAxisAlignment.spaceEvenly,
                children: [
                  Column(
                    children: [
                      Text(
                        user.totalCoins ?? '0',
                        style: const TextStyle(
                          fontSize: 18,
                          fontWeight: FontWeight.bold,
                        ),
                      ),
                      const Text('Coins'),
                    ],
                  ),
                  Column(
                    children: [
                      Text(
                        user.totalWins ?? '0',
                        style: const TextStyle(
                          fontSize: 18,
                          fontWeight: FontWeight.bold,
                        ),
                      ),
                      const Text('Wins'),
                    ],
                  ),
                  Column(
                    children: [
                      Text(
                        (user.friendsList?.length ?? 0).toString(),
                        style: const TextStyle(
                          fontSize: 18,
                          fontWeight: FontWeight.bold,
                        ),
                      ),
                      const Text('Friends'),
                    ],
                  ),
                ],
              ),
              const SizedBox(height: 16),
              Row(
                mainAxisAlignment: MainAxisAlignment.end,
                children: [
                  TextButton(
                    onPressed: () => Get.back(),
                    child: const Text('CLOSE'),
                  ),
                  const SizedBox(width: 8),
                  ElevatedButton(
                    onPressed: () {
                      Get.back();
                      // Navigate to detailed user profile
                      // This would be implemented in a future update
                    },
                    style: ElevatedButton.styleFrom(
                      backgroundColor: Colors.deepPurpleAccent,
                    ),
                    child: const Text('VIEW PROFILE'),
                  ),
                ],
              ),
            ],
          ),
        ),
      ),
    );
  }

  void _showGameDetails(Map<String, dynamic> game) {
    // Show game details dialog
    Get.dialog(
      Dialog(
        child: Container(
          width: Get.width * 0.8,
          padding: const EdgeInsets.all(16),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text(
                game['name'] as String,
                style: const TextStyle(
                  fontSize: 20,
                  fontWeight: FontWeight.bold,
                ),
              ),
              const SizedBox(height: 16),
              // Game statistics would go here
              Text('Total Plays: ${game['plays']}'),
              Text('Active Users: ${game['active']}'),
              const Text('Revenue: \${game[revenue]}'),
              const SizedBox(height: 16),
              Row(
                mainAxisAlignment: MainAxisAlignment.end,
                children: [
                  TextButton(
                    onPressed: () => Get.back(),
                    child: const Text('CLOSE'),
                  ),
                  const SizedBox(width: 8),
                  ElevatedButton(
                    onPressed: () {
                      Get.back();
                      Get.find<AdminController>().tabController.animateTo(4);
                    },
                    style: ElevatedButton.styleFrom(
                      backgroundColor: Colors.deepPurpleAccent,
                    ),
                    child: const Text('MANAGE GAME'),
                  ),
                ],
              ),
            ],
          ),
        ),
      ),
    );
  }

  void _showSystemLogs() {
    // Show system logs dialog
    Get.dialog(
      Dialog(
        child: Container(
          width: Get.width * 0.8,
          height: Get.height * 0.6,
          padding: const EdgeInsets.all(16),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              const Text(
                'System Logs',
                style: TextStyle(
                  fontSize: 20,
                  fontWeight: FontWeight.bold,
                ),
              ),
              const SizedBox(height: 16),
              Expanded(
                child: ListView.builder(
                  itemCount: 20, // Placeholder
                  itemBuilder: (context, index) {
                    return const ListTile(
                      dense: true,
                      title: Text('Log entry would go here'),
                    );
                  },
                ),
              ),
              const SizedBox(height: 16),
              Align(
                alignment: Alignment.centerRight,
                child: TextButton(
                  onPressed: () => Get.back(),
                  child: const Text('CLOSE'),
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }

  void _showMaintenanceDialog() {
    bool maintenanceMode = false;

    Get.dialog(
      StatefulBuilder(
        builder: (context, setState) {
          return Dialog(
            child: Container(
              width: Get.width * 0.6,
              padding: const EdgeInsets.all(16),
              child: Column(
                mainAxisSize: MainAxisSize.min,
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  const Text(
                    'Maintenance Settings',
                    style: TextStyle(
                      fontSize: 20,
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                  const SizedBox(height: 16),
                  SwitchListTile(
                    title: const Text('Maintenance Mode'),
                    subtitle: const Text(
                      'Enable to block user access during maintenance',
                    ),
                    value: maintenanceMode,
                    onChanged: (value) {
                      setState(() {
                        maintenanceMode = value;
                      });
                    },
                  ),
                  const SizedBox(height: 16),
                  TextFormField(
                    decoration: const InputDecoration(
                      labelText: 'Maintenance Message',
                      border: OutlineInputBorder(),
                    ),
                    maxLines: 3,
                    initialValue:
                        'We are currently performing maintenance. Please check back later.',
                  ),
                  const SizedBox(height: 16),
                  Column(
                    children: [
                      const Text('Scheduled End Time:'),
                      OutlinedButton.icon(
                        onPressed: () {
                          // Show datetime picker
                        },
                        icon: const Icon(Icons.calendar_today),
                        label: const Text('Select Time'),
                      ),
                    ],
                  ),
                  const SizedBox(height: 24),
                  Row(
                    mainAxisAlignment: MainAxisAlignment.end,
                    children: [
                      TextButton(
                        onPressed: () => Get.back(),
                        child: const Text('CANCEL'),
                      ),
                      const SizedBox(width: 8),
                      ElevatedButton(
                        onPressed: () {
                          // Apply maintenance settings
                          Get.back();
                          if (maintenanceMode) {
                            successMessage('Maintenance mode enabled');
                          } else {
                            successMessage('Maintenance mode disabled');
                          }
                        },
                        style: ElevatedButton.styleFrom(
                          backgroundColor: Colors.deepPurpleAccent,
                        ),
                        child: const Text('APPLY'),
                      ),
                    ],
                  ),
                ],
              ),
            ),
          );
        },
      ),
    );
  }

  void _showCreateAnnouncementDialog() {
    final formKey = GlobalKey<FormState>();
    final titleController = TextEditingController();
    final messageController = TextEditingController();
    String type = 'system';
    String targetAudience = 'all';
    DateTime? startDate;
    DateTime? endDate;

    Get.dialog(
      Dialog(
        child: Container(
          padding: const EdgeInsets.all(16.0),
          constraints: const BoxConstraints(maxWidth: 500),
          child: Form(
            key: formKey,
            child: SingleChildScrollView(
              child: Column(
                mainAxisSize: MainAxisSize.min,
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  const Text(
                    'Create Announcement',
                    style: TextStyle(
                      fontSize: 20,
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                  const SizedBox(height: 16),
                  TextFormField(
                    controller: titleController,
                    decoration: const InputDecoration(
                      labelText: 'Title',
                      border: OutlineInputBorder(),
                    ),
                    validator: (value) {
                      if (value == null || value.isEmpty) {
                        return 'Please enter a title';
                      }
                      return null;
                    },
                  ),
                  const SizedBox(height: 16),
                  TextFormField(
                    controller: messageController,
                    decoration: const InputDecoration(
                      labelText: 'Message',
                      border: OutlineInputBorder(),
                    ),
                    maxLines: 5,
                    validator: (value) {
                      if (value == null || value.isEmpty) {
                        return 'Please enter a message';
                      }
                      return null;
                    },
                  ),
                  const SizedBox(height: 16),
                  StatefulBuilder(
                    builder: (context, setState) {
                      return Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          DropdownButtonFormField<String>(
                            decoration: const InputDecoration(
                              labelText: 'Type',
                              border: OutlineInputBorder(),
                            ),
                            value: type,
                            onChanged: (value) {
                              if (value != null) {
                                setState(() {
                                  type = value;
                                });
                              }
                            },
                            items: const [
                              DropdownMenuItem(
                                  value: 'system', child: Text('System')),
                              DropdownMenuItem(
                                  value: 'maintenance',
                                  child: Text('Maintenance')),
                              DropdownMenuItem(
                                  value: 'update', child: Text('Update')),
                              DropdownMenuItem(
                                  value: 'event', child: Text('Event')),
                            ],
                          ),
                          const SizedBox(height: 16),
                          DropdownButtonFormField<String>(
                            decoration: const InputDecoration(
                              labelText: 'Target Audience',
                              border: OutlineInputBorder(),
                            ),
                            value: targetAudience,
                            onChanged: (value) {
                              if (value != null) {
                                setState(() {
                                  targetAudience = value;
                                });
                              }
                            },
                            items: const [
                              DropdownMenuItem(
                                  value: 'all', child: Text('All Users')),
                              DropdownMenuItem(
                                  value: 'admin', child: Text('Admins Only')),
                              DropdownMenuItem(
                                  value: 'moderator',
                                  child: Text('Moderators & Admins')),
                              DropdownMenuItem(
                                  value: 'new',
                                  child: Text('New Users (< 7 days)')),
                            ],
                          ),
                          const SizedBox(height: 16),
                          Row(
                            children: [
                              Expanded(
                                child: InkWell(
                                  onTap: () async {
                                    final date = await showDatePicker(
                                      context: context,
                                      initialDate: DateTime.now(),
                                      firstDate: DateTime.now(),
                                      lastDate: DateTime.now()
                                          .add(const Duration(days: 365)),
                                    );
                                    if (date != null) {
                                      setState(() {
                                        startDate = date;
                                      });
                                    }
                                  },
                                  child: InputDecorator(
                                    decoration: const InputDecoration(
                                      labelText: 'Start Date',
                                      border: OutlineInputBorder(),
                                    ),
                                    child: Text(
                                      startDate != null
                                          ? DateFormat('MMM dd, yyyy')
                                              .format(startDate!)
                                          : 'Select Date',
                                    ),
                                  ),
                                ),
                              ),
                              const SizedBox(width: 16),
                              Expanded(
                                child: InkWell(
                                  onTap: () async {
                                    if (startDate == null) {
                                      Get.snackbar(
                                        'Error',
                                        'Please select a start date first',
                                        snackPosition: SnackPosition.BOTTOM,
                                      );
                                      return;
                                    }

                                    final date = await showDatePicker(
                                      context: context,
                                      initialDate: startDate!
                                          .add(const Duration(days: 1)),
                                      firstDate: startDate!
                                          .add(const Duration(days: 1)),
                                      lastDate: startDate!
                                          .add(const Duration(days: 365)),
                                    );
                                    if (date != null) {
                                      setState(() {
                                        endDate = date;
                                      });
                                    }
                                  },
                                  child: InputDecorator(
                                    decoration: const InputDecoration(
                                      labelText: 'End Date (Optional)',
                                      border: OutlineInputBorder(),
                                    ),
                                    child: Row(
                                      mainAxisAlignment:
                                          MainAxisAlignment.spaceBetween,
                                      children: [
                                        Text(
                                          endDate != null
                                              ? DateFormat('MMM dd, yyyy')
                                                  .format(endDate!)
                                              : 'No End Date',
                                        ),
                                        if (endDate != null)
                                          IconButton(
                                            icon: const Icon(Icons.clear,
                                                size: 16),
                                            onPressed: () {
                                              setState(() => endDate = null);
                                            },
                                          ),
                                      ],
                                    ),
                                  ),
                                ),
                              ),
                            ],
                          ),
                        ],
                      );
                    },
                  ),
                  const SizedBox(height: 24),
                  Row(
                    mainAxisAlignment: MainAxisAlignment.end,
                    children: [
                      TextButton(
                        onPressed: () => Get.back(),
                        child: const Text('CANCEL'),
                      ),
                      const SizedBox(width: 8),
                      ElevatedButton(
                        onPressed: () {
                          if (formKey.currentState!.validate()) {
                            Get.find<AdminController>()
                                .createAnnouncement(
                              title: titleController.text,
                              message: messageController.text,
                              type: type,
                              targetAudience: targetAudience,
                              startDate: startDate,
                              endDate: endDate,
                            )
                                .then((success) {
                              if (success) {
                                Get.back();
                                successMessage(
                                    'Announcement created successfully!');
                                Get.find<DashboardController>()
                                    .loadActiveAnnouncements();
                              }
                            });
                          }
                        },
                        style: ElevatedButton.styleFrom(
                          backgroundColor: Colors.deepPurpleAccent,
                        ),
                        child: const Text('CREATE'),
                      ),
                    ],
                  ),
                ],
              ),
            ),
          ),
        ),
      ),
    );
  }
}

```

---


### Pages\Admin\Pages\tabs\analytics_tab.dart

```dart
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:fl_chart/fl_chart.dart';
import 'package:intl/intl.dart';
import 'package:tictactoe_gameapp/Pages/Admin/controllers/admin_controller.dart';

class AnalyticsTab extends StatelessWidget {
  const AnalyticsTab({super.key});

  @override
  Widget build(BuildContext context) {
    final controller = Get.find<AdminController>();
    return Scaffold(
      body: Obx(() {
        if (controller.isLoadingAnalytics.value) {
          return const Center(child: CircularProgressIndicator());
        }

        if (controller.analytics.value.isEmpty) {
          return Center(
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                const Icon(
                  Icons.analytics_outlined,
                  size: 64,
                  color: Colors.grey,
                ),
                const SizedBox(height: 16),
                const Text(
                  'No analytics data available',
                  style: TextStyle(fontSize: 18),
                ),
                const SizedBox(height: 8),
                ElevatedButton(
                  onPressed: controller.fetchAnalytics,
                  child: const Text('Refresh Analytics'),
                ),
              ],
            ),
          );
        }

        return RefreshIndicator(
          onRefresh: () => controller.fetchAnalytics(),
          child: SingleChildScrollView(
            padding: const EdgeInsets.all(16.0),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                _buildDateRangeSelector(controller),
                const SizedBox(height: 16),
                _buildOverviewCards(controller),
                const SizedBox(height: 24),
                _buildUserAnalytics(controller),
                const SizedBox(height: 24),
                _buildContentAnalytics(controller),
                const SizedBox(height: 24),
                _buildEngagementAnalytics(controller),
                const SizedBox(height: 24),
                _buildGameAnalytics(controller),
              ],
            ),
          ),
        );
      }),
    );
  }

  Widget _buildDateRangeSelector(AdminController controller) {
    return Card(
      elevation: 2,
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            const Text(
              'Date Range',
              style: TextStyle(
                fontSize: 18,
                fontWeight: FontWeight.bold,
              ),
            ),
            const SizedBox(height: 16),
            Row(
              children: [
                Expanded(
                  child: Obx(() => OutlinedButton.icon(
                        icon: const Icon(Icons.calendar_today),
                        label: Text(
                          DateFormat('MMM dd, yyyy')
                              .format(controller.analyticsStartDate.value),
                        ),
                        onPressed: () async {
                          final DateTime? picked = await showDatePicker(
                            context: Get.context!,
                            initialDate: controller.analyticsStartDate.value,
                            firstDate: DateTime(2020),
                            lastDate: DateTime.now(),
                          );
                          if (picked != null) {
                            controller.analyticsStartDate.value = picked;
                          }
                        },
                      )),
                ),
                const SizedBox(width: 16),
                const Text('to'),
                const SizedBox(width: 16),
                Expanded(
                  child: Obx(() => OutlinedButton.icon(
                        icon: const Icon(Icons.calendar_today),
                        label: Text(
                          DateFormat('MMM dd, yyyy')
                              .format(controller.analyticsEndDate.value),
                        ),
                        onPressed: () async {
                          final DateTime? picked = await showDatePicker(
                            context: Get.context!,
                            initialDate: controller.analyticsEndDate.value,
                            firstDate: controller.analyticsStartDate.value,
                            lastDate: DateTime.now(),
                          );
                          if (picked != null) {
                            controller.analyticsEndDate.value = picked;
                          }
                        },
                      )),
                ),
              ],
            ),
            const SizedBox(height: 16),
            SingleChildScrollView(
              scrollDirection: Axis.horizontal,
              child: Row(
                mainAxisAlignment: MainAxisAlignment.spaceEvenly,
                children: [
                  _dateRangeButton('Last 7 Days', controller, 7),
                  _dateRangeButton('Last 30 Days', controller, 30),
                  _dateRangeButton('Last 90 Days', controller, 90),
                ],
              ),
            ),
            const SizedBox(height: 16),
            SizedBox(
              width: double.infinity,
              child: ElevatedButton(
                onPressed: () => controller.fetchCustomAnalytics(),
                style: ElevatedButton.styleFrom(
                  backgroundColor: Colors.deepPurpleAccent,
                ),
                child: const Text('Apply Date Range'),
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _dateRangeButton(String text, AdminController controller, int days) {
    return ElevatedButton(
      onPressed: () {
        controller.analyticsEndDate.value = DateTime.now();
        controller.analyticsStartDate.value =
            DateTime.now().subtract(Duration(days: days));
      },
      style: ElevatedButton.styleFrom(
        backgroundColor: Colors.grey[200],
        foregroundColor: Colors.black87,
      ),
      child: Text(text),
    );
  }

  Widget _buildOverviewCards(AdminController controller) {
    final analytics = controller.analytics.value;
    final totalUsers = analytics['totalUsers'] ?? 0;
    final totalPosts = analytics['totalPosts'] ?? 0;
    final reportedContent = analytics['reportedContent'] ?? 0;
    final activeGames = analytics['activeGames'] ?? 0;

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        const Text(
          'Overview',
          style: TextStyle(
            fontSize: 20,
            fontWeight: FontWeight.bold,
          ),
        ),
        const SizedBox(height: 16),
        GridView.count(
          crossAxisCount: 2,
          crossAxisSpacing: 16,
          mainAxisSpacing: 16,
          shrinkWrap: true,
          physics: const NeverScrollableScrollPhysics(),
          children: [
            _buildOverviewCard(
              icon: Icons.people,
              title: 'Total Users',
              value: totalUsers.toString(),
              color: Colors.blue,
            ),
            _buildOverviewCard(
              icon: Icons.post_add,
              title: 'Total Posts',
              value: totalPosts.toString(),
              color: Colors.green,
            ),
            _buildOverviewCard(
              icon: Icons.report,
              title: 'Reported Content',
              value: reportedContent.toString(),
              color: Colors.orange,
            ),
            _buildOverviewCard(
              icon: Icons.games,
              title: 'Active Games',
              value: activeGames.toString(),
              color: Colors.purple,
            ),
          ],
        ),
      ],
    );
  }

  Widget _buildOverviewCard({
    required IconData icon,
    required String title,
    required String value,
    required Color color,
  }) {
    return Card(
      elevation: 4,
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(
              icon,
              size: 40,
              color: color,
            ),
            const SizedBox(height: 8),
            Text(
              title,
              style: const TextStyle(
                fontSize: 14,
                fontWeight: FontWeight.bold,
              ),
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: 8),
            Text(
              value,
              style: TextStyle(
                fontSize: 24,
                fontWeight: FontWeight.bold,
                color: color,
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildUserAnalytics(AdminController controller) {
    final analytics = controller.analytics.value;
    final usersByRole = analytics['usersByRole'] as Map<String, dynamic>? ?? {};

    // Prepare data for pie chart
    final pieData = <PieChartSectionData>[];

    if (usersByRole.containsKey('admin')) {
      pieData.add(PieChartSectionData(
        value: (usersByRole['admin'] ?? 0).toDouble(),
        title: 'Admin',
        color: Colors.red,
        radius: 60,
        titleStyle: const TextStyle(
          color: Colors.white,
          fontWeight: FontWeight.bold,
          fontSize: 16,
        ),
      ));
    }

    if (usersByRole.containsKey('moderator')) {
      pieData.add(PieChartSectionData(
        value: (usersByRole['moderator'] ?? 0).toDouble(),
        title: 'Mod',
        color: Colors.green,
        radius: 60,
        titleStyle: const TextStyle(
          color: Colors.white,
          fontWeight: FontWeight.bold,
          fontSize: 16,
        ),
      ));
    }

    if (usersByRole.containsKey('user')) {
      pieData.add(PieChartSectionData(
        value: (usersByRole['user'] ?? 0).toDouble(),
        title: 'User',
        color: Colors.blue,
        radius: 60,
        titleStyle: const TextStyle(
          color: Colors.white,
          fontWeight: FontWeight.bold,
          fontSize: 16,
        ),
      ));
    }

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        const Text(
          'User Analytics',
          style: TextStyle(
            fontSize: 20,
            fontWeight: FontWeight.bold,
          ),
        ),
        const SizedBox(height: 16),
        Card(
          elevation: 2,
          child: Padding(
            padding: const EdgeInsets.all(16.0),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                const Text(
                  'Users by Role',
                  style: TextStyle(
                    fontSize: 16,
                    fontWeight: FontWeight.bold,
                  ),
                ),
                const SizedBox(height: 16),
                SizedBox(
                  height: 200,
                  child: pieData.isEmpty
                      ? const Center(child: Text('No data available'))
                      : PieChart(
                          PieChartData(
                            sections: pieData,
                            centerSpaceRadius: 40,
                            sectionsSpace: 2,
                          ),
                        ),
                ),
                const SizedBox(height: 16),
                // Legend
                Row(
                  mainAxisAlignment: MainAxisAlignment.spaceEvenly,
                  children: [
                    _buildLegendItem(
                        'Admin', Colors.red, usersByRole['admin'] ?? 0),
                    _buildLegendItem('Moderator', Colors.green,
                        usersByRole['moderator'] ?? 0),
                    _buildLegendItem(
                        'User', Colors.blue, usersByRole['user'] ?? 0),
                  ],
                ),
              ],
            ),
          ),
        ),
      ],
    );
  }

  Widget _buildLegendItem(String label, Color color, int value) {
    return Row(
      children: [
        Container(
          width: 16,
          height: 16,
          color: color,
        ),
        const SizedBox(width: 4),
        Text('$label: $value'),
      ],
    );
  }

  Widget _buildContentAnalytics(AdminController controller) {
    final analytics = controller.analytics.value;
    final totalPosts = analytics['totalPosts'] ?? 0;
    final recentPosts = analytics['recentPosts'] ?? 0;

    // Mock data for bar chart
    final mockData = [
      {'day': 'Mon', 'posts': 25, 'comments': 120},
      {'day': 'Tue', 'posts': 40, 'comments': 200},
      {'day': 'Wed', 'posts': 35, 'comments': 180},
      {'day': 'Thu', 'posts': 50, 'comments': 250},
      {'day': 'Fri', 'posts': 65, 'comments': 300},
      {'day': 'Sat', 'posts': 80, 'comments': 400},
      {'day': 'Sun', 'posts': 60, 'comments': 320},
    ];

    final customRange = analytics['customRange'] as Map<String, dynamic>? ?? {};
    final customRangeNewPosts = customRange['newPosts'] ?? 0;

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        const Text(
          'Content Analytics',
          style: TextStyle(
            fontSize: 20,
            fontWeight: FontWeight.bold,
          ),
        ),
        const SizedBox(height: 16),
        Card(
          elevation: 2,
          child: Padding(
            padding: const EdgeInsets.all(16.0),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Row(
                  children: [
                    Expanded(
                      child: _buildStatCard(
                        title: 'Total Posts',
                        value: '$totalPosts',
                        icon: Icons.post_add,
                        color: Colors.blue,
                      ),
                    ),
                    const SizedBox(width: 16),
                    Expanded(
                      child: _buildStatCard(
                        title: 'Recent Posts (7d)',
                        value: '$recentPosts',
                        icon: Icons.trending_up,
                        color: Colors.green,
                      ),
                    ),
                  ],
                ),
                const SizedBox(height: 16),
                const Text(
                  'Content Creation Trend',
                  style: TextStyle(
                    fontSize: 16,
                    fontWeight: FontWeight.bold,
                  ),
                ),
                const SizedBox(height: 16),
                SizedBox(
                  height: 250,
                  child: BarChart(
                    BarChartData(
                      alignment: BarChartAlignment.spaceAround,
                      maxY: 500,
                      barTouchData: BarTouchData(
                        enabled: true,
                        touchTooltipData: BarTouchTooltipData(
                          getTooltipItem: (group, groupIndex, rod, rodIndex) {
                            final day = mockData[group.x.toInt()]['day'];
                            final value = rodIndex == 0
                                ? mockData[group.x.toInt()]['posts']
                                : mockData[group.x.toInt()]['comments'];
                            final label = rodIndex == 0 ? 'Posts' : 'Comments';
                            return BarTooltipItem(
                              '$day\n$label: $value',
                              const TextStyle(color: Colors.white),
                            );
                          },
                        ),
                      ),
                      titlesData: FlTitlesData(
                        show: true,
                        bottomTitles: AxisTitles(
                          sideTitles: SideTitles(
                            showTitles: true,
                            getTitlesWidget: (value, meta) {
                              return SideTitleWidget(
                                axisSide: meta.axisSide,
                                child: Text(
                                    mockData[value.toInt()]['day'] as String),
                              );
                            },
                          ),
                        ),
                        leftTitles: AxisTitles(
                          sideTitles: SideTitles(
                            showTitles: true,
                            getTitlesWidget: (value, meta) {
                              return SideTitleWidget(
                                axisSide: meta.axisSide,
                                child: Text(value.toInt().toString()),
                              );
                            },
                            interval: 100,
                          ),
                        ),
                        topTitles: const AxisTitles(
                            sideTitles: SideTitles(showTitles: false)),
                        rightTitles: const AxisTitles(
                            sideTitles: SideTitles(showTitles: false)),
                      ),
                      gridData: const FlGridData(
                        show: true,
                        drawVerticalLine: false,
                      ),
                      borderData: FlBorderData(show: false),
                      barGroups: mockData.asMap().entries.map((entry) {
                        final index = entry.key;
                        final data = entry.value;
                        return BarChartGroupData(
                          x: index,
                          barRods: [
                            BarChartRodData(
                              toY: (data['posts'] as int).toDouble(),
                              color: Colors.blue,
                              width: 12,
                              borderRadius: const BorderRadius.only(
                                topLeft: Radius.circular(4),
                                topRight: Radius.circular(4),
                              ),
                            ),
                            BarChartRodData(
                              toY: (data['comments'] as int).toDouble(),
                              color: Colors.orange,
                              width: 12,
                              borderRadius: const BorderRadius.only(
                                topLeft: Radius.circular(4),
                                topRight: Radius.circular(4),
                              ),
                            ),
                          ],
                        );
                      }).toList(),
                    ),
                  ),
                ),
                const SizedBox(height: 16),
                Row(
                  mainAxisAlignment: MainAxisAlignment.center,
                  children: [
                    _buildLegendItem('Posts', Colors.blue, 0),
                    const SizedBox(width: 16),
                    _buildLegendItem('Comments', Colors.orange, 0),
                  ],
                ),
                if (customRange.isNotEmpty) ...[
                  const SizedBox(height: 16),
                  const Divider(),
                  const SizedBox(height: 8),
                  Text(
                    'Custom Range: ${DateFormat('MMM dd').format(controller.analyticsStartDate.value)} - ${DateFormat('MMM dd').format(controller.analyticsEndDate.value)}',
                    style: const TextStyle(fontWeight: FontWeight.bold),
                  ),
                  const SizedBox(height: 8),
                  Text('New Posts: $customRangeNewPosts'),
                ],
              ],
            ),
          ),
        ),
      ],
    );
  }

  Widget _buildStatCard({
    required String title,
    required String value,
    required IconData icon,
    required Color color,
  }) {
    return Container(
      padding: const EdgeInsets.all(12),
      decoration: BoxDecoration(
        color: color.withOpacity(0.1),
        borderRadius: BorderRadius.circular(8),
        border: Border.all(color: color.withOpacity(0.3)),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          SingleChildScrollView(
            scrollDirection: Axis.horizontal,
            child: Row(
              children: [
                Icon(
                  icon,
                  color: color,
                  size: 20,
                ),
                const SizedBox(width: 8),
                Text(
                  title,
                  style: TextStyle(
                    color: color,
                    fontWeight: FontWeight.bold,
                  ),
                ),
              ],
            ),
          ),
          const SizedBox(height: 8),
          Text(
            value,
            style: TextStyle(
              fontSize: 24,
              fontWeight: FontWeight.bold,
              color: color,
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildEngagementAnalytics(AdminController controller) {
    // Mock data for line chart
    final mockEngagementData = [
      {'day': 'Week 1', 'likes': 1200, 'shares': 400, 'comments': 800},
      {'day': 'Week 2', 'likes': 1800, 'shares': 600, 'comments': 1200},
      {'day': 'Week 3', 'likes': 1400, 'shares': 500, 'comments': 900},
      {'day': 'Week 4', 'likes': 2000, 'shares': 700, 'comments': 1300},
    ];

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        const Text(
          'Engagement Analytics',
          style: TextStyle(
            fontSize: 20,
            fontWeight: FontWeight.bold,
          ),
        ),
        const SizedBox(height: 16),
        Card(
          elevation: 2,
          child: Padding(
            padding: const EdgeInsets.all(16.0),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                const Text(
                  'Monthly Engagement Trends',
                  style: TextStyle(
                    fontSize: 16,
                    fontWeight: FontWeight.bold,
                  ),
                ),
                const SizedBox(height: 16),
                SizedBox(
                  height: 250,
                  child: LineChart(
                    LineChartData(
                      lineTouchData: LineTouchData(
                        enabled: true,
                        touchTooltipData: LineTouchTooltipData(
                          getTooltipItems: (touchedSpots) {
                            return touchedSpots.map((spot) {
                              final data = mockEngagementData[spot.x.toInt()];
                              String value = '';
                              String label = '';
                              Color color = Colors.white;

                              if (spot.barIndex == 0) {
                                value = data['likes'].toString();
                                label = 'Likes';
                                color = Colors.pink;
                              } else if (spot.barIndex == 1) {
                                value = data['shares'].toString();
                                label = 'Shares';
                                color = Colors.blue;
                              } else {
                                value = data['comments'].toString();
                                label = 'Comments';
                                color = Colors.orange;
                              }

                              return LineTooltipItem(
                                '$label: $value',
                                TextStyle(
                                    color: color, fontWeight: FontWeight.bold),
                              );
                            }).toList();
                          },
                        ),
                      ),
                      gridData: const FlGridData(
                        show: true,
                        drawVerticalLine: false,
                      ),
                      titlesData: FlTitlesData(
                        bottomTitles: AxisTitles(
                          sideTitles: SideTitles(
                            showTitles: true,
                            getTitlesWidget: (value, meta) {
                              return SideTitleWidget(
                                axisSide: meta.axisSide,
                                child: Text(mockEngagementData[value.toInt()]
                                    ['day'] as String),
                              );
                            },
                          ),
                        ),
                        leftTitles: AxisTitles(
                          sideTitles: SideTitles(
                            showTitles: true,
                            interval: 500,
                            getTitlesWidget: (value, meta) {
                              return SideTitleWidget(
                                axisSide: meta.axisSide,
                                child: Text(value.toInt().toString()),
                              );
                            },
                          ),
                        ),
                        topTitles: const AxisTitles(
                            sideTitles: SideTitles(showTitles: false)),
                        rightTitles: const AxisTitles(
                            sideTitles: SideTitles(showTitles: false)),
                      ),
                      borderData: FlBorderData(
                        show: true,
                        border: Border.all(color: Colors.grey.shade300),
                      ),
                      minX: 0,
                      maxX: mockEngagementData.length - 1.0,
                      minY: 0,
                      maxY: 2200,
                      lineBarsData: [
                        // Likes line
                        LineChartBarData(
                          spots:
                              mockEngagementData.asMap().entries.map((entry) {
                            return FlSpot(
                              entry.key.toDouble(),
                              (entry.value['likes'] as int).toDouble(),
                            );
                          }).toList(),
                          isCurved: true,
                          color: Colors.pink,
                          barWidth: 3,
                          isStrokeCapRound: true,
                          dotData: const FlDotData(show: true),
                          belowBarData: BarAreaData(
                            show: true,
                            color: Colors.pink.withOpacity(0.1),
                          ),
                        ),
                        // Shares line
                        LineChartBarData(
                          spots:
                              mockEngagementData.asMap().entries.map((entry) {
                            return FlSpot(
                              entry.key.toDouble(),
                              (entry.value['shares'] as int).toDouble(),
                            );
                          }).toList(),
                          isCurved: true,
                          color: Colors.blue,
                          barWidth: 3,
                          isStrokeCapRound: true,
                          dotData: const FlDotData(show: true),
                          belowBarData: BarAreaData(
                            show: true,
                            color: Colors.blue.withOpacity(0.1),
                          ),
                        ),
                        // Comments line
                        LineChartBarData(
                          spots:
                              mockEngagementData.asMap().entries.map((entry) {
                            return FlSpot(
                              entry.key.toDouble(),
                              (entry.value['comments'] as int).toDouble(),
                            );
                          }).toList(),
                          isCurved: true,
                          color: Colors.orange,
                          barWidth: 3,
                          isStrokeCapRound: true,
                          dotData: const FlDotData(show: true),
                          belowBarData: BarAreaData(
                            show: true,
                            color: Colors.orange.withOpacity(0.1),
                          ),
                        ),
                      ],
                    ),
                  ),
                ),
                const SizedBox(height: 16),
                Row(
                  mainAxisAlignment: MainAxisAlignment.center,
                  children: [
                    _buildLegendItem('Likes', Colors.pink, 0),
                    const SizedBox(width: 16),
                    _buildLegendItem('Shares', Colors.blue, 0),
                    const SizedBox(width: 16),
                    _buildLegendItem('Comments', Colors.orange, 0),
                  ],
                ),
              ],
            ),
          ),
        ),
      ],
    );
  }

  Widget _buildGameAnalytics(AdminController controller) {
    // Mock data for game analytics
    final mockGameData = {
      'tictactoe': {'plays': 12500, 'users': 2800, 'avgTimePerGame': '2m 15s'},
      'sudoku': {'plays': 8200, 'users': 1900, 'avgTimePerGame': '8m 30s'},
      'minesweeper': {'plays': 6400, 'users': 1500, 'avgTimePerGame': '5m 45s'},
      'match3': {'plays': 15800, 'users': 3200, 'avgTimePerGame': '6m 20s'},
      '2048': {'plays': 9300, 'users': 2100, 'avgTimePerGame': '4m 10s'},
    };

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        const Text(
          'Game Analytics',
          style: TextStyle(
            fontSize: 20,
            fontWeight: FontWeight.bold,
          ),
        ),
        const SizedBox(height: 16),
        Card(
          elevation: 2,
          child: Padding(
            padding: const EdgeInsets.all(16.0),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                const Text(
                  'Game Performance',
                  style: TextStyle(
                    fontSize: 16,
                    fontWeight: FontWeight.bold,
                  ),
                ),
                const SizedBox(height: 16),
                Column(
                  children: mockGameData.entries.map((entry) {
                    final gameName = entry.key;
                    final gameData = entry.value;
                    return Padding(
                      padding: const EdgeInsets.only(bottom: 16.0),
                      child: Row(
                        children: [
                          SizedBox(
                            width: 120,
                            child: Text(
                              gameName.capitalize!,
                              style:
                                  const TextStyle(fontWeight: FontWeight.bold),
                            ),
                          ),
                          Expanded(
                            child: Column(
                              crossAxisAlignment: CrossAxisAlignment.start,
                              children: [
                                LinearProgressIndicator(
                                  value: (gameData['plays'] as int) / 20000,
                                  backgroundColor: Colors.grey[200],
                                  color: _getGameColor(gameName),
                                ),
                                const SizedBox(height: 4),
                                Row(
                                  mainAxisAlignment:
                                      MainAxisAlignment.spaceBetween,
                                  children: [
                                    Text(
                                      '${gameData['plays']} plays',
                                      style: const TextStyle(fontSize: 12),
                                    ),
                                  ],
                                ),
                              ],
                            ),
                          ),
                        ],
                      ),
                    );
                  }).toList(),
                ),
                const SizedBox(height: 16),
                const Text(
                  'Game Distribution',
                  style: TextStyle(
                    fontSize: 16,
                    fontWeight: FontWeight.bold,
                  ),
                ),
                const SizedBox(height: 16),
                SizedBox(
                  height: 200,
                  child: PieChart(
                    PieChartData(
                      sections: mockGameData.entries.map((entry) {
                        final gameName = entry.key;
                        final gameData = entry.value;
                        return PieChartSectionData(
                          value: (gameData['plays'] as int).toDouble(),
                          title:
                              '${(gameData['plays'] as int) * 100 ~/ 52200}%',
                          radius: 60,
                          color: _getGameColor(gameName),
                          titleStyle: const TextStyle(
                            color: Colors.white,
                            fontWeight: FontWeight.bold,
                            fontSize: 14,
                          ),
                        );
                      }).toList(),
                      centerSpaceRadius: 40,
                      sectionsSpace: 2,
                    ),
                  ),
                ),
                const SizedBox(height: 16),
                Wrap(
                  spacing: 16,
                  runSpacing: 8,
                  alignment: WrapAlignment.center,
                  children: mockGameData.entries.map((entry) {
                    final gameName = entry.key;
                    return _buildLegendItem(
                      gameName.capitalize!,
                      _getGameColor(gameName),
                      entry.value['plays'] as int,
                    );
                  }).toList(),
                ),
              ],
            ),
          ),
        ),
      ],
    );
  }

  Color _getGameColor(String gameName) {
    switch (gameName.toLowerCase()) {
      case 'tictactoe':
        return Colors.blue;
      case 'sudoku':
        return Colors.green;
      case 'minesweeper':
        return Colors.red;
      case 'match3':
        return Colors.purple;
      case '2048':
        return Colors.orange;
      default:
        return Colors.grey;
    }
  }
}

```

---


### Pages\Admin\Pages\tabs\announcements_tab.dart

```dart
// ignore_for_file: unnecessary_null_comparison

import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:tictactoe_gameapp/Models/Functions/time_functions.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:intl/intl.dart';
import 'package:tictactoe_gameapp/Pages/Admin/controllers/admin_controller.dart';

class AnnouncementsTab extends StatelessWidget {
  const AnnouncementsTab({super.key});

  @override
  Widget build(BuildContext context) {
    final controller = Get.find<AdminController>();

    return Column(
      children: [
        _buildFilterBar(controller),
        Expanded(
          child: _buildAnnouncementsList(controller),
        ),
      ],
    );
  }

  Widget _buildFilterBar(AdminController controller) {
    return Padding(
      padding: const EdgeInsets.all(8.0),
      child: Row(
        children: [
          const Text('Filter by: '),
          const SizedBox(width: 8),
          Obx(() => DropdownButton<String>(
                value: controller.announcementTypeFilter.value,
                items: const [
                  DropdownMenuItem(value: 'all', child: Text('All')),
                  DropdownMenuItem(value: 'system', child: Text('System')),
                  DropdownMenuItem(
                      value: 'maintenance', child: Text('Maintenance')),
                  DropdownMenuItem(value: 'update', child: Text('Update')),
                  DropdownMenuItem(value: 'event', child: Text('Event')),
                ],
                onChanged: (value) {
                  if (value != null) {
                    controller.announcementTypeFilter.value = value;
                  }
                },
              )),
          const Spacer(),
          ElevatedButton.icon(
            onPressed: () => _showCreateAnnouncementDialog(controller),
            icon: const Icon(Icons.add),
            label: const Text('New Announcement'),
            style: ElevatedButton.styleFrom(
              backgroundColor: Colors.red,
            ),
          ),
        ],
      ),
    );
  }
}

Widget _buildAnnouncementsList(AdminController controller) {
  return Obx(() {
    if (controller.isLoadingAnnouncements.value) {
      return const Center(child: CircularProgressIndicator());
    }

    if (controller.announcements.isEmpty) {
      return Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            const Icon(
              Icons.announcement_outlined,
              size: 64,
              color: Colors.grey,
            ),
            const SizedBox(height: 16),
            const Text(
              'No announcements found',
              style: TextStyle(fontSize: 18),
            ),
            const SizedBox(height: 8),
            ElevatedButton(
              onPressed: () => _showCreateAnnouncementDialog(controller),
              child: const Text('Create Announcement'),
            ),
          ],
        ),
      );
    }

    return NotificationListener<ScrollNotification>(
      onNotification: (ScrollNotification scrollInfo) {
        if (scrollInfo.metrics.pixels == scrollInfo.metrics.maxScrollExtent) {
          controller.fetchAnnouncements(); // Load more when reaching the end
        }
        return true;
      },
      child: ListView.builder(
        itemCount: controller.announcements.length,
        itemBuilder: (context, index) {
          final announcement = controller.announcements[index];
          return _buildAnnouncementItem(controller, announcement);
        },
      ),
    );
  });
}

Widget _buildAnnouncementItem(
    AdminController controller, Map<String, dynamic> announcement) {
  final String id = announcement['id'] ?? '';
  final String title = announcement['title'] ?? 'No Title';
  final String message = announcement['message'] ?? 'No message';
  final String type = announcement['type'] ?? 'system';
  final String targetAudience = announcement['targetAudience'] ?? 'all';
  final bool active = announcement['active'] ?? false;

  // Parse timestamps
  DateTime? createdAt;
  if (announcement['createdAt'] != null) {
    createdAt = (announcement['createdAt'] as Timestamp).toDate();
  }

  DateTime? startDate;
  if (announcement['startDate'] != null) {
    startDate = (announcement['startDate'] as Timestamp).toDate();
  }

  DateTime? endDate;
  if (announcement['endDate'] != null) {
    endDate = (announcement['endDate'] as Timestamp).toDate();
  }

  // Determine if announcement is current, upcoming, or expired
  final now = DateTime.now();
  String status = 'current';

  if (startDate != null && startDate.isAfter(now)) {
    status = 'upcoming';
  } else if (endDate != null && endDate.isBefore(now)) {
    status = 'expired';
  }

  return Card(
    margin: const EdgeInsets.all(8.0),
    elevation: 2,
    shape: RoundedRectangleBorder(
      borderRadius: BorderRadius.circular(8),
      side: BorderSide(
        color: _getBorderColor(status, active),
        width: 2,
      ),
    ),
    child: Padding(
      padding: const EdgeInsets.all(16.0),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            children: [
              _buildAnnouncementTypeChip(type),
              const SizedBox(width: 8),
              _buildStatusChip(status, active),
              const Spacer(),
              Text(
                createdAt != null
                    ? TimeFunctions.timeAgo(now: now, createdAt: createdAt)
                    : 'Unknown time',
                style: const TextStyle(color: Colors.grey),
              ),
            ],
          ),
          const SizedBox(height: 12),
          Text(
            title,
            style: const TextStyle(
              fontSize: 18,
              fontWeight: FontWeight.bold,
            ),
          ),
          const SizedBox(height: 8),
          Text(message),
          const SizedBox(height: 12),
          Row(
            children: [
              const Icon(Icons.people, size: 16),
              const SizedBox(width: 4),
              Text(
                'Target: ${targetAudience.capitalize}',
                style: const TextStyle(fontSize: 12),
              ),
              const Spacer(),
              if (startDate != null && endDate != null)
                Text(
                  '${DateFormat('MMM dd').format(startDate)} - ${DateFormat('MMM dd').format(endDate)}',
                  style: const TextStyle(fontSize: 12),
                )
              else if (startDate != null)
                Text(
                  'From ${DateFormat('MMM dd').format(startDate)}',
                  style: const TextStyle(fontSize: 12),
                ),
            ],
          ),
          const SizedBox(height: 12),
          Row(
            mainAxisAlignment: MainAxisAlignment.end,
            children: [
              IconButton(
                onPressed: () => _editAnnouncement(controller, announcement),
                icon: const Icon(Icons.edit),
                tooltip: 'Edit',
              ),
              if (active)
                IconButton(
                  onPressed: () => _deactivateAnnouncement(controller, id),
                  icon: const Icon(Icons.visibility_off),
                  tooltip: 'Deactivate',
                )
              else
                IconButton(
                  onPressed: () => _activateAnnouncement(controller, id),
                  icon: const Icon(Icons.visibility),
                  tooltip: 'Activate',
                ),
              IconButton(
                onPressed: () =>
                    _confirmDeleteAnnouncement(controller, id, title),
                icon: const Icon(Icons.delete, color: Colors.red),
                tooltip: 'Delete',
              ),
            ],
          ),
        ],
      ),
    ),
  );
}

Widget _buildAnnouncementTypeChip(String type) {
  IconData icon;
  Color color;

  switch (type) {
    case 'system':
      icon = Icons.info;
      color = Colors.blue;
      break;
    case 'maintenance':
      icon = Icons.build;
      color = Colors.orange;
      break;
    case 'update':
      icon = Icons.system_update;
      color = Colors.green;
      break;
    case 'event':
      icon = Icons.event;
      color = Colors.purple;
      break;
    default:
      icon = Icons.announcement;
      color = Colors.grey;
  }

  return Chip(
    avatar: Icon(
      icon,
      size: 16,
      color: Colors.white,
    ),
    label: Text(
      type.capitalize!,
      style: const TextStyle(color: Colors.white, fontSize: 12),
    ),
    backgroundColor: color,
    materialTapTargetSize: MaterialTapTargetSize.shrinkWrap,
    padding: EdgeInsets.zero,
  );
}

Widget _buildStatusChip(String status, bool active) {
  IconData icon;
  Color color;
  String label;

  if (!active) {
    icon = Icons.visibility_off;
    color = Colors.grey;
    label = 'Inactive';
  } else {
    switch (status) {
      case 'upcoming':
        icon = Icons.access_time;
        color = Colors.amber;
        label = 'Upcoming';
        break;
      case 'expired':
        icon = Icons.timer_off;
        color = Colors.red;
        label = 'Expired';
        break;
      default:
        icon = Icons.check_circle;
        color = Colors.green;
        label = 'Active';
    }
  }

  return Chip(
    avatar: Icon(
      icon,
      size: 16,
      color: Colors.white,
    ),
    label: Text(
      label,
      style: const TextStyle(color: Colors.white, fontSize: 12),
    ),
    backgroundColor: color,
    materialTapTargetSize: MaterialTapTargetSize.shrinkWrap,
    padding: EdgeInsets.zero,
  );
}

Color _getBorderColor(String status, bool active) {
  if (!active) return Colors.grey;

  switch (status) {
    case 'upcoming':
      return Colors.amber;
    case 'expired':
      return Colors.red;
    default:
      return Colors.green;
  }
}

void _showCreateAnnouncementDialog(AdminController controller) {
  final formKey = GlobalKey<FormState>();
  final titleController = TextEditingController();
  final messageController = TextEditingController();
  String type = 'system';
  String targetAudience = 'all';
  DateTime? startDate;
  DateTime? endDate;

  Get.dialog(
    Dialog(
      child: Container(
        padding: const EdgeInsets.all(16.0),
        constraints: const BoxConstraints(maxWidth: 500),
        child: Form(
          key: formKey,
          child: SingleChildScrollView(
            child: Column(
              mainAxisSize: MainAxisSize.min,
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                const Text(
                  'Create Announcement',
                  style: TextStyle(
                    fontSize: 20,
                    fontWeight: FontWeight.bold,
                  ),
                ),
                const SizedBox(height: 16),
                TextFormField(
                  controller: titleController,
                  decoration: const InputDecoration(
                    labelText: 'Title',
                    border: OutlineInputBorder(),
                  ),
                  validator: (value) {
                    if (value == null || value.isEmpty) {
                      return 'Please enter a title';
                    }
                    return null;
                  },
                ),
                const SizedBox(height: 16),
                TextFormField(
                  controller: messageController,
                  decoration: const InputDecoration(
                    labelText: 'Message',
                    border: OutlineInputBorder(),
                  ),
                  maxLines: 5,
                  validator: (value) {
                    if (value == null || value.isEmpty) {
                      return 'Please enter a message';
                    }
                    return null;
                  },
                ),
                const SizedBox(height: 16),
                DropdownButtonFormField<String>(
                  decoration: const InputDecoration(
                    labelText: 'Type',
                    border: OutlineInputBorder(),
                  ),
                  value: type,
                  onChanged: (value) {
                    if (value != null) {
                      type = value;
                    }
                  },
                  items: const [
                    DropdownMenuItem(value: 'system', child: Text('System')),
                    DropdownMenuItem(
                        value: 'maintenance', child: Text('Maintenance')),
                    DropdownMenuItem(value: 'update', child: Text('Update')),
                    DropdownMenuItem(value: 'event', child: Text('Event')),
                  ],
                ),
                const SizedBox(height: 16),
                DropdownButtonFormField<String>(
                  decoration: const InputDecoration(
                    labelText: 'Target Audience',
                    border: OutlineInputBorder(),
                  ),
                  value: targetAudience,
                  onChanged: (value) {
                    if (value != null) {
                      targetAudience = value;
                    }
                  },
                  items: const [
                    DropdownMenuItem(value: 'all', child: Text('All Users')),
                    DropdownMenuItem(
                        value: 'admin', child: Text('Admins Only')),
                    DropdownMenuItem(
                        value: 'moderator', child: Text('Moderators & Admins')),
                  ],
                ),
                const SizedBox(height: 16),
                Row(
                  children: [
                    Expanded(
                      child: InkWell(
                        onTap: () async {
                          final date = await showDatePicker(
                            context: Get.context!,
                            initialDate: DateTime.now(),
                            firstDate: DateTime.now(),
                            lastDate:
                                DateTime.now().add(const Duration(days: 365)),
                          );
                          if (date != null) {
                            startDate = date;
                          }
                        },
                        child: InputDecorator(
                          decoration: const InputDecoration(
                            labelText: 'Start Date',
                            border: OutlineInputBorder(),
                          ),
                          child: Text(
                            startDate != null
                                ? DateFormat('MMM dd, yyyy').format(startDate)
                                : 'Select Date',
                          ),
                        ),
                      ),
                    ),
                    const SizedBox(width: 16),
                    Expanded(
                      child: InkWell(
                        onTap: () async {
                          if (startDate == null) {
                            Get.snackbar(
                              'Error',
                              'Please select a start date first',
                              snackPosition: SnackPosition.BOTTOM,
                            );
                            return;
                          }

                          final date = await showDatePicker(
                            context: Get.context!,
                            initialDate:
                                startDate!.add(const Duration(days: 1)),
                            firstDate: startDate!.add(const Duration(days: 1)),
                            lastDate: startDate!.add(const Duration(days: 365)),
                          );
                          if (date != null) {
                            endDate = date;
                          }
                        },
                        child: InputDecorator(
                          decoration: const InputDecoration(
                            labelText: 'End Date (Optional)',
                            border: OutlineInputBorder(),
                          ),
                          child: Text(
                            endDate != null
                                ? DateFormat('MMM dd, yyyy').format(endDate)
                                : 'No End Date',
                          ),
                        ),
                      ),
                    ),
                  ],
                ),
                const SizedBox(height: 24),
                Row(
                  mainAxisAlignment: MainAxisAlignment.end,
                  children: [
                    TextButton(
                      onPressed: () => Get.back(),
                      child: const Text('CANCEL'),
                    ),
                    const SizedBox(width: 8),
                    ElevatedButton(
                      onPressed: () {
                        if (formKey.currentState!.validate()) {
                          controller
                              .createAnnouncement(
                            title: titleController.text,
                            message: messageController.text,
                            type: type,
                            targetAudience: targetAudience,
                            startDate: startDate,
                            endDate: endDate,
                          )
                              .then((success) {
                            if (success) {
                              Get.back();
                            }
                          });
                        }
                      },
                      style: ElevatedButton.styleFrom(
                        backgroundColor: Colors.deepPurpleAccent,
                      ),
                      child: const Text('CREATE'),
                    ),
                  ],
                ),
              ],
            ),
          ),
        ),
      ),
    ),
  );
}

void _editAnnouncement(
    AdminController controller, Map<String, dynamic> announcement) {
  final formKey = GlobalKey<FormState>();
  final String id = announcement['id'] ?? '';
  final titleController =
      TextEditingController(text: announcement['title'] ?? '');
  final messageController =
      TextEditingController(text: announcement['message'] ?? '');
  String type = announcement['type'] ?? 'system';
  String targetAudience = announcement['targetAudience'] ?? 'all';

  DateTime? startDate;
  if (announcement['startDate'] != null) {
    startDate = (announcement['startDate'] as Timestamp).toDate();
  }

  DateTime? endDate;
  if (announcement['endDate'] != null) {
    endDate = (announcement['endDate'] as Timestamp).toDate();
  }

  Get.dialog(
    Dialog(
      child: Container(
        padding: const EdgeInsets.all(16.0),
        constraints: const BoxConstraints(maxWidth: 500),
        child: Form(
          key: formKey,
          child: SingleChildScrollView(
            child: Column(
              mainAxisSize: MainAxisSize.min,
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                const Text(
                  'Edit Announcement',
                  style: TextStyle(
                    fontSize: 20,
                    fontWeight: FontWeight.bold,
                  ),
                ),
                const SizedBox(height: 16),
                TextFormField(
                  controller: titleController,
                  decoration: const InputDecoration(
                    labelText: 'Title',
                    border: OutlineInputBorder(),
                  ),
                  validator: (value) {
                    if (value == null || value.isEmpty) {
                      return 'Please enter a title';
                    }
                    return null;
                  },
                ),
                const SizedBox(height: 16),
                TextFormField(
                  controller: messageController,
                  decoration: const InputDecoration(
                    labelText: 'Message',
                    border: OutlineInputBorder(),
                  ),
                  maxLines: 5,
                  validator: (value) {
                    if (value == null || value.isEmpty) {
                      return 'Please enter a message';
                    }
                    return null;
                  },
                ),
                const SizedBox(height: 16),
                DropdownButtonFormField<String>(
                  decoration: const InputDecoration(
                    labelText: 'Type',
                    border: OutlineInputBorder(),
                  ),
                  value: type,
                  onChanged: (value) {
                    if (value != null) {
                      type = value;
                    }
                  },
                  items: const [
                    DropdownMenuItem(value: 'system', child: Text('System')),
                    DropdownMenuItem(
                        value: 'maintenance', child: Text('Maintenance')),
                    DropdownMenuItem(value: 'update', child: Text('Update')),
                    DropdownMenuItem(value: 'event', child: Text('Event')),
                  ],
                ),
                const SizedBox(height: 16),
                DropdownButtonFormField<String>(
                  decoration: const InputDecoration(
                    labelText: 'Target Audience',
                    border: OutlineInputBorder(),
                  ),
                  value: targetAudience,
                  onChanged: (value) {
                    if (value != null) {
                      targetAudience = value;
                    }
                  },
                  items: const [
                    DropdownMenuItem(value: 'all', child: Text('All Users')),
                    DropdownMenuItem(
                        value: 'admin', child: Text('Admins Only')),
                    DropdownMenuItem(
                        value: 'moderator', child: Text('Moderators & Admins')),
                  ],
                ),
                const SizedBox(height: 16),
                Row(
                  children: [
                    Expanded(
                      child: StatefulBuilder(
                        builder: (context, setState) => InkWell(
                          onTap: () async {
                            final date = await showDatePicker(
                              context: context,
                              initialDate: startDate ?? DateTime.now(),
                              firstDate: DateTime(2020),
                              lastDate:
                                  DateTime.now().add(const Duration(days: 365)),
                            );
                            if (date != null) {
                              setState(() => startDate = date);
                            }
                          },
                          child: InputDecorator(
                            decoration: const InputDecoration(
                              labelText: 'Start Date',
                              border: OutlineInputBorder(),
                            ),
                            child: Text(
                              startDate != null
                                  ? DateFormat('MMM dd, yyyy')
                                      .format(startDate!)
                                  : 'Select Date',
                            ),
                          ),
                        ),
                      ),
                    ),
                    const SizedBox(width: 16),
                    Expanded(
                      child: StatefulBuilder(
                        builder: (context, setState) => InkWell(
                          onTap: () async {
                            if (startDate == null) {
                              Get.snackbar(
                                'Error',
                                'Please select a start date first',
                                snackPosition: SnackPosition.BOTTOM,
                              );
                              return;
                            }

                            final date = await showDatePicker(
                              context: context,
                              initialDate: endDate ??
                                  startDate!.add(const Duration(days: 1)),
                              firstDate:
                                  startDate!.add(const Duration(days: 1)),
                              lastDate:
                                  startDate!.add(const Duration(days: 365)),
                            );
                            if (date != null) {
                              setState(() => endDate = date);
                            }
                          },
                          child: InputDecorator(
                            decoration: const InputDecoration(
                              labelText: 'End Date (Optional)',
                              border: OutlineInputBorder(),
                            ),
                            child: Row(
                              mainAxisAlignment: MainAxisAlignment.spaceBetween,
                              children: [
                                Text(
                                  endDate != null
                                      ? DateFormat('MMM dd, yyyy')
                                          .format(endDate!)
                                      : 'No End Date',
                                ),
                                if (endDate != null)
                                  IconButton(
                                    icon: const Icon(Icons.clear, size: 16),
                                    onPressed: () {
                                      setState(() => endDate = null);
                                    },
                                  ),
                              ],
                            ),
                          ),
                        ),
                      ),
                    ),
                  ],
                ),
                const SizedBox(height: 24),
                Row(
                  mainAxisAlignment: MainAxisAlignment.end,
                  children: [
                    TextButton(
                      onPressed: () => Get.back(),
                      child: const Text('CANCEL'),
                    ),
                    const SizedBox(width: 8),
                    ElevatedButton(
                      onPressed: () {
                        if (formKey.currentState!.validate()) {
                          final updateData = {
                            'title': titleController.text,
                            'message': messageController.text,
                            'type': type,
                            'targetAudience': targetAudience,
                            'startDate': startDate,
                            'endDate': endDate,
                          };

                          controller
                              .updateAnnouncement(id, updateData)
                              .then((success) {
                            if (success) {
                              Get.back();
                            }
                          });
                        }
                      },
                      style: ElevatedButton.styleFrom(
                        backgroundColor: Colors.deepPurpleAccent,
                      ),
                      child: const Text('SAVE'),
                    ),
                  ],
                ),
              ],
            ),
          ),
        ),
      ),
    ),
  );
}

void _activateAnnouncement(AdminController controller, String id) {
  controller.updateAnnouncement(id, {'active': true});
}

void _deactivateAnnouncement(AdminController controller, String id) {
  controller.updateAnnouncement(id, {'active': false});
}

void _confirmDeleteAnnouncement(
    AdminController controller, String id, String title) {
  Get.dialog(Dialog(child: Text(title)));
}

```

---


### Pages\Admin\Pages\tabs\content_moderation_tab.dart

```dart
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:tictactoe_gameapp/Components/belong_to_users/avatar_user_widget.dart';
import 'package:tictactoe_gameapp/Models/Functions/time_functions.dart';
import 'package:tictactoe_gameapp/Pages/Admin/controllers/admin_controller.dart';

class ContentModerationTab extends StatelessWidget {
  const ContentModerationTab({super.key});

  @override
  Widget build(BuildContext context) {
    final controller = Get.find<AdminController>();
    
    return Column(
      children: [
        _buildFilterBar(controller),
        Expanded(
          child: _buildReportedContentList(controller),
        ),
      ],
    );
  }
  
  Widget _buildFilterBar(AdminController controller) {
    return Padding(
      padding: const EdgeInsets.all(8.0),
      child: Row(
        children: [
          const Text('Filter by: '),
          const SizedBox(width: 8),
          Obx(() => DropdownButton<String>(
            value: controller.contentTypeFilter.value,
            items: const [
              DropdownMenuItem(value: 'all', child: Text('All')),
              DropdownMenuItem(value: 'post', child: Text('Posts')),
              DropdownMenuItem(value: 'comment', child: Text('Comments')),
              DropdownMenuItem(value: 'reel', child: Text('Reels')),
              DropdownMenuItem(value: 'user', child: Text('Users')),
            ],
            onChanged: (value) {
              if (value != null) {
                controller.contentTypeFilter.value = value;
              }
            },
          )),
          const Spacer(),
          ElevatedButton.icon(
            onPressed: () => controller.fetchReportedContent(refresh: true),
            icon: const Icon(Icons.refresh),
            label: const Text('Refresh'),
            style: ElevatedButton.styleFrom(
              backgroundColor: Colors.deepPurpleAccent,
            ),
          ),
        ],
      ),
    );
  }
  
  Widget _buildReportedContentList(AdminController controller) {
    return Obx(() {
      if (controller.isLoadingReports.value) {
        return const Center(child: CircularProgressIndicator());
      }
      
      if (controller.reportedContent.isEmpty) {
        return const Center(
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              Icon(
                Icons.check_circle,
                size: 64,
                color: Colors.green,
              ),
              SizedBox(height: 16),
              Text(
                'No reported content to review',
                style: TextStyle(fontSize: 18),
              ),
              Text(
                'All clear! Check back later for new reports.',
                style: TextStyle(color: Colors.grey),
              ),
            ],
          ),
        );
      }
      
      return NotificationListener<ScrollNotification>(
        onNotification: (ScrollNotification scrollInfo) {
          if (scrollInfo.metrics.pixels == scrollInfo.metrics.maxScrollExtent) {
            controller.fetchReportedContent(); // Load more when reaching the end
          }
          return true;
        },
        child: ListView.builder(
          itemCount: controller.reportedContent.length,
          itemBuilder: (context, index) {
            final report = controller.reportedContent[index];
            return _buildReportedContentItem(controller, report);
          },
        ),
      );
    });
  }
  
  Widget _buildReportedContentItem(AdminController controller, Map<String, dynamic> report) {
    String contentType = report['contentType'] ?? '';
    String contentId = report['contentId'] ?? '';
    int reportCount = report['reportCount'] ?? 1;
    String reason = report['reason'] ?? 'Not specified';
    DateTime reportedAt = report['reportedAt'] != null 
      ? (report['reportedAt'] as Timestamp).toDate()
      : DateTime.now();
    Map<String, dynamic>? reporterData = report['reporter'];
    Map<String, dynamic>? contentData = report['contentData'];
    
    // Prepare user data
    String reporterName = reporterData?['name'] ?? 'Unknown';
    String reporterImage = reporterData?['image'] ?? '';
    
    // Prepare content preview
    String contentPreview = '';
    if (contentData != null) {
      if (contentType == 'post') {
        contentPreview = contentData['content'] ?? '';
      } else if (contentType == 'comment') {
        contentPreview = contentData['content'] ?? '';
      } else if (contentType == 'reel') {
        contentPreview = contentData['description'] ?? '';
      } else if (contentType == 'user') {
        contentPreview = 'User profile reported';
      }
    }
    
    // Create a readable content identifier
    String contentIdentifier = contentType.capitalizeFirst ?? '';
    if (contentPreview.isNotEmpty) {
      contentIdentifier += ': "${contentPreview.length > 50 ? contentPreview.substring(0, 50) + '...' : contentPreview}"';
    }
    
    return Card(
      margin: const EdgeInsets.all(8.0),
      elevation: 2,
      child: Padding(
        padding: const EdgeInsets.all(12.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              children: [
                _buildReportTypeChip(contentType),
                const SizedBox(width: 8),
                Chip(
                  label: Text('$reportCount reports'),
                  backgroundColor: _getReportCountColor(reportCount),
                ),
                const Spacer(),
                Text(
                  TimeFunctions.timeAgo(now: DateTime.now(), createdAt: reportedAt),
                  style: const TextStyle(color: Colors.grey),
                ),
              ],
            ),
            const SizedBox(height: 8),
            Row(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                // Reporter info
                Expanded(
                  flex: 1,
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      const Text(
                        'Reported by:',
                        style: TextStyle(fontWeight: FontWeight.bold),
                      ),
                      const SizedBox(height: 4),
                      Row(
                        children: [
                          if (reporterImage.isNotEmpty)
                            AvatarUserWidget(
                              radius: 20,
                              imagePath: reporterImage,
                            )
                          else
                            const CircleAvatar(
                              radius: 20,
                              child: Icon(Icons.person),
                            ),
                          const SizedBox(width: 8),
                          Expanded(
                            child: Text(reporterName),
                          ),
                        ],
                      ),
                    ],
                  ),
                ),
                const SizedBox(width: 16),
                // Content info
                Expanded(
                  flex: 2,
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      const Text(
                        'Content:',
                        style: TextStyle(fontWeight: FontWeight.bold),
                      ),
                      const SizedBox(height: 4),
                      Text(contentIdentifier),
                      const SizedBox(height: 8),
                      const Text(
                        'Reason:',
                        style: TextStyle(fontWeight: FontWeight.bold),
                      ),
                      Text(reason),
                    ],
                  ),
                ),
              ],
            ),
            const SizedBox(height: 16),
            Row(
              mainAxisAlignment: MainAxisAlignment.end,
              children: [
                TextButton.icon(
                  onPressed: () => _viewReportedContent(report, controller),
                  icon: const Icon(Icons.visibility),
                  label: const Text('View'),
                ),
                const SizedBox(width: 8),
                TextButton.icon(
                  onPressed: () => _showModerationActionsDialog(report, controller),
                  icon: const Icon(Icons.gavel),
                  label: const Text('Moderate'),
                  style: TextButton.styleFrom(
                    foregroundColor: Colors.deepPurple,
                  ),
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }
  
  Widget _buildReportTypeChip(String contentType) {
    IconData icon;
    Color color;
    
    switch (contentType) {
      case 'post':
        icon = Icons.post_add;
        color = Colors.blue;
        break;
      case 'comment':
        icon = Icons.comment;
        color = Colors.green;
        break;
      case 'reel':
        icon = Icons.video_collection;
        color = Colors.purple;
        break;
      case 'user':
        icon = Icons.person;
        color = Colors.orange;
        break;
      default:
        icon = Icons.warning;
        color = Colors.red;
    }
    
    return Chip(
      avatar: Icon(
        icon,
        size: 16,
        color: Colors.white,
      ),
      label: Text(
        contentType.capitalizeFirst ?? '',
        style: const TextStyle(color: Colors.white),
      ),
      backgroundColor: color,
    );
  }
  
  Color _getReportCountColor(int count) {
    if (count >= 10) {
      return Colors.red;
    } else if (count >= 5) {
      return Colors.orange;
    } else {
      return Colors.amber;
    }
  }
  
  void _viewReportedContent(Map<String, dynamic> report, AdminController controller) {
    // Different actions based on content type
    String contentType = report['contentType'] ?? '';
    String contentId = report['contentId'] ?? '';
    Map<String, dynamic>? contentData = report['contentData'];
    
    if (contentData == null) {
      Get.snackbar(
        'Error',
        'Content data not available',
        snackPosition: SnackPosition.BOTTOM,
      );
      return;
    }
    
    Get.dialog(
      Dialog(
        child: Container(
          width: Get.width * 0.8,
          padding: const EdgeInsets.all(16.0),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text(
                'Reported ${contentType.capitalizeFirst}',
                style: const TextStyle(
                  fontSize: 20,
                  fontWeight: FontWeight.bold,
                ),
              ),
              const SizedBox(height: 16),
              _buildContentPreview(contentType, contentData),
              const SizedBox(height: 16),
              Row(
                mainAxisAlignment: MainAxisAlignment.end,
                children: [
                  TextButton(
                    onPressed: () => Get.back(),
                    child: const Text('CLOSE'),
                  ),
                  const SizedBox(width: 8),
                  ElevatedButton(
                    onPressed: () {
                      Get.back();
                      _showModerationActionsDialog(report, controller);
                    },
                    child: const Text('MODERATE'),
                  ),
                ],
              ),
            ],
          ),
        ),
      ),
    );
  }
  
  Widget _buildContentPreview(String contentType, Map<String, dynamic> contentData) {
    switch (contentType) {
      case 'post':
        return Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            if (contentData['postUser'] != null)
              Row(
                children: [
                  AvatarUserWidget(
                    radius: 20,
                    imagePath: contentData['postUser']['image'] ?? '',
                  ),
                  const SizedBox(width: 8),
                  Text(
                    contentData['postUser']['name'] ?? 'Unknown',
                    style: const TextStyle(fontWeight: FontWeight.bold),
                  ),
                ],
              ),
            const SizedBox(height: 8),
            Text(contentData['content'] ?? 'No content'),
            if (contentData['imageUrls'] != null && (contentData['imageUrls'] as List).isNotEmpty)
              const Padding(
                padding: EdgeInsets.only(top: 8.0),
                child: Text('[Post contains images]'),
              ),
          ],
        );
        
      case 'comment':
        return Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            if (contentData['commentUser'] != null)
              Row(
                children: [
                  AvatarUserWidget(
                    radius: 20,
                    imagePath: contentData['commentUser']['image'] ?? '',
                  ),
                  const SizedBox(width: 8),
                  Text(
                    contentData['commentUser']['name'] ?? 'Unknown',
                    style: const TextStyle(fontWeight: FontWeight.bold),
                  ),
                ],
              ),
            const SizedBox(height: 8),
            Text(contentData['content'] ?? 'No content'),
            const SizedBox(height: 8),
            Text(
              'On post: ${contentData['postId'] ?? 'Unknown post'}',
              style: const TextStyle(fontStyle: FontStyle.italic, color: Colors.grey),
            ),
          ],
        );
        
      case 'reel':
        return Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            if (contentData['reelUser'] != null)
              Row(
                children: [
                  AvatarUserWidget(
                    radius: 20,
                    imagePath: contentData['reelUser']['image'] ?? '',
                  ),
                  const SizedBox(width: 8),
                  Text(
                    contentData['reelUser']['name'] ?? 'Unknown',
                    style: const TextStyle(fontWeight: FontWeight.bold),
                  ),
                ],
              ),
            const SizedBox(height: 8),
            Text(contentData['description'] ?? 'No description'),
            const SizedBox(height: 8),
            const Text('[Reel video content]'),
          ],
        );
        
      case 'user':
        return Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              children: [
                AvatarUserWidget(
                  radius: 30,
                  imagePath: contentData['image'] ?? '',
                ),
                const SizedBox(width: 16),
                Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      contentData['name'] ?? 'Unknown',
                      style: const TextStyle(
                        fontSize: 18,
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                    Text(contentData['email'] ?? ''),
                    Text('Role: ${contentData['role'] ?? 'user'}'),
                  ],
                ),
              ],
            ),
            const SizedBox(height: 16),
            Text('Bio: ${contentData['bio'] ?? 'No bio'}'),
          ],
        );
        
      default:
        return const Text('Unknown content type');
    }
  }
  
  void _showModerationActionsDialog(Map<String, dynamic> report, AdminController controller) {
    final contentType = report['contentType'] ?? '';
    final contentId = report['contentId'] ?? '';
    final formKey = GlobalKey<FormState>();
    final reasonController = TextEditingController();
    
    Get.dialog(
      Dialog(
        child: Padding(
          padding: const EdgeInsets.all(16.0),
          child: Form(
            key: formKey,
            child: Column(
              mainAxisSize: MainAxisSize.min,
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                const Text(
                  'Moderation Actions',
                  style: TextStyle(
                    fontSize: 20,
                    fontWeight: FontWeight.bold,
                  ),
                ),
                const SizedBox(height: 16),
                TextField(
                  controller: reasonController,
                  decoration: const InputDecoration(
                    labelText: 'Moderation Reason',
                    hintText: 'Optional: Add a note for this action',
                    border: OutlineInputBorder(),
                  ),
                  maxLines: 2,
                ),
                const SizedBox(height: 16),
                const Text(
                  'Select Action:',
                  style: TextStyle(fontWeight: FontWeight.bold),
                ),
                const SizedBox(height: 8),
                Wrap(
                  spacing: 8,
                  runSpacing: 8,
                  children: [
                    _actionButton(
                      icon: Icons.visibility_off,
                      label: 'Hide',
                      color: Colors.orange,
                      onTap: () {
                        _performModeration(
                          controller,
                          contentType,
                          contentId,
                          'hide',
                          reasonController.text,
                        );
                      },
                    ),
                    _actionButton(
                      icon: Icons.delete,
                      label: 'Delete',
                      color: Colors.red,
                      onTap: () {
                        _performModeration(
                          controller,
                          contentType,
                          contentId,
                          'delete',
                          reasonController.text,
                        );
                      },
                    ),
                    _actionButton(
                      icon: Icons.warning,
                      label: 'Warn User',
                      color: Colors.amber,
                      onTap: () {
                        _performModeration(
                          controller,
                          contentType,
                          contentId,
                          'warn',
                          reasonController.text,
                        );
                      },
                    ),
                    _actionButton(
                      icon: Icons.restore,
                      label: 'Restore',
                      color: Colors.green,
                      onTap: () {
                        _performModeration(
                          controller,
                          contentType,
                          contentId,
                          'restore',
                          reasonController.text,
                        );
                      },
                    ),
                  ],
                ),
                const SizedBox(height: 16),
                Align(
                  alignment: Alignment.centerRight,
                  child: TextButton(
                    onPressed: () => Get.back(),
                    child: const Text('CANCEL'),
                  ),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }
  
  Widget _actionButton({
    required IconData icon,
    required String label,
    required Color color,
    required VoidCallback onTap,
  }) {
    return InkWell(
      onTap: onTap,
      borderRadius: BorderRadius.circular(8),
      child: Container(
        padding: const EdgeInsets.symmetric(
          horizontal: 12,
          vertical: 8,
        ),
        decoration: BoxDecoration(
          color: color.withOpacity(0.1),
          borderRadius: BorderRadius.circular(8),
          border: Border.all(color: color),
        ),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            Icon(icon, color: color),
            const SizedBox(height: 4),
            Text(
              label,
              style: TextStyle(color: color),
            ),
          ],
        ),
      ),
    );
  }
  
  Future<void> _performModeration(
    AdminController controller,
    String contentType,
    String contentId,
    String action,
    String reason,
  ) async {
    if (contentType.isEmpty || contentId.isEmpty) {
      Get.back();
      Get.snackbar(
        'Error',
        'Invalid content information',
        snackPosition: SnackPosition.BOTTOM,
      );
      return;
    }
    
    Get.back();
    
    final success = await controller.moderateContent(
      contentType,
      contentId,
      action,
      reason: reason,
    );
    
    if (success) {
      Get.snackbar(
        'Success',
        'Content has been moderated',
        snackPosition: SnackPosition.BOTTOM,
        backgroundColor: Colors.green,
        colorText: Colors.white,
      );
    }
  }
}
```

---


### Pages\Admin\Pages\tabs\game_management_tab.dart

```dart
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:tictactoe_gameapp/Pages/Admin/controllers/admin_controller.dart';
import 'package:tictactoe_gameapp/Components/belong_to_users/avatar_user_widget.dart';

class GameManagementTab extends StatefulWidget {
  const GameManagementTab({super.key});

  @override
  State<GameManagementTab> createState() => _GameManagementTabState();
}

class _GameManagementTabState extends State<GameManagementTab>
    with SingleTickerProviderStateMixin {
  late TabController _gameTabController;

  @override
  void initState() {
    super.initState();
    _gameTabController = TabController(length: 3, vsync: this);
  }

  @override
  void dispose() {
    _gameTabController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final controller = Get.find<AdminController>();

    return Padding(
      padding: const EdgeInsets.all(16.0),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          _buildGameSelector(controller),
          const SizedBox(height: 24),
          // Game tab selector
          TabBar(
            controller: _gameTabController,
            labelColor: Colors.deepPurpleAccent,
            unselectedLabelColor: Colors.grey,
            tabs: const [
              Tab(text: 'Configuration'),
              Tab(text: 'Leaderboard'),
              Tab(text: 'Statistics'),
            ],
          ),
          const SizedBox(height: 16),
          Expanded(
            child: Obx(() {
              if (controller.isLoadingLeaderboards.value) {
                return const Center(child: CircularProgressIndicator());
              }

              return TabBarView(
                controller: _gameTabController,
                children: [
                  _buildGameConfigTab(controller),
                  _buildLeaderboardTab(controller),
                  _buildGameStatsTab(controller),
                ],
              );
            }),
          ),
        ],
      ),
    );
  }

  Widget _buildGameSelector(AdminController controller) {
    return Card(
      elevation: 2,
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            const Text(
              'Select Game',
              style: TextStyle(
                fontSize: 18,
                fontWeight: FontWeight.bold,
              ),
            ),
            const SizedBox(height: 16),
            SingleChildScrollView(
              scrollDirection: Axis.horizontal,
              child: Row(
                children: [
                  _buildGameButton(
                    controller,
                    'tictactoe',
                    'Tic Tac Toe',
                    Icons.grid_3x3,
                  ),
                  _buildGameButton(
                    controller,
                    'sudoku',
                    'Sudoku',
                    Icons.grid_4x4,
                  ),
                  _buildGameButton(
                    controller,
                    'minesweeper',
                    'Minesweeper',
                    Icons.flag,
                  ),
                  _buildGameButton(
                    controller,
                    'match3',
                    'Match 3',
                    Icons.view_comfy,
                  ),
                  _buildGameButton(
                    controller,
                    '2048',
                    '2048',
                    Icons.view_module,
                  ),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildGameButton(
    AdminController controller,
    String gameId,
    String name,
    IconData icon,
  ) {
    return Obx(() {
      final isSelected = controller.selectedGame.value == gameId;

      return Padding(
        padding: const EdgeInsets.only(right: 8.0),
        child: ElevatedButton.icon(
          onPressed: () {
            controller.selectedGame.value = gameId;
            controller.fetchGameLeaderboard(gameId);
            controller.fetchGameConfig(gameId);
          },
          icon: Icon(icon),
          label: Text(name),
          style: ElevatedButton.styleFrom(
            backgroundColor:
                isSelected ? Colors.deepPurpleAccent : Colors.grey[200],
            foregroundColor: isSelected ? Colors.white : Colors.black87,
          ),
        ),
      );
    });
  }

  Widget _buildGameConfigTab(AdminController controller) {
    return Obx(() {
      final gameId = controller.selectedGame.value;
      final gameConfig = controller.gameConfig.value;

      // Default configurations if none exists
      final defaultConfigs = _getDefaultGameConfig(gameId);

      return SingleChildScrollView(
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Card(
              elevation: 2,
              child: Padding(
                padding: const EdgeInsets.all(16.0),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Text(
                          '${gameId.capitalize} Configuration',
                          style: const TextStyle(
                            fontSize: 18,
                            fontWeight: FontWeight.bold,
                          ),
                        ),
                        ElevatedButton.icon(
                          onPressed: () => _saveGameConfig(controller),
                          icon: const Icon(Icons.save),
                          label: const Text('Save Changes'),
                          style: ElevatedButton.styleFrom(
                            backgroundColor: Colors.deepPurpleAccent,
                          ),
                        ),
                      ],
                    ),
                    const SizedBox(height: 16),
                    const Divider(),
                    const SizedBox(height: 16),
                    _buildConfigPanel(
                        controller, gameId, gameConfig, defaultConfigs),
                  ],
                ),
              ),
            ),
            const SizedBox(height: 24),
            _buildEmoteConfigCard(controller, gameId),
          ],
        ),
      );
    });
  }

  Widget _buildConfigPanel(
    AdminController controller,
    String gameId,
    Map<String, dynamic> gameConfig,
    Map<String, dynamic> defaultConfigs,
  ) {
    switch (gameId) {
      case 'tictactoe':
        return _buildTicTacToeConfig(controller, gameConfig, defaultConfigs);
      case 'sudoku':
        return _buildSudokuConfig(controller, gameConfig, defaultConfigs);
      case 'minesweeper':
        return _buildMinesweeperConfig(controller, gameConfig, defaultConfigs);
      case 'match3':
        return _buildMatch3Config(controller, gameConfig, defaultConfigs);
      case '2048':
        return _build2048Config(controller, gameConfig, defaultConfigs);
      default:
        return const Center(
            child: Text('No configuration available for this game'));
    }
  }

  Widget _buildTicTacToeConfig(
    AdminController controller,
    Map<String, dynamic> gameConfig,
    Map<String, dynamic> defaultConfigs,
  ) {
    final boardSizes = ['3x3', '4x4', '5x5'];

    // Get values with defaults
    final activeBoardSizes = List<String>.from(
        gameConfig['activeBoardSizes'] ?? defaultConfigs['activeBoardSizes']);
    final winReward = gameConfig['winReward'] ?? defaultConfigs['winReward'];
    final drawReward = gameConfig['drawReward'] ?? defaultConfigs['drawReward'];
    final timeLimit = gameConfig['timeLimit'] ?? defaultConfigs['timeLimit'];
    final aiDifficulty =
        gameConfig['aiDifficulty'] ?? defaultConfigs['aiDifficulty'];

    // Controllers for editable fields
    final winRewardController =
        TextEditingController(text: winReward.toString());
    final drawRewardController =
        TextEditingController(text: drawReward.toString());
    final timeLimitController =
        TextEditingController(text: timeLimit.toString());

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        const Text(
          'Active Board Sizes',
          style: TextStyle(fontWeight: FontWeight.bold),
        ),
        const SizedBox(height: 8),
        Wrap(
          spacing: 8,
          children: boardSizes.map((size) {
            final isActive = activeBoardSizes.contains(size);
            return FilterChip(
              label: Text(size),
              selected: isActive,
              onSelected: (selected) {
                if (selected) {
                  activeBoardSizes.add(size);
                } else {
                  if (activeBoardSizes.length > 1) {
                    activeBoardSizes.remove(size);
                  } else {
                    Get.snackbar(
                      'Error',
                      'At least one board size must be active',
                      snackPosition: SnackPosition.BOTTOM,
                    );
                  }
                }

                // Create a copy of the current config for immutability
                final updatedConfig =
                    Map<String, dynamic>.from(controller.gameConfig.value);
                updatedConfig['activeBoardSizes'] = activeBoardSizes;
                controller.gameConfig.value = updatedConfig;
              },
            );
          }).toList(),
        ),
        const SizedBox(height: 16),
        Row(
          children: [
            Expanded(
              child: TextField(
                controller: winRewardController,
                decoration: const InputDecoration(
                  labelText: 'Win Reward (Coins)',
                  border: OutlineInputBorder(),
                ),
                keyboardType: TextInputType.number,
                onChanged: (value) {
                  final reward = int.tryParse(value) ?? winReward;
                  final updatedConfig =
                      Map<String, dynamic>.from(controller.gameConfig.value);
                  updatedConfig['winReward'] = reward;
                  controller.gameConfig.value = updatedConfig;
                },
              ),
            ),
            const SizedBox(width: 16),
            Expanded(
              child: TextField(
                controller: drawRewardController,
                decoration: const InputDecoration(
                  labelText: 'Draw Reward (Coins)',
                  border: OutlineInputBorder(),
                ),
                keyboardType: TextInputType.number,
                onChanged: (value) {
                  final reward = int.tryParse(value) ?? drawReward;
                  final updatedConfig =
                      Map<String, dynamic>.from(controller.gameConfig.value);
                  updatedConfig['drawReward'] = reward;
                  controller.gameConfig.value = updatedConfig;
                },
              ),
            ),
          ],
        ),
        const SizedBox(height: 16),
        Row(
          children: [
            Expanded(
              child: TextField(
                controller: timeLimitController,
                decoration: const InputDecoration(
                  labelText: 'Time Limit (seconds)',
                  border: OutlineInputBorder(),
                ),
                keyboardType: TextInputType.number,
                onChanged: (value) {
                  final limit = int.tryParse(value) ?? timeLimit;
                  final updatedConfig =
                      Map<String, dynamic>.from(controller.gameConfig.value);
                  updatedConfig['timeLimit'] = limit;
                  controller.gameConfig.value = updatedConfig;
                },
              ),
            ),
            const SizedBox(width: 16),
            Expanded(
              child: DropdownButtonFormField<String>(
                decoration: const InputDecoration(
                  labelText: 'AI Difficulty',
                  border: OutlineInputBorder(),
                ),
                value: aiDifficulty,
                onChanged: (value) {
                  if (value != null) {
                    final updatedConfig =
                        Map<String, dynamic>.from(controller.gameConfig.value);
                    updatedConfig['aiDifficulty'] = value;
                    controller.gameConfig.value = updatedConfig;
                  }
                },
                items: const [
                  DropdownMenuItem(value: 'easy', child: Text('Easy')),
                  DropdownMenuItem(value: 'medium', child: Text('Medium')),
                  DropdownMenuItem(value: 'hard', child: Text('Hard')),
                ],
              ),
            ),
          ],
        ),
      ],
    );
  }

  Widget _buildSudokuConfig(
    AdminController controller,
    Map<String, dynamic> gameConfig,
    Map<String, dynamic> defaultConfigs,
  ) {
    final difficulties = ['easy', 'medium', 'hard', 'expert'];
    final gridSizes = ['4x4', '9x9', '16x16'];

    // Get values with defaults
    final activeDifficulties = List<String>.from(
        gameConfig['activeDifficulties'] ??
            defaultConfigs['activeDifficulties']);
    final activeGridSizes = List<String>.from(
        gameConfig['activeGridSizes'] ?? defaultConfigs['activeGridSizes']);
    final completionReward =
        gameConfig['completionReward'] ?? defaultConfigs['completionReward'];
    final enableHints =
        gameConfig['enableHints'] ?? defaultConfigs['enableHints'];
    final hintsLimit = gameConfig['hintsLimit'] ?? defaultConfigs['hintsLimit'];

    // Controllers for editable fields
    final completionRewardController =
        TextEditingController(text: completionReward.toString());
    final hintsLimitController =
        TextEditingController(text: hintsLimit.toString());

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        const Text(
          'Active Difficulties',
          style: TextStyle(fontWeight: FontWeight.bold),
        ),
        const SizedBox(height: 8),
        Wrap(
          spacing: 8,
          children: difficulties.map((diff) {
            final isActive = activeDifficulties.contains(diff);
            return FilterChip(
              label: Text(diff.capitalize!),
              selected: isActive,
              onSelected: (selected) {
                if (selected) {
                  activeDifficulties.add(diff);
                } else {
                  if (activeDifficulties.length > 1) {
                    activeDifficulties.remove(diff);
                  } else {
                    Get.snackbar(
                      'Error',
                      'At least one difficulty must be active',
                      snackPosition: SnackPosition.BOTTOM,
                    );
                  }
                }

                final updatedConfig =
                    Map<String, dynamic>.from(controller.gameConfig.value);
                updatedConfig['activeDifficulties'] = activeDifficulties;
                controller.gameConfig.value = updatedConfig;
              },
            );
          }).toList(),
        ),
        const SizedBox(height: 16),
        const Text(
          'Active Grid Sizes',
          style: TextStyle(fontWeight: FontWeight.bold),
        ),
        const SizedBox(height: 8),
        Wrap(
          spacing: 8,
          children: gridSizes.map((size) {
            final isActive = activeGridSizes.contains(size);
            return FilterChip(
              label: Text(size),
              selected: isActive,
              onSelected: (selected) {
                if (selected) {
                  activeGridSizes.add(size);
                } else {
                  if (activeGridSizes.length > 1) {
                    activeGridSizes.remove(size);
                  } else {
                    Get.snackbar(
                      'Error',
                      'At least one grid size must be active',
                      snackPosition: SnackPosition.BOTTOM,
                    );
                  }
                }

                final updatedConfig =
                    Map<String, dynamic>.from(controller.gameConfig.value);
                updatedConfig['activeGridSizes'] = activeGridSizes;
                controller.gameConfig.value = updatedConfig;
              },
            );
          }).toList(),
        ),
        const SizedBox(height: 16),
        Row(
          children: [
            Expanded(
              child: TextField(
                controller: completionRewardController,
                decoration: const InputDecoration(
                  labelText: 'Completion Reward (Coins)',
                  border: OutlineInputBorder(),
                ),
                keyboardType: TextInputType.number,
                onChanged: (value) {
                  final reward = int.tryParse(value) ?? completionReward;
                  final updatedConfig =
                      Map<String, dynamic>.from(controller.gameConfig.value);
                  updatedConfig['completionReward'] = reward;
                  controller.gameConfig.value = updatedConfig;
                },
              ),
            ),
            const SizedBox(width: 16),
            Expanded(
              child: SwitchListTile(
                title: const Text('Enable Hints'),
                value: enableHints,
                onChanged: (value) {
                  final updatedConfig =
                      Map<String, dynamic>.from(controller.gameConfig.value);
                  updatedConfig['enableHints'] = value;
                  controller.gameConfig.value = updatedConfig;
                },
                contentPadding: EdgeInsets.zero,
              ),
            ),
          ],
        ),
        const SizedBox(height: 16),
        Obx(() {
          final isHintsEnabled =
              controller.gameConfig.value['enableHints'] ?? enableHints;
          return TextField(
            controller: hintsLimitController,
            decoration: const InputDecoration(
              labelText: 'Hints Limit per Game',
              border: OutlineInputBorder(),
            ),
            keyboardType: TextInputType.number,
            enabled: isHintsEnabled,
            onChanged: (value) {
              final limit = int.tryParse(value) ?? hintsLimit;
              final updatedConfig =
                  Map<String, dynamic>.from(controller.gameConfig.value);
              updatedConfig['hintsLimit'] = limit;
              controller.gameConfig.value = updatedConfig;
            },
          );
        }),
      ],
    );
  }

  Widget _buildMinesweeperConfig(
    AdminController controller,
    Map<String, dynamic> gameConfig,
    Map<String, dynamic> defaultConfigs,
  ) {
    final boardSizes = ['8x8', '16x16', '32x32'];

    // Get values with defaults
    final activeBoardSizes = List<String>.from(
        gameConfig['activeBoardSizes'] ?? defaultConfigs['activeBoardSizes']);
    final completionReward =
        gameConfig['completionReward'] ?? defaultConfigs['completionReward'];
    final minesPercentage =
        gameConfig['minesPercentage'] ?? defaultConfigs['minesPercentage'];
    final enableFirstClickSafety = gameConfig['enableFirstClickSafety'] ??
        defaultConfigs['enableFirstClickSafety'];

    // Controllers for editable fields
    final completionRewardController =
        TextEditingController(text: completionReward.toString());
    final minesPercentageController =
        TextEditingController(text: minesPercentage.toString());

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        const Text(
          'Active Board Sizes',
          style: TextStyle(fontWeight: FontWeight.bold),
        ),
        const SizedBox(height: 8),
        Wrap(
          spacing: 8,
          children: boardSizes.map((size) {
            final isActive = activeBoardSizes.contains(size);
            return FilterChip(
              label: Text(size),
              selected: isActive,
              onSelected: (selected) {
                if (selected) {
                  activeBoardSizes.add(size);
                } else {
                  if (activeBoardSizes.length > 1) {
                    activeBoardSizes.remove(size);
                  } else {
                    Get.snackbar(
                      'Error',
                      'At least one board size must be active',
                      snackPosition: SnackPosition.BOTTOM,
                    );
                  }
                }

                final updatedConfig =
                    Map<String, dynamic>.from(controller.gameConfig.value);
                updatedConfig['activeBoardSizes'] = activeBoardSizes;
                controller.gameConfig.value = updatedConfig;
              },
            );
          }).toList(),
        ),
        const SizedBox(height: 16),
        Row(
          children: [
            Expanded(
              child: TextField(
                controller: completionRewardController,
                decoration: const InputDecoration(
                  labelText: 'Completion Reward (Coins)',
                  border: OutlineInputBorder(),
                ),
                keyboardType: TextInputType.number,
                onChanged: (value) {
                  final reward = int.tryParse(value) ?? completionReward;
                  final updatedConfig =
                      Map<String, dynamic>.from(controller.gameConfig.value);
                  updatedConfig['completionReward'] = reward;
                  controller.gameConfig.value = updatedConfig;
                },
              ),
            ),
            const SizedBox(width: 16),
            Expanded(
              child: TextField(
                controller: minesPercentageController,
                decoration: const InputDecoration(
                  labelText: 'Mines Percentage (1-40)',
                  border: OutlineInputBorder(),
                ),
                keyboardType: TextInputType.number,
                onChanged: (value) {
                  var percentage = int.tryParse(value) ?? minesPercentage;
                  if (percentage < 1) percentage = 1;
                  if (percentage > 40) percentage = 40;

                  final updatedConfig =
                      Map<String, dynamic>.from(controller.gameConfig.value);
                  updatedConfig['minesPercentage'] = percentage;
                  controller.gameConfig.value = updatedConfig;
                },
              ),
            ),
          ],
        ),
        const SizedBox(height: 16),
        SwitchListTile(
          title: const Text('Enable First Click Safety'),
          subtitle: const Text('First click will never be a mine'),
          value: enableFirstClickSafety,
          onChanged: (value) {
            final updatedConfig =
                Map<String, dynamic>.from(controller.gameConfig.value);
            updatedConfig['enableFirstClickSafety'] = value;
            controller.gameConfig.value = updatedConfig;
          },
          contentPadding: EdgeInsets.zero,
        ),
      ],
    );
  }

  Widget _buildMatch3Config(
    AdminController controller,
    Map<String, dynamic> gameConfig,
    Map<String, dynamic> defaultConfigs,
  ) {
    // Get values with defaults
    final boardSizes = List<String>.from(
        gameConfig['boardSizes'] ?? defaultConfigs['boardSizes']);
    final maxMoves = gameConfig['maxMoves'] ?? defaultConfigs['maxMoves'];

    final Map<String, dynamic> defaultTargetScores = {
      'easy': 1000,
      'medium': 2000,
      'hard': 3000,
    };

    final targetScores = Map<String, int>.from(
        gameConfig['targetScores'] ?? defaultTargetScores);

    final List<int> defaultRewards = [5, 10, 15];
    final rewardsPerStar =
        List<int>.from(gameConfig['rewardsPerStar'] ?? defaultRewards);

    // Controllers for editable fields
    final maxMovesController = TextEditingController(text: maxMoves.toString());
    final easyScoreController =
        TextEditingController(text: targetScores['easy'].toString());
    final mediumScoreController =
        TextEditingController(text: targetScores['medium'].toString());
    final hardScoreController =
        TextEditingController(text: targetScores['hard'].toString());
    final star1RewardController =
        TextEditingController(text: rewardsPerStar[0].toString());
    final star2RewardController =
        TextEditingController(text: rewardsPerStar[1].toString());
    final star3RewardController =
        TextEditingController(text: rewardsPerStar[2].toString());

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        const Text(
          'Game Settings',
          style: TextStyle(fontWeight: FontWeight.bold),
        ),
        const SizedBox(height: 16),
        TextField(
          controller: maxMovesController,
          decoration: const InputDecoration(
            labelText: 'Max Moves per Game',
            border: OutlineInputBorder(),
          ),
          keyboardType: TextInputType.number,
          onChanged: (value) {
            final moves = int.tryParse(value) ?? maxMoves;
            final updatedConfig =
                Map<String, dynamic>.from(controller.gameConfig.value);
            updatedConfig['maxMoves'] = moves;
            controller.gameConfig.value = updatedConfig;
          },
        ),
        const SizedBox(height: 16),
        const Text(
          'Target Scores by Difficulty',
          style: TextStyle(fontWeight: FontWeight.bold),
        ),
        const SizedBox(height: 8),
        Row(
          children: [
            Expanded(
              child: TextField(
                controller: easyScoreController,
                decoration: const InputDecoration(
                  labelText: 'Easy Score',
                  border: OutlineInputBorder(),
                ),
                keyboardType: TextInputType.number,
                onChanged: (value) {
                  final score = int.tryParse(value) ?? targetScores['easy'];

                  final updatedConfig =
                      Map<String, dynamic>.from(controller.gameConfig.value);
                  if (updatedConfig['targetScores'] == null) {
                    updatedConfig['targetScores'] =
                        Map<String, int>.from(targetScores);
                  }
                  (updatedConfig['targetScores']
                      as Map<String, dynamic>)['easy'] = score;
                  controller.gameConfig.value = updatedConfig;
                },
              ),
            ),
            const SizedBox(width: 8),
            Expanded(
              child: TextField(
                controller: mediumScoreController,
                decoration: const InputDecoration(
                  labelText: 'Medium Score',
                  border: OutlineInputBorder(),
                ),
                keyboardType: TextInputType.number,
                onChanged: (value) {
                  final score = int.tryParse(value) ?? targetScores['medium'];

                  final updatedConfig =
                      Map<String, dynamic>.from(controller.gameConfig.value);
                  if (updatedConfig['targetScores'] == null) {
                    updatedConfig['targetScores'] =
                        Map<String, int>.from(targetScores);
                  }
                  (updatedConfig['targetScores']
                      as Map<String, dynamic>)['medium'] = score;
                  controller.gameConfig.value = updatedConfig;
                },
              ),
            ),
            const SizedBox(width: 8),
            Expanded(
              child: TextField(
                controller: hardScoreController,
                decoration: const InputDecoration(
                  labelText: 'Hard Score',
                  border: OutlineInputBorder(),
                ),
                keyboardType: TextInputType.number,
                onChanged: (value) {
                  final score = int.tryParse(value) ?? targetScores['hard'];

                  final updatedConfig =
                      Map<String, dynamic>.from(controller.gameConfig.value);
                  if (updatedConfig['targetScores'] == null) {
                    updatedConfig['targetScores'] =
                        Map<String, int>.from(targetScores);
                  }
                  (updatedConfig['targetScores']
                      as Map<String, dynamic>)['hard'] = score;
                  controller.gameConfig.value = updatedConfig;
                },
              ),
            ),
          ],
        ),
        const SizedBox(height: 16),
        const Text(
          'Rewards per Star (Coins)',
          style: TextStyle(fontWeight: FontWeight.bold),
        ),
        const SizedBox(height: 8),
        Row(
          children: [
            Expanded(
              child: TextField(
                controller: star1RewardController,
                decoration: const InputDecoration(
                  labelText: '1 Star',
                  border: OutlineInputBorder(),
                ),
                keyboardType: TextInputType.number,
                onChanged: (value) {
                  final reward = int.tryParse(value) ?? rewardsPerStar[0];

                  final updatedConfig =
                      Map<String, dynamic>.from(controller.gameConfig.value);
                  if (updatedConfig['rewardsPerStar'] == null) {
                    updatedConfig['rewardsPerStar'] =
                        List<int>.from(rewardsPerStar);
                  }

                  final rewards = updatedConfig['rewardsPerStar'] as List;
                  if (rewards.isNotEmpty) {
                    rewards[0] = reward;
                  }
                  controller.gameConfig.value = updatedConfig;
                },
              ),
            ),
            const SizedBox(width: 8),
            Expanded(
              child: TextField(
                controller: star2RewardController,
                decoration: const InputDecoration(
                  labelText: '2 Stars',
                  border: OutlineInputBorder(),
                ),
                keyboardType: TextInputType.number,
                onChanged: (value) {
                  final reward = int.tryParse(value) ?? rewardsPerStar[1];

                  final updatedConfig =
                      Map<String, dynamic>.from(controller.gameConfig.value);
                  if (updatedConfig['rewardsPerStar'] == null) {
                    updatedConfig['rewardsPerStar'] =
                        List<int>.from(rewardsPerStar);
                  }

                  final rewards = updatedConfig['rewardsPerStar'] as List;
                  if (rewards.length > 1) {
                    rewards[1] = reward;
                  }
                  controller.gameConfig.value = updatedConfig;
                },
              ),
            ),
            const SizedBox(width: 8),
            Expanded(
              child: TextField(
                controller: star3RewardController,
                decoration: const InputDecoration(
                  labelText: '3 Stars',
                  border: OutlineInputBorder(),
                ),
                keyboardType: TextInputType.number,
                onChanged: (value) {
                  final reward = int.tryParse(value) ?? rewardsPerStar[2];

                  final updatedConfig =
                      Map<String, dynamic>.from(controller.gameConfig.value);
                  if (updatedConfig['rewardsPerStar'] == null) {
                    updatedConfig['rewardsPerStar'] =
                        List<int>.from(rewardsPerStar);
                  }

                  final rewards = updatedConfig['rewardsPerStar'] as List;
                  if (rewards.length > 2) {
                    rewards[2] = reward;
                  }
                  controller.gameConfig.value = updatedConfig;
                },
              ),
            ),
          ],
        ),
      ],
    );
  }

  Widget _build2048Config(
    AdminController controller,
    Map<String, dynamic> gameConfig,
    Map<String, dynamic> defaultConfigs,
  ) {
    // Get values with defaults
    final gridSizes = List<String>.from(
        gameConfig['gridSizes'] ?? defaultConfigs['gridSizes']);
    final targetTiles = List<int>.from(
        gameConfig['targetTiles'] ?? defaultConfigs['targetTiles']);

    // Default rewards if not present
    final Map<String, int> defaultRewards = {
      '1024': 10,
      '2048': 25,
      '4096': 50,
      '8192': 100,
    };

    final rewardsPerTarget =
        Map<String, int>.from(gameConfig['rewardsPerTarget'] ?? defaultRewards);

    // Controllers for editable fields
    final r1024Controller =
        TextEditingController(text: rewardsPerTarget['1024'].toString());
    final r2048Controller =
        TextEditingController(text: rewardsPerTarget['2048'].toString());
    final r4096Controller =
        TextEditingController(text: rewardsPerTarget['4096'].toString());
    final r8192Controller =
        TextEditingController(text: rewardsPerTarget['8192'].toString());

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        const Text(
          'Active Grid Sizes',
          style: TextStyle(fontWeight: FontWeight.bold),
        ),
        const SizedBox(height: 8),
        Wrap(
          spacing: 8,
          children: ['4x4', '5x5', '6x6'].map((size) {
            final isActive = gridSizes.contains(size);
            return FilterChip(
              label: Text(size),
              selected: isActive,
              onSelected: (selected) {
                if (selected) {
                  gridSizes.add(size);
                } else {
                  if (gridSizes.length > 1) {
                    gridSizes.remove(size);
                  } else {
                    Get.snackbar(
                      'Error',
                      'At least one grid size must be active',
                      snackPosition: SnackPosition.BOTTOM,
                    );
                  }
                }

                final updatedConfig =
                    Map<String, dynamic>.from(controller.gameConfig.value);
                updatedConfig['gridSizes'] = gridSizes;
                controller.gameConfig.value = updatedConfig;
              },
            );
          }).toList(),
        ),
        const SizedBox(height: 16),
        const Text(
          'Target Tiles',
          style: TextStyle(fontWeight: FontWeight.bold),
        ),
        const SizedBox(height: 8),
        Wrap(
          spacing: 8,
          children: [1024, 2048, 4096, 8192].map((tile) {
            final isActive = targetTiles.contains(tile);
            return FilterChip(
              label: Text(tile.toString()),
              selected: isActive,
              onSelected: (selected) {
                if (selected) {
                  targetTiles.add(tile);
                } else {
                  if (targetTiles.length > 1) {
                    targetTiles.remove(tile);
                  } else {
                    Get.snackbar(
                      'Error',
                      'At least one target tile must be active',
                      snackPosition: SnackPosition.BOTTOM,
                    );
                  }
                }

                final updatedConfig =
                    Map<String, dynamic>.from(controller.gameConfig.value);
                updatedConfig['targetTiles'] = targetTiles;
                controller.gameConfig.value = updatedConfig;
              },
            );
          }).toList(),
        ),
        const SizedBox(height: 16),
        const Text(
          'Rewards per Target (Coins)',
          style: TextStyle(fontWeight: FontWeight.bold),
        ),
        const SizedBox(height: 8),
        Row(
          children: [
            Expanded(
              child: TextField(
                controller: r1024Controller,
                decoration: const InputDecoration(
                  labelText: '1024 Tile',
                  border: OutlineInputBorder(),
                ),
                keyboardType: TextInputType.number,
                onChanged: (value) {
                  final reward =
                      int.tryParse(value) ?? rewardsPerTarget['1024'];

                  final updatedConfig =
                      Map<String, dynamic>.from(controller.gameConfig.value);
                  if (updatedConfig['rewardsPerTarget'] == null) {
                    updatedConfig['rewardsPerTarget'] =
                        Map<String, int>.from(rewardsPerTarget);
                  }

                  (updatedConfig['rewardsPerTarget']
                      as Map<String, dynamic>)['1024'] = reward;
                  controller.gameConfig.value = updatedConfig;
                },
              ),
            ),
            const SizedBox(width: 8),
            Expanded(
              child: TextField(
                controller: r2048Controller,
                decoration: const InputDecoration(
                  labelText: '2048 Tile',
                  border: OutlineInputBorder(),
                ),
                keyboardType: TextInputType.number,
                onChanged: (value) {
                  final reward =
                      int.tryParse(value) ?? rewardsPerTarget['2048'];

                  final updatedConfig =
                      Map<String, dynamic>.from(controller.gameConfig.value);
                  if (updatedConfig['rewardsPerTarget'] == null) {
                    updatedConfig['rewardsPerTarget'] =
                        Map<String, int>.from(rewardsPerTarget);
                  }

                  (updatedConfig['rewardsPerTarget']
                      as Map<String, dynamic>)['2048'] = reward;
                  controller.gameConfig.value = updatedConfig;
                },
              ),
            ),
          ],
        ),
        const SizedBox(height: 8),
        Row(
          children: [
            Expanded(
              child: TextField(
                controller: r4096Controller,
                decoration: const InputDecoration(
                  labelText: '4096 Tile',
                  border: OutlineInputBorder(),
                ),
                keyboardType: TextInputType.number,
                onChanged: (value) {
                  final reward =
                      int.tryParse(value) ?? rewardsPerTarget['4096'];

                  final updatedConfig =
                      Map<String, dynamic>.from(controller.gameConfig.value);
                  if (updatedConfig['rewardsPerTarget'] == null) {
                    updatedConfig['rewardsPerTarget'] =
                        Map<String, int>.from(rewardsPerTarget);
                  }

                  (updatedConfig['rewardsPerTarget']
                      as Map<String, dynamic>)['4096'] = reward;
                  controller.gameConfig.value = updatedConfig;
                },
              ),
            ),
            const SizedBox(width: 8),
            Expanded(
              child: TextField(
                controller: r8192Controller,
                decoration: const InputDecoration(
                  labelText: '8192 Tile',
                  border: OutlineInputBorder(),
                ),
                keyboardType: TextInputType.number,
                onChanged: (value) {
                  final reward =
                      int.tryParse(value) ?? rewardsPerTarget['8192'];

                  final updatedConfig =
                      Map<String, dynamic>.from(controller.gameConfig.value);
                  if (updatedConfig['rewardsPerTarget'] == null) {
                    updatedConfig['rewardsPerTarget'] =
                        Map<String, int>.from(rewardsPerTarget);
                  }

                  (updatedConfig['rewardsPerTarget']
                      as Map<String, dynamic>)['8192'] = reward;
                  controller.gameConfig.value = updatedConfig;
                },
              ),
            ),
          ],
        ),
      ],
    );
  }

  Widget _buildEmoteConfigCard(AdminController controller, String gameId) {
    // Mock emote data
    final emotes = [
      {'id': 'emote1', 'name': 'Thumbs Up', 'free': true, 'price': 0},
      {'id': 'emote2', 'name': 'Good Game', 'free': true, 'price': 0},
      {'id': 'emote3', 'name': 'Happy', 'free': false, 'price': 50},
      {'id': 'emote4', 'name': 'Sad', 'free': false, 'price': 50},
      {'id': 'emote5', 'name': 'Angry', 'free': false, 'price': 100},
      {'id': 'emote6', 'name': 'Surprised', 'free': false, 'price': 100},
    ];

    return Card(
      elevation: 2,
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            const Text(
              'Game Emotes',
              style: TextStyle(
                fontSize: 18,
                fontWeight: FontWeight.bold,
              ),
            ),
            const SizedBox(height: 16),
            const Text(
              'Configure available emotes and pricing',
              style: TextStyle(color: Colors.grey),
            ),
            const SizedBox(height: 16),
            const Divider(),
            ListView.builder(
              shrinkWrap: true,
              physics: const NeverScrollableScrollPhysics(),
              itemCount: emotes.length,
              itemBuilder: (context, index) {
                final emote = emotes[index];
                return ListTile(
                  leading: CircleAvatar(
                    child: Text((emote['name'] as String)[0]),
                  ),
                  title: Text(emote['name'] as String),
                  subtitle: Text(
                    emote['free'] as bool ? 'Free' : '${emote['price']} coins',
                  ),
                  trailing: Row(
                    mainAxisSize: MainAxisSize.min,
                    children: [
                      Switch(
                        value: true, // All emotes enabled by default
                        onChanged: (enabled) {
                          // Update emote availability
                        },
                      ),
                      IconButton(
                        icon: const Icon(Icons.edit),
                        onPressed: () {
                          // Show edit dialog
                        },
                      ),
                    ],
                  ),
                );
              },
            ),
            const SizedBox(height: 16),
            Center(
              child: ElevatedButton.icon(
                onPressed: () {
                  // Show add emote dialog
                },
                icon: const Icon(Icons.add),
                label: const Text('Add New Emote'),
                style: ElevatedButton.styleFrom(
                  backgroundColor: Colors.deepPurpleAccent,
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildLeaderboardTab(AdminController controller) {
    return Obx(() {
      final gameId = controller.selectedGame.value;
      final leaderboard = controller.gameLeaderboards[gameId] ?? [];

      if (leaderboard.isEmpty) {
        return Center(
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              const Icon(
                Icons.leaderboard,
                size: 64,
                color: Colors.grey,
              ),
              const SizedBox(height: 16),
              const Text(
                'No leaderboard data available',
                style: TextStyle(fontSize: 18),
              ),
              const SizedBox(height: 8),
              ElevatedButton(
                onPressed: () => controller.fetchGameLeaderboard(gameId),
                child: const Text('Refresh Leaderboard'),
              ),
            ],
          ),
        );
      }

      return RefreshIndicator(
        onRefresh: () => controller.fetchGameLeaderboard(gameId),
        child: ListView.builder(
          itemCount: leaderboard.length + 1, // +1 for the header
          itemBuilder: (context, index) {
            if (index == 0) {
              return const Padding(
                padding: EdgeInsets.all(16.0),
                child: Row(
                  children: [
                    SizedBox(
                        width: 50,
                        child: Text('Rank',
                            style: TextStyle(fontWeight: FontWeight.bold))),
                    SizedBox(width: 16),
                    Expanded(
                        child: Text('Player',
                            style: TextStyle(fontWeight: FontWeight.bold))),
                    SizedBox(
                        width: 80,
                        child: Text('Score',
                            style: TextStyle(fontWeight: FontWeight.bold))),
                    SizedBox(
                        width: 80,
                        child: Text('Games',
                            style: TextStyle(fontWeight: FontWeight.bold))),
                    SizedBox(width: 40),
                  ],
                ),
              );
            }

            final entryIndex = index - 1;
            final entry = leaderboard[entryIndex];
            final userData = entry['user'] as Map<String, dynamic>?;

            return ListTile(
              leading: SizedBox(
                width: 50,
                child: Row(
                  children: [
                    Text(
                      '${entryIndex + 1}',
                      style: TextStyle(
                        fontWeight: FontWeight.bold,
                        color: _getRankColor(entryIndex),
                      ),
                    ),
                    if (entryIndex < 3)
                      Icon(
                        Icons.emoji_events,
                        color: _getRankColor(entryIndex),
                        size: 16,
                      ),
                  ],
                ),
              ),
              title: Row(
                children: [
                  AvatarUserWidget(
                    radius: 20,
                    imagePath: userData?['image'] ?? '',
                  ),
                  const SizedBox(width: 8),
                  Expanded(child: Text(userData?['name'] ?? 'Unknown')),
                ],
              ),
              trailing: Row(
                mainAxisSize: MainAxisSize.min,
                children: [
                  SizedBox(
                    width: 80,
                    child: Text(
                      '${entry['score']}',
                      style: const TextStyle(fontWeight: FontWeight.bold),
                    ),
                  ),
                  SizedBox(
                    width: 80,
                    child: Text('${entry['gamesPlayed'] ?? 0}'),
                  ),
                  IconButton(
                    icon: const Icon(Icons.more_vert),
                    onPressed: () {
                      // Show options menu
                      _showLeaderboardEntryOptions(entry, controller);
                    },
                  ),
                ],
              ),
            );
          },
        ),
      );
    });
  }

  Color _getRankColor(int rank) {
    switch (rank) {
      case 0:
        return Colors.amber; // Gold
      case 1:
        return Colors.grey.shade400; // Silver
      case 2:
        return Colors.brown.shade300; // Bronze
      default:
        return Colors.black; // Regular
    }
  }

  void _showLeaderboardEntryOptions(
      Map<String, dynamic> entry, AdminController controller) {
    Get.dialog(
      SimpleDialog(
        title: Text('Manage ${entry['user']?['name'] ?? 'Player'}'),
        children: [
          SimpleDialogOption(
            onPressed: () {
              Get.back();
              _showUserDetailsDialog(entry['user'], controller);
            },
            child: const Text('View Player Details'),
          ),
          SimpleDialogOption(
            onPressed: () {
              Get.back();
              _confirmResetScoreDialog(entry, controller);
            },
            child: const Text('Reset Score'),
          ),
          SimpleDialogOption(
            onPressed: () {
              Get.back();
              _confirmRemoveEntryDialog(entry, controller);
            },
            child: const Text('Remove from Leaderboard'),
          ),
        ],
      ),
    );
  }

  void _showUserDetailsDialog(
      Map<String, dynamic>? userData, AdminController controller) {
    if (userData == null) return;

    // Here you would fetch detailed user data
    // For now, show what we have
    Get.dialog(
      AlertDialog(
        title: Text(userData['name'] ?? 'Unknown Player'),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            AvatarUserWidget(
              radius: 40,
              imagePath: userData['image'] ?? '',
            ),
            const SizedBox(height: 16),
            Text('ID: ${userData['id'] ?? 'Unknown'}'),
            Text('Role: ${userData['role'] ?? 'user'}'),
            // Additional details would be fetched and shown here
          ],
        ),
        actions: [
          TextButton(
            onPressed: () => Get.back(),
            child: const Text('CLOSE'),
          ),
        ],
      ),
    );
  }

  void _confirmResetScoreDialog(
      Map<String, dynamic> entry, AdminController controller) {
    final gameId = controller.selectedGame.value;
    final entryId = entry['id'];
    final userName = entry['user']?['name'] ?? 'this player';

    Get.dialog(
      AlertDialog(
        title: const Text('Reset Score'),
        content:
            Text('Are you sure you want to reset the score for $userName?'),
        actions: [
          TextButton(
            onPressed: () => Get.back(),
            child: const Text('CANCEL'),
          ),
          ElevatedButton(
            style: ElevatedButton.styleFrom(
              backgroundColor: Colors.red,
            ),
            onPressed: () {
              // Implement reset score logic
              Get.back();

              // Mock implementation
              Get.snackbar(
                'Score Reset',
                'Score for $userName has been reset',
                snackPosition: SnackPosition.BOTTOM,
              );

              // Refresh leaderboard
              controller.fetchGameLeaderboard(gameId);
            },
            child: const Text('RESET'),
          ),
        ],
      ),
    );
  }

  void _confirmRemoveEntryDialog(
      Map<String, dynamic> entry, AdminController controller) {
    final gameId = controller.selectedGame.value;
    final entryId = entry['id'];
    final userName = entry['user']?['name'] ?? 'this player';

    Get.dialog(
      AlertDialog(
        title: const Text('Remove from Leaderboard'),
        content: Text(
            'Are you sure you want to remove $userName from the leaderboard?'),
        actions: [
          TextButton(
            onPressed: () => Get.back(),
            child: const Text('CANCEL'),
          ),
          ElevatedButton(
            style: ElevatedButton.styleFrom(
              backgroundColor: Colors.red,
            ),
            onPressed: () {
              // Implement remove entry logic
              Get.back();

              // Mock implementation
              Get.snackbar(
                'Entry Removed',
                '$userName has been removed from the leaderboard',
                snackPosition: SnackPosition.BOTTOM,
              );

              // Refresh leaderboard
              controller.fetchGameLeaderboard(gameId);
            },
            child: const Text('REMOVE'),
          ),
        ],
      ),
    );
  }

  Widget _buildGameStatsTab(AdminController controller) {
    // Mock data for game stats
    final stats = {
      'totalGamesPlayed': 12500,
      'activeUsers': 1850,
      'avgGameDuration': '4m 30s',
      'completionRate': 68.5,
    };

    // Mock data for daily game plays
    final dailyPlays = [
      {'day': 'Mon', 'plays': 1250},
      {'day': 'Tue', 'plays': 1450},
      {'day': 'Wed', 'plays': 1350},
      {'day': 'Thu', 'plays': 1650},
      {'day': 'Fri', 'plays': 1850},
      {'day': 'Sat', 'plays': 2250},
      {'day': 'Sun', 'plays': 1950},
    ];

    return Obx(() {
      final gameId = controller.selectedGame.value;

      return SingleChildScrollView(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              '${gameId.capitalize} Statistics',
              style: const TextStyle(
                fontSize: 20,
                fontWeight: FontWeight.bold,
              ),
            ),
            const SizedBox(height: 16),
            _buildStatsOverviewCard(stats),
            const SizedBox(height: 24),
            _buildDailyPlaysChart(dailyPlays),
            const SizedBox(height: 24),
            _buildDeviceStats(),
            const SizedBox(height: 24),
            _buildDifficultyStats(),
          ],
        ),
      );
    });
  }

  Widget _buildStatsOverviewCard(Map<String, dynamic> stats) {
    return Card(
      elevation: 2,
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            const Text(
              'Overview',
              style: TextStyle(
                fontSize: 18,
                fontWeight: FontWeight.bold,
              ),
            ),
            const SizedBox(height: 16),
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceAround,
              children: [
                _buildStatItem(
                  'Total Games',
                  stats['totalGamesPlayed'].toString(),
                  Icons.sports_esports,
                  Colors.blue,
                ),
                _buildStatItem(
                  'Active Users',
                  stats['activeUsers'].toString(),
                  Icons.people,
                  Colors.green,
                ),
              ],
            ),
            const SizedBox(height: 16),
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceAround,
              children: [
                _buildStatItem(
                  'Avg. Duration',
                  stats['avgGameDuration'],
                  Icons.timer,
                  Colors.orange,
                ),
                _buildStatItem(
                  'Completion Rate',
                  '${stats['completionRate']}%',
                  Icons.check_circle,
                  Colors.purple,
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildStatItem(
    String label,
    String value,
    IconData icon,
    Color color,
  ) {
    return Column(
      children: [
        Icon(icon, color: color, size: 32),
        const SizedBox(height: 8),
        Text(
          value,
          style: TextStyle(
            fontSize: 20,
            fontWeight: FontWeight.bold,
            color: color,
          ),
        ),
        Text(
          label,
          style: const TextStyle(color: Colors.grey),
        ),
      ],
    );
  }

  Widget _buildDailyPlaysChart(List<Map<String, dynamic>> dailyPlays) {
    return Card(
      elevation: 2,
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            const Text(
              'Daily Game Plays',
              style: TextStyle(
                fontSize: 18,
                fontWeight: FontWeight.bold,
              ),
            ),
            const SizedBox(height: 16),
            SizedBox(
              height: 250,
              child: Placeholder(
                color: Colors.deepPurpleAccent.withOpacity(0.5),
                child: const Center(
                  child: Text(
                    'Daily Plays Chart\n(Bar Chart from fl_chart would be here)',
                    textAlign: TextAlign.center,
                  ),
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildDeviceStats() {
    // Mock device stats
    final deviceStats = [
      {'device': 'Android', 'percentage': 65},
      {'device': 'iOS', 'percentage': 35},
    ];

    return Card(
      elevation: 2,
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            const Text(
              'Device Distribution',
              style: TextStyle(
                fontSize: 18,
                fontWeight: FontWeight.bold,
              ),
            ),
            const SizedBox(height: 16),
            Row(
              children: [
                Expanded(
                  flex: 2,
                  child: SizedBox(
                    height: 180,
                    child: Placeholder(
                      color: Colors.deepPurpleAccent.withOpacity(0.5),
                      child: const Center(
                        child: Text(
                          'Device Distribution Chart\n(Pie Chart would be here)',
                          textAlign: TextAlign.center,
                        ),
                      ),
                    ),
                  ),
                ),
                Expanded(
                  flex: 3,
                  child: Column(
                    children: deviceStats.map((stat) {
                      return Padding(
                        padding: const EdgeInsets.symmetric(vertical: 8.0),
                        child: Row(
                          children: [
                            Container(
                              width: 16,
                              height: 16,
                              color: stat['device'] == 'Android'
                                  ? Colors.green
                                  : Colors.blue,
                            ),
                            const SizedBox(width: 8),
                            Text(stat['device'] as String),
                            const Spacer(),
                            Text('${stat['percentage']}%'),
                          ],
                        ),
                      );
                    }).toList(),
                  ),
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildDifficultyStats() {
    // Mock difficulty stats
    final difficultyStats = [
      {'difficulty': 'Easy', 'percentage': 45},
      {'difficulty': 'Medium', 'percentage': 35},
      {'difficulty': 'Hard', 'percentage': 20},
    ];

    return Card(
      elevation: 2,
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            const Text(
              'Difficulty Distribution',
              style: TextStyle(
                fontSize: 18,
                fontWeight: FontWeight.bold,
              ),
            ),
            const SizedBox(height: 16),
            Column(
              children: difficultyStats.map((stat) {
                final difficulty = stat['difficulty'] as String;
                final percentage = stat['percentage'] as int;

                Color color;
                switch (difficulty) {
                  case 'Easy':
                    color = Colors.green;
                    break;
                  case 'Medium':
                    color = Colors.orange;
                    break;
                  case 'Hard':
                    color = Colors.red;
                    break;
                  default:
                    color = Colors.grey;
                }

                return Padding(
                  padding: const EdgeInsets.only(bottom: 16.0),
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Row(
                        children: [
                          Text(difficulty),
                          const Spacer(),
                          Text('$percentage%'),
                        ],
                      ),
                      const SizedBox(height: 4),
                      LinearProgressIndicator(
                        value: percentage / 100,
                        backgroundColor: Colors.grey[200],
                        valueColor: AlwaysStoppedAnimation<Color>(color),
                      ),
                    ],
                  ),
                );
              }).toList(),
            ),
          ],
        ),
      ),
    );
  }

  Map<String, dynamic> _getDefaultGameConfig(String gameId) {
    switch (gameId) {
      case 'tictactoe':
        return {
          'activeBoardSizes': ['3x3', '4x4', '5x5'],
          'winReward': 10,
          'drawReward': 5,
          'timeLimit': 30,
          'aiDifficulty': 'medium',
        };
      case 'sudoku':
        return {
          'activeDifficulties': ['easy', 'medium', 'hard'],
          'activeGridSizes': ['9x9'],
          'completionReward': 20,
          'enableHints': true,
          'hintsLimit': 3,
        };
      case 'minesweeper':
        return {
          'activeBoardSizes': ['8x8', '16x16'],
          'completionReward': 15,
          'minesPercentage': 15,
          'enableFirstClickSafety': true,
        };
      case 'match3':
        return {
          'boardSizes': ['8x8'],
          'maxMoves': 30,
          'targetScores': {
            'easy': 1000,
            'medium': 2000,
            'hard': 3000,
          },
          'rewardsPerStar': [5, 10, 15],
        };
      case '2048':
        return {
          'gridSizes': ['4x4'],
          'targetTiles': [2048],
          'rewardsPerTarget': {
            '1024': 10,
            '2048': 25,
            '4096': 50,
            '8192': 100,
          },
        };
      default:
        return {};
    }
  }

  void _saveGameConfig(AdminController controller) {
    final gameId = controller.selectedGame.value;
    final config = controller.gameConfig.value;

    controller.updateGameConfig(gameId, config).then((success) {
      if (success) {
        Get.snackbar(
          'Success',
          'Game configuration saved successfully',
          snackPosition: SnackPosition.BOTTOM,
          backgroundColor: Colors.green,
          colorText: Colors.white,
        );
      } else {
        Get.snackbar(
          'Error',
          'Failed to save game configuration',
          snackPosition: SnackPosition.BOTTOM,
          backgroundColor: Colors.red,
          colorText: Colors.white,
        );
      }
    });
  }
}

```

---


### Pages\Admin\Pages\tabs\user_management_tab.dart

```dart
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:flutter_svg/svg.dart';
import 'package:cached_network_image/cached_network_image.dart';
import 'package:tictactoe_gameapp/Components/belong_to_users/avatar_user_widget.dart';
import 'package:tictactoe_gameapp/Pages/Admin/controllers/admin_controller.dart';
import 'package:tictactoe_gameapp/Pages/Admin/models/user_model.dart';
import 'package:tictactoe_gameapp/Configs/assets_path.dart';
import 'package:tictactoe_gameapp/Configs/messages.dart';

class UserManagementTab extends StatefulWidget {
  const UserManagementTab({super.key});

  @override
  State<UserManagementTab> createState() => _UserManagementTabState();
}

class _UserManagementTabState extends State<UserManagementTab> {
  final RxString searchQuery = ''.obs;
  final expandedIndex = (-1).obs;
  final TextEditingController searchEditingController = TextEditingController();

  @override
  void dispose() {
    searchQuery.close();
    expandedIndex.close();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final controller = Get.find<AdminController>();

    return Column(
      children: [
        _buildSearchBar(controller),
        _buildBatchOperationsBar(controller),
        Expanded(
          child: _buildUserList(controller),
        ),
      ],
    );
  }

  Widget _buildSearchBar(AdminController controller) {
    return Padding(
      padding: const EdgeInsets.all(8.0),
      child: Row(
        children: [
          Expanded(
            child: TextField(
              controller: searchEditingController,
              decoration: InputDecoration(
                hintText: 'Search users...',
                prefixIcon: const Icon(Icons.search),
                suffixIcon: Obx(() => searchQuery.value.isNotEmpty
                    ? IconButton(
                        icon: const Icon(Icons.clear),
                        onPressed: () {
                          searchEditingController.clear();
                          FocusNode().unfocus();
                          searchQuery.value = '';
                          controller.userSearchQuery.value = '';
                        },
                      )
                    : const SizedBox()),
                border: OutlineInputBorder(
                  borderRadius: BorderRadius.circular(10),
                ),
                contentPadding: const EdgeInsets.symmetric(vertical: 0),
              ),
              onChanged: (value) {
                searchQuery.value = value.trim();
                controller.userSearchQuery.value = value.trim();
              },
            ),
          ),
          const SizedBox(width: 8),
          Obx(() => DropdownButton<String>(
                value: controller.selectedRoleFilter.value,
                items: const [
                  DropdownMenuItem(value: 'all', child: Text('All')),
                  DropdownMenuItem(value: 'admin', child: Text('Admin')),
                  DropdownMenuItem(
                      value: 'moderator', child: Text('Moderator')),
                  DropdownMenuItem(value: 'user', child: Text('User')),
                ],
                onChanged: (value) {
                  if (value != null) {
                    controller.selectedRoleFilter.value = value;
                  }
                },
              )),
        ],
      ),
    );
  }

  Widget _buildBatchOperationsBar(AdminController controller) {
    return Obx(() {
      if (controller.selectedUserIds.isEmpty) {
        return const SizedBox.shrink();
      }

      return Container(
        padding: const EdgeInsets.all(8.0),
        color: Colors.grey[200],
        child: Row(
          children: [
            Text(
              '${controller.selectedUserIds.length} users selected',
              style: const TextStyle(fontWeight: FontWeight.bold),
            ),
            const Spacer(),
            PopupMenuButton<String>(
              onSelected: (value) {
                if (value == 'clear') {
                  controller.clearUserSelection();
                } else {
                  _confirmBatchOperation(
                    controller,
                    value,
                    controller.selectedUserIds.length,
                  );
                }
              },
              itemBuilder: (context) => [
                const PopupMenuItem(
                  value: 'verify',
                  child: Text('Verify Selected'),
                ),
                const PopupMenuItem(
                  value: 'suspend',
                  child: Text('Suspend Selected'),
                ),
                const PopupMenuItem(
                  value: 'activate',
                  child: Text('Activate Selected'),
                ),
                const PopupMenuItem(
                  value: 'delete',
                  child: Text('Delete Selected'),
                ),
                const PopupMenuItem(
                  value: 'clear',
                  child: Text('Clear Selection'),
                ),
              ],
              child: Chip(
                label: const Text('Actions'),
                avatar: const Icon(Icons.more_vert),
                backgroundColor: Colors.deepPurpleAccent.withOpacity(0.2),
              ),
            ),
          ],
        ),
      );
    });
  }

  Widget _buildUserList(AdminController controller) {
    return Obx(() {
      if (controller.isLoadingUsers.value) {
        return Container(
          width: double.infinity,
          height: double.infinity,
          decoration: const BoxDecoration(
            image: DecorationImage(
              image: AssetImage(
                GifsPath.transitionGif,
              ),
              fit: BoxFit.cover,
            ),
          ),
        );
      }

      if (controller.users.isEmpty) {
        return const Center(
          child: Text('No users found'),
        );
      }

      // Lọc danh sách người dùng theo từ khóa tìm kiếm
      var filteredUsers = controller.users.where((user) {
        if (searchQuery.value.isEmpty) {
          return true;
        }

        final query = searchQuery.value.toLowerCase();
        final name = user.name?.toLowerCase() ?? '';
        final email = user.email?.toLowerCase() ?? '';
        final id = user.id?.toLowerCase() ?? '';

        return name.contains(query) ||
            email.contains(query) ||
            id.contains(query);
      }).toList();

      // Áp dụng bộ lọc theo vai trò nếu được chọn
      if (controller.selectedRoleFilter.value != 'all') {
        filteredUsers = filteredUsers
            .where((user) => user.role == controller.selectedRoleFilter.value)
            .toList();
      }

      if (filteredUsers.isEmpty) {
        return Center(
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              const Icon(Icons.search_off, size: 64, color: Colors.grey),
              const SizedBox(height: 16),
              Text(
                'No users found matching "${searchQuery.value}"',
                style: const TextStyle(fontSize: 18),
              ),
              const SizedBox(height: 8),
              ElevatedButton.icon(
                onPressed: () {
                  searchEditingController.clear();
                  FocusNode().unfocus();
                  searchQuery.value = '';
                  controller.userSearchQuery.value = '';
                },
                icon: const Icon(Icons.clear),
                label: const Text('Clear Search'),
              ),
            ],
          ),
        );
      }

      // Sắp xếp người dùng theo coins giảm dần
      filteredUsers.sort((a, b) {
        int totalCoinsA = int.tryParse(a.totalCoins ?? '0') ?? 0;
        int totalCoinsB = int.tryParse(b.totalCoins ?? '0') ?? 0;
        return totalCoinsB.compareTo(totalCoinsA);
      });

      return Scrollbar(
        child: ListView.builder(
          physics: const BouncingScrollPhysics(),
          itemCount: filteredUsers.length,
          itemBuilder: (context, index) {
            return _buildUserRankingItem(
                controller, filteredUsers[index], index);
          },
        ),
      );
    });
  }

  Widget _buildUserRankingItem(
      AdminController controller, UserModel user, int position) {
    final isSelected = controller.selectedUserIds.contains(user.id);

    return Obx(() => Column(
          children: [
            Container(
              margin:
                  const EdgeInsets.only(bottom: 10, left: 8, right: 8, top: 10),
              decoration: BoxDecoration(
                border: Border.all(color: Colors.white, width: 2),
                boxShadow: const [
                  BoxShadow(
                    blurRadius: 2.0,
                    spreadRadius: 2.0,
                    color: Colors.white,
                  ),
                ],
                borderRadius: BorderRadius.circular(8),
              ),
              child: ExpansionTile(
                onExpansionChanged: (bool expanded) {
                  if (expanded) {
                    expandedIndex.value = position;
                  } else if (expandedIndex.value == position) {
                    expandedIndex.value = -1;
                  }
                },
                iconColor: Colors.white,
                collapsedIconColor: Colors.pink,
                collapsedBackgroundColor: isSelected
                    ? Colors.purpleAccent.withOpacity(0.5)
                    : Colors.lightBlueAccent,
                backgroundColor: isSelected
                    ? Colors.purpleAccent.withOpacity(0.5)
                    : Colors.lightBlueAccent,
                shape: RoundedRectangleBorder(
                  borderRadius: BorderRadius.circular(8),
                ),
                collapsedShape: RoundedRectangleBorder(
                  borderRadius: BorderRadius.circular(8),
                ),
                leading: Badge(
                  label: Text("${position + 1}"),
                  textColor: position == 0
                      ? Colors.red
                      : position == 1
                          ? Colors.yellow
                          : position == 2
                              ? Colors.greenAccent
                              : Colors.white,
                  backgroundColor: Colors.black,
                  child: Column(
                    children: [
                      Image.asset(
                        position == 0
                            ? TrimRanking.challTrim
                            : position == 1
                                ? TrimRanking.masterTrim
                                : position == 2
                                    ? TrimRanking.diamondTrim
                                    : TrimRanking.goldTrim,
                        width: 45,
                      ),
                    ],
                  ),
                ),
                trailing: Column(
                  children: [
                    user.status == "online"
                        ? const Text(
                            "Online",
                            style: TextStyle(
                              color: Colors.lightGreenAccent,
                              fontSize: 15,
                            ),
                          )
                        : const Text(
                            "Offline",
                            style: TextStyle(
                              color: Colors.blueGrey,
                              fontSize: 15,
                            ),
                          ),
                    Icon(
                      expandedIndex.value == position
                          ? Icons.keyboard_arrow_up
                          : Icons.keyboard_arrow_down,
                    ),
                  ],
                ),
                title: Row(
                  children: [
                    GestureDetector(
                      onTap: () {
                        _showUserDetailsDialog(user);
                      },
                      onLongPress: () {
                        if (user.id != null) {
                          controller.toggleUserSelection(user.id!);
                        }
                      },
                      child: Stack(
                        children: [
                          user.image != null && user.image!.isNotEmpty
                              ? CircleAvatar(
                                  backgroundImage:
                                      CachedNetworkImageProvider(user.image!),
                                  radius: 25,
                                )
                              : const CircleAvatar(
                                  radius: 25,
                                  child: Icon(Icons.person_2_outlined),
                                ),
                          if (isSelected)
                            Positioned(
                              bottom: 0,
                              right: 0,
                              child: Container(
                                padding: const EdgeInsets.all(2),
                                decoration: const BoxDecoration(
                                  color: Colors.deepPurpleAccent,
                                  shape: BoxShape.circle,
                                ),
                                child: const Icon(
                                  Icons.check,
                                  size: 12,
                                  color: Colors.white,
                                ),
                              ),
                            ),
                        ],
                      ),
                    ),
                    const SizedBox(width: 10),
                    // Sử dụng Expanded cho phần thông tin user
                    Expanded(
                      child: Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          Text(
                            user.name ?? 'Unknown',
                            style: TextStyle(
                              fontWeight: FontWeight.bold,
                              color: user.suspended == true
                                  ? Colors.grey
                                  : Colors.deepPurple,
                              fontSize: 15,
                              decoration: user.suspended == true
                                  ? TextDecoration.lineThrough
                                  : null,
                            ),
                            overflow: TextOverflow.ellipsis,
                            maxLines: 1,
                          ),
                          Row(
                            children: [
                              Text(
                                user.totalCoins ?? "0",
                                style: const TextStyle(
                                  fontWeight: FontWeight.bold,
                                  color: Colors.yellowAccent,
                                  fontSize: 18,
                                ),
                              ),
                              const SizedBox(width: 5),
                              SvgPicture.asset(
                                IconsPath.coinIcon,
                                width: 20,
                                color: Colors.yellowAccent,
                              ),
                            ],
                          ),
                        ],
                      ),
                    ),
                    // Phần này sẽ luôn hiển thị
                    Row(
                      mainAxisSize: MainAxisSize.min,
                      children: [
                        Chip(
                          label: Text(user.role ?? 'user'),
                          backgroundColor: _getRoleColor(user.role),
                          labelStyle: const TextStyle(
                              fontSize: 10, color: Colors.white),
                          padding: EdgeInsets.zero,
                          materialTapTargetSize:
                              MaterialTapTargetSize.shrinkWrap,
                          visualDensity: VisualDensity.compact,
                        ),
                        const SizedBox(width: 4),
                        if (user.verified == true)
                          const Icon(Icons.verified,
                              size: 16, color: Colors.blue),
                        if (user.suspended == true)
                          const Icon(Icons.block, size: 16, color: Colors.red),
                      ],
                    ),
                  ],
                ),
                children: [
                  Padding(
                    padding: const EdgeInsets.symmetric(
                        horizontal: 16.0, vertical: 8.0),
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Text(
                          "Email: ${user.email ?? "${user.name}@gmail.com"}",
                          maxLines: 2,
                          style: const TextStyle(
                            fontSize: 12,
                            color: Colors.white,
                          ),
                        ),
                        if (user.bio != null && user.bio!.isNotEmpty)
                          Padding(
                            padding: const EdgeInsets.only(top: 8.0),
                            child: Text(
                              "Bio: ${user.bio}",
                              style: const TextStyle(
                                fontSize: 12,
                                color: Colors.white,
                              ),
                            ),
                          ),
                        const SizedBox(height: 12),
                        SingleChildScrollView(
                          scrollDirection: Axis.horizontal,
                          child: Row(
                            mainAxisAlignment: MainAxisAlignment.end,
                            children: [
                              OutlinedButton.icon(
                                icon: const Icon(Icons.edit),
                                label: const Text('Edit Role'),
                                onPressed: () {
                                  _showEditRoleDialog(user, controller);
                                },
                                style: OutlinedButton.styleFrom(
                                  foregroundColor: Colors.white,
                                  side: const BorderSide(color: Colors.white),
                                ),
                              ),
                              const SizedBox(width: 8),
                              OutlinedButton.icon(
                                icon: Icon(user.suspended == true
                                    ? Icons.check_circle
                                    : Icons.block),
                                label: Text(user.suspended == true
                                    ? 'Activate'
                                    : 'Suspend'),
                                onPressed: () {
                                  if (user.suspended == true) {
                                    _confirmActivateUser(user, controller);
                                  } else {
                                    _confirmSuspendUser(user, controller);
                                  }
                                },
                                style: OutlinedButton.styleFrom(
                                  foregroundColor: user.suspended == true
                                      ? Colors.green
                                      : Colors.red,
                                  side: BorderSide(
                                      color: user.suspended == true
                                          ? Colors.green
                                          : Colors.red),
                                ),
                              ),
                              const SizedBox(width: 8),
                              OutlinedButton.icon(
                                icon:
                                    const Icon(Icons.delete, color: Colors.red),
                                label: const Text('Delete'),
                                onPressed: () {
                                  _confirmDeleteUser(user, controller);
                                },
                                style: OutlinedButton.styleFrom(
                                  foregroundColor: Colors.red,
                                  side: const BorderSide(color: Colors.red),
                                ),
                              ),
                            ],
                          ),
                        ),
                      ],
                    ),
                  ),
                ],
              ),
            ),
          ],
        ));
  }

  Color _getRoleColor(String? role) {
    switch (role) {
      case 'admin':
        return Colors.red;
      case 'moderator':
        return Colors.green;
      case 'user':
      default:
        return Colors.blue;
    }
  }

  void _showUserDetailsDialog(UserModel user) {
    Get.dialog(
      Dialog(
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
        child: Container(
          padding: const EdgeInsets.all(16.0),
          decoration: BoxDecoration(
            color: Colors.white,
            borderRadius: BorderRadius.circular(16),
            boxShadow: [
              BoxShadow(
                color: Colors.grey.withOpacity(0.5),
                spreadRadius: 5,
                blurRadius: 7,
                offset: const Offset(0, 3),
              ),
            ],
          ),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Center(
                child: Stack(
                  alignment: Alignment.bottomRight,
                  children: [
                    AvatarUserWidget(
                      radius: 50,
                      imagePath: user.image ?? '',
                      gradientColors: user.avatarFrame,
                    ),
                    Container(
                      padding: const EdgeInsets.all(4),
                      decoration: BoxDecoration(
                        color: user.status == "online"
                            ? Colors.green
                            : Colors.grey,
                        shape: BoxShape.circle,
                        border: Border.all(color: Colors.white, width: 2),
                      ),
                      width: 20,
                      height: 20,
                    ),
                  ],
                ),
              ),
              const SizedBox(height: 16),
              Center(
                child: Text(
                  user.name ?? 'Unknown',
                  style: const TextStyle(
                    fontSize: 22,
                    fontWeight: FontWeight.bold,
                    color: Colors.deepPurple,
                  ),
                ),
              ),
              Center(
                child: Text(
                  user.email ?? '',
                  style: const TextStyle(
                    fontSize: 16,
                    color: Colors.grey,
                  ),
                ),
              ),
              const SizedBox(height: 8),
              Center(
                child: Row(
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    Chip(
                      label: Text(user.role ?? 'user'),
                      backgroundColor: _getRoleColor(user.role),
                      labelStyle: const TextStyle(color: Colors.white),
                    ),
                    const SizedBox(width: 8),
                    if (user.verified == true)
                      const Chip(
                        label: Text('Verified'),
                        avatar:
                            Icon(Icons.verified, color: Colors.blue, size: 18),
                        backgroundColor: Color(0xFFE3F2FD),
                      ),
                    if (user.suspended == true)
                      const Chip(
                        label: Text('Suspended'),
                        avatar: Icon(Icons.block, color: Colors.red, size: 18),
                        backgroundColor: Color(0xFFFFEBEE),
                      ),
                  ],
                ),
              ),
              const SizedBox(height: 16),
              const Divider(),
              const SizedBox(height: 8),
              Row(
                mainAxisAlignment: MainAxisAlignment.spaceAround,
                children: [
                  _userStatItem(
                      'Coins', user.totalCoins ?? '0', Icons.monetization_on),
                  _userStatItem(
                      'Wins', user.totalWins ?? '0', Icons.emoji_events),
                  _userStatItem('Friends', '${user.friendsList?.length ?? 0}',
                      Icons.people),
                ],
              ),
              const SizedBox(height: 16),
              if (user.bio != null && user.bio!.isNotEmpty) ...[
                const Text(
                  'Bio',
                  style: TextStyle(
                    fontWeight: FontWeight.bold,
                    fontSize: 16,
                  ),
                ),
                const SizedBox(height: 4),
                Text(user.bio!),
                const SizedBox(height: 16),
              ],
              const Divider(),
              const SizedBox(height: 8),
              _detailRow('User ID', user.id ?? ''),
              _detailRow('Status', user.status ?? 'Offline'),
              _detailRow(
                  'Joined',
                  user.createdAt?.toDate().toString().split(' ')[0] ??
                      'Unknown'),
              _detailRow('Last Active',
                  user.lastActive?.toDate().toString() ?? 'Unknown'),
              const SizedBox(height: 16),
              Align(
                alignment: Alignment.center,
                child: ElevatedButton(
                  onPressed: () => Get.back(),
                  style: ElevatedButton.styleFrom(
                    backgroundColor: Colors.deepPurpleAccent,
                    foregroundColor: Colors.white,
                    padding: const EdgeInsets.symmetric(
                        horizontal: 40, vertical: 12),
                    shape: RoundedRectangleBorder(
                      borderRadius: BorderRadius.circular(20),
                    ),
                  ),
                  child: const Text('CLOSE'),
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }

  Widget _userStatItem(String label, String value, IconData icon) {
    return Column(
      children: [
        Icon(icon, color: Colors.deepPurpleAccent, size: 28),
        const SizedBox(height: 4),
        Text(
          value,
          style: const TextStyle(
            fontWeight: FontWeight.bold,
            fontSize: 18,
          ),
        ),
        Text(
          label,
          style: const TextStyle(
            color: Colors.grey,
            fontSize: 14,
          ),
        ),
      ],
    );
  }

  Widget _detailRow(String label, String value) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 4.0),
      child: Row(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          SizedBox(
            width: 100,
            child: Text(
              label,
              style: const TextStyle(
                fontWeight: FontWeight.bold,
              ),
            ),
          ),
          Expanded(
            child: Text(value),
          ),
        ],
      ),
    );
  }

  void _showEditRoleDialog(UserModel user, AdminController controller) {
    final currentRole = user.role ?? 'user';
    var selectedRole = currentRole;

    Get.dialog(
      Dialog(
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
        child: Padding(
          padding: const EdgeInsets.all(16.0),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Row(
                children: [
                  AvatarUserWidget(
                    radius: 25,
                    imagePath: user.image ?? '',
                  ),
                  const SizedBox(width: 16),
                  Expanded(
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        const Text(
                          'Edit User Role',
                          style: TextStyle(
                            fontSize: 18,
                            fontWeight: FontWeight.bold,
                          ),
                        ),
                        Text('User: ${user.name ?? "Unknown"}'),
                        Text('Current Role: $currentRole',
                            style:
                                TextStyle(color: _getRoleColor(currentRole))),
                      ],
                    ),
                  ),
                ],
              ),
              const SizedBox(height: 16),
              const Divider(),
              const SizedBox(height: 8),
              StatefulBuilder(
                builder: (context, setState) {
                  return Column(
                    children: [
                      RadioListTile<String>(
                        title: const Text('User'),
                        value: 'user',
                        groupValue: selectedRole,
                        onChanged: (value) {
                          setState(() {
                            selectedRole = value!;
                          });
                        },
                        activeColor: Colors.blue,
                      ),
                      RadioListTile<String>(
                        title: const Text('Moderator'),
                        value: 'moderator',
                        groupValue: selectedRole,
                        onChanged: (value) {
                          setState(() {
                            selectedRole = value!;
                          });
                        },
                        activeColor: Colors.green,
                      ),
                      RadioListTile<String>(
                        title: const Text('Admin'),
                        value: 'admin',
                        groupValue: selectedRole,
                        onChanged: (value) {
                          setState(() {
                            selectedRole = value!;
                          });
                        },
                        activeColor: Colors.red,
                      ),
                    ],
                  );
                },
              ),
              const SizedBox(height: 16),
              Row(
                mainAxisAlignment: MainAxisAlignment.end,
                children: [
                  TextButton(
                    onPressed: () => Get.back(),
                    child: const Text('CANCEL'),
                  ),
                  const SizedBox(width: 8),
                  ElevatedButton(
                    onPressed: () {
                      if (selectedRole != currentRole && user.id != null) {
                        controller
                            .updateUserRole(user.id!, selectedRole)
                            .then((success) {
                          if (success) {
                            Get.back();
                            successMessage('User role updated successfully!');
                          }
                        });
                      } else {
                        Get.back();
                      }
                    },
                    style: ElevatedButton.styleFrom(
                      backgroundColor: Colors.deepPurpleAccent,
                    ),
                    child: const Text('SAVE'),
                  ),
                ],
              ),
            ],
          ),
        ),
      ),
    );
  }

  void _confirmSuspendUser(UserModel user, AdminController controller) {
    if (user.id == null) return;

    Get.dialog(
      AlertDialog(
        title: const Text('Suspend User'),
        content: Text(
            'Are you sure you want to suspend ${user.name}? This will prevent them from accessing the app.'),
        actions: [
          TextButton(
            onPressed: () => Get.back(),
            child: const Text('CANCEL'),
          ),
          ElevatedButton(
            style: ElevatedButton.styleFrom(
              backgroundColor: Colors.red,
            ),
            onPressed: () {
              // Add the user ID to selected list
              controller.selectedUserIds.clear();
              controller.selectedUserIds.add(user.id!);

              controller.performBatchOperation('suspend').then((success) {
                if (success) {
                  Get.back();
                  successMessage('User suspended successfully!');
                }
              });
            },
            child: const Text('SUSPEND'),
          ),
        ],
      ),
    );
  }

  void _confirmActivateUser(UserModel user, AdminController controller) {
    if (user.id == null) return;

    Get.dialog(
      AlertDialog(
        title: const Text('Activate User'),
        content: Text(
            'Are you sure you want to activate ${user.name}? This will restore their access to the app.'),
        actions: [
          TextButton(
            onPressed: () => Get.back(),
            child: const Text('CANCEL'),
          ),
          ElevatedButton(
            style: ElevatedButton.styleFrom(
              backgroundColor: Colors.green,
            ),
            onPressed: () {
              // Add the user ID to selected list
              controller.selectedUserIds.clear();
              controller.selectedUserIds.add(user.id!);

              controller.performBatchOperation('activate').then((success) {
                if (success) {
                  Get.back();
                  successMessage('User activated successfully!');
                }
              });
            },
            child: const Text('ACTIVATE'),
          ),
        ],
      ),
    );
  }

  void _confirmDeleteUser(UserModel user, AdminController controller) {
    if (user.id == null) return;

    Get.dialog(
      AlertDialog(
        title: const Text('Delete User'),
        content: Text(
            'Are you sure you want to permanently delete ${user.name}? This action cannot be undone.'),
        actions: [
          TextButton(
            onPressed: () => Get.back(),
            child: const Text('CANCEL'),
          ),
          ElevatedButton(
            style: ElevatedButton.styleFrom(
              backgroundColor: Colors.red,
            ),
            onPressed: () {
              // Add the user ID to selected list
              controller.selectedUserIds.clear();
              controller.selectedUserIds.add(user.id!);

              controller.performBatchOperation('delete').then((success) {
                if (success) {
                  Get.back();
                  successMessage('User deleted successfully!');
                }
              });
            },
            child: const Text('DELETE'),
          ),
        ],
      ),
    );
  }

  void _confirmBatchOperation(
      AdminController controller, String operation, int count) {
    String title;
    String content;
    String action;
    Color actionColor = Colors.blue;

    switch (operation) {
      case 'verify':
        title = 'Verify Users';
        content = 'Are you sure you want to verify $count users?';
        action = 'VERIFY';
        break;
      case 'suspend':
        title = 'Suspend Users';
        content =
            'Are you sure you want to suspend $count users? This will prevent them from accessing the app.';
        action = 'SUSPEND';
        actionColor = Colors.red;
        break;
      case 'activate':
        title = 'Activate Users';
        content =
            'Are you sure you want to activate $count users? This will restore their access to the app.';
        action = 'ACTIVATE';
        break;
      case 'delete':
        title = 'Delete Users';
        content =
            'Are you sure you want to permanently delete $count users? This action cannot be undone.';
        action = 'DELETE';
        actionColor = Colors.red;
        break;
      default:
        return;
    }

    Get.dialog(
      AlertDialog(
        title: Text(title),
        content: Text(content),
        actions: [
          TextButton(
            onPressed: () => Get.back(),
            child: const Text('CANCEL'),
          ),
          ElevatedButton(
            style: ElevatedButton.styleFrom(
              backgroundColor: actionColor,
            ),
            onPressed: () {
              controller.performBatchOperation(operation).then((success) {
                if (success) {
                  Get.back();
                  successMessage('Operation completed successfully!');
                }
              });
            },
            child: Text(action),
          ),
        ],
      ),
    );
  }
}

```

---


### Pages\Admin\Pages\tabs\user_support_system_tab.dart

```dart
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:intl/intl.dart';
import 'package:tictactoe_gameapp/Pages/Admin/controllers/support_system_controller.dart';
import 'package:tictactoe_gameapp/Components/belong_to_users/avatar_user_widget.dart';
import 'package:tictactoe_gameapp/Configs/messages.dart';

class SupportSystemPage extends StatelessWidget {
  const SupportSystemPage({super.key});

  @override
  Widget build(BuildContext context) {
    final controller = Get.put(SupportSystemController());

    return Scaffold(
      appBar: AppBar(
        title: const Text('User Support System'),
        backgroundColor: Colors.deepPurpleAccent,
        actions: [
          IconButton(
            icon: const Icon(Icons.refresh),
            tooltip: 'Refresh',
            onPressed: () => controller.refreshData(),
          ),
          IconButton(
            icon: const Icon(Icons.analytics),
            tooltip: 'Support Analytics',
            onPressed: () => _showSupportAnalytics(controller),
          ),
          IconButton(
            icon: const Icon(Icons.settings),
            tooltip: 'Settings',
            onPressed: () => _showSupportSettings(controller),
          ),
        ],
      ),
      body: Row(
        children: [
          // Left sidebar - Ticket list
          Container(
            width: 320,
            decoration: BoxDecoration(
              color: Colors.white,
              boxShadow: [
                BoxShadow(
                  color: Colors.grey.withOpacity(0.2),
                  spreadRadius: 1,
                  blurRadius: 5,
                  offset: const Offset(1, 0),
                ),
              ],
            ),
            child: Column(
              children: [
                _buildSearchAndFilter(controller),
                Expanded(
                  child: _buildTicketList(controller),
                ),
              ],
            ),
          ),

          // Main content area
          Expanded(
            child: Obx(() {
              if (controller.selectedTicketId.isEmpty) {
                return _buildNoTicketSelectedView();
              } else {
                return _buildTicketDetailView(controller);
              }
            }),
          ),
        ],
      ),
      floatingActionButton: FloatingActionButton(
        onPressed: () => _showCreateKnowledgeBaseArticleDialog(controller),
        backgroundColor: Colors.deepPurpleAccent,
        child: const Icon(Icons.add),
        tooltip: 'Add Knowledge Base Article',
      ),
    );
  }

  Widget _buildSearchAndFilter(SupportSystemController controller) {
    return Container(
      padding: const EdgeInsets.all(16),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          TextField(
            controller: controller.searchController,
            decoration: InputDecoration(
              hintText: 'Search tickets...',
              prefixIcon: const Icon(Icons.search),
              suffixIcon: Obx(() => controller.searchQuery.value.isNotEmpty
                  ? IconButton(
                      icon: const Icon(Icons.clear),
                      onPressed: () {
                        controller.searchController.clear();
                        controller.searchQuery.value = '';
                      },
                    )
                  : const SizedBox()),
              border: OutlineInputBorder(
                borderRadius: BorderRadius.circular(8),
              ),
              contentPadding: EdgeInsets.zero,
            ),
            onChanged: (value) {
              controller.searchQuery.value = value.trim();
            },
          ),
          const SizedBox(height: 16),
          Row(
            children: [
              _buildFilterChip(
                label: 'All',
                selected: controller.selectedStatusFilter.value == 'all',
                onSelected: (selected) {
                  if (selected) controller.selectedStatusFilter.value = 'all';
                },
              ),
              const SizedBox(width: 8),
              _buildFilterChip(
                label: 'Open',
                selected: controller.selectedStatusFilter.value == 'open',
                onSelected: (selected) {
                  if (selected) controller.selectedStatusFilter.value = 'open';
                },
              ),
              const SizedBox(width: 8),
              _buildFilterChip(
                label: 'Resolved',
                selected: controller.selectedStatusFilter.value == 'resolved',
                onSelected: (selected) {
                  if (selected) {
                    controller.selectedStatusFilter.value = 'resolved';
                  }
                },
              ),
            ],
          ),
          const SizedBox(height: 8),
          Row(
            children: [
              _buildFilterChip(
                label: 'High',
                selected: controller.selectedPriorityFilter.value == 'high',
                onSelected: (selected) {
                  if (selected) {
                    controller.selectedPriorityFilter.value = 'high';
                  }
                },
                color: Colors.red,
              ),
              const SizedBox(width: 8),
              _buildFilterChip(
                label: 'Medium',
                selected: controller.selectedPriorityFilter.value == 'medium',
                onSelected: (selected) {
                  if (selected) {
                    controller.selectedPriorityFilter.value = 'medium';
                  }
                },
                color: Colors.orange,
              ),
              const SizedBox(width: 8),
              _buildFilterChip(
                label: 'Low',
                selected: controller.selectedPriorityFilter.value == 'low',
                onSelected: (selected) {
                  if (selected) controller.selectedPriorityFilter.value = 'low';
                },
                color: Colors.blue,
              ),
            ],
          ),
          const SizedBox(height: 8),
          Row(
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            children: [
              const Text(
                'Sort by:',
                style: TextStyle(fontWeight: FontWeight.bold),
              ),
              DropdownButton<String>(
                value: controller.sortCriteria.value,
                underline: const SizedBox.shrink(),
                items: const [
                  DropdownMenuItem(value: 'date', child: Text('Date')),
                  DropdownMenuItem(value: 'priority', child: Text('Priority')),
                  DropdownMenuItem(value: 'status', child: Text('Status')),
                ],
                onChanged: (value) {
                  if (value != null) {
                    controller.sortCriteria.value = value;
                  }
                },
              ),
            ],
          ),
        ],
      ),
    );
  }

  Widget _buildTicketList(SupportSystemController controller) {
    return Obx(() {
      if (controller.isLoading.value) {
        return const Center(child: CircularProgressIndicator());
      }

      final filteredTickets = controller.getFilteredTickets();

      if (filteredTickets.isEmpty) {
        return Center(
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              Icon(Icons.search_off, size: 64, color: Colors.grey[300]),
              const SizedBox(height: 16),
              Text(
                controller.searchQuery.value.isNotEmpty
                    ? 'No tickets match your search'
                    : 'No tickets found for the selected filters',
                style: TextStyle(color: Colors.grey[600]),
                textAlign: TextAlign.center,
              ),
              const SizedBox(height: 16),
              TextButton.icon(
                onPressed: () => controller.resetFilters(),
                icon: const Icon(Icons.refresh),
                label: const Text('Reset Filters'),
              ),
            ],
          ),
        );
      }

      return ListView.separated(
        itemCount: filteredTickets.length,
        separatorBuilder: (context, index) => const Divider(height: 1),
        itemBuilder: (context, index) {
          final ticket = filteredTickets[index];
          return _buildTicketListItem(ticket, controller);
        },
      );
    });
  }

  Widget _buildTicketListItem(
      Map<String, dynamic> ticket, SupportSystemController controller) {
    final ticketId = ticket['id'] as String;
    final subject = ticket['subject'] as String;
    final userId = ticket['userId'] as String;
    final userName = ticket['userName'] as String;
    final userImage = ticket['userImage'] as String?;
    final status = ticket['status'] as String;
    final priority = ticket['priority'] as String;
    final category = ticket['category'] as String;
    final createdAt = ticket['createdAt'] as DateTime;
    final lastUpdated = ticket['lastUpdated'] as DateTime;
    final hasNewMessage = ticket['hasNewMessage'] as bool? ?? false;

    final isSelected = controller.selectedTicketId.value == ticketId;

    Color priorityColor;
    switch (priority) {
      case 'high':
        priorityColor = Colors.red;
        break;
      case 'medium':
        priorityColor = Colors.orange;
        break;
      default:
        priorityColor = Colors.blue;
    }

    Color statusColor;
    switch (status) {
      case 'open':
        statusColor = Colors.green;
        break;
      case 'pending':
        statusColor = Colors.orange;
        break;
      case 'resolved':
        statusColor = Colors.grey;
        break;
      default:
        statusColor = Colors.grey;
    }

    return InkWell(
      onTap: () => controller.selectTicket(ticketId),
      child: Container(
        padding: const EdgeInsets.symmetric(vertical: 8, horizontal: 16),
        color: isSelected ? Colors.deepPurpleAccent.withOpacity(0.1) : null,
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              children: [
                if (hasNewMessage)
                  Container(
                    width: 8,
                    height: 8,
                    margin: const EdgeInsets.only(right: 8),
                    decoration: const BoxDecoration(
                      color: Colors.deepPurpleAccent,
                      shape: BoxShape.circle,
                    ),
                  ),
                Container(
                  padding:
                      const EdgeInsets.symmetric(horizontal: 8, vertical: 2),
                  decoration: BoxDecoration(
                    color: priorityColor.withOpacity(0.1),
                    borderRadius: BorderRadius.circular(12),
                  ),
                  child: Text(
                    priority.capitalize!,
                    style: TextStyle(
                      color: priorityColor,
                      fontSize: 10,
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                ),
                const SizedBox(width: 8),
                Container(
                  padding:
                      const EdgeInsets.symmetric(horizontal: 8, vertical: 2),
                  decoration: BoxDecoration(
                    color: statusColor.withOpacity(0.1),
                    borderRadius: BorderRadius.circular(12),
                  ),
                  child: Text(
                    status.capitalize!,
                    style: TextStyle(
                      color: statusColor,
                      fontSize: 10,
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                ),
                const Spacer(),
                Text(
                  _timeAgo(lastUpdated),
                  style: TextStyle(
                    fontSize: 10,
                    color: Colors.grey[600],
                  ),
                ),
              ],
            ),
            const SizedBox(height: 8),
            Text(
              subject,
              style: const TextStyle(
                fontWeight: FontWeight.bold,
              ),
              maxLines: 2,
              overflow: TextOverflow.ellipsis,
            ),
            const SizedBox(height: 4),
            Text(
              'Category: $category',
              style: TextStyle(
                fontSize: 12,
                color: Colors.grey[700],
              ),
            ),
            const SizedBox(height: 8),
            Row(
              children: [
                SizedBox(
                  width: 20,
                  height: 20,
                  child: AvatarUserWidget(
                    radius: 10,
                    imagePath: userImage ?? '',
                  ),
                ),
                const SizedBox(width: 8),
                Text(
                  userName,
                  style: TextStyle(
                    fontSize: 12,
                    color: Colors.grey[700],
                  ),
                ),
                const Spacer(),
                Text(
                  '#${ticketId.substring(0, 8)}',
                  style: TextStyle(
                    fontSize: 12,
                    color: Colors.grey[700],
                    fontFamily: 'monospace',
                  ),
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildNoTicketSelectedView() {
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(Icons.support_agent, size: 100, color: Colors.grey[300]),
          const SizedBox(height: 16),
          Text(
            'Select a ticket to view details',
            style: TextStyle(
              fontSize: 20,
              color: Colors.grey[600],
            ),
          ),
          const SizedBox(height: 8),
          Text(
            'Or search for a specific ticket using the sidebar filters',
            style: TextStyle(color: Colors.grey[500]),
          ),
        ],
      ),
    );
  }

  Widget _buildTicketDetailView(SupportSystemController controller) {
    final ticket = controller.getSelectedTicket();

    if (ticket == null) {
      return const Center(child: CircularProgressIndicator());
    }

    final ticketId = ticket['id'] as String;
    final subject = ticket['subject'] as String;
    final description = ticket['description'] as String;
    final userId = ticket['userId'] as String;
    final userName = ticket['userName'] as String;
    final userEmail = ticket['userEmail'] as String;
    final userImage = ticket['userImage'] as String?;
    final status = ticket['status'] as String;
    final priority = ticket['priority'] as String;
    final category = ticket['category'] as String;
    final assignedTo = ticket['assignedTo'] as String?;
    final createdAt = ticket['createdAt'] as DateTime;
    final messages = ticket['messages'] as List<dynamic>? ?? [];

    return Container(
      padding: const EdgeInsets.all(24),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      'Ticket #${ticketId.substring(0, 8)}',
                      style: TextStyle(
                        fontSize: 12,
                        color: Colors.grey[600],
                        fontFamily: 'monospace',
                      ),
                    ),
                    const SizedBox(height: 4),
                    Text(
                      subject,
                      style: const TextStyle(
                        fontSize: 24,
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                    const SizedBox(height: 8),
                    Row(
                      children: [
                        _buildTicketPropertyPill(
                          label: status.capitalize!,
                          color: _getStatusColor(status),
                        ),
                        const SizedBox(width: 8),
                        _buildTicketPropertyPill(
                          label: priority.capitalize!,
                          color: _getPriorityColor(priority),
                        ),
                        const SizedBox(width: 8),
                        _buildTicketPropertyPill(
                          label: category,
                          color: Colors.deepPurpleAccent,
                        ),
                      ],
                    ),
                  ],
                ),
              ),
              _buildTicketActions(ticket, controller),
            ],
          ),
          const SizedBox(height: 16),
          const Divider(),
          const SizedBox(height: 16),
          Row(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              // Left side - User info and ticket details
              Expanded(
                flex: 3,
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    _buildUserCard(
                      userName: userName,
                      userEmail: userEmail,
                      userImage: userImage,
                      userId: userId,
                    ),
                    const SizedBox(height: 16),
                    _buildTicketInfoCard(
                      createdAt: createdAt,
                      assignedTo: assignedTo,
                      controller: controller,
                      ticket: ticket,
                    ),
                    const SizedBox(height: 16),
                    _buildRelatedArticlesCard(controller, category),
                  ],
                ),
              ),
              const SizedBox(width: 24),
              // Right side - Conversation thread
              Expanded(
                flex: 5,
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    const Text(
                      'Conversation',
                      style: TextStyle(
                        fontSize: 18,
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                    const SizedBox(height: 16),
                    // First message (description)
                    _buildMessageBubble(
                      sender: userName,
                      senderImage: userImage,
                      message: description,
                      timestamp: createdAt,
                      isUser: true,
                    ),
                    const SizedBox(height: 16),
                    // Other messages
                    Expanded(
                      child: messages.isEmpty
                          ? Center(
                              child: Text(
                                'No replies yet',
                                style: TextStyle(color: Colors.grey[600]),
                              ),
                            )
                          : ListView.builder(
                              itemCount: messages.length,
                              itemBuilder: (context, index) {
                                final message =
                                    messages[index] as Map<String, dynamic>;
                                final sender = message['sender'] as String;
                                final senderImage =
                                    message['senderImage'] as String?;
                                final content = message['content'] as String;
                                final timestamp =
                                    message['timestamp'] as DateTime;
                                final isUserMessage =
                                    message['isUser'] as bool? ?? false;

                                return Padding(
                                  padding: const EdgeInsets.only(bottom: 16),
                                  child: _buildMessageBubble(
                                    sender: sender,
                                    senderImage: senderImage,
                                    message: content,
                                    timestamp: timestamp,
                                    isUser: isUserMessage,
                                  ),
                                );
                              },
                            ),
                    ),
                    const SizedBox(height: 16),
                    // Reply form
                    if (status != 'resolved')
                      _buildReplyForm(controller, ticketId),
                  ],
                ),
              ),
            ],
          ),
        ],
      ),
    );
  }

  Widget _buildTicketPropertyPill(
      {required String label, required Color color}) {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 4),
      decoration: BoxDecoration(
        color: color.withOpacity(0.1),
        borderRadius: BorderRadius.circular(16),
        border: Border.all(color: color.withOpacity(0.3)),
      ),
      child: Text(
        label,
        style: TextStyle(
          color: color,
          fontWeight: FontWeight.bold,
          fontSize: 12,
        ),
      ),
    );
  }

  Widget _buildTicketActions(
      Map<String, dynamic> ticket, SupportSystemController controller) {
    final status = ticket['status'] as String;
    final ticketId = ticket['id'] as String;

    return Row(
      children: [
        if (status == 'open' || status == 'pending')
          OutlinedButton.icon(
            onPressed: () => _showResolveTicketDialog(ticket, controller),
            icon: const Icon(Icons.check_circle),
            label: const Text('Resolve'),
            style: OutlinedButton.styleFrom(
              foregroundColor: Colors.green,
            ),
          ),
        const SizedBox(width: 8),
        OutlinedButton.icon(
          onPressed: () => _showAssignTicketDialog(ticket, controller),
          icon: const Icon(Icons.person_add),
          label: const Text('Assign'),
        ),
        const SizedBox(width: 8),
        PopupMenuButton(
          icon: const Icon(Icons.more_vert),
          itemBuilder: (context) => [
            const PopupMenuItem(
              value: 'changePriority',
              child: ListTile(
                leading: Icon(Icons.flag),
                title: Text('Change Priority'),
              ),
            ),
            const PopupMenuItem(
              value: 'changeCategory',
              child: ListTile(
                leading: Icon(Icons.category),
                title: Text('Change Category'),
              ),
            ),
            const PopupMenuItem(
              value: 'addNote',
              child: ListTile(
                leading: Icon(Icons.note_add),
                title: Text('Add Internal Note'),
              ),
            ),
            if (status == 'resolved')
              const PopupMenuItem(
                value: 'reopen',
                child: ListTile(
                  leading: Icon(Icons.refresh),
                  title: Text('Reopen Ticket'),
                ),
              ),
            const PopupMenuItem(
              value: 'merge',
              child: ListTile(
                leading: Icon(Icons.merge_type),
                title: Text('Merge with Another Ticket'),
              ),
            ),
            const PopupMenuItem(
              value: 'export',
              child: ListTile(
                leading: Icon(Icons.download),
                title: Text('Export Ticket'),
              ),
            ),
          ],
          onSelected: (value) {
            switch (value) {
              case 'changePriority':
                _showChangePriorityDialog(ticket, controller);
                break;
              case 'changeCategory':
                _showChangeCategoryDialog(ticket, controller);
                break;
              case 'addNote':
                _showAddNoteDialog(ticket, controller);
                break;
              case 'reopen':
                _showReopenTicketDialog(ticket, controller);
                break;
              case 'merge':
                _showMergeTicketDialog(ticket, controller);
                break;
              case 'export':
                _exportTicket(ticket);
                break;
            }
          },
        ),
      ],
    );
  }

  Widget _buildUserCard({
    required String userName,
    required String userEmail,
    required String? userImage,
    required String userId,
  }) {
    return Container(
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(8),
        boxShadow: [
          BoxShadow(
            color: Colors.grey.withOpacity(0.1),
            blurRadius: 10,
            spreadRadius: 1,
          ),
        ],
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          const Text(
            'User Information',
            style: TextStyle(
              fontWeight: FontWeight.bold,
              fontSize: 16,
            ),
          ),
          const SizedBox(height: 16),
          Row(
            children: [
              AvatarUserWidget(
                radius: 25,
                imagePath: userImage ?? '',
              ),
              const SizedBox(width: 16),
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      userName,
                      style: const TextStyle(
                        fontWeight: FontWeight.bold,
                        fontSize: 16,
                      ),
                    ),
                    Text(
                      userEmail,
                      style: TextStyle(
                        color: Colors.grey[700],
                        fontSize: 14,
                      ),
                    ),
                    Text(
                      'User ID: ${userId.substring(0, 8)}...',
                      style: TextStyle(
                        color: Colors.grey[700],
                        fontSize: 12,
                      ),
                    ),
                  ],
                ),
              ),
            ],
          ),
          const SizedBox(height: 16),
          Row(
            mainAxisAlignment: MainAxisAlignment.end,
            children: [
              OutlinedButton.icon(
                onPressed: () => Get.toNamed('/admin/users/$userId'),
                icon: const Icon(Icons.person),
                label: const Text('View Profile'),
              ),
              const SizedBox(width: 8),
              OutlinedButton.icon(
                onPressed: () {
                  // Show user's previous tickets
                },
                icon: const Icon(Icons.history),
                label: const Text('View History'),
              ),
            ],
          ),
        ],
      ),
    );
  }

  Widget _buildTicketInfoCard({
    required DateTime createdAt,
    required String? assignedTo,
    required SupportSystemController controller,
    required Map<String, dynamic> ticket,
  }) {
    return Container(
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(8),
        boxShadow: [
          BoxShadow(
            color: Colors.grey.withOpacity(0.1),
            blurRadius: 10,
            spreadRadius: 1,
          ),
        ],
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          const Text(
            'Ticket Details',
            style: TextStyle(
              fontWeight: FontWeight.bold,
              fontSize: 16,
            ),
          ),
          const SizedBox(height: 16),
          _buildInfoRow(
            label: 'Created',
            value: DateFormat('MMM dd, yyyy - HH:mm').format(createdAt),
          ),
          const SizedBox(height: 8),
          _buildInfoRow(
            label: 'Assigned To',
            value: assignedTo ?? 'Unassigned',
            valueColor:
                assignedTo != null ? Colors.deepPurpleAccent : Colors.grey,
          ),
          const SizedBox(height: 8),
          _buildInfoRow(
            label: 'Device',
            value: ticket['deviceInfo'] as String? ?? 'Unknown',
          ),
          const SizedBox(height: 8),
          _buildInfoRow(
            label: 'App Version',
            value: ticket['appVersion'] as String? ?? 'Unknown',
          ),
          const SizedBox(height: 8),
          _buildInfoRow(
            label: 'Platform',
            value: ticket['platform'] as String? ?? 'Unknown',
          ),
          const SizedBox(height: 16),
          // Tags
          const Text(
            'Tags',
            style: TextStyle(
              fontWeight: FontWeight.bold,
            ),
          ),
          const SizedBox(height: 8),
          Wrap(
            spacing: 8,
            runSpacing: 8,
            children: [
              ...(ticket['tags'] as List<dynamic>? ?? [])
                  .map((tag) => _buildTagChip(
                        tag: tag as String,
                        onDeleted: () {
                          // Remove tag
                          controller.removeTagFromTicket(
                              ticket['id'] as String, tag);
                        },
                      )),
              ActionChip(
                label: const Text('Add Tag'),
                avatar: const Icon(Icons.add, size: 16),
                onPressed: () => _showAddTagDialog(ticket, controller),
              ),
            ],
          ),
        ],
      ),
    );
  }

  Widget _buildRelatedArticlesCard(
      SupportSystemController controller, String category) {
    final articles = controller.getRelatedArticles(category);

    return Container(
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(8),
        boxShadow: [
          BoxShadow(
            color: Colors.grey.withOpacity(0.1),
            blurRadius: 10,
            spreadRadius: 1,
          ),
        ],
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            children: [
              const Text(
                'Knowledge Base',
                style: TextStyle(
                  fontWeight: FontWeight.bold,
                  fontSize: 16,
                ),
              ),
              TextButton(
                onPressed: () => _showKnowledgeBaseDialog(controller),
                child: const Text('View All'),
              ),
            ],
          ),
          const SizedBox(height: 16),
          const Text(
            'Related Articles',
            style: TextStyle(
              fontWeight: FontWeight.bold,
            ),
          ),
          const SizedBox(height: 8),
          articles.isEmpty
              ? Text(
                  'No related articles found',
                  style: TextStyle(color: Colors.grey[600]),
                )
              : ListView.builder(
                  shrinkWrap: true,
                  physics: const NeverScrollableScrollPhysics(),
                  itemCount: articles.length > 3 ? 3 : articles.length,
                  itemBuilder: (context, index) {
                    final article = articles[index];
                    return ListTile(
                      contentPadding: EdgeInsets.zero,
                      leading: const Icon(Icons.article),
                      title: Text(article['title'] as String),
                    );
                  },
                ),
          const SizedBox(height: 16),
          const Text(
            'Suggested Responses',
            style: TextStyle(
              fontWeight: FontWeight.bold,
            ),
          ),
          const SizedBox(height: 8),
          ListView.builder(
            shrinkWrap: true,
            physics: const NeverScrollableScrollPhysics(),
            itemCount: 2,
            itemBuilder: (context, index) {
              return ListTile(
                contentPadding: EdgeInsets.zero,
                leading: const Icon(Icons.quickreply),
                title: Text(
                  index == 0
                      ? 'Thank you for reporting this issue. We\'re looking into it.'
                      : 'This is a known issue and our team is working on a fix.',
                  maxLines: 2,
                  overflow: TextOverflow.ellipsis,
                ),
                trailing: OutlinedButton(
                  onPressed: () {
                    // Insert the template into the reply field
                    controller.replyController.text = index == 0
                        ? 'Thank you for reporting this issue. We\'re looking into it and will get back to you as soon as possible. In the meantime, please let us know if you have any other questions.'
                        : 'Thank you for bringing this to our attention. This is a known issue and our development team is actively working on a fix. We expect to release an update within the next few days that should resolve this problem. We appreciate your patience.';
                  },
                  child: const Text('Use'),
                ),
              );
            },
          ),
        ],
      ),
    );
  }

  Widget _buildMessageBubble({
    required String sender,
    required String? senderImage,
    required String message,
    required DateTime timestamp,
    required bool isUser,
  }) {
    return Row(
      crossAxisAlignment: CrossAxisAlignment.start,
      mainAxisAlignment:
          isUser ? MainAxisAlignment.end : MainAxisAlignment.start,
      children: [
        if (!isUser) ...[
          AvatarUserWidget(
            radius: 16,
            imagePath: senderImage ?? '',
          ),
          const SizedBox(width: 8),
        ],
        Flexible(
          child: Column(
            crossAxisAlignment:
                isUser ? CrossAxisAlignment.end : CrossAxisAlignment.start,
            children: [
              Container(
                padding: const EdgeInsets.all(12),
                decoration: BoxDecoration(
                  color: isUser
                      ? Colors.grey[100]
                      : Colors.deepPurpleAccent.withOpacity(0.1),
                  borderRadius: BorderRadius.circular(12),
                  border: Border.all(
                    color: isUser
                        ? Colors.grey[300]!
                        : Colors.deepPurpleAccent.withOpacity(0.3),
                  ),
                ),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      sender,
                      style: TextStyle(
                        fontWeight: FontWeight.bold,
                        color: isUser ? Colors.black : Colors.deepPurpleAccent,
                      ),
                    ),
                    const SizedBox(height: 4),
                    Text(message),
                  ],
                ),
              ),
              const SizedBox(height: 4),
              Text(
                DateFormat('MMM dd, yyyy - HH:mm').format(timestamp),
                style: TextStyle(
                  fontSize: 10,
                  color: Colors.grey[600],
                ),
              ),
            ],
          ),
        ),
        if (isUser) ...[
          const SizedBox(width: 8),
          AvatarUserWidget(
            radius: 16,
            imagePath: senderImage ?? '',
          ),
        ],
      ],
    );
  }

  Widget _buildReplyForm(SupportSystemController controller, String ticketId) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        const Text(
          'Reply',
          style: TextStyle(
            fontWeight: FontWeight.bold,
          ),
        ),
        const SizedBox(height: 8),
        TextField(
          controller: controller.replyController,
          decoration: const InputDecoration(
            hintText: 'Type your response here...',
            border: OutlineInputBorder(),
          ),
          maxLines: 5,
        ),
        const SizedBox(height: 8),
        Row(
          mainAxisAlignment: MainAxisAlignment.end,
          children: [
            OutlinedButton.icon(
              onPressed: () {
                // Show template responses dialog
                _showTemplateResponsesDialog(controller);
              },
              icon: const Icon(Icons.format_quote),
              label: const Text('Templates'),
            ),
            const SizedBox(width: 8),
            OutlinedButton.icon(
              onPressed: () {
                // Show attachment dialog
                _showAttachmentDialog(controller);
              },
              icon: const Icon(Icons.attach_file),
              label: const Text('Add Attachment'),
            ),
            const SizedBox(width: 8),
            ElevatedButton.icon(
              onPressed: () {
                if (controller.replyController.text.isEmpty) {
                  errorMessage('Please enter a response');
                  return;
                }

                controller
                    .sendReply(ticketId, controller.replyController.text)
                    .then((success) {
                  if (success) {
                    controller.replyController.clear();
                    successMessage('Reply sent successfully');
                  }
                });
              },
              icon: const Icon(Icons.send),
              label: const Text('Send Reply'),
              style: ElevatedButton.styleFrom(
                backgroundColor: Colors.deepPurpleAccent,
              ),
            ),
          ],
        ),
      ],
    );
  }

  Widget _buildFilterChip({
    required String label,
    required bool selected,
    required ValueChanged<bool> onSelected,
    Color? color,
  }) {
    return FilterChip(
      label: Text(label),
      selected: selected,
      onSelected: onSelected,
      selectedColor: (color ?? Colors.deepPurpleAccent).withOpacity(0.2),
      checkmarkColor: color ?? Colors.deepPurpleAccent,
      labelStyle: TextStyle(
        color: selected ? (color ?? Colors.deepPurpleAccent) : Colors.black,
        fontWeight: selected ? FontWeight.bold : FontWeight.normal,
      ),
    );
  }

  Widget _buildInfoRow({
    required String label,
    required String value,
    Color? valueColor,
  }) {
    return Row(
      mainAxisAlignment: MainAxisAlignment.spaceBetween,
      children: [
        Text(
          label,
          style: TextStyle(
            color: Colors.grey[700],
          ),
        ),
        Text(
          value,
          style: TextStyle(
            fontWeight: FontWeight.bold,
            color: valueColor,
          ),
        ),
      ],
    );
  }

  Widget _buildTagChip({
    required String tag,
    required VoidCallback onDeleted,
  }) {
    return Chip(
      label: Text(tag),
      deleteIcon: const Icon(Icons.cancel, size: 16),
      onDeleted: onDeleted,
      materialTapTargetSize: MaterialTapTargetSize.shrinkWrap,
      visualDensity: VisualDensity.compact,
    );
  }

  Color _getStatusColor(String status) {
    switch (status) {
      case 'open':
        return Colors.green;
      case 'pending':
        return Colors.orange;
      case 'resolved':
        return Colors.grey;
      default:
        return Colors.grey;
    }
  }

  Color _getPriorityColor(String priority) {
    switch (priority) {
      case 'high':
        return Colors.red;
      case 'medium':
        return Colors.orange;
      case 'low':
        return Colors.blue;
      default:
        return Colors.grey;
    }
  }

  String _timeAgo(DateTime dateTime) {
    final now = DateTime.now();
    final difference = now.difference(dateTime);

    if (difference.inDays > 365) {
      return '${(difference.inDays / 365).floor()} years ago';
    } else if (difference.inDays > 30) {
      return '${(difference.inDays / 30).floor()} months ago';
    } else if (difference.inDays > 7) {
      return '${(difference.inDays / 7).floor()} weeks ago';
    } else if (difference.inDays > 0) {
      return '${difference.inDays} days ago';
    } else if (difference.inHours > 0) {
      return '${difference.inHours} hours ago';
    } else if (difference.inMinutes > 0) {
      return '${difference.inMinutes} minutes ago';
    } else {
      return 'Just now';
    }
  }

  void _showResolveTicketDialog(
      Map<String, dynamic> ticket, SupportSystemController controller) {
    final resolutionController = TextEditingController();
    final ticketId = ticket['id'] as String;

    Get.dialog(
      Dialog(
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
        child: Container(
          padding: const EdgeInsets.all(16),
          constraints: const BoxConstraints(maxWidth: 500),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              const Text(
                'Resolve Ticket',
                style: TextStyle(
                  fontSize: 18,
                  fontWeight: FontWeight.bold,
                ),
              ),
              const SizedBox(height: 16),
              const Text(
                'Please provide a summary of the resolution for this ticket.',
              ),
              const SizedBox(height: 16),
              TextField(
                controller: resolutionController,
                decoration: const InputDecoration(
                  labelText: 'Resolution',
                  border: OutlineInputBorder(),
                  hintText: 'Explain how the issue was resolved...',
                ),
                maxLines: 3,
              ),
              const SizedBox(height: 16),
              CheckboxListTile(
                title: const Text('Send resolution email to user'),
                value: true,
                onChanged: (_) {},
                contentPadding: EdgeInsets.zero,
              ),
              const SizedBox(height: 16),
              Row(
                mainAxisAlignment: MainAxisAlignment.end,
                children: [
                  TextButton(
                    onPressed: () => Get.back(),
                    child: const Text('CANCEL'),
                  ),
                  const SizedBox(width: 8),
                  ElevatedButton(
                    onPressed: () {
                      if (resolutionController.text.isEmpty) {
                        errorMessage('Please enter a resolution summary');
                        return;
                      }

                      controller
                          .resolveTicket(
                        ticketId,
                        resolutionController.text,
                      )
                          .then((success) {
                        if (success) {
                          Get.back();
                          successMessage('Ticket resolved successfully');
                        }
                      });
                    },
                    style: ElevatedButton.styleFrom(
                      backgroundColor: Colors.green,
                    ),
                    child: const Text('RESOLVE'),
                  ),
                ],
              ),
            ],
          ),
        ),
      ),
    );
  }

  void _showAssignTicketDialog(
      Map<String, dynamic> ticket, SupportSystemController controller) {
    final ticketId = ticket['id'] as String;
    final RxString selectedAgentId = ''.obs;

    // Mock agent data
    final List<Map<String, dynamic>> agents = [
      {
        'id': 'agent1',
        'name': 'John Smith',
        'role': 'Support Agent',
        'image': '',
        'activeTickets': 5
      },
      {
        'id': 'agent2',
        'name': 'Jane Doe',
        'role': 'Senior Support',
        'image': '',
        'activeTickets': 3
      },
      {
        'id': 'agent3',
        'name': 'Mike Johnson',
        'role': 'Support Agent',
        'image': '',
        'activeTickets': 7
      },
      {
        'id': 'agent4',
        'name': 'Sarah Wilson',
        'role': 'Technical Support',
        'image': '',
        'activeTickets': 2
      },
    ];

    Get.dialog(
      Dialog(
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
        child: Container(
          padding: const EdgeInsets.all(16),
          constraints: const BoxConstraints(maxWidth: 500, maxHeight: 600),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              const Text(
                'Assign Ticket',
                style: TextStyle(
                  fontSize: 18,
                  fontWeight: FontWeight.bold,
                ),
              ),
              const SizedBox(height: 16),
              const Text(
                'Select an agent to assign this ticket to:',
              ),
              const SizedBox(height: 16),
              Expanded(
                child: ListView.builder(
                  itemCount: agents.length,
                  itemBuilder: (context, index) {
                    final agent = agents[index];
                    final agentId = agent['id'] as String;

                    return Obx(() => RadioListTile<String>(
                          title: Text(agent['name'] as String),
                          subtitle: Row(
                            children: [
                              Text(agent['role'] as String),
                              const SizedBox(width: 8),
                              Container(
                                padding: const EdgeInsets.symmetric(
                                    horizontal: 8, vertical: 2),
                                decoration: BoxDecoration(
                                  color: Colors.blue.withOpacity(0.1),
                                  borderRadius: BorderRadius.circular(12),
                                ),
                                child: Text(
                                  '${agent['activeTickets']} active tickets',
                                  style: const TextStyle(
                                    color: Colors.blue,
                                    fontSize: 10,
                                    fontWeight: FontWeight.bold,
                                  ),
                                ),
                              ),
                            ],
                          ),
                          value: agentId,
                          groupValue: selectedAgentId.value,
                          onChanged: (value) {
                            selectedAgentId.value = value!;
                          },
                        ));
                  },
                ),
              ),
              const SizedBox(height: 16),
              Row(
                mainAxisAlignment: MainAxisAlignment.spaceBetween,
                children: [
                  OutlinedButton(
                    onPressed: () {
                      // Unassign ticket logic
                      controller.unassignTicket(ticketId).then((success) {
                        if (success) {
                          Get.back();
                          successMessage('Ticket unassigned successfully');
                        }
                      });
                    },
                    child: const Text('Unassign'),
                  ),
                  Row(
                    children: [
                      TextButton(
                        onPressed: () => Get.back(),
                        child: const Text('CANCEL'),
                      ),
                      const SizedBox(width: 8),
                      Obx(() => ElevatedButton(
                            onPressed: selectedAgentId.value.isEmpty
                                ? null
                                : () {
                                    controller
                                        .assignTicket(
                                      ticketId,
                                      selectedAgentId.value,
                                      agents.firstWhere((agent) =>
                                              agent['id'] ==
                                              selectedAgentId.value)['name']
                                          as String,
                                    )
                                        .then((success) {
                                      if (success) {
                                        Get.back();
                                        successMessage(
                                            'Ticket assigned successfully');
                                      }
                                    });
                                  },
                            style: ElevatedButton.styleFrom(
                              backgroundColor: Colors.deepPurpleAccent,
                            ),
                            child: const Text('ASSIGN'),
                          )),
                    ],
                  ),
                ],
              ),
            ],
          ),
        ),
      ),
    );
  }

  void _showChangePriorityDialog(
      Map<String, dynamic> ticket, SupportSystemController controller) {
    final ticketId = ticket['id'] as String;
    final currentPriority = ticket['priority'] as String;
    RxString selectedPriority = currentPriority.obs;

    Get.dialog(
      Dialog(
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
        child: Container(
          padding: const EdgeInsets.all(16),
          constraints: const BoxConstraints(maxWidth: 400),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              const Text(
                'Change Priority',
                style: TextStyle(
                  fontSize: 18,
                  fontWeight: FontWeight.bold,
                ),
              ),
              const SizedBox(height: 16),
              const Text(
                'Select the new priority level for this ticket:',
              ),
              const SizedBox(height: 16),
              Obx(() => Column(
                    children: [
                      _buildPriorityOption(
                        label: 'High',
                        description: 'Critical issue affecting many users',
                        value: 'high',
                        groupValue: selectedPriority.value,
                        color: Colors.red,
                        onChanged: (value) {
                          selectedPriority.value = value!;
                        },
                      ),
                      const SizedBox(height: 8),
                      _buildPriorityOption(
                        label: 'Medium',
                        description: 'Important issue with limited impact',
                        value: 'medium',
                        groupValue: selectedPriority.value,
                        color: Colors.orange,
                        onChanged: (value) {
                          selectedPriority.value = value!;
                        },
                      ),
                      const SizedBox(height: 8),
                      _buildPriorityOption(
                        label: 'Low',
                        description: 'Minor issue or question',
                        value: 'low',
                        groupValue: selectedPriority.value,
                        color: Colors.blue,
                        onChanged: (value) {
                          selectedPriority.value = value!;
                        },
                      ),
                    ],
                  )),
              const SizedBox(height: 16),
              Row(
                mainAxisAlignment: MainAxisAlignment.end,
                children: [
                  TextButton(
                    onPressed: () => Get.back(),
                    child: const Text('CANCEL'),
                  ),
                  const SizedBox(width: 8),
                  Obx(() => ElevatedButton(
                        onPressed: selectedPriority.value == currentPriority
                            ? null
                            : () {
                                controller
                                    .changeTicketPriority(
                                  ticketId,
                                  selectedPriority.value,
                                )
                                    .then((success) {
                                  if (success) {
                                    Get.back();
                                    successMessage(
                                        'Priority changed successfully');
                                  }
                                });
                              },
                        style: ElevatedButton.styleFrom(
                          backgroundColor: Colors.deepPurpleAccent,
                        ),
                        child: const Text('SAVE'),
                      )),
                ],
              ),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildPriorityOption({
    required String label,
    required String description,
    required String value,
    required String groupValue,
    required Color color,
    required ValueChanged<String?> onChanged,
  }) {
    return InkWell(
      onTap: () => onChanged(value),
      borderRadius: BorderRadius.circular(8),
      child: Container(
        padding: const EdgeInsets.all(12),
        decoration: BoxDecoration(
          color:
              value == groupValue ? color.withOpacity(0.1) : Colors.transparent,
          border: Border.all(
            color: value == groupValue ? color : Colors.grey.withOpacity(0.3),
            width: value == groupValue ? 2 : 1,
          ),
          borderRadius: BorderRadius.circular(8),
        ),
        child: Row(
          children: [
            Radio<String>(
              value: value,
              groupValue: groupValue,
              onChanged: onChanged,
              activeColor: color,
            ),
            const SizedBox(width: 8),
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    label,
                    style: TextStyle(
                      fontWeight: FontWeight.bold,
                      color: value == groupValue ? color : Colors.black,
                    ),
                  ),
                  Text(
                    description,
                    style: TextStyle(
                      fontSize: 12,
                      color: Colors.grey[700],
                    ),
                  ),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }

  void _showChangeCategoryDialog(
      Map<String, dynamic> ticket, SupportSystemController controller) {
    final ticketId = ticket['id'] as String;
    final currentCategory = ticket['category'] as String;
    RxString selectedCategory = currentCategory.obs;

    // Mock categories
    const List<String> categories = [
      'Account',
      'Billing',
      'Game Play',
      'Technical',
      'Feature Request',
      'Bug Report',
      'Other',
    ];

    Get.dialog(
      Dialog(
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
        child: Container(
          padding: const EdgeInsets.all(16),
          constraints: const BoxConstraints(maxWidth: 400),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              const Text(
                'Change Category',
                style: TextStyle(
                  fontSize: 18,
                  fontWeight: FontWeight.bold,
                ),
              ),
              const SizedBox(height: 16),
              const Text(
                'Select the new category for this ticket:',
              ),
              const SizedBox(height: 16),
              Obx(() => Container(
                    decoration: BoxDecoration(
                      border: Border.all(color: Colors.grey.withOpacity(0.3)),
                      borderRadius: BorderRadius.circular(8),
                    ),
                    child: DropdownButtonHideUnderline(
                      child: DropdownButton<String>(
                        value: selectedCategory.value,
                        isExpanded: true,
                        icon: const Icon(Icons.arrow_drop_down),
                        iconSize: 24,
                        elevation: 16,
                        padding: const EdgeInsets.symmetric(horizontal: 16),
                        items: categories.map((String category) {
                          return DropdownMenuItem<String>(
                            value: category,
                            child: Text(category),
                          );
                        }).toList(),
                        onChanged: (value) {
                          if (value != null) {
                            selectedCategory.value = value;
                          }
                        },
                      ),
                    ),
                  )),
              const SizedBox(height: 16),
              Row(
                mainAxisAlignment: MainAxisAlignment.end,
                children: [
                  TextButton(
                    onPressed: () => Get.back(),
                    child: const Text('CANCEL'),
                  ),
                  const SizedBox(width: 8),
                  Obx(() => ElevatedButton(
                        onPressed: selectedCategory.value == currentCategory
                            ? null
                            : () {
                                controller
                                    .changeTicketCategory(
                                  ticketId,
                                  selectedCategory.value,
                                )
                                    .then((success) {
                                  if (success) {
                                    Get.back();
                                    successMessage(
                                        'Category changed successfully');
                                  }
                                });
                              },
                        style: ElevatedButton.styleFrom(
                          backgroundColor: Colors.deepPurpleAccent,
                        ),
                        child: const Text('SAVE'),
                      )),
                ],
              ),
            ],
          ),
        ),
      ),
    );
  }

  void _showAddTagDialog(
      Map<String, dynamic> ticket, SupportSystemController controller) {
    final tagController = TextEditingController();
    final ticketId = ticket['id'] as String;
    final currentTags = ticket['tags'] as List<dynamic>? ?? [];

    // Mock suggested tags
    final List<String> suggestedTags = [
      'login-issue',
      'payment-error',
      'game-crash',
      'feature-request',
      'account-recovery',
      'performance',
      'ui-bug',
    ];

    Get.dialog(
      Dialog(
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
        child: Container(
          padding: const EdgeInsets.all(16),
          constraints: const BoxConstraints(maxWidth: 400),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              const Text(
                'Add Tag',
                style: TextStyle(
                  fontSize: 18,
                  fontWeight: FontWeight.bold,
                ),
              ),
              const SizedBox(height: 16),
              TextField(
                controller: tagController,
                decoration: const InputDecoration(
                  labelText: 'Tag',
                  border: OutlineInputBorder(),
                  hintText: 'Enter a new tag...',
                ),
              ),
              const SizedBox(height: 16),
              const Text(
                'Suggested Tags:',
                style: TextStyle(
                  fontWeight: FontWeight.bold,
                ),
              ),
              const SizedBox(height: 8),
              Wrap(
                spacing: 8,
                runSpacing: 8,
                children: suggestedTags
                    .where((tag) => !currentTags.contains(tag))
                    .map((tag) => ActionChip(
                          label: Text(tag),
                          onPressed: () {
                            tagController.text = tag;
                          },
                        ))
                    .toList(),
              ),
              const SizedBox(height: 16),
              Row(
                mainAxisAlignment: MainAxisAlignment.end,
                children: [
                  TextButton(
                    onPressed: () => Get.back(),
                    child: const Text('CANCEL'),
                  ),
                  const SizedBox(width: 8),
                  ElevatedButton(
                    onPressed: () {
                      if (tagController.text.isEmpty) {
                        errorMessage('Please enter a tag');
                        return;
                      }

                      if (currentTags.contains(tagController.text)) {
                        errorMessage('This tag already exists');
                        return;
                      }

                      controller
                          .addTagToTicket(
                        ticketId,
                        tagController.text,
                      )
                          .then((success) {
                        if (success) {
                          Get.back();
                          successMessage('Tag added successfully');
                        }
                      });
                    },
                    style: ElevatedButton.styleFrom(
                      backgroundColor: Colors.deepPurpleAccent,
                    ),
                    child: const Text('ADD'),
                  ),
                ],
              ),
            ],
          ),
        ),
      ),
    );
  }

  void _showAddNoteDialog(
      Map<String, dynamic> ticket, SupportSystemController controller) {
    final noteController = TextEditingController();
    final ticketId = ticket['id'] as String;

    Get.dialog(
      Dialog(
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
        child: Container(
          padding: const EdgeInsets.all(16),
          constraints: const BoxConstraints(maxWidth: 500),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              const Text(
                'Add Internal Note',
                style: TextStyle(
                  fontSize: 18,
                  fontWeight: FontWeight.bold,
                ),
              ),
              const SizedBox(height: 16),
              const Text(
                'This note will only be visible to support staff.',
              ),
              const SizedBox(height: 16),
              TextField(
                controller: noteController,
                decoration: const InputDecoration(
                  labelText: 'Note',
                  border: OutlineInputBorder(),
                  hintText: 'Enter your internal note here...',
                ),
                maxLines: 5,
              ),
              const SizedBox(height: 16),
              Row(
                mainAxisAlignment: MainAxisAlignment.end,
                children: [
                  TextButton(
                    onPressed: () => Get.back(),
                    child: const Text('CANCEL'),
                  ),
                  const SizedBox(width: 8),
                  ElevatedButton(
                    onPressed: () {
                      if (noteController.text.isEmpty) {
                        errorMessage('Please enter a note');
                        return;
                      }

                      controller
                          .addInternalNote(
                        ticketId,
                        noteController.text,
                      )
                          .then((success) {
                        if (success) {
                          Get.back();
                          successMessage('Note added successfully');
                        }
                      });
                    },
                    style: ElevatedButton.styleFrom(
                      backgroundColor: Colors.deepPurpleAccent,
                    ),
                    child: const Text('ADD NOTE'),
                  ),
                ],
              ),
            ],
          ),
        ),
      ),
    );
  }

  void _showReopenTicketDialog(
      Map<String, dynamic> ticket, SupportSystemController controller) {
    final reasonController = TextEditingController();
    final ticketId = ticket['id'] as String;

    Get.dialog(
      Dialog(
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
        child: Container(
          padding: const EdgeInsets.all(16),
          constraints: const BoxConstraints(maxWidth: 500),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              const Text(
                'Reopen Ticket',
                style: TextStyle(
                  fontSize: 18,
                  fontWeight: FontWeight.bold,
                ),
              ),
              const SizedBox(height: 16),
              const Text(
                'Please provide a reason for reopening this ticket.',
              ),
              const SizedBox(height: 16),
              TextField(
                controller: reasonController,
                decoration: const InputDecoration(
                  labelText: 'Reason',
                  border: OutlineInputBorder(),
                  hintText: 'Explain why this ticket needs to be reopened...',
                ),
                maxLines: 3,
              ),
              const SizedBox(height: 16),
              Row(
                mainAxisAlignment: MainAxisAlignment.end,
                children: [
                  TextButton(
                    onPressed: () => Get.back(),
                    child: const Text('CANCEL'),
                  ),
                  const SizedBox(width: 8),
                  ElevatedButton(
                    onPressed: () {
                      if (reasonController.text.isEmpty) {
                        errorMessage('Please enter a reason');
                        return;
                      }
                      controller
                          .reopenTicket(
                        ticketId,
                        reasonController.text,
                      )
                          .then((success) {
                        if (success) {
                          Get.back();
                          successMessage('Ticket reopened successfully');
                        }
                      });
                    },
                    style: ElevatedButton.styleFrom(
                      backgroundColor: Colors.deepPurpleAccent,
                    ),
                    child: const Text('REOPEN'),
                  ),
                ],
              ),
            ],
          ),
        ),
      ),
    );
  }

  void _showMergeTicketDialog(
      Map<String, dynamic> ticket, SupportSystemController controller) {
    final ticketId = ticket['id'] as String;
    final RxString selectedTicketId = ''.obs;

    // Get other open tickets
    final otherTickets = controller
        .getAllTickets()
        .where((t) => t['id'] != ticketId && t['status'] == 'open')
        .toList();

    if (otherTickets.isEmpty) {
      errorMessage('No other open tickets available to merge with');
      return;
    }

    Get.dialog(
      Dialog(
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
        child: Container(
          padding: const EdgeInsets.all(16),
          constraints: const BoxConstraints(maxWidth: 500, maxHeight: 600),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              const Text(
                'Merge Ticket',
                style: TextStyle(
                  fontSize: 18,
                  fontWeight: FontWeight.bold,
                ),
              ),
              const SizedBox(height: 16),
              const Text(
                'Select another ticket to merge this one with:',
              ),
              const SizedBox(height: 16),
              Expanded(
                child: ListView.builder(
                  itemCount: otherTickets.length,
                  itemBuilder: (context, index) {
                    final otherTicket = otherTickets[index];
                    final otherTicketId = otherTicket['id'] as String;

                    return Obx(() => RadioListTile<String>(
                          title: Text(otherTicket['subject'] as String),
                          subtitle: Text('From: ${otherTicket['userName']}'),
                          value: otherTicketId,
                          groupValue: selectedTicketId.value,
                          onChanged: (value) {
                            selectedTicketId.value = value!;
                          },
                        ));
                  },
                ),
              ),
              const SizedBox(height: 16),
              Row(
                mainAxisAlignment: MainAxisAlignment.end,
                children: [
                  TextButton(
                    onPressed: () => Get.back(),
                    child: const Text('CANCEL'),
                  ),
                  const SizedBox(width: 8),
                  Obx(() => ElevatedButton(
                        onPressed: selectedTicketId.value.isEmpty
                            ? null
                            : () {
                                controller
                                    .mergeTickets(
                                  ticketId,
                                  selectedTicketId.value,
                                )
                                    .then((success) {
                                  if (success) {
                                    Get.back();
                                    successMessage(
                                        'Tickets merged successfully');
                                  }
                                });
                              },
                        style: ElevatedButton.styleFrom(
                          backgroundColor: Colors.deepPurpleAccent,
                        ),
                        child: const Text('MERGE'),
                      )),
                ],
              ),
            ],
          ),
        ),
      ),
    );
  }

  void _exportTicket(Map<String, dynamic> ticket) {
    // This would be implemented to export ticket data to a file
    successMessage('Ticket exported successfully');
  }

  void _showTemplateResponsesDialog(SupportSystemController controller) {
    // Mock template responses
    final List<Map<String, String>> templates = [
      {
        'title': 'Thank you',
        'content':
            'Thank you for contacting us. We appreciate your patience while we work on resolving your issue.',
      },
      {
        'title': 'Additional information needed',
        'content':
            'To better assist you with this issue, could you please provide more information about the problem you\'re experiencing?',
      },
      {
        'title': 'Issue resolved',
        'content':
            'We\'re pleased to inform you that the issue you reported has been resolved. Please let us know if you encounter any further problems.',
      },
      {
        'title': 'Known issue',
        'content':
            'Thank you for your report. This is a known issue that our team is currently working on. We expect to have a fix available in our next update.',
      },
      {
        'title': 'User error',
        'content':
            'Based on our investigation, it appears this issue may be related to how the feature is being used. Here are the correct steps to follow:',
      },
    ];

    Get.dialog(
      Dialog(
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
        child: Container(
          padding: const EdgeInsets.all(16),
          constraints: const BoxConstraints(maxWidth: 600, maxHeight: 600),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              const Text(
                'Template Responses',
                style: TextStyle(
                  fontSize: 18,
                  fontWeight: FontWeight.bold,
                ),
              ),
              const SizedBox(height: 16),
              Expanded(
                child: ListView.separated(
                  itemCount: templates.length,
                  separatorBuilder: (context, index) => const Divider(),
                  itemBuilder: (context, index) {
                    final template = templates[index];
                    return ListTile(
                      title: Text(template['title']!),
                      trailing: TextButton(
                        onPressed: () {
                          controller.replyController.text =
                              template['content']!;
                          Get.back();
                        },
                        child: const Text('Use'),
                      ),
                    );
                  },
                ),
              ),
              const SizedBox(height: 16),
              Row(
                mainAxisAlignment: MainAxisAlignment.spaceBetween,
                children: [
                  TextButton.icon(
                    onPressed: () {
                      // Show create template dialog
                      Get.back();
                      _showCreateTemplateDialog(controller);
                    },
                    icon: const Icon(Icons.add),
                    label: const Text('Create New Template'),
                  ),
                  TextButton(
                    onPressed: () => Get.back(),
                    child: const Text('CLOSE'),
                  ),
                ],
              ),
            ],
          ),
        ),
      ),
    );
  }

  void _showCreateTemplateDialog(SupportSystemController controller) {
    final titleController = TextEditingController();
    final contentController = TextEditingController();

    Get.dialog(
      Dialog(
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
        child: Container(
          padding: const EdgeInsets.all(16),
          constraints: const BoxConstraints(maxWidth: 500),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              const Text(
                'Create Response Template',
                style: TextStyle(
                  fontSize: 18,
                  fontWeight: FontWeight.bold,
                ),
              ),
              const SizedBox(height: 16),
              TextField(
                controller: titleController,
                decoration: const InputDecoration(
                  labelText: 'Template Title',
                  border: OutlineInputBorder(),
                  hintText: 'Enter a descriptive title...',
                ),
              ),
              const SizedBox(height: 16),
              TextField(
                controller: contentController,
                decoration: const InputDecoration(
                  labelText: 'Response Content',
                  border: OutlineInputBorder(),
                  hintText: 'Enter the template content...',
                ),
                maxLines: 5,
              ),
              const SizedBox(height: 16),
              Row(
                mainAxisAlignment: MainAxisAlignment.end,
                children: [
                  TextButton(
                    onPressed: () => Get.back(),
                    child: const Text('CANCEL'),
                  ),
                  const SizedBox(width: 8),
                  ElevatedButton(
                    onPressed: () {
                      if (titleController.text.isEmpty ||
                          contentController.text.isEmpty) {
                        errorMessage('Please fill in all fields');
                        return;
                      }

                      // This would save the template in a real app
                      Get.back();
                      successMessage('Template saved successfully');
                    },
                    style: ElevatedButton.styleFrom(
                      backgroundColor: Colors.deepPurpleAccent,
                    ),
                    child: const Text('SAVE'),
                  ),
                ],
              ),
            ],
          ),
        ),
      ),
    );
  }

  void _showAttachmentDialog(SupportSystemController controller) {
    Get.dialog(
      Dialog(
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
        child: Container(
          padding: const EdgeInsets.all(16),
          constraints: const BoxConstraints(maxWidth: 400),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              const Text(
                'Add Attachment',
                style: TextStyle(
                  fontSize: 18,
                  fontWeight: FontWeight.bold,
                ),
              ),
              const SizedBox(height: 16),
              const Text(
                'Select file(s) to attach to your response:',
              ),
              const SizedBox(height: 16),
              Center(
                child: Container(
                  width: double.infinity,
                  height: 120,
                  decoration: BoxDecoration(
                    color: Colors.grey.withOpacity(0.1),
                    borderRadius: BorderRadius.circular(8),
                    border: Border.all(color: Colors.grey.withOpacity(0.3)),
                  ),
                  child: Column(
                    mainAxisAlignment: MainAxisAlignment.center,
                    children: [
                      Icon(Icons.cloud_upload,
                          size: 40, color: Colors.grey[400]),
                      const SizedBox(height: 8),
                      TextButton(
                        onPressed: () {
                          // File selection would be implemented here
                        },
                        child: const Text('Click to select files'),
                      ),
                    ],
                  ),
                ),
              ),
              const SizedBox(height: 8),
              Text(
                'Maximum file size: 10MB. Allowed formats: PNG, JPG, PDF, ZIP.',
                style: TextStyle(
                  fontSize: 12,
                  color: Colors.grey[600],
                ),
              ),
              const SizedBox(height: 16),
              Row(
                mainAxisAlignment: MainAxisAlignment.end,
                children: [
                  TextButton(
                    onPressed: () => Get.back(),
                    child: const Text('CANCEL'),
                  ),
                  const SizedBox(width: 8),
                  ElevatedButton(
                    onPressed: () {
                      // This would upload the file in a real app
                      Get.back();
                      successMessage('Files would be attached here');
                    },
                    style: ElevatedButton.styleFrom(
                      backgroundColor: Colors.deepPurpleAccent,
                    ),
                    child: const Text('ATTACH'),
                  ),
                ],
              ),
            ],
          ),
        ),
      ),
    );
  }

  void _showArticleDialog(Map<String, dynamic> article) {
    Get.dialog(
      Dialog(
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
        child: Container(
          padding: const EdgeInsets.all(24),
          constraints: const BoxConstraints(maxWidth: 800, maxHeight: 600),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text(
                article['title'] as String,
                style: const TextStyle(
                  fontSize: 24,
                  fontWeight: FontWeight.bold,
                ),
              ),
              const SizedBox(height: 8),
              Text(
                'Last updated: ${DateFormat('MMM dd, yyyy').format(article['updatedAt'] as DateTime)}',
                style: TextStyle(
                  color: Colors.grey[600],
                  fontSize: 12,
                ),
              ),
              const SizedBox(height: 16),
              const Divider(),
              const SizedBox(height: 16),
              Expanded(
                child: SingleChildScrollView(
                  child: Text(article['content'] as String),
                ),
              ),
              const SizedBox(height: 16),
              Row(
                mainAxisAlignment: MainAxisAlignment.spaceBetween,
                children: [
                  OutlinedButton.icon(
                    onPressed: () {
                      // Edit the article
                      Get.back();
                      _showEditArticleDialog(article);
                    },
                    icon: const Icon(Icons.edit),
                    label: const Text('Edit Article'),
                  ),
                  ElevatedButton(
                    onPressed: () => Get.back(),
                    style: ElevatedButton.styleFrom(
                      backgroundColor: Colors.deepPurpleAccent,
                    ),
                    child: const Text('CLOSE'),
                  ),
                ],
              ),
            ],
          ),
        ),
      ),
    );
  }

  void _showEditArticleDialog(Map<String, dynamic> article) {
    final titleController =
        TextEditingController(text: article['title'] as String);
    final contentController =
        TextEditingController(text: article['content'] as String);
    final summaryController =
        TextEditingController(text: article['summary'] as String);
    final List<String> categories = [
      'Account',
      'Billing',
      'Game Play',
      'Technical',
      'Feature Request',
      'Bug Report',
      'Other'
    ];
    final RxString selectedCategory = (article['category'] as String).obs;

    Get.dialog(
      Dialog(
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
        child: Container(
          padding: const EdgeInsets.all(16),
          constraints: const BoxConstraints(maxWidth: 800, maxHeight: 700),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              const Text(
                'Edit Knowledge Base Article',
                style: TextStyle(
                  fontSize: 18,
                  fontWeight: FontWeight.bold,
                ),
              ),
              const SizedBox(height: 16),
              TextField(
                controller: titleController,
                decoration: const InputDecoration(
                  labelText: 'Title',
                  border: OutlineInputBorder(),
                ),
              ),
              const SizedBox(height: 16),
              TextField(
                controller: summaryController,
                decoration: const InputDecoration(
                  labelText: 'Summary',
                  border: OutlineInputBorder(),
                  hintText: 'Brief description of the article',
                ),
                maxLines: 2,
              ),
              const SizedBox(height: 16),
              Row(
                children: [
                  Expanded(
                    child: Obx(() => Container(
                          decoration: BoxDecoration(
                            border:
                                Border.all(color: Colors.grey.withOpacity(0.3)),
                            borderRadius: BorderRadius.circular(8),
                          ),
                          child: DropdownButtonHideUnderline(
                            child: DropdownButton<String>(
                              value: selectedCategory.value,
                              isExpanded: true,
                              icon: const Icon(Icons.arrow_drop_down),
                              iconSize: 24,
                              elevation: 16,
                              padding:
                                  const EdgeInsets.symmetric(horizontal: 16),
                              items: categories.map((String category) {
                                return DropdownMenuItem<String>(
                                  value: category,
                                  child: Text(category),
                                );
                              }).toList(),
                              onChanged: (value) {
                                if (value != null) {
                                  selectedCategory.value = value;
                                }
                              },
                            ),
                          ),
                        )),
                  ),
                ],
              ),
              const SizedBox(height: 16),
              const Text(
                'Content',
                style: TextStyle(
                  fontWeight: FontWeight.bold,
                ),
              ),
              const SizedBox(height: 8),
              Expanded(
                child: TextField(
                  controller: contentController,
                  decoration: const InputDecoration(
                    border: OutlineInputBorder(),
                    hintText: 'Article content...',
                  ),
                  maxLines: null,
                  expands: true,
                ),
              ),
              const SizedBox(height: 16),
              Row(
                mainAxisAlignment: MainAxisAlignment.end,
                children: [
                  TextButton(
                    onPressed: () => Get.back(),
                    child: const Text('CANCEL'),
                  ),
                  const SizedBox(width: 8),
                  ElevatedButton(
                    onPressed: () {
                      if (titleController.text.isEmpty ||
                          contentController.text.isEmpty ||
                          summaryController.text.isEmpty) {
                        errorMessage('Please fill in all fields');
                        return;
                      }

                      // This would update the article in a real app
                      Get.back();
                      successMessage('Article updated successfully');
                    },
                    style: ElevatedButton.styleFrom(
                      backgroundColor: Colors.deepPurpleAccent,
                    ),
                    child: const Text('SAVE'),
                  ),
                ],
              ),
            ],
          ),
        ),
      ),
    );
  }

  void _showCreateKnowledgeBaseArticleDialog(
      SupportSystemController controller) {
    final titleController = TextEditingController();
    final contentController = TextEditingController();
    final summaryController = TextEditingController();
    final List<String> categories = [
      'Account',
      'Billing',
      'Game Play',
      'Technical',
      'Feature Request',
      'Bug Report',
      'Other'
    ];
    final RxString selectedCategory = categories[0].obs;

    Get.dialog(
      Dialog(
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
        child: Container(
          padding: const EdgeInsets.all(16),
          constraints: const BoxConstraints(maxWidth: 800, maxHeight: 700),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              const Text(
                'Create Knowledge Base Article',
                style: TextStyle(
                  fontSize: 18,
                  fontWeight: FontWeight.bold,
                ),
              ),
              const SizedBox(height: 16),
              TextField(
                controller: titleController,
                decoration: const InputDecoration(
                  labelText: 'Title',
                  border: OutlineInputBorder(),
                  hintText: 'Enter article title',
                ),
              ),
              const SizedBox(height: 16),
              TextField(
                controller: summaryController,
                decoration: const InputDecoration(
                  labelText: 'Summary',
                  border: OutlineInputBorder(),
                  hintText: 'Brief description of the article',
                ),
                maxLines: 2,
              ),
              const SizedBox(height: 16),
              Row(
                children: [
                  Expanded(
                    child: Obx(() => Container(
                          decoration: BoxDecoration(
                            border:
                                Border.all(color: Colors.grey.withOpacity(0.3)),
                            borderRadius: BorderRadius.circular(8),
                          ),
                          child: DropdownButtonHideUnderline(
                            child: DropdownButton<String>(
                              value: selectedCategory.value,
                              isExpanded: true,
                              icon: const Icon(Icons.arrow_drop_down),
                              iconSize: 24,
                              elevation: 16,
                              padding:
                                  const EdgeInsets.symmetric(horizontal: 16),
                              items: categories.map((String category) {
                                return DropdownMenuItem<String>(
                                  value: category,
                                  child: Text(category),
                                );
                              }).toList(),
                              onChanged: (value) {
                                if (value != null) {
                                  selectedCategory.value = value;
                                }
                              },
                            ),
                          ),
                        )),
                  ),
                ],
              ),
              const SizedBox(height: 16),
              const Text(
                'Content',
                style: TextStyle(
                  fontWeight: FontWeight.bold,
                ),
              ),
              const SizedBox(height: 8),
              Expanded(
                child: TextField(
                  controller: contentController,
                  decoration: const InputDecoration(
                    border: OutlineInputBorder(),
                    hintText: 'Article content...',
                  ),
                  maxLines: null,
                  expands: true,
                ),
              ),
              const SizedBox(height: 16),
              Row(
                mainAxisAlignment: MainAxisAlignment.end,
                children: [
                  TextButton(
                    onPressed: () => Get.back(),
                    child: const Text('CANCEL'),
                  ),
                  const SizedBox(width: 8),
                  ElevatedButton(
                    onPressed: () {
                      if (titleController.text.isEmpty ||
                          contentController.text.isEmpty ||
                          summaryController.text.isEmpty) {
                        errorMessage('Please fill in all fields');
                        return;
                      }

                      // Create the article
                      controller
                          .createKnowledgeBaseArticle(
                        title: titleController.text,
                        content: contentController.text,
                        summary: summaryController.text,
                        category: selectedCategory.value,
                      )
                          .then((success) {
                        if (success) {
                          Get.back();
                          successMessage('Article created successfully');
                        }
                      });
                    },
                    style: ElevatedButton.styleFrom(
                      backgroundColor: Colors.deepPurpleAccent,
                    ),
                    child: const Text('CREATE'),
                  ),
                ],
              ),
            ],
          ),
        ),
      ),
    );
  }

  void _showKnowledgeBaseDialog(SupportSystemController controller) {
    final searchController = TextEditingController();
    final RxString searchQuery = ''.obs;
    final RxString selectedCategory = 'All'.obs;

    final List<String> categories = [
      'All',
      'Account',
      'Billing',
      'Game Play',
      'Technical',
      'Feature Request',
      'Bug Report',
      'Other',
    ];

    Get.dialog(
      Dialog(
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
        child: Container(
          padding: const EdgeInsets.all(24),
          constraints: const BoxConstraints(maxWidth: 900, maxHeight: 700),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              const Text(
                'Knowledge Base',
                style: TextStyle(
                  fontSize: 24,
                  fontWeight: FontWeight.bold,
                ),
              ),
              const SizedBox(height: 16),
              Row(
                children: [
                  Expanded(
                    child: TextField(
                      controller: searchController,
                      decoration: InputDecoration(
                        hintText: 'Search articles...',
                        prefixIcon: const Icon(Icons.search),
                        suffixIcon: Obx(() => searchQuery.value.isNotEmpty
                            ? IconButton(
                                icon: const Icon(Icons.clear),
                                onPressed: () {
                                  searchController.clear();
                                  searchQuery.value = '';
                                },
                              )
                            : const SizedBox()),
                        border: OutlineInputBorder(
                          borderRadius: BorderRadius.circular(8),
                        ),
                      ),
                      onChanged: (value) {
                        searchQuery.value = value.trim();
                      },
                    ),
                  ),
                  const SizedBox(width: 16),
                  Obx(() => Container(
                        padding: const EdgeInsets.symmetric(horizontal: 12),
                        decoration: BoxDecoration(
                          border:
                              Border.all(color: Colors.grey.withOpacity(0.3)),
                          borderRadius: BorderRadius.circular(8),
                        ),
                        child: DropdownButtonHideUnderline(
                          child: DropdownButton<String>(
                            value: selectedCategory.value,
                            hint: const Text('Category'),
                            items: categories.map((String category) {
                              return DropdownMenuItem<String>(
                                value: category,
                                child: Text(category),
                              );
                            }).toList(),
                            onChanged: (value) {
                              if (value != null) {
                                selectedCategory.value = value;
                              }
                            },
                          ),
                        ),
                      )),
                ],
              ),
              const SizedBox(height: 16),
              Expanded(
                child: Obx(() {
                  final articles = controller.getFilteredKnowledgeBaseArticles(
                    searchQuery.value,
                    selectedCategory.value == 'All'
                        ? null
                        : selectedCategory.value,
                  );

                  if (articles.isEmpty) {
                    return Center(
                      child: Column(
                        mainAxisAlignment: MainAxisAlignment.center,
                        children: [
                          Icon(Icons.article,
                              size: 64, color: Colors.grey[300]),
                          const SizedBox(height: 16),
                          Text(
                            searchQuery.value.isNotEmpty ||
                                    selectedCategory.value != 'All'
                                ? 'No articles match your search'
                                : 'No articles found',
                            style: TextStyle(color: Colors.grey[600]),
                          ),
                        ],
                      ),
                    );
                  }

                  return ListView.separated(
                    itemCount: articles.length,
                    separatorBuilder: (context, index) => const Divider(),
                    itemBuilder: (context, index) {
                      final article = articles[index];
                      return ListTile(
                        title: Text(
                          article['title'] as String,
                          style: const TextStyle(
                            fontWeight: FontWeight.bold,
                          ),
                        ),
                        trailing: Row(
                          mainAxisSize: MainAxisSize.min,
                          children: [
                            IconButton(
                              icon: const Icon(Icons.edit),
                              tooltip: 'Edit',
                              onPressed: () {
                                Get.back();
                                _showEditArticleDialog(article);
                              },
                            ),
                            IconButton(
                              icon: const Icon(Icons.visibility),
                              tooltip: 'View',
                              onPressed: () {
                                Get.back();
                                _showArticleDialog(article);
                              },
                            ),
                          ],
                        ),
                      );
                    },
                  );
                }),
              ),
              const SizedBox(height: 16),
              Row(
                mainAxisAlignment: MainAxisAlignment.spaceBetween,
                children: [
                  OutlinedButton.icon(
                    onPressed: () {
                      Get.back();
                      _showCreateKnowledgeBaseArticleDialog(controller);
                    },
                    icon: const Icon(Icons.add),
                    label: const Text('Create New Article'),
                  ),
                  TextButton(
                    onPressed: () => Get.back(),
                    child: const Text('CLOSE'),
                  ),
                ],
              ),
            ],
          ),
        ),
      ),
    );
  }

  void _showSupportAnalytics(SupportSystemController controller) {
    Get.dialog(
      Dialog(
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
        child: Container(
          padding: const EdgeInsets.all(24),
          constraints: const BoxConstraints(maxWidth: 900, maxHeight: 700),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              const Text(
                'Support Analytics',
                style: TextStyle(
                  fontSize: 24,
                  fontWeight: FontWeight.bold,
                ),
              ),
              const SizedBox(height: 16),
              const Expanded(
                child: SingleChildScrollView(
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      // Analytics content would go here
                      Text(
                          'Support analytics and reporting would be displayed here.'),
                    ],
                  ),
                ),
              ),
              const SizedBox(height: 16),
              Align(
                alignment: Alignment.centerRight,
                child: TextButton(
                  onPressed: () => Get.back(),
                  child: const Text('CLOSE'),
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }

  void _showSupportSettings(SupportSystemController controller) {
    Get.dialog(
      Dialog(
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
        child: Container(
          padding: const EdgeInsets.all(24),
          constraints: const BoxConstraints(maxWidth: 600),
          child: SingleChildScrollView(
            child: Column(
              mainAxisSize: MainAxisSize.min,
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                const Text(
                  'Support Settings',
                  style: TextStyle(
                    fontSize: 24,
                    fontWeight: FontWeight.bold,
                  ),
                ),
                const SizedBox(height: 16),
                const Text(
                  'Email Notifications',
                  style: TextStyle(
                    fontSize: 18,
                    fontWeight: FontWeight.bold,
                  ),
                ),
                const SizedBox(height: 8),
                CheckboxListTile(
                  title: const Text('New ticket notifications'),
                  subtitle:
                      const Text('Receive email when a new ticket is created'),
                  value: true,
                  onChanged: (_) {},
                ),
                CheckboxListTile(
                  title: const Text('Ticket assignment notifications'),
                  subtitle: const Text(
                      'Receive email when a ticket is assigned to you'),
                  value: true,
                  onChanged: (_) {},
                ),
                CheckboxListTile(
                  title: const Text('Ticket update notifications'),
                  subtitle:
                      const Text('Receive email when a ticket is updated'),
                  value: false,
                  onChanged: (_) {},
                ),
                const SizedBox(height: 16),
                const Text(
                  'Automation Settings',
                  style: TextStyle(
                    fontSize: 18,
                    fontWeight: FontWeight.bold,
                  ),
                ),
                const SizedBox(height: 8),
                CheckboxListTile(
                  title: const Text('Auto-assign tickets'),
                  subtitle: const Text(
                      'Automatically assign tickets to available agents'),
                  value: true,
                  onChanged: (_) {},
                ),
                CheckboxListTile(
                  title: const Text('Auto-tag tickets'),
                  subtitle:
                      const Text('Automatically tag tickets based on content'),
                  value: true,
                  onChanged: (_) {},
                ),
                const SizedBox(height: 16),
                Row(
                  mainAxisAlignment: MainAxisAlignment.end,
                  children: [
                    TextButton(
                      onPressed: () => Get.back(),
                      child: const Text('CANCEL'),
                    ),
                    const SizedBox(width: 8),
                    ElevatedButton(
                      onPressed: () {
                        Get.back();
                        successMessage('Settings saved successfully');
                      },
                      style: ElevatedButton.styleFrom(
                        backgroundColor: Colors.deepPurpleAccent,
                      ),
                      child: const Text('SAVE'),
                    ),
                  ],
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }
}

Widget _buildMessageBubble({
  required String sender,
  required String? senderImage,
  required String message,
  required DateTime timestamp,
  required bool isUser,
}) {
  return Row(
    crossAxisAlignment: CrossAxisAlignment.start,
    mainAxisAlignment: isUser ? MainAxisAlignment.end : MainAxisAlignment.start,
    children: [
      if (!isUser) ...[
        AvatarUserWidget(
          radius: 16,
          imagePath: senderImage ?? '',
        ),
        const SizedBox(width: 8),
      ],
      Flexible(
        child: Column(
          crossAxisAlignment:
              isUser ? CrossAxisAlignment.end : CrossAxisAlignment.start,
          children: [
            Container(
              padding: const EdgeInsets.all(12),
              decoration: BoxDecoration(
                color: isUser
                    ? Colors.grey[100]
                    : Colors.deepPurpleAccent.withOpacity(0.1),
                borderRadius: BorderRadius.circular(12),
                border: Border.all(
                  color: isUser
                      ? Colors.grey[300]!
                      : Colors.deepPurpleAccent.withOpacity(0.3),
                ),
              ),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    sender,
                    style: TextStyle(
                      fontWeight: FontWeight.bold,
                      color: isUser ? Colors.black : Colors.deepPurpleAccent,
                    ),
                  ),
                  const SizedBox(height: 4),
                  Text(message),
                ],
              ),
            ),
            const SizedBox(height: 4),
            Text(
              DateFormat('MMM dd, yyyy - HH:mm').format(timestamp),
              style: TextStyle(
                fontSize: 10,
                color: Colors.grey[600],
              ),
            ),
          ],
        ),
      ),
      if (isUser) ...[
        const SizedBox(width: 8),
        AvatarUserWidget(
          radius: 16,
          imagePath: senderImage ?? '',
        ),
      ],
    ],
  );
}

Widget _buildReplyForm(SupportSystemController controller, String ticketId) {
  return Column(
    crossAxisAlignment: CrossAxisAlignment.start,
    children: [
      const Text(
        'Reply',
        style: TextStyle(
          fontWeight: FontWeight.bold,
        ),
      ),
      const SizedBox(height: 8),
      TextField(
        controller: controller.replyController,
        decoration: const InputDecoration(
          hintText: 'Type your response here...',
          border: OutlineInputBorder(),
        ),
        maxLines: 5,
      ),
      const SizedBox(height: 8),
      Row(
        mainAxisAlignment: MainAxisAlignment.end,
        children: [
          OutlinedButton.icon(
            onPressed: () {
              // Show template responses dialog
              _showTemplateResponsesDialog(controller);
            },
            icon: const Icon(Icons.format_quote),
            label: const Text('Templates'),
          ),
          const SizedBox(width: 8),
          OutlinedButton.icon(
            onPressed: () {
              // Show attachment dialog
              _showAttachmentDialog(controller);
            },
            icon: const Icon(Icons.attach_file),
            label: const Text('Add Attachment'),
          ),
          const SizedBox(width: 8),
          ElevatedButton.icon(
            onPressed: () {
              if (controller.replyController.text.isEmpty) {
                errorMessage('Please enter a response');
                return;
              }

              controller
                  .sendReply(ticketId, controller.replyController.text)
                  .then((success) {
                if (success) {
                  controller.replyController.clear();
                  successMessage('Reply sent successfully');
                }
              });
            },
            icon: const Icon(Icons.send),
            label: const Text('Send Reply'),
            style: ElevatedButton.styleFrom(
              backgroundColor: Colors.deepPurpleAccent,
            ),
          ),
        ],
      ),
    ],
  );
}

void _showAttachmentDialog(SupportSystemController controller) {
  Get.dialog(
    Dialog(
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
      child: Container(
        padding: const EdgeInsets.all(16),
        constraints: const BoxConstraints(maxWidth: 400),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            const Text(
              'Add Attachment',
              style: TextStyle(
                fontSize: 18,
                fontWeight: FontWeight.bold,
              ),
            ),
            const SizedBox(height: 16),
            const Text(
              'Select file(s) to attach to your response:',
            ),
            const SizedBox(height: 16),
            Center(
              child: Container(
                width: double.infinity,
                height: 120,
                decoration: BoxDecoration(
                  color: Colors.grey.withOpacity(0.1),
                  borderRadius: BorderRadius.circular(8),
                  border: Border.all(color: Colors.grey.withOpacity(0.3)),
                ),
                child: Column(
                  mainAxisAlignment: MainAxisAlignment.center,
                  children: [
                    Icon(Icons.cloud_upload, size: 40, color: Colors.grey[400]),
                    const SizedBox(height: 8),
                    TextButton(
                      onPressed: () {
                        // File selection would be implemented here
                      },
                      child: const Text('Click to select files'),
                    ),
                  ],
                ),
              ),
            ),
            const SizedBox(height: 8),
            Text(
              'Maximum file size: 10MB. Allowed formats: PNG, JPG, PDF, ZIP.',
              style: TextStyle(
                fontSize: 12,
                color: Colors.grey[600],
              ),
            ),
            const SizedBox(height: 16),
            Row(
              mainAxisAlignment: MainAxisAlignment.end,
              children: [
                TextButton(
                  onPressed: () => Get.back(),
                  child: const Text('CANCEL'),
                ),
                const SizedBox(width: 8),
                ElevatedButton(
                  onPressed: () {
                    // This would upload the file in a real app
                    Get.back();
                    successMessage('Files would be attached here');
                  },
                  style: ElevatedButton.styleFrom(
                    backgroundColor: Colors.deepPurpleAccent,
                  ),
                  child: const Text('ATTACH'),
                ),
              ],
            ),
          ],
        ),
      ),
    ),
  );
}

void _showTemplateResponsesDialog(SupportSystemController controller) {
  // Mock template responses
  final List<Map<String, String>> templates = [
    {
      'title': 'Thank you',
      'content':
          'Thank you for contacting us. We appreciate your patience while we work on resolving your issue.',
    },
    {
      'title': 'Additional information needed',
      'content':
          'To better assist you with this issue, could you please provide more information about the problem you\'re experiencing?',
    },
    {
      'title': 'Issue resolved',
      'content':
          'We\'re pleased to inform you that the issue you reported has been resolved. Please let us know if you encounter any further problems.',
    },
    {
      'title': 'Known issue',
      'content':
          'Thank you for your report. This is a known issue that our team is currently working on. We expect to have a fix available in our next update.',
    },
    {
      'title': 'User error',
      'content':
          'Based on our investigation, it appears this issue may be related to how the feature is being used. Here are the correct steps to follow:',
    },
  ];

  Get.dialog(
    Dialog(
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
      child: Container(
        padding: const EdgeInsets.all(16),
        constraints: const BoxConstraints(maxWidth: 600, maxHeight: 600),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            const Text(
              'Template Responses',
              style: TextStyle(
                fontSize: 18,
                fontWeight: FontWeight.bold,
              ),
            ),
            const SizedBox(height: 16),
            Expanded(
              child: ListView.separated(
                itemCount: templates.length,
                separatorBuilder: (context, index) => const Divider(),
                itemBuilder: (context, index) {
                  final template = templates[index];
                  return ListTile(
                    title: Text(template['title']!),
                    subtitle: Text(
                      template['content']!,
                      maxLines: 2,
                      overflow: TextOverflow.ellipsis,
                    ),
                    trailing: TextButton(
                      onPressed: () {
                        controller.replyController.text = template['content']!;
                        Get.back();
                      },
                      child: const Text('Use'),
                    ),
                    onTap: () {
                      controller.replyController.text = template['content']!;
                      Get.back();
                    },
                  );
                },
              ),
            ),
            const SizedBox(height: 16),
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                TextButton.icon(
                  onPressed: () {
                    // Show create template dialog
                    Get.back();
                    _showCreateTemplateDialog(controller);
                  },
                  icon: const Icon(Icons.add),
                  label: const Text('Create New Template'),
                ),
                TextButton(
                  onPressed: () => Get.back(),
                  child: const Text('CLOSE'),
                ),
              ],
            ),
          ],
        ),
      ),
    ),
  );
}

void _showCreateTemplateDialog(SupportSystemController controller) {
  final titleController = TextEditingController();
  final contentController = TextEditingController();

  Get.dialog(
    Dialog(
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
      child: Container(
        padding: const EdgeInsets.all(16),
        constraints: const BoxConstraints(maxWidth: 500),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            const Text(
              'Create Response Template',
              style: TextStyle(
                fontSize: 18,
                fontWeight: FontWeight.bold,
              ),
            ),
            const SizedBox(height: 16),
            TextField(
              controller: titleController,
              decoration: const InputDecoration(
                labelText: 'Template Title',
                border: OutlineInputBorder(),
                hintText: 'Enter a descriptive title...',
              ),
            ),
            const SizedBox(height: 16),
            TextField(
              controller: contentController,
              decoration: const InputDecoration(
                labelText: 'Response Content',
                border: OutlineInputBorder(),
                hintText: 'Enter the template content...',
              ),
              maxLines: 5,
            ),
            const SizedBox(height: 16),
            Row(
              mainAxisAlignment: MainAxisAlignment.end,
              children: [
                TextButton(
                  onPressed: () => Get.back(),
                  child: const Text('CANCEL'),
                ),
                const SizedBox(width: 8),
                ElevatedButton(
                  onPressed: () {
                    if (titleController.text.isEmpty ||
                        contentController.text.isEmpty) {
                      errorMessage('Please fill in all fields');
                      return;
                    }

                    // This would save the template in a real app
                    Get.back();
                    successMessage('Template saved successfully');
                  },
                  style: ElevatedButton.styleFrom(
                    backgroundColor: Colors.deepPurpleAccent,
                  ),
                  child: const Text('SAVE'),
                ),
              ],
            ),
          ],
        ),
      ),
    ),
  );
}

Widget _buildFilterChip({
  required String label,
  required bool selected,
  required ValueChanged<bool> onSelected,
  Color? color,
}) {
  return FilterChip(
    label: Text(label),
    selected: selected,
    onSelected: onSelected,
    selectedColor: (color ?? Colors.deepPurpleAccent).withOpacity(0.2),
    checkmarkColor: color ?? Colors.deepPurpleAccent,
    labelStyle: TextStyle(
      color: selected ? (color ?? Colors.deepPurpleAccent) : Colors.black,
      fontWeight: selected ? FontWeight.bold : FontWeight.normal,
    ),
  );
}

Widget _buildInfoRow({
  required String label,
  required String value,
  Color? valueColor,
}) {
  return Row(
    mainAxisAlignment: MainAxisAlignment.spaceBetween,
    children: [
      Text(
        label,
        style: TextStyle(
          color: Colors.grey[700],
        ),
      ),
      Text(
        value,
        style: TextStyle(
          fontWeight: FontWeight.bold,
          color: valueColor,
        ),
      ),
    ],
  );
}

Widget _buildTagChip({
  required String tag,
  required VoidCallback onDeleted,
}) {
  return Chip(
    label: Text(tag),
    deleteIcon: const Icon(Icons.cancel, size: 16),
    onDeleted: onDeleted,
    materialTapTargetSize: MaterialTapTargetSize.shrinkWrap,
    visualDensity: VisualDensity.compact,
  );
}

Color _getStatusColor(String status) {
  switch (status) {
    case 'open':
      return Colors.green;
    case 'pending':
      return Colors.orange;
    case 'resolved':
      return Colors.grey;
    default:
      return Colors.grey;
  }
}

Color _getPriorityColor(String priority) {
  switch (priority) {
    case 'high':
      return Colors.red;
    case 'medium':
      return Colors.orange;
    case 'low':
      return Colors.blue;
    default:
      return Colors.grey;
  }
}

String _timeAgo(DateTime dateTime) {
  final now = DateTime.now();
  final difference = now.difference(dateTime);

  if (difference.inDays > 365) {
    return '${(difference.inDays / 365).floor()} years ago';
  } else if (difference.inDays > 30) {
    return '${(difference.inDays / 30).floor()} months ago';
  } else if (difference.inDays > 7) {
    return '${(difference.inDays / 7).floor()} weeks ago';
  } else if (difference.inDays > 0) {
    return '${difference.inDays} days ago';
  } else if (difference.inHours > 0) {
    return '${difference.inHours} hours ago';
  } else if (difference.inMinutes > 0) {
    return '${difference.inMinutes} minutes ago';
  } else {
    return 'Just now';
  }
}

void _showResolveTicketDialog(
    Map<String, dynamic> ticket, SupportSystemController controller) {
  final resolutionController = TextEditingController();
  final ticketId = ticket['id'] as String;

  Get.dialog(
    Dialog(
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
      child: Container(
        padding: const EdgeInsets.all(16),
        constraints: const BoxConstraints(maxWidth: 500),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            const Text(
              'Resolve Ticket',
              style: TextStyle(
                fontSize: 18,
                fontWeight: FontWeight.bold,
              ),
            ),
            const SizedBox(height: 16),
            const Text(
              'Please provide a summary of the resolution for this ticket.',
            ),
            const SizedBox(height: 16),
            TextField(
              controller: resolutionController,
              decoration: const InputDecoration(
                labelText: 'Resolution',
                border: OutlineInputBorder(),
                hintText: 'Explain how the issue was resolved...',
              ),
              maxLines: 3,
            ),
            const SizedBox(height: 16),
            CheckboxListTile(
              title: const Text('Send resolution email to user'),
              value: true,
              onChanged: (_) {},
              contentPadding: EdgeInsets.zero,
            ),
            const SizedBox(height: 16),
            Row(
              mainAxisAlignment: MainAxisAlignment.end,
              children: [
                TextButton(
                  onPressed: () => Get.back(),
                  child: const Text('CANCEL'),
                ),
                const SizedBox(width: 8),
                ElevatedButton(
                  onPressed: () {
                    if (resolutionController.text.isEmpty) {
                      errorMessage('Please enter a resolution summary');
                      return;
                    }

                    controller
                        .resolveTicket(
                      ticketId,
                      resolutionController.text,
                    )
                        .then((success) {
                      if (success) {
                        Get.back();
                        successMessage('Ticket resolved successfully');
                      }
                    });
                  },
                  style: ElevatedButton.styleFrom(
                    backgroundColor: Colors.green,
                  ),
                  child: const Text('RESOLVE'),
                ),
              ],
            ),
          ],
        ),
      ),
    ),
  );
}

void _showAssignTicketDialog(
    Map<String, dynamic> ticket, SupportSystemController controller) {
  final ticketId = ticket['id'] as String;
  final RxString selectedAgentId = ''.obs;

  // Mock agent data
  final List<Map<String, dynamic>> agents = [
    {
      'id': 'agent1',
      'name': 'John Smith',
      'role': 'Support Agent',
      'image': '',
      'activeTickets': 5
    },
    {
      'id': 'agent2',
      'name': 'Jane Doe',
      'role': 'Senior Support',
      'image': '',
      'activeTickets': 3
    },
    {
      'id': 'agent3',
      'name': 'Mike Johnson',
      'role': 'Support Agent',
      'image': '',
      'activeTickets': 7
    },
    {
      'id': 'agent4',
      'name': 'Sarah Wilson',
      'role': 'Technical Support',
      'image': '',
      'activeTickets': 2
    },
  ];

  Get.dialog(
    Dialog(
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
      child: Container(
        padding: const EdgeInsets.all(16),
        constraints: const BoxConstraints(maxWidth: 500, maxHeight: 600),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            const Text(
              'Assign Ticket',
              style: TextStyle(
                fontSize: 18,
                fontWeight: FontWeight.bold,
              ),
            ),
            const SizedBox(height: 16),
            const Text(
              'Select an agent to assign this ticket to:',
            ),
            const SizedBox(height: 16),
            Expanded(
              child: ListView.builder(
                itemCount: agents.length,
                itemBuilder: (context, index) {
                  final agent = agents[index];
                  final agentId = agent['id'] as String;

                  return Obx(() => RadioListTile<String>(
                        title: Text(agent['name'] as String),
                        subtitle: Row(
                          children: [
                            Text(agent['role'] as String),
                            const SizedBox(width: 8),
                            Container(
                              padding: const EdgeInsets.symmetric(
                                  horizontal: 8, vertical: 2),
                              decoration: BoxDecoration(
                                color: Colors.blue.withOpacity(0.1),
                                borderRadius: BorderRadius.circular(12),
                              ),
                              child: Text(
                                '${agent['activeTickets']} active tickets',
                                style: const TextStyle(
                                  color: Colors.blue,
                                  fontSize: 10,
                                  fontWeight: FontWeight.bold,
                                ),
                              ),
                            ),
                          ],
                        ),
                        value: agentId,
                        groupValue: selectedAgentId.value,
                        onChanged: (value) {
                          selectedAgentId.value = value!;
                        },
                      ));
                },
              ),
            ),
            const SizedBox(height: 16),
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                OutlinedButton(
                  onPressed: () {
                    // Unassign ticket logic
                    controller.unassignTicket(ticketId).then((success) {
                      if (success) {
                        Get.back();
                        successMessage('Ticket unassigned successfully');
                      }
                    });
                  },
                  child: const Text('Unassign'),
                ),
                Row(
                  children: [
                    TextButton(
                      onPressed: () => Get.back(),
                      child: const Text('CANCEL'),
                    ),
                    const SizedBox(width: 8),
                    Obx(() => ElevatedButton(
                          onPressed: selectedAgentId.value.isEmpty
                              ? null
                              : () {
                                  controller
                                      .assignTicket(
                                    ticketId,
                                    selectedAgentId.value,
                                    agents.firstWhere((agent) =>
                                            agent['id'] ==
                                            selectedAgentId.value)['name']
                                        as String,
                                  )
                                      .then((success) {
                                    if (success) {
                                      Get.back();
                                      successMessage(
                                          'Ticket assigned successfully');
                                    }
                                  });
                                },
                          style: ElevatedButton.styleFrom(
                            backgroundColor: Colors.deepPurpleAccent,
                          ),
                          child: const Text('ASSIGN'),
                        )),
                  ],
                ),
              ],
            ),
          ],
        ),
      ),
    ),
  );
}

void _showChangePriorityDialog(
    Map<String, dynamic> ticket, SupportSystemController controller) {
  final ticketId = ticket['id'] as String;
  final currentPriority = ticket['priority'] as String;
  RxString selectedPriority = currentPriority.obs;

  Get.dialog(
    Dialog(
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
      child: Container(
        padding: const EdgeInsets.all(16),
        constraints: const BoxConstraints(maxWidth: 400),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            const Text(
              'Change Priority',
              style: TextStyle(
                fontSize: 18,
                fontWeight: FontWeight.bold,
              ),
            ),
            const SizedBox(height: 16),
            const Text(
              'Select the new priority level for this ticket:',
            ),
            const SizedBox(height: 16),
            Obx(() => Column(
                  children: [
                    _buildPriorityOption(
                      label: 'High',
                      description: 'Critical issue affecting many users',
                      value: 'high',
                      groupValue: selectedPriority.value,
                      color: Colors.red,
                      onChanged: (value) {
                        selectedPriority.value = value!;
                      },
                    ),
                    const SizedBox(height: 8),
                    _buildPriorityOption(
                      label: 'Medium',
                      description: 'Important issue with limited impact',
                      value: 'medium',
                      groupValue: selectedPriority.value,
                      color: Colors.orange,
                      onChanged: (value) {
                        selectedPriority.value = value!;
                      },
                    ),
                    const SizedBox(height: 8),
                    _buildPriorityOption(
                      label: 'Low',
                      description: 'Minor issue or question',
                      value: 'low',
                      groupValue: selectedPriority.value,
                      color: Colors.blue,
                      onChanged: (value) {
                        selectedPriority.value = value!;
                      },
                    ),
                  ],
                )),
            const SizedBox(height: 16),
            Row(
              mainAxisAlignment: MainAxisAlignment.end,
              children: [
                TextButton(
                  onPressed: () => Get.back(),
                  child: const Text('CANCEL'),
                ),
                const SizedBox(width: 8),
                Obx(() => ElevatedButton(
                      onPressed: selectedPriority.value == currentPriority
                          ? null
                          : () {
                              controller
                                  .changeTicketPriority(
                                ticketId,
                                selectedPriority.value,
                              )
                                  .then((success) {
                                if (success) {
                                  Get.back();
                                  successMessage(
                                      'Priority changed successfully');
                                }
                              });
                            },
                      style: ElevatedButton.styleFrom(
                        backgroundColor: Colors.deepPurpleAccent,
                      ),
                      child: const Text('SAVE'),
                    )),
              ],
            ),
          ],
        ),
      ),
    ),
  );
}

Widget _buildPriorityOption({
  required String label,
  required String description,
  required String value,
  required String groupValue,
  required Color color,
  required ValueChanged<String?> onChanged,
}) {
  return InkWell(
    onTap: () => onChanged(value),
    borderRadius: BorderRadius.circular(8),
    child: Container(
      padding: const EdgeInsets.all(12),
      decoration: BoxDecoration(
        color:
            value == groupValue ? color.withOpacity(0.1) : Colors.transparent,
        border: Border.all(
          color: value == groupValue ? color : Colors.grey.withOpacity(0.3),
          width: value == groupValue ? 2 : 1,
        ),
        borderRadius: BorderRadius.circular(8),
      ),
      child: Row(
        children: [
          Radio<String>(
            value: value,
            groupValue: groupValue,
            onChanged: onChanged,
            activeColor: color,
          ),
          const SizedBox(width: 8),
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  label,
                  style: TextStyle(
                    fontWeight: FontWeight.bold,
                    color: value == groupValue ? color : Colors.black,
                  ),
                ),
                Text(
                  description,
                  style: TextStyle(
                    fontSize: 12,
                    color: Colors.grey[700],
                  ),
                ),
              ],
            ),
          ),
        ],
      ),
    ),
  );
}

void _showChangeCategoryDialog(
    Map<String, dynamic> ticket, SupportSystemController controller) {
  final ticketId = ticket['id'] as String;
  final currentCategory = ticket['category'] as String;
  RxString selectedCategory = currentCategory.obs;

  // Mock categories
  const List<String> categories = [
    'Account',
    'Billing',
    'Game Play',
    'Technical',
    'Feature Request',
    'Bug Report',
    'Other',
  ];

  Get.dialog(
    Dialog(
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
      child: Container(
        padding: const EdgeInsets.all(16),
        constraints: const BoxConstraints(maxWidth: 400),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            const Text(
              'Change Category',
              style: TextStyle(
                fontSize: 18,
                fontWeight: FontWeight.bold,
              ),
            ),
            const SizedBox(height: 16),
            const Text(
              'Select the new category for this ticket:',
            ),
            const SizedBox(height: 16),
            Obx(() => Container(
                  decoration: BoxDecoration(
                    border: Border.all(color: Colors.grey.withOpacity(0.3)),
                    borderRadius: BorderRadius.circular(8),
                  ),
                  child: DropdownButtonHideUnderline(
                    child: DropdownButton<String>(
                      value: selectedCategory.value,
                      isExpanded: true,
                      icon: const Icon(Icons.arrow_drop_down),
                      iconSize: 24,
                      elevation: 16,
                      padding: const EdgeInsets.symmetric(horizontal: 16),
                      items: categories.map((String category) {
                        return DropdownMenuItem<String>(
                          value: category,
                          child: Text(category),
                        );
                      }).toList(),
                      onChanged: (value) {
                        if (value != null) {
                          selectedCategory.value = value;
                        }
                      },
                    ),
                  ),
                )),
            const SizedBox(height: 16),
            Row(
              mainAxisAlignment: MainAxisAlignment.end,
              children: [
                TextButton(
                  onPressed: () => Get.back(),
                  child: const Text('CANCEL'),
                ),
                const SizedBox(width: 8),
                Obx(() => ElevatedButton(
                      onPressed: selectedCategory.value == currentCategory
                          ? null
                          : () {
                              controller
                                  .changeTicketCategory(
                                ticketId,
                                selectedCategory.value,
                              )
                                  .then((success) {
                                if (success) {
                                  Get.back();
                                  successMessage(
                                      'Category changed successfully');
                                }
                              });
                            },
                      style: ElevatedButton.styleFrom(
                        backgroundColor: Colors.deepPurpleAccent,
                      ),
                      child: const Text('SAVE'),
                    )),
              ],
            ),
          ],
        ),
      ),
    ),
  );
}

void _showAddTagDialog(
    Map<String, dynamic> ticket, SupportSystemController controller) {
  final tagController = TextEditingController();
  final ticketId = ticket['id'] as String;
  final currentTags = ticket['tags'] as List<dynamic>? ?? [];

  // Mock suggested tags
  final List<String> suggestedTags = [
    'login-issue',
    'payment-error',
    'game-crash',
    'feature-request',
    'account-recovery',
    'performance',
    'ui-bug',
  ];

  Get.dialog(
    Dialog(
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
      child: Container(
        padding: const EdgeInsets.all(16),
        constraints: const BoxConstraints(maxWidth: 400),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            const Text(
              'Add Tag',
              style: TextStyle(
                fontSize: 18,
                fontWeight: FontWeight.bold,
              ),
            ),
            const SizedBox(height: 16),
            TextField(
              controller: tagController,
              decoration: const InputDecoration(
                labelText: 'Tag',
                border: OutlineInputBorder(),
                hintText: 'Enter a new tag...',
              ),
            ),
            const SizedBox(height: 16),
            const Text(
              'Suggested Tags:',
              style: TextStyle(
                fontWeight: FontWeight.bold,
              ),
            ),
            const SizedBox(height: 8),
            Wrap(
              spacing: 8,
              runSpacing: 8,
              children: suggestedTags
                  .where((tag) => !currentTags.contains(tag))
                  .map((tag) => ActionChip(
                        label: Text(tag),
                        onPressed: () {
                          tagController.text = tag;
                        },
                      ))
                  .toList(),
            ),
            const SizedBox(height: 16),
            Row(
              mainAxisAlignment: MainAxisAlignment.end,
              children: [
                TextButton(
                  onPressed: () => Get.back(),
                  child: const Text('CANCEL'),
                ),
                const SizedBox(width: 8),
                ElevatedButton(
                  onPressed: () {
                    if (tagController.text.isEmpty) {
                      errorMessage('Please enter a tag');
                      return;
                    }

                    if (currentTags.contains(tagController.text)) {
                      errorMessage('This tag already exists');
                      return;
                    }

                    controller
                        .addTagToTicket(
                      ticketId,
                      tagController.text,
                    )
                        .then((success) {
                      if (success) {
                        Get.back();
                        successMessage('Tag added successfully');
                      }
                    });
                  },
                  style: ElevatedButton.styleFrom(
                    backgroundColor: Colors.deepPurpleAccent,
                  ),
                  child: const Text('ADD'),
                ),
              ],
            ),
          ],
        ),
      ),
    ),
  );
}

void _showAddNoteDialog(
    Map<String, dynamic> ticket, SupportSystemController controller) {
  final noteController = TextEditingController();
  final ticketId = ticket['id'] as String;

  Get.dialog(
    Dialog(
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
      child: Container(
        padding: const EdgeInsets.all(16),
        constraints: const BoxConstraints(maxWidth: 500),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            const Text(
              'Add Internal Note',
              style: TextStyle(
                fontSize: 18,
                fontWeight: FontWeight.bold,
              ),
            ),
            const SizedBox(height: 16),
            const Text(
              'This note will only be visible to support staff.',
            ),
            const SizedBox(height: 16),
            TextField(
              controller: noteController,
              decoration: const InputDecoration(
                labelText: 'Note',
                border: OutlineInputBorder(),
                hintText: 'Enter your internal note here...',
              ),
              maxLines: 5,
            ),
            const SizedBox(height: 16),
            Row(
              mainAxisAlignment: MainAxisAlignment.end,
              children: [
                TextButton(
                  onPressed: () => Get.back(),
                  child: const Text('CANCEL'),
                ),
                const SizedBox(width: 8),
                ElevatedButton(
                  onPressed: () {
                    if (noteController.text.isEmpty) {
                      errorMessage('Please enter a note');
                      return;
                    }

                    controller
                        .addInternalNote(
                      ticketId,
                      noteController.text,
                    )
                        .then((success) {
                      if (success) {
                        Get.back();
                        successMessage('Note added successfully');
                      }
                    });
                  },
                  style: ElevatedButton.styleFrom(
                    backgroundColor: Colors.deepPurpleAccent,
                  ),
                  child: const Text('ADD NOTE'),
                ),
              ],
            ),
          ],
        ),
      ),
    ),
  );
}

void _showReopenTicketDialog(
    Map<String, dynamic> ticket, SupportSystemController controller) {
  final reasonController = TextEditingController();
  final ticketId = ticket['id'] as String;

  Get.dialog(Dialog(
    shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
    child: Container(
        padding: const EdgeInsets.all(16),
        constraints: const BoxConstraints(maxWidth: 500),
        child: Column(
            mainAxisSize: MainAxisSize.min,
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              const Text(
                'Reopen Ticket',
                style: TextStyle(
                  fontSize: 18,
                  fontWeight: FontWeight.bold,
                ),
              ),
              const SizedBox(height: 16),
              const Text(
                'Please provide a reason for reopening this ticket.',
              ),
              const SizedBox(height: 16),
              TextField(
                controller: reasonController,
                decoration: const InputDecoration(
                  labelText: 'Reason',
                  border: OutlineInputBorder(),
                  hintText: 'Explain why this ticket needs to be reopened...',
                ),
                maxLines: 3,
              ),
              const SizedBox(height: 16),
              Row(mainAxisAlignment: MainAxisAlignment.end, children: [
                TextButton(
                  onPressed: () => Get.back(),
                  child: const Text('CANCEL'),
                ),
                const SizedBox(width: 8),
              ])
            ])),
  ));
}

void _showArticleDialog(Map<String, dynamic> article) {
  Get.dialog(
    Dialog(
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
      child: Container(
        padding: const EdgeInsets.all(24),
        constraints: const BoxConstraints(maxWidth: 800, maxHeight: 600),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              article['title'] as String,
              style: const TextStyle(
                fontSize: 24,
                fontWeight: FontWeight.bold,
              ),
            ),
            const SizedBox(height: 8),
            Text(
              'Last updated: ${DateFormat('MMM dd, yyyy').format(article['updatedAt'] as DateTime)}',
              style: TextStyle(
                color: Colors.grey[600],
                fontSize: 12,
              ),
            ),
            const SizedBox(height: 16),
            const Divider(),
            const SizedBox(height: 16),
            Expanded(
              child: SingleChildScrollView(
                child: Text(article['content'] as String),
              ),
            ),
            const SizedBox(height: 16),
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                OutlinedButton.icon(
                  onPressed: () {
                    // Edit the article
                    Get.back();
                    _showEditArticleDialog(article);
                  },
                  icon: const Icon(Icons.edit),
                  label: const Text('Edit Article'),
                ),
                ElevatedButton(
                  onPressed: () => Get.back(),
                  style: ElevatedButton.styleFrom(
                    backgroundColor: Colors.deepPurpleAccent,
                  ),
                  child: const Text('CLOSE'),
                ),
              ],
            ),
          ],
        ),
      ),
    ),
  );
}

void _showEditArticleDialog(Map<String, dynamic> article) {
  final titleController =
      TextEditingController(text: article['title'] as String);
  final contentController =
      TextEditingController(text: article['content'] as String);
  final summaryController =
      TextEditingController(text: article['summary'] as String);
  final List<String> categories = [
    'Account',
    'Billing',
    'Game Play',
    'Technical',
    'Feature Request',
    'Bug Report',
    'Other'
  ];
  final RxString selectedCategory = (article['category'] as String).obs;

  Get.dialog(
    Dialog(
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
      child: Container(
        padding: const EdgeInsets.all(16),
        constraints: const BoxConstraints(maxWidth: 800, maxHeight: 700),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            const Text(
              'Edit Knowledge Base Article',
              style: TextStyle(
                fontSize: 18,
                fontWeight: FontWeight.bold,
              ),
            ),
            const SizedBox(height: 16),
            TextField(
              controller: titleController,
              decoration: const InputDecoration(
                labelText: 'Title',
                border: OutlineInputBorder(),
              ),
            ),
            const SizedBox(height: 16),
            TextField(
              controller: summaryController,
              decoration: const InputDecoration(
                labelText: 'Summary',
                border: OutlineInputBorder(),
                hintText: 'Brief description of the article',
              ),
              maxLines: 2,
            ),
            const SizedBox(height: 16),
            Row(
              children: [
                Expanded(
                  child: Obx(() => Container(
                        decoration: BoxDecoration(
                          border:
                              Border.all(color: Colors.grey.withOpacity(0.3)),
                          borderRadius: BorderRadius.circular(8),
                        ),
                        child: DropdownButtonHideUnderline(
                          child: DropdownButton<String>(
                            value: selectedCategory.value,
                            isExpanded: true,
                            icon: const Icon(Icons.arrow_drop_down),
                            iconSize: 24,
                            elevation: 16,
                            padding: const EdgeInsets.symmetric(horizontal: 16),
                            items: categories.map((String category) {
                              return DropdownMenuItem<String>(
                                value: category,
                                child: Text(category),
                              );
                            }).toList(),
                            onChanged: (value) {
                              if (value != null) {
                                selectedCategory.value = value;
                              }
                            },
                          ),
                        ),
                      )),
                ),
              ],
            ),
            const SizedBox(height: 16),
            const Text(
              'Content',
              style: TextStyle(
                fontWeight: FontWeight.bold,
              ),
            ),
            const SizedBox(height: 8),
            Expanded(
              child: TextField(
                controller: contentController,
                decoration: const InputDecoration(
                  border: OutlineInputBorder(),
                  hintText: 'Article content...',
                ),
                maxLines: null,
                expands: true,
              ),
            ),
            const SizedBox(height: 16),
            Row(
              mainAxisAlignment: MainAxisAlignment.end,
              children: [
                TextButton(
                  onPressed: () => Get.back(),
                  child: const Text('CANCEL'),
                ),
                const SizedBox(width: 8),
                ElevatedButton(
                  onPressed: () {
                    if (titleController.text.isEmpty ||
                        contentController.text.isEmpty ||
                        summaryController.text.isEmpty) {
                      errorMessage('Please fill in all fields');
                      return;
                    }

                    // This would update the article in a real app
                    Get.back();
                    successMessage('Article updated successfully');
                  },
                  style: ElevatedButton.styleFrom(
                    backgroundColor: Colors.deepPurpleAccent,
                  ),
                  child: const Text('SAVE'),
                ),
              ],
            ),
          ],
        ),
      ),
    ),
  );
}

Widget _buildTicketPropertyPill({required String label, required Color color}) {
  return Container(
    padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 4),
    decoration: BoxDecoration(
      color: color.withOpacity(0.1),
      borderRadius: BorderRadius.circular(16),
      border: Border.all(color: color.withOpacity(0.3)),
    ),
    child: Text(
      label,
      style: TextStyle(
        color: color,
        fontWeight: FontWeight.bold,
        fontSize: 12,
      ),
    ),
  );
}

Widget _buildTicketActions(
    Map<String, dynamic> ticket, SupportSystemController controller) {
  final status = ticket['status'] as String;
  final ticketId = ticket['id'] as String;

  return Row(
    children: [
      if (status == 'open' || status == 'pending')
        OutlinedButton.icon(
          onPressed: () => _showResolveTicketDialog(ticket, controller),
          icon: const Icon(Icons.check_circle),
          label: const Text('Resolve'),
          style: OutlinedButton.styleFrom(
            foregroundColor: Colors.green,
          ),
        ),
      const SizedBox(width: 8),
      OutlinedButton.icon(
        onPressed: () => _showAssignTicketDialog(ticket, controller),
        icon: const Icon(Icons.person_add),
        label: const Text('Assign'),
      ),
      const SizedBox(width: 8),
      PopupMenuButton(
        icon: const Icon(Icons.more_vert),
        itemBuilder: (context) => [
          const PopupMenuItem(
            value: 'changePriority',
            child: ListTile(
              leading: Icon(Icons.flag),
              title: Text('Change Priority'),
              dense: true,
            ),
          ),
          const PopupMenuItem(
            value: 'changeCategory',
            child: ListTile(
              leading: Icon(Icons.category),
              title: Text('Change Category'),
              dense: true,
            ),
          ),
          const PopupMenuItem(
            value: 'addNote',
            child: ListTile(
              leading: Icon(Icons.note_add),
              title: Text('Add Internal Note'),
              dense: true,
            ),
          ),
          if (status == 'resolved')
            const PopupMenuItem(
              value: 'reopen',
              child: ListTile(
                leading: Icon(Icons.refresh),
                title: Text('Reopen Ticket'),
                dense: true,
              ),
            ),
          const PopupMenuItem(
            value: 'merge',
            child: ListTile(
              leading: Icon(Icons.merge_type),
              title: Text('Merge with Another Ticket'),
              dense: true,
            ),
          ),
          const PopupMenuItem(
            value: 'export',
            child: ListTile(
              leading: Icon(Icons.download),
              title: Text('Export Ticket'),
              dense: true,
            ),
          ),
        ],
        onSelected: (value) {
          switch (value) {
            case 'changePriority':
              _showChangePriorityDialog(ticket, controller);
              break;
            case 'changeCategory':
              _showChangeCategoryDialog(ticket, controller);
              break;
            case 'addNote':
              _showAddNoteDialog(ticket, controller);
              break;
            case 'reopen':
              _showReopenTicketDialog(ticket, controller);
              break;
            case 'merge':
              _showMergeTicketDialog(ticket, controller);
              break;
            case 'export':
              _exportTicket(ticket);
              break;
          }
        },
      ),
    ],
  );
}

void _showMergeTicketDialog(
    Map<String, dynamic> ticket, SupportSystemController controller) {
  final ticketId = ticket['id'] as String;
  final RxString selectedTicketId = ''.obs;

  // Get other open tickets
  final otherTickets = controller
      .getAllTickets()
      .where((t) => t['id'] != ticketId && t['status'] == 'open')
      .toList();

  if (otherTickets.isEmpty) {
    errorMessage('No other open tickets available to merge with');
    return;
  }

  Get.dialog(
    Dialog(
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
      child: Container(
        padding: const EdgeInsets.all(16),
        constraints: const BoxConstraints(maxWidth: 500, maxHeight: 600),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            const Text(
              'Merge Ticket',
              style: TextStyle(
                fontSize: 18,
                fontWeight: FontWeight.bold,
              ),
            ),
            const SizedBox(height: 16),
            const Text(
              'Select another ticket to merge this one with:',
            ),
            const SizedBox(height: 16),
            Expanded(
              child: ListView.builder(
                itemCount: otherTickets.length,
                itemBuilder: (context, index) {
                  final otherTicket = otherTickets[index];
                  final otherTicketId = otherTicket['id'] as String;

                  return Obx(() => RadioListTile<String>(
                        title: Text(otherTicket['subject'] as String),
                        subtitle: Text('From: ${otherTicket['userName']}'),
                        value: otherTicketId,
                        groupValue: selectedTicketId.value,
                        onChanged: (value) {
                          selectedTicketId.value = value!;
                        },
                      ));
                },
              ),
            ),
            const SizedBox(height: 16),
            Row(
              mainAxisAlignment: MainAxisAlignment.end,
              children: [
                TextButton(
                  onPressed: () => Get.back(),
                  child: const Text('CANCEL'),
                ),
                const SizedBox(width: 8),
                Obx(() => ElevatedButton(
                      onPressed: selectedTicketId.value.isEmpty
                          ? null
                          : () {
                              controller
                                  .mergeTickets(
                                ticketId,
                                selectedTicketId.value,
                              )
                                  .then((success) {
                                if (success) {
                                  Get.back();
                                  successMessage('Tickets merged successfully');
                                }
                              });
                            },
                      style: ElevatedButton.styleFrom(
                        backgroundColor: Colors.deepPurpleAccent,
                      ),
                      child: const Text('MERGE'),
                    )),
              ],
            ),
          ],
        ),
      ),
    ),
  );
}

void _exportTicket(Map<String, dynamic> ticket) {
  // This would be implemented to export ticket data to a file
  successMessage('Ticket exported successfully');
}

Widget _buildUserCard({
  required String userName,
  required String userEmail,
  required String? userImage,
  required String userId,
}) {
  return Container(
    padding: const EdgeInsets.all(16),
    decoration: BoxDecoration(
      color: Colors.white,
      borderRadius: BorderRadius.circular(8),
      boxShadow: [
        BoxShadow(
          color: Colors.grey.withOpacity(0.1),
          blurRadius: 10,
          spreadRadius: 1,
        ),
      ],
    ),
    child: Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        const Text(
          'User Information',
          style: TextStyle(
            fontWeight: FontWeight.bold,
            fontSize: 16,
          ),
        ),
        const SizedBox(height: 16),
        Row(
          children: [
            AvatarUserWidget(
              radius: 25,
              imagePath: userImage ?? '',
            ),
            const SizedBox(width: 16),
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    userName,
                    style: const TextStyle(
                      fontWeight: FontWeight.bold,
                      fontSize: 16,
                    ),
                  ),
                  Text(
                    userEmail,
                    style: TextStyle(
                      color: Colors.grey[700],
                      fontSize: 14,
                    ),
                  ),
                  Text(
                    'User ID: ${userId.substring(0, 8)}...',
                    style: TextStyle(
                      color: Colors.grey[700],
                      fontSize: 12,
                    ),
                  ),
                ],
              ),
            ),
          ],
        ),
        const SizedBox(height: 16),
        Row(
          mainAxisAlignment: MainAxisAlignment.end,
          children: [
            OutlinedButton.icon(
              onPressed: () => Get.toNamed('/admin/users/$userId'),
              icon: const Icon(Icons.person),
              label: const Text('View Profile'),
            ),
            const SizedBox(width: 8),
            OutlinedButton.icon(
              onPressed: () {
                // Show user's previous tickets
              },
              icon: const Icon(Icons.history),
              label: const Text('View History'),
            ),
          ],
        ),
      ],
    ),
  );
}

Widget _buildTicketInfoCard({
  required DateTime createdAt,
  required String? assignedTo,
  required SupportSystemController controller,
  required Map<String, dynamic> ticket,
}) {
  return Container(
    padding: const EdgeInsets.all(16),
    decoration: BoxDecoration(
      color: Colors.white,
      borderRadius: BorderRadius.circular(8),
      boxShadow: [
        BoxShadow(
          color: Colors.grey.withOpacity(0.1),
          blurRadius: 10,
          spreadRadius: 1,
        ),
      ],
    ),
    child: Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        const Text(
          'Ticket Details',
          style: TextStyle(
            fontWeight: FontWeight.bold,
            fontSize: 16,
          ),
        ),
        const SizedBox(height: 16),
        _buildInfoRow(
          label: 'Created',
          value: DateFormat('MMM dd, yyyy - HH:mm').format(createdAt),
        ),
        const SizedBox(height: 8),
        _buildInfoRow(
          label: 'Assigned To',
          value: assignedTo ?? 'Unassigned',
          valueColor:
              assignedTo != null ? Colors.deepPurpleAccent : Colors.grey,
        ),
        const SizedBox(height: 8),
        _buildInfoRow(
          label: 'Device',
          value: ticket['deviceInfo'] as String? ?? 'Unknown',
        ),
        const SizedBox(height: 8),
        _buildInfoRow(
          label: 'App Version',
          value: ticket['appVersion'] as String? ?? 'Unknown',
        ),
        const SizedBox(height: 8),
        _buildInfoRow(
          label: 'Platform',
          value: ticket['platform'] as String? ?? 'Unknown',
        ),
        const SizedBox(height: 16),
        // Tags
        const Text(
          'Tags',
          style: TextStyle(
            fontWeight: FontWeight.bold,
          ),
        ),
        const SizedBox(height: 8),
        Wrap(
          spacing: 8,
          runSpacing: 8,
          children: [
            ...(ticket['tags'] as List<dynamic>? ?? [])
                .map((tag) => _buildTagChip(
                      tag: tag as String,
                      onDeleted: () {
                        // Remove tag
                        controller.removeTagFromTicket(
                            ticket['id'] as String, tag);
                      },
                    )),
            ActionChip(
              label: const Text('Add Tag'),
              avatar: const Icon(Icons.add, size: 16),
              onPressed: () => _showAddTagDialog(ticket, controller),
            ),
          ],
        ),
      ],
    ),
  );
}

```

---


### Pages\Admin\Pages\widgets\admin_access_widget.dart

```dart
// Đoạn code này thêm vào trang MainHome.dart trong phần drawer hoặc menu profile

// Import các thư viện cần thiết
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:flutter/material.dart';
import 'package:get/get.dart';

// Class để kiểm tra và hiển thị nút Admin
class AdminAccessWidget extends StatelessWidget {
  final FirebaseAuth _auth = FirebaseAuth.instance;
  final FirebaseFirestore _firestore = FirebaseFirestore.instance;

  AdminAccessWidget({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return FutureBuilder<bool>(
      future: _checkIsAdmin(),
      builder: (context, snapshot) {
        if (snapshot.connectionState == ConnectionState.waiting) {
          return const SizedBox.shrink();
        }

        if (snapshot.hasData && snapshot.data == true) {
          return _buildAdminButton();
        }

        return const SizedBox.shrink();
      },
    );
  }

  Widget _buildAdminButton() {
    return Column(
      children: [
        const Divider(),
        ListTile(
          leading: Container(
            padding: const EdgeInsets.all(8),
            decoration: BoxDecoration(
              color: Colors.deepPurpleAccent.withOpacity(0.1),
              borderRadius: BorderRadius.circular(8),
            ),
            child: const Icon(
              Icons.admin_panel_settings,
              color: Colors.deepPurpleAccent,
            ),
          ),
          title: const Text(
            'Quản Trị Viên',
            style: TextStyle(
              fontWeight: FontWeight.bold,
            ),
          ),
          subtitle: const Text('Truy cập bảng điều khiển admin'),
          onTap: () {
            Get.toNamed('/admin');
          },
        ),
      ],
    );
  }

  Future<bool> _checkIsAdmin() async {
    try {
      final user = _auth.currentUser;
      if (user == null) {
        return false;
      }

      final userDoc = await _firestore.collection('users').doc(user.uid).get();
      if (!userDoc.exists) {
        return false;
      }

      final userData = userDoc.data() as Map<String, dynamic>;
      return userData['role'] == 'admin';
    } catch (e) {
      print('Error checking admin role: $e');
      return false;
    }
  }
}

// Thêm đoạn này vào Drawer hoặc menu profile của MainHome.dart
// ...
// Các menu item khác
// ...
// AdminAccessWidget(), // Thêm dòng này
// ...
```

---


### Pages\Admin\services\admin_service.dart

```dart
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:tictactoe_gameapp/Pages/Admin/models/user_model.dart';

class AdminService {
  final FirebaseFirestore _firestore = FirebaseFirestore.instance;
  final FirebaseAuth _auth = FirebaseAuth.instance;

  // Trong AdminService.getAllUsers()
  Future<List<UserModel>> getAllUsers({
    String? searchQuery,
    String? role,
    bool? verified,
    bool? suspended,
    String? orderBy,
    bool descending = false,
    int limit = 100, // Tăng giới hạn lên
    DocumentSnapshot? startAfter,
  }) async {
    try {
      // Bỏ qua tất cả các điều kiện lọc nếu muốn hiển thị tất cả
      Query query = _firestore.collection('users');

      // Chỉ áp dụng bộ lọc theo vai trò nếu được chỉ định
      if (role != null && role != 'all') {
        query = query.where('role', isEqualTo: role);
      }

      // Luôn lấy toàn bộ người dùng
      query = query.limit(limit);

      final snapshot = await query.get();
      final users = snapshot.docs.map((doc) {
        Map<String, dynamic> data = doc.data() as Map<String, dynamic>;
        data['id'] = doc.id; // Đảm bảo ID được đưa vào
        return UserModel.fromJson(data);
      }).toList();

      return users;
    } catch (e) {
      print('Error getting users: $e');
      return [];
    }
  }

  Future<UserModel?> getUserById(String userId) async {
    try {
      final doc = await _firestore.collection('users').doc(userId).get();
      if (!doc.exists) return null;

      Map<String, dynamic> data = doc.data() as Map<String, dynamic>;
      data['id'] = doc.id; // Ensure the ID is included
      return UserModel.fromJson(data);
    } catch (e) {
      print('Error getting user by id: $e');
      return null;
    }
  }

  Future<bool> updateUserRole(String userId, String newRole) async {
    try {
      await _firestore.collection('users').doc(userId).update({
        'role': newRole,
        'updatedAt': FieldValue.serverTimestamp(),
      });
      return true;
    } catch (e) {
      print('Error updating user role: $e');
      return false;
    }
  }

  Future<bool> batchUserOperation(
      List<String> userIds, String operation) async {
    try {
      final batch = _firestore.batch();

      for (final userId in userIds) {
        final userRef = _firestore.collection('users').doc(userId);

        switch (operation) {
          case 'verify':
            batch.update(userRef, {
              'verified': true,
              'updatedAt': FieldValue.serverTimestamp(),
            });
            break;
          case 'suspend':
            batch.update(userRef, {
              'suspended': true,
              'updatedAt': FieldValue.serverTimestamp(),
            });
            break;
          case 'activate':
            batch.update(userRef, {
              'suspended': false,
              'updatedAt': FieldValue.serverTimestamp(),
            });
            break;
          case 'delete':
            batch.delete(userRef);
            break;
          default:
            throw Exception('Unknown operation: $operation');
        }
      }

      await batch.commit();
      return true;
    } catch (e) {
      print('Error performing batch operation: $e');
      return false;
    }
  }

  // Content Moderation
  Future<List<Map<String, dynamic>>> getReportedContent({
    String? contentType,
    String? status,
    DocumentSnapshot? startAfter,
    int limit = 20,
  }) async {
    try {
      Query query = _firestore.collection('reported_content');

      if (contentType != null && contentType != 'all') {
        query = query.where('contentType', isEqualTo: contentType);
      }

      if (status != null) {
        query = query.where('status', isEqualTo: status);
      }

      query = query.orderBy('reportedAt', descending: true);

      if (startAfter != null) {
        query = query.startAfterDocument(startAfter);
      }

      query = query.limit(limit);

      final snapshot = await query.get();

      return snapshot.docs.map((doc) {
        Map<String, dynamic> data = doc.data() as Map<String, dynamic>;
        data['id'] = doc.id;
        return data;
      }).toList();
    } catch (e) {
      print('Error getting reported content: $e');
      return [];
    }
  }

  Future<bool> moderateContent({
    required String contentType,
    required String contentId,
    required String action,
    String? reason,
  }) async {
    try {
      // Get the current user (admin)
      final currentUser = _auth.currentUser;
      if (currentUser == null) return false;

      // Create moderation record
      final moderationRef = _firestore.collection('content_moderation').doc();

      await moderationRef.set({
        'contentType': contentType,
        'contentId': contentId,
        'action': action,
        'reason': reason,
        'moderatorId': currentUser.uid,
        'moderatedAt': FieldValue.serverTimestamp(),
      });

      // Update the content based on action
      final contentRef = _getContentReference(contentType, contentId);

      switch (action) {
        case 'hide':
          await contentRef.update({
            'hidden': true,
            'hiddenBy': currentUser.uid,
            'hiddenAt': FieldValue.serverTimestamp(),
            'hiddenReason': reason,
          });
          break;
        case 'delete':
          await contentRef.delete();
          break;
        case 'restore':
          await contentRef.update({
            'hidden': false,
            'restoredBy': currentUser.uid,
            'restoredAt': FieldValue.serverTimestamp(),
          });
          break;
        case 'warn':
          // Get the user who created the content
          final contentData =
              (await contentRef.get()).data() as Map<String, dynamic>?;
          if (contentData != null && contentData['userId'] != null) {
            final userRef =
                _firestore.collection('users').doc(contentData['userId']);

            // Add warning to user
            await userRef.collection('warnings').add({
              'contentType': contentType,
              'contentId': contentId,
              'reason': reason,
              'warnedBy': currentUser.uid,
              'warnedAt': FieldValue.serverTimestamp(),
            });

            // Update warning count
            await userRef.update({
              'warningCount': FieldValue.increment(1),
              'updatedAt': FieldValue.serverTimestamp(),
            });
          }
          break;
        default:
          throw Exception('Unknown action: $action');
      }

      // Update status in reported_content collection
      await _firestore
          .collection('reported_content')
          .where('contentType', isEqualTo: contentType)
          .where('contentId', isEqualTo: contentId)
          .get()
          .then((snapshot) {
        final batch = _firestore.batch();
        for (final doc in snapshot.docs) {
          batch.update(doc.reference, {
            'status': action,
            'resolvedBy': currentUser.uid,
            'resolvedAt': FieldValue.serverTimestamp(),
          });
        }
        return batch.commit();
      });

      return true;
    } catch (e) {
      print('Error moderating content: $e');
      return false;
    }
  }

  DocumentReference _getContentReference(String contentType, String contentId) {
    switch (contentType) {
      case 'post':
        return _firestore.collection('posts').doc(contentId);
      case 'comment':
        return _firestore.collection('comments').doc(contentId);
      case 'reel':
        return _firestore.collection('reels').doc(contentId);
      case 'user':
        return _firestore.collection('users').doc(contentId);
      default:
        throw Exception('Unknown content type: $contentType');
    }
  }

  // Analytics
  Future<Map<String, dynamic>> getAnalytics() async {
    try {
      // Get user analytics
      final usersSnapshot = await _firestore.collection('users').get();
      final usersByRole = <String, int>{};

      for (final doc in usersSnapshot.docs) {
        final data = doc.data();
        final role = data['role'] as String? ?? 'user';
        usersByRole[role] = (usersByRole[role] ?? 0) + 1;
      }

      // Get content analytics
      final postsSnapshot = await _firestore.collection('posts').get();
      final recentPostsSnapshot = await _firestore
          .collection('posts')
          .where('createdAt',
              isGreaterThan: Timestamp.fromDate(
                  DateTime.now().subtract(const Duration(days: 7))))
          .get();

      // Get reported content analytics
      final reportedContentSnapshot =
          await _firestore.collection('reported_content').get();

      // Get game analytics
      final gameDataSnapshot = await _firestore
          .collection('game_data')
          .where('status', isEqualTo: 'active')
          .get();

      return {
        'totalUsers': usersSnapshot.docs.length,
        'usersByRole': usersByRole,
        'totalPosts': postsSnapshot.docs.length,
        'recentPosts': recentPostsSnapshot.docs.length,
        'reportedContent': reportedContentSnapshot.docs.length,
        'activeGames': gameDataSnapshot.docs.length,
      };
    } catch (e) {
      print('Error getting analytics: $e');
      return {};
    }
  }

  Future<Map<String, dynamic>> getCustomAnalyticsRange(
    DateTime startDate,
    DateTime endDate,
  ) async {
    try {
      final startTimestamp = Timestamp.fromDate(startDate);
      final endTimestamp = Timestamp.fromDate(endDate);

      // Get new users in range
      final newUsersSnapshot = await _firestore
          .collection('users')
          .where('createdAt', isGreaterThanOrEqualTo: startTimestamp)
          .where('createdAt', isLessThanOrEqualTo: endTimestamp)
          .get();

      // Get new posts in range
      final newPostsSnapshot = await _firestore
          .collection('posts')
          .where('createdAt', isGreaterThanOrEqualTo: startTimestamp)
          .where('createdAt', isLessThanOrEqualTo: endTimestamp)
          .get();

      // Get games played in range
      final gamesPlayedSnapshot = await _firestore
          .collection('game_data')
          .where('createdAt', isGreaterThanOrEqualTo: startTimestamp)
          .where('createdAt', isLessThanOrEqualTo: endTimestamp)
          .get();

      return {
        'newUsers': newUsersSnapshot.docs.length,
        'newPosts': newPostsSnapshot.docs.length,
        'gamesPlayed': gamesPlayedSnapshot.docs.length,
        'startDate': startDate,
        'endDate': endDate,
      };
    } catch (e) {
      print('Error getting custom analytics: $e');
      return {};
    }
  }

  // Announcements
  Future<List<Map<String, dynamic>>> getAnnouncements({
    bool activeOnly = false,
    String? type,
    DocumentSnapshot? startAfter,
    int limit = 20,
  }) async {
    try {
      Query query = _firestore.collection('announcements');

      if (activeOnly) {
        final now = Timestamp.fromDate(DateTime.now());

        query = query
            .where('active', isEqualTo: true)
            .where('startDate', isLessThanOrEqualTo: now);

        // We can't use multiple range operators in a compound query
        // So we'll filter end dates in the app
      }

      if (type != null && type != 'all') {
        query = query.where('type', isEqualTo: type);
      }

      query = query.orderBy(activeOnly ? 'startDate' : 'createdAt',
          descending: true);

      if (startAfter != null) {
        query = query.startAfterDocument(startAfter);
      }

      query = query.limit(limit);

      final snapshot = await query.get();

      List<Map<String, dynamic>> announcements = snapshot.docs.map((doc) {
        Map<String, dynamic> data = doc.data() as Map<String, dynamic>;
        data['id'] = doc.id;
        return data;
      }).toList();

      // If activeOnly, filter out announcements with passed end dates
      if (activeOnly) {
        final now = DateTime.now();

        announcements = announcements.where((announcement) {
          if (announcement['endDate'] == null) return true;

          final endDate = (announcement['endDate'] as Timestamp).toDate();
          return endDate.isAfter(now);
        }).toList();
      }

      return announcements;
    } catch (e) {
      print('Error getting announcements: $e');
      return [];
    }
  }

  Future<bool> createAnnouncement({
    required String title,
    required String message,
    required String type,
    String? targetAudience,
    DateTime? startDate,
    DateTime? endDate,
  }) async {
    try {
      final announcementRef = _firestore.collection('announcements').doc();

      await announcementRef.set({
        'title': title,
        'message': message,
        'type': type,
        'targetAudience': targetAudience ?? 'all',
        'startDate':
            startDate != null ? Timestamp.fromDate(startDate) : Timestamp.now(),
        'endDate': endDate != null ? Timestamp.fromDate(endDate) : null,
        'createdAt': FieldValue.serverTimestamp(),
        'createdBy': _auth.currentUser?.uid,
        'active': true,
      });

      return true;
    } catch (e) {
      print('Error creating announcement: $e');
      return false;
    }
  }

  Future<bool> updateAnnouncement(
      String announcementId, Map<String, dynamic> updateData) async {
    try {
      final Map<String, dynamic> dataToUpdate = {};

      // Convert DateTime to Timestamp for Firestore
      updateData.forEach((key, value) {
        if (value is DateTime) {
          dataToUpdate[key] = Timestamp.fromDate(value);
        } else {
          dataToUpdate[key] = value;
        }
      });

      dataToUpdate['updatedAt'] = FieldValue.serverTimestamp();
      dataToUpdate['updatedBy'] = _auth.currentUser?.uid;

      await _firestore
          .collection('announcements')
          .doc(announcementId)
          .update(dataToUpdate);

      return true;
    } catch (e) {
      print('Error updating announcement: $e');
      return false;
    }
  }

  Future<bool> deleteAnnouncement(String announcementId) async {
    try {
      await _firestore.collection('announcements').doc(announcementId).delete();
      return true;
    } catch (e) {
      print('Error deleting announcement: $e');
      return false;
    }
  }

  // Game Management
  Future<List<Map<String, dynamic>>> getGameLeaderboard(String gameId) async {
    try {
      final snapshot = await _firestore
          .collection('game_leaderboards')
          .doc(gameId)
          .collection('entries')
          .orderBy('score', descending: true)
          .limit(100)
          .get();

      List<Map<String, dynamic>> leaderboard = [];

      // For each leaderboard entry, get the user data
      for (final doc in snapshot.docs) {
        Map<String, dynamic> entry = doc.data();
        entry['id'] = doc.id;

        if (entry['userId'] != null) {
          final userDoc =
              await _firestore.collection('users').doc(entry['userId']).get();
          if (userDoc.exists) {
            final userData = userDoc.data() as Map<String, dynamic>;
            entry['user'] = {
              'id': userDoc.id,
              'name': userData['name'],
              'image': userData['image'],
              'role': userData['role'],
            };
          }
        }

        leaderboard.add(entry);
      }

      return leaderboard;
    } catch (e) {
      print('Error getting game leaderboard: $e');
      return [];
    }
  }

  Future<bool> updateGameConfig(
      String gameId, Map<String, dynamic> config) async {
    try {
      await _firestore.collection('game_configs').doc(gameId).set(
        {
          ...config,
          'updatedAt': FieldValue.serverTimestamp(),
          'updatedBy': _auth.currentUser?.uid,
        },
        SetOptions(merge: true),
      );
      return true;
    } catch (e) {
      print('Error updating game config: $e');
      return false;
    }
  }

  // Admin Settings
  Future<Map<String, dynamic>> getAdminSettings() async {
    try {
      final doc = await _firestore.collection('admin').doc('settings').get();

      if (!doc.exists) {
        // Create default settings if they don't exist
        final defaultSettings = {
          'maintenanceMode': false,
          'enableRealTimeReports': true,
          'enableBackupDaily': true,
          'notifyAdminsOnReport': true,
          'autoDeleteReportsAfterDays': 30,
          'createdAt': FieldValue.serverTimestamp(),
        };

        await _firestore
            .collection('admin')
            .doc('settings')
            .set(defaultSettings);
        return defaultSettings;
      }

      return doc.data() as Map<String, dynamic>;
    } catch (e) {
      print('Error getting admin settings: $e');
      return {};
    }
  }

  Future<bool> updateAdminSettings(Map<String, dynamic> settings) async {
    try {
      await _firestore.collection('admin').doc('settings').update({
        ...settings,
        'updatedAt': FieldValue.serverTimestamp(),
        'updatedBy': _auth.currentUser?.uid,
      });
      return true;
    } catch (e) {
      print('Error updating admin settings: $e');
      return false;
    }
  }

  // Authentication Checks
  Future<bool> isCurrentUserAdmin() async {
    try {
      final user = _auth.currentUser;
      if (user == null) return false;

      final userDoc = await _firestore.collection('users').doc(user.uid).get();

      if (!userDoc.exists) return false;

      final userData = userDoc.data() as Map<String, dynamic>;
      return userData['role'] == 'admin';
    } catch (e) {
      print('Error checking admin access: $e');
      return false;
    }
  }
}

```

---


### Pages\Auth\auth_page.dart

```dart
import 'package:flutter/material.dart';
import 'package:flutter_svg/flutter_svg.dart';
import 'package:get/get.dart';
import 'package:tictactoe_gameapp/Components/primary_with_icon_button.dart';
import 'package:tictactoe_gameapp/Configs/assets_path.dart';
import 'package:tictactoe_gameapp/Pages/Login/login_sheet.dart';
import 'package:tictactoe_gameapp/Pages/Registration/Register_sheet.dart';

import '../../Controller/auth_controller.dart';

class AuthPage extends StatelessWidget {
  const AuthPage({super.key});

  @override
  Widget build(BuildContext context) {
    final AuthController authController = Get.find<AuthController>();

    return Scaffold(
      backgroundColor: Theme.of(context).colorScheme.surface,
      body: Padding(
        padding: const EdgeInsets.all(10.0),
        child: SafeArea(
          child: SingleChildScrollView(
            child: Stack(
              children: [
                Column(
                  mainAxisAlignment: MainAxisAlignment.center,
                  children: [
                    Row(
                      mainAxisAlignment: MainAxisAlignment.center,
                      children: [
                        Image.asset(
                          IconsPath.applogo,
                          width: 120,
                        )
                      ],
                    ),
                    const SizedBox(
                      height: 20,
                    ),
                    Text(
                      "title_auth".tr,
                      style: Theme.of(context).textTheme.bodyLarge,
                    ),
                    Text(
                      "description_auth".tr,
                      style: Theme.of(context).textTheme.bodySmall,
                    ),
                    const SizedBox(
                      height: 20,
                    ),
                    ClipRRect(
                      borderRadius: BorderRadius.circular(20),
                      child: Image.asset(
                        GifsPath.chloe1,
                        width: 120,
                      ),
                    ),
                    const SizedBox(
                      height: 20,
                    ),
                    Column(
                      children: [
                        SizedBox(
                          width: double.maxFinite,
                          child: Row(
                            mainAxisAlignment: MainAxisAlignment.center,
                            children: [
                              Expanded(
                                child: PrimaryIconWithButton(
                                  buttonText: "Sign in",
                                  onTap: () async {
                                    await loginBottomSheet(context);
                                  },
                                  iconPath: IconsPath.applogo,
                                  isLogo: true,
                                  color: Theme.of(context)
                                      .colorScheme
                                      .primary
                                      .withOpacity(0.3),
                                ),
                              ),
                              const SizedBox(
                                width: 20,
                              ),
                              Expanded(
                                child: PrimaryIconWithButton(
                                  buttonText: "Sign up",
                                  onTap: () async {
                                    await registerBottomSheet(context);
                                  },
                                  iconPath: IconsPath.applogo,
                                  isLogo: true,
                                  color: Theme.of(context)
                                      .colorScheme
                                      .primary
                                      .withOpacity(0.2),
                                ),
                              ),
                            ],
                          ),
                        ),
                        const SizedBox(
                          height: 10,
                        ),
                        PrimaryIconWithButton(
                            color: Colors.redAccent.withOpacity(0.5),
                            width: double.infinity,
                            buttonText: "google_auth".tr,
                            onTap: () {
                              authController.loginByGoogle();
                            },
                            iconPath: IconsPath.google),
                        const SizedBox(
                          height: 10,
                        ),
                        PrimaryIconWithButton(
                          buttonText: "facebook_auth".tr,
                          width: double.infinity,
                          color: Colors.lightBlueAccent,
                          onTap: () {
                            authController.loginByGoogle();
                          },
                          iconPath: IconsPath.facebook,
                        ),
                        const SizedBox(
                          height: 10,
                        ),
                        PrimaryIconWithButton(
                            buttonText: "github_auth".tr,
                            width: double.infinity,
                            color: Colors.grey,
                            onTap: () {
                              authController.loginByGoogle();
                            },
                            iconPath: IconsPath.github),
                      ],
                    )
                  ],
                ),
                Positioned(
                  top: 0,
                  right: 10,
                  child: InkWell(
                    borderRadius: BorderRadius.circular(100),
                    splashColor: Colors.blueAccent,
                    onTap: () => Get.toNamed("/settings"),
                    child: Ink(
                      width: 40,
                      height: 40,
                      child: Image.asset("assets/icons/settings.png"),
                    ),
                  ),
                )
              ],
            ),
          ),
        ),
      ),
    );
  }
}

```

---


### Pages\Chat\chat_screen.dart

```dart
// chat_screen.dart
import 'dart:io';
import 'package:animated_text_kit/animated_text_kit.dart';
import 'package:flutter/material.dart';
import 'package:flutter_animate/flutter_animate.dart';
import 'package:get/get.dart';
import 'package:image_picker/image_picker.dart';
import 'package:tictactoe_gameapp/Components/belong_to_users/avatar_user_widget.dart';
import 'package:tictactoe_gameapp/Configs/assets_path.dart';
import 'package:tictactoe_gameapp/Configs/messages.dart';
import 'package:tictactoe_gameapp/Controller/Animations/dot_matching_animation_controller.dart';
import 'package:tictactoe_gameapp/Controller/Music/background_music_controller.dart';
import 'package:tictactoe_gameapp/Controller/text_to_speech_controller.dart';
import 'package:tictactoe_gameapp/Data/gemini_api_controller.dart';
import 'package:tictactoe_gameapp/Controller/profile_controller.dart';
import 'package:tictactoe_gameapp/Controller/speech_to_text_controller.dart';
import 'package:tictactoe_gameapp/Pages/Chat/Widgets/chat_mess_item.dart';
import 'package:tictactoe_gameapp/Pages/Chat/Widgets/option_card.dart';
import 'package:tictactoe_gameapp/Pages/Chat/Widgets/section_widget.dart';
import 'package:tictactoe_gameapp/Components/customized_widgets/tts_change_setting_widget.dart';
import 'package:tictactoe_gameapp/Components/emotes_picker_widget.dart';

class ChatBotPage extends StatelessWidget {
  const ChatBotPage({super.key});

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final SpeechController speechController = Get.put(SpeechController());
    final ProfileController profileController = Get.find<ProfileController>();
    final user = profileController.user!;
    final ChatController chatController = Get.put(ChatController());
    final TextEditingController textController = TextEditingController();
    final GlobalKey<RefreshIndicatorState> refreshKey =
        GlobalKey<RefreshIndicatorState>();
    final TextToSpeechController ttsController =
        Get.put(TextToSpeechController());
    RxString imagePath = "".obs;
    RxBool isEmojiPickerVisible = false.obs;

    XFile? image;
    double appBarHeight = AppBar().preferredSize.height;
    final MatchingAnimationController matchingAnimationController =
        Get.put(MatchingAnimationController());

    return Scaffold(
      resizeToAvoidBottomInset: true,
      appBar: AppBar(
        flexibleSpace: Container(
          decoration: const BoxDecoration(
            gradient: LinearGradient(
              colors: [Colors.lightGreenAccent, Colors.lightBlue],
              begin: Alignment.topLeft,
              end: Alignment.bottomRight,
            ),
          ),
        ),
        backgroundColor: Colors.lightBlueAccent,
        title: Row(
          mainAxisAlignment: MainAxisAlignment.spaceBetween,
          children: [
            const CircleAvatar(
              backgroundImage: AssetImage(GifsPath.chloe1),
            ),
            Expanded(
              child: Row(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  Obx(
                    () {
                      return speechController.isListening.value
                          ? IconButton(
                              onPressed: () async {
                                await speechController.stopListening();
                                if (speechController
                                    .lastWords.value.isNotEmpty) {
                                  await chatController.sendPrompt(
                                      speechController.lastWords.value);
                                } else {
                                  await chatController
                                      .sendPrompt("Can you hear me?");
                                }
                              },
                              icon: const Icon(
                                Icons.done_outline_rounded,
                              ),
                            )
                          : IconButton(
                              onPressed: () async {
                                await speechController.startListening();
                              },
                              icon: const Icon(Icons.mic),
                            );
                    },
                  ),
                  Obx(() {
                    return Text(
                      speechController.isListening.value
                          ? "Listening ... 😴 ${speechController.lastWords.value}"
                          : "Chloe",
                      style: Theme.of(context).textTheme.headlineSmall,
                    );
                  }),
                  IconButton(
                    onPressed: () {
                      Get.dialog(
                        Stack(
                          children: [
                            Positioned(
                              top: appBarHeight, // Đặt dialog ngay dưới AppBar
                              left: 0,
                              right: 0,
                              child: Material(
                                child: TtsChangeSettingWidget(
                                  ttsController: ttsController,
                                ),
                              ),
                            ),
                          ],
                        ),
                      );
                    },
                    icon: const Icon(Icons.keyboard_arrow_down_sharp),
                  ),
                ],
              ),
            ),
            user.image != null && user.image!.isNotEmpty
                ? AvatarUserWidget(
                    radius: 25,
                    imagePath: user.image!,
                    gradientColors:
                        user.avatarFrame ?? ["#FF2196F3", "#FF42A5F5"],
                  )
                : const Icon(Icons.person_2_outlined)
          ],
        ),
      ),
      body: DecoratedBox(
        decoration: const BoxDecoration(
          gradient: LinearGradient(
            colors: [Colors.grey, Colors.white54, Colors.blueGrey],
            begin: Alignment.topCenter,
            end: Alignment.bottomCenter,
          ),
        ),
        child: Padding(
          padding: const EdgeInsets.only(left: 10, right: 10, bottom: 5),
          child: Column(
            children: [
              Expanded(
                child: Obx(
                  () => RefreshIndicator(
                    key: refreshKey,
                    backgroundColor: Colors.white,
                    color: Colors.blue,
                    onRefresh: () => chatController.refreshChat(),
                    child: chatController.messages.isEmpty
                        ? SingleChildScrollView(
                            child: Padding(
                              padding: const EdgeInsets.all(10),
                              child: Column(
                                children: [
                                  Container(
                                    height: 50,
                                    width: double.infinity,
                                    alignment: Alignment.center,
                                    decoration: BoxDecoration(
                                        color: Colors.lightBlue.shade100,
                                        borderRadius: BorderRadius.circular(20),
                                        border: Border.all(
                                          color: Colors.white,
                                          width: 2,
                                        ),
                                        boxShadow: const [
                                          BoxShadow(
                                            color: Colors.white,
                                            spreadRadius: 2.0,
                                            blurRadius: 3.0,
                                            offset: Offset(0, 2.0),
                                          )
                                        ]),
                                    child: AnimatedTextKit(
                                      totalRepeatCount: 1,
                                      animatedTexts: [
                                        TypewriterAnimatedText(
                                          "Hi ${user.name ?? " "}",
                                          speed:
                                              const Duration(milliseconds: 100),
                                          textStyle: theme
                                              .textTheme.headlineLarge!
                                              .copyWith(
                                                  color: Colors.deepPurple),
                                        )
                                      ],
                                    ),
                                  ),
                                  const SizedBox(
                                    height: 10,
                                  ),
                                  const SectionWidget(
                                    options: [
                                      OptionCard(
                                        icon: Icons.article,
                                        title: 'Write an Articles',
                                        description:
                                            'Generate well-written articles on any topic you want.',
                                      ),
                                      OptionCard(
                                        icon: Icons.school,
                                        title: 'Academic Writer',
                                        description:
                                            'Generate educational writing such as essays, reports, etc.',
                                      ),
                                    ],
                                  ),
                                  const SizedBox(
                                    height: 5,
                                  ),
                                  const SectionWidget(
                                    options: [
                                      OptionCard(
                                        icon: Icons.science,
                                        title: 'Write an Science',
                                        description:
                                            'Generate well-written articles on any topic you want.',
                                      ),
                                      OptionCard(
                                        icon: Icons.favorite,
                                        title: 'Favorite Crusher',
                                        description:
                                            'Generate educational writing such as essays, reports, etc.',
                                      ),
                                    ],
                                  ),
                                  const SectionWidget(
                                    options: [
                                      OptionCard(
                                        icon: Icons.tv,
                                        title: 'Write a Content',
                                        description:
                                            'Generate well-written articles on any topic you want.',
                                      ),
                                      OptionCard(
                                        icon: Icons.image,
                                        title: 'Favorite Images',
                                        description:
                                            'Generate educational writing such as essays, reports, etc.',
                                      ),
                                    ],
                                  ),
                                ],
                              ),
                            ),
                          )
                        : Stack(
                            children: [
                              NotificationListener<ScrollNotification>(
                                onNotification:
                                    (ScrollNotification scrollInfo) {
                                  if (scrollInfo is ScrollUpdateNotification) {
                                    if (chatController
                                            .isOpenedJumpButton.value =
                                        chatController.messages.length > 2) {
                                      chatController.isOpenedJumpButton.value =
                                          true;
                                      chatController.resetHideButtonTimer();
                                    }
                                    if (scrollInfo.metrics.pixels ==
                                        scrollInfo.metrics.maxScrollExtent) {
                                      if (chatController
                                          .isOpenedJumpButton.value) {
                                        chatController
                                            .isOpenedJumpButton.value = false;
                                      }
                                    }
                                  }
                                  return true;
                                },
                                child: ListView.builder(
                                  controller: chatController.scrollController,
                                  itemCount: chatController.messages.length,
                                  itemBuilder: (context, index) {
                                    final message =
                                        chatController.messages[index];
                                    return ChatMessageItem(
                                      chatController: chatController,
                                      message: message,
                                      user: user,
                                      ttsController: ttsController,
                                    ).animate().slide(
                                        duration:
                                            const Duration(milliseconds: 750));
                                  },
                                ),
                              ),
                              Align(
                                alignment: Alignment.bottomCenter,
                                child: Obx(() => chatController
                                        .isOpenedJumpButton.value
                                    ? IconButton(
                                        onPressed: chatController.scrollDown,
                                        icon: const Icon(
                                          Icons.arrow_downward,
                                          size: 25,
                                          color: Colors.white,
                                        ),
                                      )
                                    : const SizedBox.shrink()),
                              ),
                              Align(
                                alignment: Alignment.bottomCenter,
                                child: Obx(() => chatController.isLoading.value
                                    ? Container(
                                        height: 40,
                                        width: 100,
                                        alignment: Alignment.center,
                                        padding: const EdgeInsets.all(5.0),
                                        decoration: BoxDecoration(
                                          color: Colors.white,
                                          borderRadius:
                                              BorderRadius.circular(50),
                                        ),
                                        child: Obx(
                                          () {
                                            return Row(
                                              mainAxisSize: MainAxisSize.min,
                                              children: [
                                                Transform.translate(
                                                  offset: Offset(
                                                      0,
                                                      matchingAnimationController
                                                          .dotsOffset1.value),
                                                  child: const Icon(
                                                    Icons.circle,
                                                    color:
                                                        Colors.lightBlueAccent,
                                                    size: 20,
                                                  ),
                                                ),
                                                const SizedBox(width: 5),
                                                Transform.translate(
                                                  offset: Offset(
                                                      0,
                                                      matchingAnimationController
                                                          .dotsOffset2.value),
                                                  child: const Icon(
                                                    Icons.circle,
                                                    color:
                                                        Colors.lightBlueAccent,
                                                    size: 20,
                                                  ),
                                                ),
                                                const SizedBox(width: 5),
                                                Transform.translate(
                                                  offset: Offset(
                                                      0,
                                                      matchingAnimationController
                                                          .dotsOffset3.value),
                                                  child: const Icon(
                                                    Icons.circle,
                                                    color:
                                                        Colors.lightBlueAccent,
                                                    size: 20,
                                                  ),
                                                ),
                                              ],
                                            );
                                          },
                                        ),
                                      )
                                    : const SizedBox.shrink()),
                              )
                            ],
                          ),
                  ),
                ),
              ),
              Obx(() {
                if (imagePath.isNotEmpty) {
                  return Column(
                    children: [
                      IconButton(
                        onPressed: () {
                          imagePath.value = "";
                        },
                        icon: const Icon(Icons.cancel),
                      ),
                      Container(
                        margin: const EdgeInsets.only(bottom: 10),
                        width: 100,
                        height: 100,
                        child: Image.file(
                          File(
                            imagePath.value,
                          ),
                          fit: BoxFit.cover,
                        ),
                      ),
                    ],
                  );
                } else {
                  return const SizedBox.shrink();
                }
              }),
              CustomEmojiPicker(
                onEmojiSelected: (emoji) {
                  textController.text += emoji;
                  textController.selection = TextSelection.fromPosition(
                    TextPosition(offset: textController.text.length),
                  );
                },
                onBackspacePressed: () {
                  final text = textController.text;
                  if (text.isNotEmpty) {
                    // Xóa ký tự cuối (bao gồm cả emoji)
                    textController.text =
                        text.characters.skipLast(1).toString();
                    textController.selection = TextSelection.fromPosition(
                      TextPosition(offset: textController.text.length),
                    );
                  }
                },
                isEmojiPickerVisible: isEmojiPickerVisible,
                backgroundColor: const [
                  Colors.lightBlue,
                  Colors.lightBlueAccent,
                ],
              ),
              Row(
                children: [
                  Expanded(
                    child: TextField(
                      controller: textController,
                      textInputAction: TextInputAction.done,
                      decoration: InputDecoration(
                        contentPadding: const EdgeInsets.all(5),
                        border: OutlineInputBorder(
                          borderRadius: BorderRadius.circular(25),
                          borderSide:
                              const BorderSide(color: Colors.blueAccent),
                        ),
                        labelText: 'Type your message...',
                        labelStyle: theme.textTheme.bodySmall,
                        prefixIcon: IconButton(
                          onPressed: () async {
                            image = await profileController
                                .pickFileX(ImageSource.gallery);
                            if (image != null) {
                              imagePath.value = image!.path;
                            } else {
                              imagePath.value = "";
                            }
                          },
                          icon: const Icon(Icons.image_outlined),
                        ),
                        suffixIcon: IconButton(
                          onPressed: () async {
                            image = await profileController
                                .pickFileX(ImageSource.camera);
                            if (image != null) {
                              imagePath.value = image!.path;
                            } else {
                              imagePath.value = "";
                            }
                          },
                          icon: const Icon(Icons.camera_enhance),
                        ),
                      ),
                    ),
                  ),
                  Obx(() => IconButton(
                      onPressed: () {
                        isEmojiPickerVisible.toggle();
                      },
                      icon: isEmojiPickerVisible.value
                          ? const Icon(
                              Icons.emoji_emotions,
                              color: Colors.yellowAccent,
                              size: 30,
                            )
                          : const Icon(
                              Icons.emoji_emotions_outlined,
                              color: Colors.yellowAccent,
                              size: 30,
                            ))),
                  IconButton(
                    onPressed: () {
                      refreshKey.currentState?.show();
                      chatController.refreshChat();
                    },
                    icon: const Icon(
                      Icons.refresh_sharp,
                      size: 30,
                      color: Colors.lightBlueAccent,
                    ),
                  ),
                  Obx(
                    () => chatController.isLoading.value
                        ? IconButton(
                            onPressed: () {},
                            icon: const Icon(
                              Icons.stop_circle_outlined,
                              size: 30,
                              color: Colors.black,
                            ),
                          )
                        : IconButton(
                            iconSize: 30,
                            icon: imagePath.isNotEmpty
                                ? const Icon(
                                    Icons.image_search_sharp,
                                    color: Colors.deepPurpleAccent,
                                    size: 30,
                                  )
                                : const Icon(
                                    Icons.send_sharp,
                                    color: Colors.deepPurpleAccent,
                                    size: 30,
                                  ),
                            onPressed: () async {
                              final BackgroundMusicController
                                  effectiveMusicController = Get.find();
                              await effectiveMusicController
                                  .digitalSoundEffect();
                              final text = textController.text;
                              if (text.isNotEmpty) {
                                if (imagePath.isNotEmpty) {
                                  //cancel keyboard
                                  FocusScope.of(context).unfocus();
                                  await chatController.sendPromptWithImage(
                                      text, image);
                                  //clear text
                                  textController.clear();
                                  //remove image
                                  imagePath.value = "";
                                } else {
                                  //cancel keyboard
                                  FocusScope.of(context).unfocus();
                                  await chatController.sendPrompt(text);
                                  //clear text
                                  textController.clear();
                                  //remove image
                                  imagePath.value = "";
                                }
                              } else {
                                errorMessage("Please enter your question");
                              }
                            },
                          ),
                  )
                ],
              ),
            ],
          ),
        ),
      ),
    );
  }
}

```

---


### Pages\Chat\Widgets\chat_mess_item.dart

```dart
import 'dart:io';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_chat_bubble/chat_bubble.dart';
import 'package:get/get_state_manager/src/rx_flutter/rx_obx_widget.dart';
import 'package:tictactoe_gameapp/Configs/assets_path.dart';
import 'package:tictactoe_gameapp/Configs/messages.dart';
import 'package:tictactoe_gameapp/Controller/text_to_speech_controller.dart';
import 'package:tictactoe_gameapp/Data/gemini_api_controller.dart';
import 'package:tictactoe_gameapp/Models/Functions/hyperlink_text_function.dart';
import 'package:tictactoe_gameapp/Models/gemini_model.dart';
import 'package:tictactoe_gameapp/Models/user_model.dart';
import 'package:tictactoe_gameapp/Pages/Friends/Widgets/chat_friend_item.dart';

class ChatMessageItem extends StatelessWidget {
  final ChatController chatController;
  final TextToSpeechController ttsController;
  final Message message;
  final UserModel user;

  const ChatMessageItem({
    super.key,
    required this.message,
    required this.user,
    required this.ttsController,
    required this.chatController,
  });

  @override
  Widget build(BuildContext context) {
    return Row(
      mainAxisAlignment:
          message.isUser ? MainAxisAlignment.end : MainAxisAlignment.start,
      crossAxisAlignment:
          message.isUser ? CrossAxisAlignment.center : CrossAxisAlignment.start,
      children: [
        if (!message.isUser)
          const CircleAvatar(
            backgroundImage: AssetImage(GifsPath.chloe1),
          ),
        if (!message.isUser) const SizedBox(width: 5),
        Flexible(
          child: Stack(
            clipBehavior: Clip.none,
            children: [
              GestureDetector(
                onLongPress: () async => await Clipboard.setData(
                        ClipboardData(text: message.content))
                    .then(
                  (value) => successMessage('Copied to Clipboard'),
                ),
                child: ChatBubble(
                  alignment:
                      message.isUser ? Alignment.topRight : Alignment.topLeft,
                  clipper: ChatBubbleClipper8(
                      type: message.isUser
                          ? BubbleType.sendBubble
                          : BubbleType.receiverBubble),
                  padding: const EdgeInsets.all(0),
                  margin: const EdgeInsets.only(top: 20),
                  backGroundColor: _checkColors().first,
                  child: Container(
                    margin:
                        const EdgeInsets.symmetric(vertical: 5, horizontal: 10),
                    decoration: BoxDecoration(
                      borderRadius: BorderRadius.circular(15),
                      gradient: LinearGradient(
                        colors: _checkColors(),
                      ),
                    ),
                    child: ClipRRect(
                      borderRadius: BorderRadius.circular(15),
                      child: BubbleBackground(
                        colors: _checkColors(),
                        child: Padding(
                          padding: const EdgeInsets.all(10),
                          child: Column(
                            crossAxisAlignment: message.isUser
                                ? CrossAxisAlignment.end
                                : CrossAxisAlignment.start,
                            children: [
                              Obx(() {
                                final displayedText =
                                    message.displayedWords.join(' ');
                                return SelectableText.rich(
                                  TextSpan(
                                    children:
                                        HyperlinkTextFunction.buildMessageText(
                                      context,
                                      text: message.isUser
                                          ? message.content
                                          : displayedText,
                                      color: Colors.blueAccent,
                                      colors: _checkColors(),
                                      previewUrlMode: true,
                                    ),
                                  ),
                                  style: const TextStyle(color: Colors.black),
                                );
                              }),
                              message.imagePath != null
                                  ? SizedBox(
                                      width: 100,
                                      height: 100,
                                      child: Image.file(
                                        File(
                                          message.imagePath!,
                                        ),
                                        fit: BoxFit.cover,
                                      ),
                                    )
                                  : const SizedBox(),
                              const SizedBox(height: 5),
                              Text(
                                message.timestamp
                                    .toLocal()
                                    .toString()
                                    .split(' ')[1]
                                    .substring(0, 5),
                                style: const TextStyle(
                                    color: Colors.blueGrey, fontSize: 10),
                              ),
                            ],
                          ),
                        ),
                      ),
                    ),
                  ),
                ),
              ),
              message.isUser
                  ? const SizedBox()
                  : Positioned(
                      bottom: 3,
                      right: 3,
                      child: Row(
                        children: [
                          IconButton(
                            onPressed: () async => await Clipboard.setData(
                                    ClipboardData(text: message.content))
                                .then(
                              (value) => successMessage('Copied to Clipboard'),
                            ),
                            icon: const Icon(
                              Icons.content_copy_rounded,
                              color: Colors.grey,
                              size: 25,
                            ),
                          ),
                          Obx(() {
                            final data = ttsController
                                .getIconAndCallback(message.content);
                            return IconButton(
                              onPressed: data["callback"],
                              icon: Icon(
                                data["icon"],
                                color: Colors.grey,
                                size: 25,
                              ),
                            );
                          }),
                        ],
                      ),
                    ),
            ],
          ),
        ),
        // if (message.isUser) const SizedBox(width: 5),
        // if (message.isUser)
        //   CircleAvatar(
        //     child: user.image != null && user.image!.isNotEmpty
        //         ? CircleAvatar(
        //             backgroundImage: CachedNetworkImageProvider(user.image!),
        //             maxRadius: 55,
        //           )
        //         : const Icon(Icons.person_2_outlined),
        //   )
      ],
    );
  }

  List<Color> _checkColors() {
    if (message.isUser) {
      return [
        Colors.lightBlue,
        Colors.lightBlueAccent,
      ];
    } else {
      return [Colors.greenAccent, Colors.lightGreenAccent];
    }
  }
}

```

---


### Pages\Chat\Widgets\option_card.dart

```dart
import 'package:animated_text_kit/animated_text_kit.dart';
import 'package:flutter/material.dart';
import 'package:flutter_animate/flutter_animate.dart';

class OptionCard extends StatelessWidget {
  final IconData icon;
  final String title;
  final String description;

  const OptionCard({
    super.key,
    required this.icon,
    required this.title,
    required this.description,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    return SizedBox(
      width: double.infinity,
      height: MediaQuery.of(context).size.height * 0.29,
      child: Card(
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(15),
        ),
        elevation: 10,
        color: theme.colorScheme.primaryContainer,
        child: Padding(
          padding: const EdgeInsets.only(right: 10, left: 10),
          child: Column(
            children: [
              Icon(icon, size: 40, color: Colors.blue),
              const SizedBox(height: 5),
              Text(
                title,
                style: theme.textTheme.bodyLarge,
                textAlign: TextAlign.center,
              ).animate().fadeIn(duration: const Duration(seconds: 1)),
              const SizedBox(height: 5),
              Text(
                description,
                style: theme.textTheme.bodyMedium!
                    .copyWith(color: Colors.blueGrey),
                textAlign: TextAlign.center,
                maxLines: 4,
              ).animate().fadeIn(duration: const Duration(seconds: 3)),
            ],
          ),
        ),
      ),
    );
  }
}

```

---


### Pages\Chat\Widgets\section_widget.dart

```dart
import 'package:flutter/material.dart';
import 'package:tictactoe_gameapp/Pages/Chat/Widgets/option_card.dart';

class SectionWidget extends StatelessWidget {
  final List<OptionCard> options;

  const SectionWidget({super.key, required this.options});

  @override
  Widget build(BuildContext context) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Row(
          children: options
              .map((option) => Expanded(
                    child: Padding(
                      padding: const EdgeInsets.symmetric(horizontal: 8.0),
                      child: option,
                    ),
                  ))
              .toList(),
        ),
      ],
    );
  }
}
```

---


### Pages\Friends\chat_with_friend_page.dart

```dart
import 'dart:io';
import 'package:flutter/material.dart';
import 'package:flutter_animate/flutter_animate.dart';
import 'package:get/get.dart';
import 'package:giphy_picker/giphy_picker.dart';
import 'package:image_picker/image_picker.dart';
import 'package:tictactoe_gameapp/Components/belong_to_users/avatar_user_widget.dart';
import 'package:tictactoe_gameapp/Components/gifphy/preview_gif_widget.dart';
import 'package:tictactoe_gameapp/Configs/assets_path.dart';
import 'package:tictactoe_gameapp/Configs/constants.dart';
import 'package:tictactoe_gameapp/Configs/messages.dart';
import 'package:tictactoe_gameapp/Controller/MainHome/notify_in_main_controller.dart';
import 'package:tictactoe_gameapp/Controller/profile_controller.dart';
import 'package:tictactoe_gameapp/Data/chat_friend_controller.dart';
import 'package:tictactoe_gameapp/Data/fetch_firestore_database.dart';
import 'package:tictactoe_gameapp/Models/Functions/color_string_reverse_function.dart';
import 'package:tictactoe_gameapp/Models/Functions/general_bottomsheet_show_function.dart';
import 'package:tictactoe_gameapp/Models/Functions/permission_handle_functions.dart';
import 'package:tictactoe_gameapp/Models/Functions/time_functions.dart';
import 'package:tictactoe_gameapp/Models/user_model.dart';
import 'package:tictactoe_gameapp/Pages/Friends/Widgets/agora_call_page.dart';
import 'package:tictactoe_gameapp/Pages/Friends/Widgets/background_list_sheet.dart';
import 'package:tictactoe_gameapp/Pages/Friends/Widgets/chat_friend_item.dart';
import 'package:tictactoe_gameapp/Components/emotes_picker_widget.dart';
import 'package:tictactoe_gameapp/Pages/Society/About/user_about_page.dart';
import 'package:uuid/uuid.dart';

class ChatWithFriendPage extends StatelessWidget {
  final NotifyInMainController notifyInMainController;
  final UserModel userFriend;
  const ChatWithFriendPage({
    super.key,
    required this.userFriend,
    required this.notifyInMainController,
  });

  @override
  Widget build(BuildContext context) {
    final ThemeData theme = Theme.of(context);
    final TextEditingController textController = TextEditingController();
    final FirestoreController firestoreController =
        Get.find<FirestoreController>();
    final ProfileController profileController = Get.find<ProfileController>();
    RxString imagePath = "".obs;
    var selectedGif = Rx<GiphyGif?>(null);
    XFile? image;
    final chatController = Get.put(ChatFriendController(
      firestoreController.userId,
      userFriend.id!,
    ));

    RxBool isEmojiPickerVisible = false.obs;

    return Obx(() {
      var themColors = chatController.chatSettings.value.themeColors;
      var backgroundColors = [Colors.transparent, Colors.transparent];
      if (themColors != null) {
        backgroundColors = themColors
            .map((hex) => ColorStringReverseFunction.hexToColor(hex))
            .toList();
      } else {
        backgroundColors = [Colors.transparent, Colors.transparent];
      }
      return Scaffold(
        appBar: AppBar(
          leading: IconButton(
              onPressed: () => Get.back(),
              icon: const Icon(
                Icons.arrow_back,
                color: Colors.deepPurpleAccent,
                size: 35,
              )),
          flexibleSpace: Container(
            decoration: BoxDecoration(
              gradient: LinearGradient(
                colors: backgroundColors,
                begin: Alignment.topLeft,
                end: Alignment.bottomRight,
              ),
            ),
          ),
          title: GestureDetector(
            onTap: () {
              Get.to(
                  UserAboutPage(
                    unknownableUser: userFriend,
                  ),
                  transition: Transition.leftToRightWithFade);
            },
            child: Row(
              children: [
                Hero(
                  tag: 'friendAvatar-${userFriend.id}',
                  transitionOnUserGestures: true,
                  child: AvatarUserWidget(
                      radius: 25, imagePath: userFriend.image!),
                ),
                const SizedBox(
                  width: 10,
                ),
                Expanded(
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text(userFriend.name!, style: theme.textTheme.bodyLarge),
                      userFriend.lastActive == null
                          ? Text(
                              "${userFriend.status ?? "Online"} 1 hour ago",
                              style: theme.textTheme.bodySmall!
                                  .copyWith(color: Colors.grey),
                            )
                          : Text(
                              "Online ${TimeFunctions.displayDate(userFriend.lastActive!)} - ${TimeFunctions.displayTimeDefault(userFriend.lastActive!)}",
                              style: theme.textTheme.bodySmall!.copyWith(
                                color: themColors != null
                                    ? Colors.lightGreenAccent
                                    : Colors.blueGrey,
                              ),
                              maxLines: 2,
                            ),
                    ],
                  ),
                )
              ],
            ),
          ),
          elevation: 3.0,
          actions: [
            IconButton(
              icon: const Icon(
                Icons.call,
                color: Colors.deepPurpleAccent,
                size: 30,
              ),
              onPressed: () async {
                final permissionHandler = PermissionHandleFunctions();
                bool micGranted =
                    await permissionHandler.checkMicrophonePermission();
                if (micGranted == true) {
                  var userCurrent = profileController.user!;
                  var uuid = const Uuid();
                  final String channelId = uuid.v4().substring(0, 12);
                  await notifyInMainController.sendCallInvite(
                    receiverId: userFriend.id!,
                    senderUser: userCurrent,
                    channelId: channelId,
                    isVideoCall: false,
                  );
                  Get.to(
                    () => AgoraCallPage(
                      userFriend: userFriend,
                      userCurrent: userCurrent,
                      channelId: channelId,
                      initialMicState: true,
                      initialVideoState: false,
                    ),
                    transition: Transition.upToDown,
                  );
                } else {
                  errorMessage("Please microphone permission");
                }
              },
            ),
            IconButton(
              icon: const Icon(
                Icons.video_call,
                color: Colors.deepPurpleAccent,
                size: 30,
              ),
              onPressed: () async {
                final permissionHandler = PermissionHandleFunctions();
                bool camGranted =
                    await permissionHandler.checkCameraPermission();
                bool micGranted =
                    await permissionHandler.checkMicrophonePermission();
                if (camGranted == true && micGranted == true) {
                  var userCurrent = profileController.user!;
                  var uuid = const Uuid();
                  final String channelId = uuid.v4().substring(0, 12);
                  await notifyInMainController.sendCallInvite(
                    receiverId: userFriend.id!,
                    senderUser: userCurrent,
                    channelId: channelId,
                    isVideoCall: true,
                  );
                  Get.to(
                    () => AgoraCallPage(
                      userFriend: userFriend,
                      userCurrent: userCurrent,
                      channelId: channelId,
                      initialMicState: true,
                      initialVideoState: true,
                    ),
                    transition: Transition.upToDown,
                  );
                } else {
                  errorMessage("Please camera permission");
                }
              },
            ),
            IconButton(
              icon: const Icon(
                Icons.color_lens_rounded,
                color: Colors.deepPurpleAccent,
                size: 30,
              ),
              onPressed: () async => _openThemeChange(context, chatController),
            ),
          ],
        ),
        body: Container(
          padding: const EdgeInsets.only(left: 10, right: 10, bottom: 5),
          decoration: BoxDecoration(
            gradient: LinearGradient(
              colors: backgroundColors,
              begin: Alignment.topCenter,
              end: Alignment.bottomCenter,
            ),
          ),
          child: Column(
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            children: [
              Expanded(
                child: GestureDetector(
                  onLongPress: () async =>
                      _openThemeChange(context, chatController),
                  child: Obx(
                    () => chatController.isEmptyMessage.value
                        ? _buildProfilePreview(theme)
                        : ChatFriendItem(
                            userFriend: userFriend,
                            currentUserId: firestoreController.userId,
                            chatController: chatController,
                            firestoreController: firestoreController,
                            color: backgroundColors,
                            theme: theme,
                          )
                            .animate()
                            .slide(duration: const Duration(milliseconds: 750)),
                  ),
                ),
              ),
              const SizedBox(
                height: 20,
              ),
              Obx(() {
                if (imagePath.value.isNotEmpty) {
                  return Column(
                    children: [
                      IconButton(
                        onPressed: () {
                          imagePath.value = "";
                        },
                        icon: const Icon(
                          Icons.cancel,
                          color: Colors.deepPurpleAccent,
                          size: 30,
                        ),
                      ),
                      SizedBox(
                        width: 200,
                        height: 120,
                        child: Image.file(
                          File(
                            imagePath.value,
                          ),
                          fit: BoxFit.cover,
                        ),
                      ),
                      const SizedBox(
                        height: 5,
                      )
                    ],
                  );
                } else {
                  return const SizedBox();
                }
              }),
              PreviewGifWidget(selectedGif: selectedGif),
              Row(
                children: [
                  Obx(() => chatController.isFocused.value
                      ? IconButton(
                          onPressed: () {
                            chatController.focusNode.unfocus();
                          },
                          icon: const Icon(
                            Icons.keyboard_arrow_right,
                            color: Colors.blueAccent,
                            size: 30,
                          ),
                        )
                      : Row(
                          children: [
                            IconButton(
                              icon: const Icon(
                                Icons.add_circle,
                                color: Colors.blueAccent,
                                size: 30,
                              ),
                              onPressed: () {},
                            ),
                            IconButton(
                              icon: const Icon(
                                Icons.camera_alt,
                                color: Colors.blueAccent,
                                size: 30,
                              ),
                              onPressed: () async {
                                image = await profileController
                                    .pickFileX(ImageSource.camera);
                                if (image != null) {
                                  imagePath.value = image!.path;
                                } else {
                                  imagePath.value = "";
                                }
                              },
                            ),
                            IconButton(
                              icon: const Icon(
                                Icons.image_rounded,
                                color: Colors.blueAccent,
                                size: 30,
                              ),
                              onPressed: () async {
                                image = await profileController
                                    .pickFileX(ImageSource.gallery);
                                if (image != null) {
                                  imagePath.value = image!.path;
                                } else {
                                  imagePath.value = "";
                                }
                              },
                            ),
                          ],
                        )),
                  Expanded(
                    child: TextField(
                      focusNode: chatController.focusNode,
                      controller: textController,
                      textInputAction: TextInputAction.done,
                      decoration: InputDecoration(
                        contentPadding: const EdgeInsets.symmetric(
                            vertical: 10.0, horizontal: 10.0),
                        border: OutlineInputBorder(
                          borderRadius: BorderRadius.circular(25),
                          borderSide:
                              const BorderSide(color: Colors.blueAccent),
                        ),
                        labelText: 'Message',
                        labelStyle: theme.textTheme.bodyLarge!
                            .copyWith(color: Colors.grey),
                        prefixIcon: IconButton(
                          icon: const Icon(
                            Icons.gif_box_outlined,
                            color: Colors.blueAccent,
                            size: 30,
                          ),
                          onPressed: () async {
                            final gif = await GiphyPicker.pickGif(
                              context: context,
                              apiKey: apiGifphy,
                              showPreviewPage: false,
                              showGiphyAttribution: false,
                              loadingBuilder: (context) {
                                return Center(
                                  child: ClipRRect(
                                    borderRadius: BorderRadius.circular(100),
                                    child: Image.asset(
                                      GifsPath.loadingGif,
                                      height: 200,
                                      width: 200,
                                    ),
                                  ),
                                );
                              },
                            );

                            if (gif != null) {
                              selectedGif.value = gif;
                            }
                          },
                        ),
                        suffixIcon: Obx(() => IconButton(
                            onPressed: () {
                              isEmojiPickerVisible.toggle();
                            },
                            icon: isEmojiPickerVisible.value
                                ? const Icon(
                                    Icons.emoji_emotions,
                                    color: Colors.blue,
                                    size: 30,
                                  )
                                : const Icon(
                                    Icons.emoji_emotions_outlined,
                                    color: Colors.blue,
                                    size: 30,
                                  ))),
                      ),
                    ),
                  ),
                  Obx(() => IconButton(
                        icon: Icon(
                          imagePath.value.isEmpty
                              ? Icons.send_sharp
                              : Icons.image_search,
                          color: Colors.blueAccent,
                          size: 30,
                        ),
                        onPressed: () async {
                          if (imagePath.value.isEmpty) {
                            if (textController.text.isNotEmpty) {
                              await chatController.sendMessage(
                                textController.text,
                                selectedGif.value?.images.original!.url!,
                              );

                              selectedGif.value = null;
                              textController.clear();
                              chatController.focusNode.unfocus();
                            } else {
                              errorMessage("Please enter a message");
                            }
                          } else {
                            await chatController.sendImageMessage(
                              textController.text,
                              image!,
                            );
                            imagePath.value = "";
                            if (textController.text.isNotEmpty) {
                              textController.clear();
                              chatController.focusNode.unfocus();
                            }
                          }
                        },
                      )),
                ],
              ),
              CustomEmojiPicker(
                onEmojiSelected: (emoji) {
                  textController.text += emoji;
                  textController.selection = TextSelection.fromPosition(
                    TextPosition(offset: textController.text.length),
                  );
                },
                onBackspacePressed: () {
                  final text = textController.text;
                  if (text.isNotEmpty) {
                    // Xóa ký tự cuối (bao gồm cả emoji)
                    textController.text =
                        text.characters.skipLast(1).toString();
                    textController.selection = TextSelection.fromPosition(
                      TextPosition(offset: textController.text.length),
                    );
                  }
                },
                isEmojiPickerVisible: isEmojiPickerVisible,
                backgroundColor: backgroundColors,
              )
            ],
          ),
        ),
      );
    });
  }

  Future<void> _openThemeChange(
      BuildContext context, ChatFriendController chatController) async {
    await GeneralBottomsheetShowFunction.showScrollableGeneralBottomsheet(
      widgetBuilder: (context, controller) => BackgroundListSheet(
        scrollController: controller,
        chatFriendController: chatController,
      ),
      context: context,
      initHeight: 0.9,
    );
  }

  Widget _buildProfilePreview(ThemeData theme) {
    return Column(
      mainAxisAlignment: MainAxisAlignment.center,
      children: [
        AvatarUserWidget(
          radius: 80,
          imagePath: userFriend.image!,
          gradientColors: userFriend.avatarFrame,
        ),
        const SizedBox(
          height: 10,
        ),
        Text(
          userFriend.name!,
          style: theme.textTheme.headlineLarge!.copyWith(
            color: Colors.deepPurple,
          ),
        ),
        const SizedBox(
          height: 10,
        ),
        Text(
          "Email: ${userFriend.email!}",
          style: const TextStyle(
            color: Colors.blueAccent,
            fontSize: 15,
          ),
        ),
        const SizedBox(
          height: 5,
        ),
        const Text(
          "You are friends on Tic Tac Toe",
          style: TextStyle(
            color: Colors.black,
            fontSize: 18,
          ),
        ),
        const SizedBox(
          height: 5,
        ),
        Row(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Text(
              "Total Wins: ${userFriend.totalWins ?? "0"}",
              style: const TextStyle(
                color: Colors.blueGrey,
              ),
            ),
            const SizedBox(
              width: 10,
            ),
            Text(
              "Total Coins: ${userFriend.totalCoins ?? "0"}",
              style: const TextStyle(
                color: Colors.blueGrey,
              ),
            ),
          ],
        ),
        const SizedBox(
          height: 10,
        ),
        ElevatedButton(
          onPressed: () {
            Get.to(
                UserAboutPage(
                  unknownableUser: userFriend,
                ),
                transition: Transition.upToDown);
          },
          style: ElevatedButton.styleFrom(
            backgroundColor: Colors.white54,
          ),
          child: Text(
            "View Profile",
            style: theme.textTheme.bodyLarge,
          ),
        ),
      ],
    );
  }
}

```

---


### Pages\Friends\listen_latest_messages_controller.dart

```dart
import 'dart:async';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:get/get.dart';
import 'package:tictactoe_gameapp/Configs/messages.dart';
import 'package:tictactoe_gameapp/Controller/profile_controller.dart';
import 'package:tictactoe_gameapp/Models/message_friend_model.dart';
import 'package:tictactoe_gameapp/Models/user_model.dart';

class ListenLatestMessagesController extends GetxController {
  final ProfileController profileController = Get.find();
  
  final FirebaseFirestore _firestore = FirebaseFirestore.instance;

  RxList<MessageFriendModel> latestMessages = <MessageFriendModel>[].obs;
  RxBool isFetching = false.obs;
  late final UserModel currentUser;
  final Map<String, StreamSubscription> _listeners = {};

  @override
  void onInit() async {
    super.onInit();
    currentUser = profileController.user!;
    await fetchLatestMessages(); // Lấy dữ liệu nhanh ban đầu
  }

  // Tạo ID phòng chat dựa trên userId và friendId
  String _getChatRoomId(String friendId) {
    return currentUser.id.hashCode <= friendId.hashCode
        ? '${currentUser.id}-$friendId'
        : '$friendId-${currentUser.id}';
  }

  // Hàm lấy tin nhắn gần nhất cho từng bạn bè
  Future<void> fetchLatestMessages() async {
    isFetching.value = true;
    try {
      List<MessageFriendModel> initialMessages =
          await getLatestMessagesFromFriends();
      latestMessages.value = initialMessages;
      listenToLatestMessages(initialMessages.map((m) => m.senderId!).toList());
    } catch (e) {
      errorMessage("Error fetching reels: $e");
    } finally {
      isFetching.value = false;
    }
  }

  // Hàm lấy tin nhắn mới nhất của bạn bè (không bao gồm listener)
  Future<List<MessageFriendModel>> getLatestMessagesFromFriends() async {
    List<Future<MessageFriendModel?>> futures = [];
    if (currentUser.friendsList != null) {
      for (String friendId in currentUser.friendsList!) {
        String chatId = _getChatRoomId(friendId);
        futures.add(
          _firestore
              .collection('chats')
              .doc(chatId)
              .collection('messages')
              .orderBy('timestamp', descending: true)
              .limit(1)
              .get()
              .then((querySnapshot) {
            if (querySnapshot.docs.isNotEmpty) {
              final messageData = querySnapshot.docs.first.data();
              return MessageFriendModel.fromJson(messageData);
            }
            return null;
          }).catchError((e) {
            errorMessage("Error fetching message for friend $friendId: $e");
            return null;
          }),
        );
      }
    }
    // Chờ tất cả Futures hoàn tất và lọc kết quả
    List<MessageFriendModel?> results = await Future.wait(futures);
    return results
        .where((message) => message != null)
        .cast<MessageFriendModel>()
        .toList();
  }

  // Lắng nghe thay đổi real-time cho từng friend
  void listenToLatestMessages(List<String> friendIds) {
    // Hủy bỏ các listener cũ nếu tồn tại
    for (var listener in _listeners.values) {
      listener.cancel();
    }
    _listeners.clear();

    for (String friendId in friendIds) {
      String chatId = _getChatRoomId(friendId);

      _listeners[friendId] = _firestore
          .collection('chats')
          .doc(chatId)
          .collection('messages')
          .orderBy('timestamp', descending: true)
          .limit(1)
          .snapshots()
          //     .listen((snapshot) {
          //   for (var change in snapshot.docChanges) {
          //     if (change.type == DocumentChangeType.added) {
          //       // Xử lý tin nhắn mới được thêm vào
          //       var newMessage = MessageFriendModel.fromJson(
          //         change.doc.data() as Map<String, dynamic>,
          //       );

          //       // Kiểm tra xem tin nhắn đã tồn tại chưa, nếu chưa thì thêm vào đầu danh sách
          //       if (!latestMessages
          //           .any((msg) => msg.messageId == newMessage.messageId)) {
          //         latestMessages.insert(
          //             0, newMessage); // Thêm tin nhắn mới vào đầu danh sách
          //       }
          //     } else if (change.type == DocumentChangeType.modified) {
          //       // Xử lý tin nhắn đã được chỉnh sửa
          //       var updatedMessage = MessageFriendModel.fromJson(
          //         change.doc.data() as Map<String, dynamic>,
          //       );

          //       // Tìm và cập nhật tin nhắn trong danh sách
          //       final index = latestMessages
          //           .indexWhere((msg) => msg.messageId == updatedMessage.messageId);
          //       if (index != -1) {
          //         latestMessages[index] = updatedMessage;
          //       }
          //     } else if (change.type == DocumentChangeType.removed) {
          //       // Xử lý khi tin nhắn bị xóa
          //       final messageId = change.doc.id;

          //       // Xóa tin nhắn khỏi danh sách nếu tồn tại
          //       latestMessages.removeWhere((msg) => msg.messageId == messageId);
          //     }
          //   }
          // });
          .listen((snapshot) {
        if (snapshot.docs.isNotEmpty) {
          final messageData = snapshot.docs.first.data();
          final message = MessageFriendModel.fromJson(messageData);

          int index = latestMessages
              .indexWhere((m) => m.messageId == message.messageId);
          if (index != -1) {
            latestMessages[index] = message;
          } else {
            latestMessages.add(message);
          }
        }
      });
    }
  }

  @override
  void onClose() {
    for (var listener in _listeners.values) {
      listener.cancel();
    }
    super.onClose();
  }
}

```

---


### Pages\Friends\messenger_page.dart

```dart
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:tictactoe_gameapp/Components/belong_to_users/avatar_user_widget.dart';
import 'package:tictactoe_gameapp/Components/shimmers/friendavatar_placeholder_widget.dart';
import 'package:tictactoe_gameapp/Controller/MainHome/notify_in_main_controller.dart';
import 'package:tictactoe_gameapp/Controller/notification_controller.dart';
import 'package:tictactoe_gameapp/Controller/profile_controller.dart';
import 'package:tictactoe_gameapp/Controller/webview_controller.dart';
import 'package:tictactoe_gameapp/Data/fetch_firestore_database.dart';
import 'package:tictactoe_gameapp/Pages/Friends/Widgets/messages_widget.dart';
import 'package:tictactoe_gameapp/Pages/Friends/Widgets/notes_widget.dart';
import 'package:tictactoe_gameapp/Pages/Friends/listen_latest_messages_controller.dart';
import 'package:tictactoe_gameapp/Pages/HomePage/Drawer/drawer_nav_bar.dart';
import 'package:tictactoe_gameapp/Pages/Society/About/user_about_page.dart';

class FriendsPage extends StatelessWidget {
  const FriendsPage({super.key});

  @override
  Widget build(BuildContext context) {
    final ThemeData theme = Theme.of(context);
    final WebViewControllers controller = Get.put(WebViewControllers());
    final NotifyInMainController notifyInMainController =
        controller.notifyInMainController;
    final FirestoreController firestoreController =
        Get.put(FirestoreController());
    final ProfileController profileController = Get.find<ProfileController>();
    final user = profileController.user!;
    final ListenLatestMessagesController listenLatestMessagesController =
        Get.find();

    return Scaffold(
      drawer: DrawerNavBar(
        firestoreController: firestoreController,
        profileController: profileController,
        user: user,
        notifyInMainController: notifyInMainController,
      ),
      appBar: AppBar(
        title: Text(
          "Friends",
          style: theme.textTheme.headlineLarge,
        ),
        actions: [
          Container(
            margin: const EdgeInsets.only(right: 10),
            decoration: BoxDecoration(
              color: Colors.grey[300],
              borderRadius: BorderRadius.circular(50),
            ),
            child: IconButton(
              onPressed: () {},
              icon: const Icon(
                Icons.edit,
                size: 25,
              ),
            ),
          ),
        ],
      ),
      body: DefaultTabController(
        length: 2,
        child: NestedScrollView(
          headerSliverBuilder: (BuildContext context, bool innerBoxIsScrolled) {
            return <Widget>[
              SliverToBoxAdapter(
                child: Padding(
                  padding: const EdgeInsets.all(10.0),
                  child: Column(
                    children: [
                      Builder(
                        builder: (context) {
                          return TextField(
                            onChanged: (value) {
                              int indexTab =
                                  DefaultTabController.of(context).index;
                              if (indexTab == 0) {
                                firestoreController.updateSearchText(value);
                              } else if (indexTab == 1) {
                                notifyInMainController.updateSearchText(value);
                              }
                            },
                            decoration: InputDecoration(
                              labelText: 'Searching',
                              labelStyle: theme.textTheme.bodyLarge!
                                  .copyWith(color: Colors.blueGrey),
                              border: OutlineInputBorder(
                                borderRadius: BorderRadius.circular(30),
                                borderSide:
                                    const BorderSide(color: Colors.blueAccent),
                              ),
                              prefixIcon: IconButton(
                                onPressed: () {},
                                icon: const Icon(Icons.search),
                              ),
                              prefixIconColor: Colors.blueGrey,
                            ),
                          );
                        },
                      ),
                      const SizedBox(height: 10),
                      Row(
                        children: [
                          SizedBox(
                            width: 100,
                            child: Column(
                              children: [
                                AvatarUserWidget(
                                  radius: 40,
                                  imagePath: user.image!,
                                  gradientColors: user.avatarFrame,
                                ),
                                const Text(
                                  "Your Story",
                                  style: TextStyle(color: Colors.deepPurple),
                                )
                              ],
                            ),
                          ),
                          const SizedBox(width: 15),
                          Obx(() {
                            if (firestoreController.isLoadingFriends.value) {
                              return Expanded(
                                child: SizedBox(
                                  height: 120,
                                  child: ListView.builder(
                                    scrollDirection: Axis.horizontal,
                                    itemCount: 5, // Số lượng placeholder
                                    itemBuilder: (context, index) {
                                      return const FriendavatarPlaceholderWidget();
                                    },
                                  ),
                                ),
                              );
                            } else {
                              if (firestoreController.friendsList.isEmpty) {
                                return const SizedBox();
                              } else {
                                var friends =
                                    firestoreController.friendsList.toList();
                                return Expanded(
                                  child: SizedBox(
                                    height: 120,
                                    child: ListView.builder(
                                      scrollDirection: Axis.horizontal,
                                      physics: const BouncingScrollPhysics(),
                                      itemCount: friends.length,
                                      itemBuilder: (context, index) {
                                        var friend = friends[index];
                                        return Padding(
                                          padding: const EdgeInsets.all(8.0),
                                          child: Column(
                                            children: [
                                              Stack(
                                                children: [
                                                  GestureDetector(
                                                    onTap: () {
                                                      Get.to(
                                                          UserAboutPage(
                                                            unknownableUser:
                                                                friend,
                                                          ),
                                                          transition: Transition
                                                              .upToDown);
                                                    },
                                                    child: AvatarUserWidget(
                                                      radius: 35,
                                                      imagePath: friend.image!,
                                                      gradientColors:
                                                          friend.avatarFrame,
                                                    ),
                                                  ),
                                                  Positioned(
                                                    bottom: 0,
                                                    right: 0,
                                                    child: Container(
                                                      width: 20,
                                                      height: 20,
                                                      decoration: BoxDecoration(
                                                        color: Colors.green,
                                                        borderRadius:
                                                            BorderRadius
                                                                .circular(100),
                                                        border: Border.all(
                                                          color: Colors.white,
                                                          width: 3,
                                                        ),
                                                      ),
                                                    ),
                                                  ),
                                                ],
                                              ),
                                              Text(friend.name!),
                                            ],
                                          ),
                                        );
                                      },
                                    ),
                                  ),
                                );
                              }
                            }
                          }),
                        ],
                      ),
                      TabBar(
                        labelColor: Colors.blueAccent,
                        indicatorColor: Colors.blueAccent,
                        unselectedLabelColor: Colors.grey,
                        dividerHeight: 0,
                        indicatorSize: TabBarIndicatorSize.tab,
                        labelStyle: theme.textTheme.bodyLarge,
                        tabs: const [
                          Tab(text: 'Chats'),
                          Tab(text: 'News'),
                        ],
                      ),
                    ],
                  ),
                ),
              ),
            ];
          },
          body: TabBarView(
            children: [
              MessagesWidget(
                firestoreController: firestoreController,
                theme: theme,
                listenLatestMessagesController: listenLatestMessagesController,
                notifyInMainController: notifyInMainController,
              ),
              NotesWidget(
                theme: theme,
                notifyInMainController: notifyInMainController,
                firestoreController: firestoreController,
              ),
            ],
          ),
        ),
      ),
    );
  }
}

```

---


### Pages\Friends\Widgets\agora_call_controller.dart

```dart
import 'dart:async';

import 'package:agora_rtc_engine/agora_rtc_engine.dart';
import 'package:agora_token_service/agora_token_service.dart';
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:tictactoe_gameapp/Configs/constants.dart';
import 'package:tictactoe_gameapp/Configs/messages.dart';
import 'package:tictactoe_gameapp/Pages/Friends/Widgets/agora_end_of_call_lay.dart';

class AgoraCallController extends GetxController {
  late final RtcEngine agoraEngine;

  var friendUid = Rx<int?>(null);
  RxBool isRemmoteVideoEnabled = false.obs;
  var localNetworkQuality = ''.obs; // Chất lượng mạng của local user
  var remoteNetworkQuality = ''.obs; // Chất lượng mạng của remote user
  var remotePing = 0.obs;

  final RxBool isMicEnabled = false.obs;
  final RxBool isVideoEnabled = false.obs;
  final RxBool isAudioEnabled = true.obs;
  RxInt callDuration = 0.obs; // Thời gian cuộc gọi (giây)
  Timer? _callTimer; // Bộ đếm thời gian
  RxBool isExtendIcons = true.obs; // Biến trạng thái để hiển thị/ẩn icon
  Timer? _inactivityTimer;

  final String channelId;
  final String userId;
  final String url;

  AgoraCallController({
    required this.channelId,
    required this.userId,
    required this.url,
    required bool initialMicState,
    required bool initialVideoState,
  }) {
    isMicEnabled.value = initialMicState;
    isVideoEnabled.value = initialVideoState;
  }

  @override
  void onInit() {
    super.onInit();
    _initialize();
  }

  @override
  void onClose() {
    disposeAgora();
    _stopCallTimer();
    super.onClose();
  }

  Future<void> _initialize() async {
    await _initAgoraRtcEngine();
    _addAgoraEventHandlers();
    await _joinChannel();
    _initialActivityTimer();
  }

  void _initialActivityTimer() {
    // Lắng nghe mọi thay đổi của biến isExtendIcons
    ever(isExtendIcons, (_) {
      if (isExtendIcons.value) {
        _startInactivityTimer(); // Khởi động lại Timer khi isExtendIcons thay đổi thành true
      } else {
        _inactivityTimer?.cancel(); // Hủy Timer nếu không cần ẩn icon
      }
    });
    // Khởi động timer ban đầu
    _startInactivityTimer();
  }

  Future<void> _initAgoraRtcEngine() async {
    agoraEngine = createAgoraRtcEngine();
    await agoraEngine.initialize( RtcEngineContext(appId: apiAgoraAppId));
    await agoraEngine.enableAudio();
    await agoraEngine.enableVideo();
    await agoraEngine.setChannelProfile(ChannelProfileType
        .channelProfileCommunication); //channelProfileLiveBroadcasting
    await agoraEngine.setClientRole(role: ClientRoleType.clientRoleBroadcaster);
    await agoraEngine.muteLocalAudioStream(!isMicEnabled.value);
    await agoraEngine.muteLocalVideoStream(!isVideoEnabled.value);
  }

  Future<void> _joinChannel() async {
    final int intUserId = int.parse(extractNumbers(userId));
    final expireTimestamp =
        DateTime.now().millisecondsSinceEpoch ~/ 1000 + 3600;

    final token = RtcTokenBuilder.build(
      appId: apiAgoraAppId,
      appCertificate: apiAgoraAppCertificate,
      channelName: channelId,
      uid: intUserId.toString(),
      role: RtcRole.publisher,
      expireTimestamp: expireTimestamp,
    );
    await agoraEngine.joinChannel(
      token: token,
      channelId: channelId,
      uid: intUserId,
      options: const ChannelMediaOptions(),
    );
  }

  Future<void> disposeAgora() async {
    await agoraEngine.leaveChannel();
    await agoraEngine.release();
  }

  void _addAgoraEventHandlers() {
    agoraEngine.registerEventHandler(
      RtcEngineEventHandler(
        onError: (err, msg) => errorMessage("error: $msg"),
        onUserJoined: (connection, remoteUid, elapsed) {
          friendUid.value = remoteUid;
          _startCallTimer();
        },
        onUserMuteVideo: (connection, remoteUid, muted) =>
            isRemmoteVideoEnabled.value = !muted,
        onUserOffline: (RtcConnection connection, int remoteUid,
            UserOfflineReasonType reason) {
          if (reason == UserOfflineReasonType.userOfflineQuit) {
            Get.back();
            Get.dialog(
              Material(
                color: Colors.black,
                child: EndOfCallLay(
                  url: url,
                  endTime: callDuration.value,
                ),
              ),
              useSafeArea: false,
            );
          }
        },
        onNetworkQuality: (RtcConnection connection, int uid,
            QualityType txQuality, QualityType rxQuality) {
          if (uid == 0) {
            localNetworkQuality.value =
                'Uplink: ${_getQualityDescription(txQuality)} \n Downlink: ${_getQualityDescription(rxQuality)}';
          } else {
            remoteNetworkQuality.value =
                'Uplink: ${_getQualityDescription(txQuality)}  \n  Downlink: ${_getQualityDescription(rxQuality)}';
          }
        },
        onRemoteAudioStats:
            (RtcConnection connection, RemoteAudioStats stats) =>
                remotePing.value = stats.networkTransportDelay ?? 0,
        onConnectionLost: (connection) => errorMessage(
            "${connection.channelId}'s Connection is lost,please try again: ${connection.channelId}"),
      ),
    );
  }

  void toggleMicro() {
    isMicEnabled.toggle();
    agoraEngine.muteLocalAudioStream(!isMicEnabled.value);
  }

  void toggleAudio() {
    isAudioEnabled.toggle();
    agoraEngine.muteAllRemoteAudioStreams(!isAudioEnabled.value);
  }

  void toggleVideo() {
    isVideoEnabled.toggle();
    agoraEngine.muteLocalVideoStream(!isVideoEnabled.value);
  }

  void switchCamera() => agoraEngine.switchCamera();

  // Hàm khởi động lại Timer
  void _startInactivityTimer() {
    _inactivityTimer?.cancel(); // Hủy timer cũ nếu có
    _inactivityTimer = Timer(const Duration(seconds: 10), () {
      isExtendIcons.value = false; // Ẩn icon sau 5 giây không tương tác
    });
  }

  void _startCallTimer() {
    _callTimer?.cancel(); // Hủy timer trước đó nếu tồn tại
    _callTimer = Timer.periodic(const Duration(seconds: 1), (Timer timer) {
      callDuration.value++;
    });
  }

  void _stopCallTimer() {
    _inactivityTimer?.cancel(); // Hủy timer khi kết thúc cuộc gọi
    _callTimer?.cancel(); // Hủy timer khi kết thúc cuộc gọi
    _callTimer = null;
  }

  String extractNumbers(String userId) {
    return userId.replaceAll(RegExp(r'[^0-9]'), '');
  }

  String _getQualityDescription(QualityType quality) {
    switch (quality) {
      case QualityType.qualityExcellent:
        return "Excellent";
      case QualityType.qualityGood:
        return "Good";
      case QualityType.qualityPoor:
        return "Poor";
      case QualityType.qualityBad:
        return "Bad";
      case QualityType.qualityUnknown:
        return "Very Bad";
      case QualityType.qualityDown:
        return "Down";
      default:
        return "Unknown";
    }
  }

  //todo: set virtual background
  Future<void> setVirtualBackground({
    required BackgroundSourceType backgroundType,
    String? source,
    int? color,
    BackgroundBlurDegree? blurDegree,
  }) async {
    final virtualBackgroundSource = VirtualBackgroundSource(
      backgroundSourceType: backgroundType,
      source: source,
      color: color,
      blurDegree: blurDegree,
    );

    const segmentationProperty = SegmentationProperty(
      modelType: SegModelType.segModelAi,
      greenCapacity: 0.5,
    );

    await agoraEngine.enableVirtualBackground(
      enabled: true,
      backgroundSource: virtualBackgroundSource,
      segproperty: segmentationProperty,
    );
  }

  Future<void> resetVirtualBackground() async {
    await agoraEngine.enableVirtualBackground(
      enabled: false,
      backgroundSource: const VirtualBackgroundSource(),
      segproperty: const SegmentationProperty(),
    );
  }

  RxBool isEnableFaceDetection = false.obs;
  Future<void> toggleFaceDetection() async {
    try {
      // Bật nhận diện khuôn mặt
      isEnableFaceDetection.value = !isEnableFaceDetection.value;
      await agoraEngine.enableFaceDetection(isEnableFaceDetection.value);
      successMessage("Face Detection enabled.");
    } catch (e) {
      errorMessage("Failed to enable face detection: $e");
    }
  }
}

```

---


### Pages\Friends\Widgets\agora_call_page.dart

```dart
import 'package:flutter/material.dart';
import 'package:flutter_animate/flutter_animate.dart';
import 'package:get/get.dart';
import 'package:tictactoe_gameapp/Components/belong_to_users/avatar_user_widget.dart';
import 'package:tictactoe_gameapp/Models/Functions/general_bottomsheet_show_function.dart';
import 'package:tictactoe_gameapp/Models/Functions/time_functions.dart';
import 'package:tictactoe_gameapp/Models/user_model.dart';
import 'package:tictactoe_gameapp/Pages/Friends/Widgets/Agoras_widget/agora_background_sheet.dart';
import 'package:tictactoe_gameapp/Pages/Friends/Widgets/Agoras_widget/beauty_filter_option_sheet.dart';
import 'package:tictactoe_gameapp/Pages/Friends/Widgets/agora_call_controller.dart';
import 'package:agora_rtc_engine/agora_rtc_engine.dart';

class AgoraCallPage extends StatelessWidget {
  final UserModel userFriend;
  final UserModel userCurrent;
  final String channelId;
  final bool initialMicState;
  final bool initialVideoState;

  const AgoraCallPage({
    super.key,
    required this.userFriend,
    required this.userCurrent,
    required this.initialMicState,
    required this.initialVideoState,
    required this.channelId,
  });

  @override
  Widget build(BuildContext context) {
    final AgoraCallController agoraCallController = Get.put(
      AgoraCallController(
        userId: userCurrent.id!,
        channelId: channelId,
        url: userFriend.image!,
        initialMicState: initialMicState,
        initialVideoState: initialVideoState,
      ),
    );

    return Scaffold(
      body: GestureDetector(
        onTap: () => agoraCallController.isExtendIcons.value = true,
        child: Stack(
          children: [
            Obx(() {
              //video of the remote user
              return agoraCallController.friendUid.value != null &&
                      agoraCallController.isRemmoteVideoEnabled.value == true
                  ? AgoraVideoView(
                      controller: VideoViewController.remote(
                        rtcEngine: agoraCallController.agoraEngine,
                        canvas: VideoCanvas(
                            uid: agoraCallController.friendUid.value),
                        connection: RtcConnection(
                          channelId: channelId,
                        ),
                      ),
                    ).animate().fadeIn(duration: const Duration(seconds: 1))
                  : Container(
                      decoration: const BoxDecoration(
                        gradient: LinearGradient(
                          colors: [Colors.grey, Colors.white],
                          begin: Alignment.topLeft,
                          end: Alignment.bottomRight,
                        ),
                      ),
                    );
            }),
            // Video của User 1 (Góc trên bên phải)
            Positioned(
              top: 70,
              right: 10,
              child: Obx(() {
                return Container(
                  width: 120,
                  height: 160,
                  decoration: BoxDecoration(
                    borderRadius: BorderRadius.circular(10),
                    border: Border.all(color: Colors.blueAccent, width: 3),
                  ),
                  child: agoraCallController.isVideoEnabled.value
                      ? ClipRRect(
                          borderRadius: BorderRadius.circular(5),
                          child: AgoraVideoView(
                            controller: VideoViewController(
                              rtcEngine: agoraCallController.agoraEngine,
                              canvas: const VideoCanvas(uid: 0),
                            ),
                          ),
                        )
                          .animate()
                          .fadeIn(duration: const Duration(milliseconds: 1000))
                      : Container(
                          color: Colors.black,
                          child: const Center(
                            child: Text(
                              'Your video is off',
                              style:
                                  TextStyle(color: Colors.white, fontSize: 12),
                            ),
                          ),
                        ),
                );
              }),
            ),
            // Back và menu phía trên

            Positioned(
              top: 20,
              left: 5,
              right: 10,
              child: Row(
                children: [
                  IconButton(
                    icon: const Icon(
                      Icons.arrow_back_rounded,
                      color: Colors.deepPurpleAccent,
                      size: 35,
                    ),
                    onPressed: () {
                      Get.back();
                    },
                  ),
                  const SizedBox(
                    width: 10,
                  ),
                  Expanded(
                    child: Row(
                      mainAxisAlignment: MainAxisAlignment.spaceBetween,
                      children: [
                        Obx(() => Text(
                              TimeFunctions.displayTimeCount(
                                  agoraCallController.callDuration.value),
                              style: const TextStyle(
                                fontSize: 20,
                                color: Colors.deepPurpleAccent,
                                fontWeight: FontWeight.bold,
                              ),
                            )),
                        Obx(() => Text(
                              'Ping: ${agoraCallController.remotePing.value} ms',
                              style: TextStyle(
                                  fontSize: 15,
                                  color: _getPingColor(
                                      agoraCallController.remotePing.value)),
                            )),
                      ],
                    ),
                  ),
                  IconButton(
                    icon: Icon(
                      _getPingIcon(agoraCallController.remotePing.value),
                      color:
                          _getPingColor(agoraCallController.remotePing.value),
                      size: 35,
                    ),
                    onPressed: () {
                      Get.dialog(_networkInfoDialog(agoraCallController));
                    },
                  ),
                ],
              ),
            ),
            // Avatar và thông tin bạn bè
            Obx(() => agoraCallController.isRemmoteVideoEnabled.value == false
                ? Positioned(
                    top: 200,
                    left: 10,
                    right: 10,
                    child: Column(
                      children: [
                        AvatarUserWidget(
                          radius: 100,
                          imagePath: userFriend.image!,
                          gradientColors: userFriend.avatarFrame ??
                              ["#FF4CAF50", "#FF81C784"],
                          borderThickness: 5,
                        ),
                        const SizedBox(height: 10),
                        Text(
                          userFriend.name!,
                          style: const TextStyle(
                            fontSize: 25,
                            fontWeight: FontWeight.bold,
                          ),
                        ),
                        const SizedBox(height: 10),
                        const Text(
                          "Calling...",
                          style: TextStyle(fontSize: 18),
                        ),
                      ],
                    ),
                  )
                : const SizedBox()),
            // Nút điều khiển phía dưới
            Obx(() => agoraCallController.isExtendIcons.value
                ? Positioned(
                    bottom: 50,
                    left: 20,
                    right: 20,
                    child: Column(
                      children: [
                        Obx(
                          () => agoraCallController.isVideoEnabled.value
                              ? Row(
                                  mainAxisAlignment: MainAxisAlignment.center,
                                  children: [
                                    Obx(() => IconButton(
                                          icon: agoraCallController
                                                  .isEnableFaceDetection.value
                                              ? const Icon(
                                                  Icons
                                                      .face_retouching_natural_rounded,
                                                  color: Colors.blueAccent,
                                                  size: 35,
                                                )
                                              : const Icon(
                                                  Icons
                                                      .face_retouching_off_rounded,
                                                  color: Colors.blueAccent,
                                                  size: 35,
                                                ),
                                          onPressed: () async {
                                            await agoraCallController
                                                .toggleFaceDetection();
                                          },
                                        )),
                                    const SizedBox(
                                      width: 20,
                                    ),
                                    IconButton(
                                      icon: const Icon(
                                        Icons.tips_and_updates,
                                        color: Colors.blueAccent,
                                        size: 35,
                                      ),
                                      onPressed: () async {
                                        await GeneralBottomsheetShowFunction
                                            .showScrollableGeneralBottomsheet(
                                          widgetBuilder:
                                              (context, controller) =>
                                                  BeautyFiltersSheet(
                                            agoraEngine:
                                                agoraCallController.agoraEngine,
                                          ),
                                          context: context,
                                          initHeight: 0.5,
                                        );
                                      },
                                    ),
                                    const SizedBox(
                                      width: 20,
                                    ),
                                    IconButton(
                                      icon: const Icon(
                                        Icons.mode_edit_outlined,
                                        color: Colors.blueAccent,
                                        size: 35,
                                      ),
                                      onPressed: () async {
                                        await GeneralBottomsheetShowFunction
                                            .showScrollableGeneralBottomsheet(
                                          widgetBuilder:
                                              (context, controller) =>
                                                  AgoraBackgroundSheet(
                                            scrollController: controller,
                                            imageAvatar: userCurrent.image!,
                                          ),
                                          context: context,
                                          initHeight: 0.9,
                                        );
                                      },
                                    ),
                                  ],
                                )
                              : const SizedBox(),
                        ),
                        Container(
                          height: 70,
                          decoration: BoxDecoration(
                            color: Colors.black.withOpacity(0.5),
                            borderRadius: BorderRadius.circular(50),
                          ),
                          child: Row(
                            mainAxisAlignment: MainAxisAlignment.spaceAround,
                            children: [
                              Obx(() =>
                                  !agoraCallController.isVideoEnabled.value
                                      ? IconButton(
                                          icon: const Icon(
                                            Icons.videocam_off_sharp,
                                            color: Colors.white,
                                            size: 35,
                                          ),
                                          onPressed: () {
                                            agoraCallController.toggleVideo();
                                          },
                                        )
                                      : IconButton(
                                          icon: const Icon(
                                            Icons.videocam,
                                            color: Colors.white,
                                            size: 35,
                                          ),
                                          onPressed: () {
                                            agoraCallController.toggleVideo();
                                          },
                                        )),
                              Obx(() => !agoraCallController.isMicEnabled.value
                                  ? IconButton(
                                      icon: const Icon(
                                        Icons.mic_off_rounded,
                                        color: Colors.white,
                                        size: 35,
                                      ),
                                      onPressed: () {
                                        agoraCallController.toggleMicro();
                                      },
                                    )
                                  : IconButton(
                                      icon: const Icon(
                                        Icons.mic,
                                        color: Colors.white,
                                        size: 35,
                                      ),
                                      onPressed: () {
                                        agoraCallController.toggleMicro();
                                      },
                                    )),
                              IconButton(
                                icon: const Icon(
                                  Icons.switch_camera_rounded,
                                  color: Colors.white,
                                  size: 35,
                                ),
                                onPressed: () {
                                  agoraCallController.switchCamera();
                                },
                              ),
                              IconButton(
                                  onPressed: () {
                                    agoraCallController.toggleAudio();
                                  },
                                  icon: Obx(() =>
                                      agoraCallController.isAudioEnabled.value
                                          ? const Icon(
                                              Icons.volume_down,
                                              color: Colors.white,
                                              size: 35,
                                            )
                                          : const Icon(
                                              Icons.volume_off_rounded,
                                              color: Colors.white,
                                              size: 35,
                                            ))),
                              IconButton(
                                icon: const Icon(
                                  Icons.phone_disabled_rounded,
                                  color: Colors.redAccent,
                                  size: 35,
                                ),
                                onPressed: () {
                                  Get.back();
                                },
                              ),
                            ],
                          ),
                        ),
                      ],
                    ),
                  ).animate().slide()
                : const SizedBox.shrink()),
          ],
        ),
      ),
    );
  }

  Widget _networkInfoDialog(AgoraCallController controller) {
    return Dialog(
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(20),
      ),
      child: Padding(
        padding: const EdgeInsets.all(20.0),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            const Center(
              child: Text(
                'Network Quality Status',
                style: TextStyle(fontSize: 20, fontWeight: FontWeight.bold),
              ),
            ),
            const SizedBox(height: 10),
            Obx(() => Text(
                  'You:\n${controller.localNetworkQuality.value}',
                  style: const TextStyle(fontSize: 16, color: Colors.green),
                )),
            const SizedBox(height: 10),
            Obx(() => Text(
                  'Your Friend:\n${controller.remoteNetworkQuality.value}',
                  style: const TextStyle(fontSize: 16, color: Colors.blue),
                )),
            const SizedBox(height: 20),
            Align(
              alignment: Alignment.centerRight,
              child: ElevatedButton(
                onPressed: () => Get.back(),
                child: const Text('Close'),
              ),
            ),
          ],
        ),
      ),
    ).animate().slide();
  }

  Color _getPingColor(int ping) {
    if (ping >= 0 && ping < 100) {
      return Colors.lightGreenAccent;
    } else if (ping >= 100 && ping < 300) {
      return Colors.yellowAccent;
    } else if (ping >= 300 && ping < 500) {
      return Colors.orangeAccent;
    } else {
      return Colors.redAccent;
    }
  }

  IconData _getPingIcon(int ping) {
    if (ping >= 0 && ping < 100) {
      return Icons.wifi_rounded;
    } else if (ping >= 100 && ping < 300) {
      return Icons.network_wifi_3_bar_rounded;
    } else if (ping >= 300 && ping < 500) {
      return Icons.wifi_2_bar_rounded;
    } else {
      return Icons.wifi_password_rounded;
    }
  }
}

```

---


### Pages\Friends\Widgets\agora_end_of_call_lay.dart

```dart
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:tictactoe_gameapp/Components/belong_to_users/avatar_user_widget.dart';
import 'package:tictactoe_gameapp/Models/Functions/time_functions.dart';

class EndOfCallLay extends StatelessWidget {
  final String url;
  final int endTime;
  const EndOfCallLay({super.key, required this.url, required this.endTime});

  @override
  Widget build(BuildContext context) {
    return Stack(
      children: [
        Padding(
          padding: const EdgeInsets.symmetric(vertical: 100, horizontal: 30),
          child: Column(
            children: [
              AvatarUserWidget(
                radius: 40,
                imagePath: url,
              ),
              const Spacer(
                flex: 1,
              ),
              Column(
                children: [
                  const Text(
                    "Call ended",
                    style: TextStyle(
                      color: Colors.white,
                      fontSize: 20,
                    ),
                  ),
                  Text(
                    TimeFunctions.displayTimeCount(endTime),
                    style: const TextStyle(
                      color: Colors.white54,
                      fontSize: 16,
                    ),
                  ),
                ],
              ),
              const Spacer(
                flex: 2,
              ),
              const Text(
                "How was the quality of your call?",
                style: TextStyle(
                  color: Colors.white,
                  fontSize: 18,
                ),
              ),
              const Spacer(
                flex: 2,
              ),
              Row(
                mainAxisAlignment: MainAxisAlignment.spaceEvenly,
                children: [
                  Column(
                    children: [
                      InkWell(
                        onTap: () {},
                        borderRadius: BorderRadius.circular(100),
                        splashColor: Colors.blueAccent,
                        child: Ink(
                          padding: const EdgeInsets.all(5.0),
                          decoration: const BoxDecoration(
                            shape: BoxShape.circle,
                            color: Colors.blueGrey,
                          ),
                          child: const Icon(
                            Icons.thumb_up_alt_rounded,
                            color: Colors.white,
                            size: 40,
                          ),
                        ),
                      ),
                      const SizedBox(
                        height: 5,
                      ),
                      const Text(
                        "Good",
                        style: TextStyle(
                          color: Colors.white,
                          fontSize: 18,
                        ),
                      ),
                    ],
                  ),
                  Column(
                    children: [
                      InkWell(
                        onTap: () {},
                        borderRadius: BorderRadius.circular(100),
                        splashColor: Colors.redAccent,
                        child: Ink(
                          padding: const EdgeInsets.all(5.0),
                          decoration: const BoxDecoration(
                            shape: BoxShape.circle,
                            color: Colors.blueGrey,
                          ),
                          child: const Icon(
                            Icons.thumb_down_alt_rounded,
                            color: Colors.white,
                            size: 40,
                          ),
                        ),
                      ),
                      const SizedBox(
                        height: 5,
                      ),
                      const Text(
                        "Bad",
                        style: TextStyle(
                          color: Colors.white,
                          fontSize: 18,
                        ),
                      ),
                    ],
                  ),
                ],
              ),
              const Spacer(
                flex: 2,
              ),
              const Column(
                children: [
                  Text(
                    "We may use your data for personalization, innovation, research and other purposes described in our",
                    textAlign: TextAlign.center,
                    style: TextStyle(
                      color: Colors.white,
                      fontSize: 13,
                    ),
                  ),
                  Text(
                    "Privacy Policy",
                    style: TextStyle(
                      color: Colors.lightBlueAccent,
                      fontSize: 13,
                    ),
                  ),
                ],
              ),
            ],
          ),
        ),
        Positioned(
          top: 10,
          right: 10,
          child: IconButton(
            onPressed: () => Get.back(),
            icon: const Icon(
              Icons.cancel,
              color: Colors.white,
              size: 35,
            ),
          ),
        ),
      ],
    );
  }
}

```

---


### Pages\Friends\Widgets\background_list_controller.dart

```dart
import 'dart:ui';

import 'package:get/get.dart';
import 'package:tictactoe_gameapp/Controller/theme_controller.dart';
import 'package:tictactoe_gameapp/Models/Functions/gradient_generator_functions.dart';

class InfiniteGradientGridController extends GetxController {
  // Rx list to store gradients
  var gradients = <Map<String, dynamic>>[].obs;
  var colors = <Color>[].obs;
  var isLoading = false.obs;
  final ThemeController themeController = Get.find();

  final bool isGradient;
  InfiniteGradientGridController({required this.isGradient});

  @override
  void onInit() {
    super.onInit();
    if (isGradient) {
      loadMoreGradients();
    } else {
      loadMoreColors();
    }
  }

  // Load more gradients function
  void loadMoreGradients() {
    if (isLoading.value) return;
    isLoading.value = true;

    Future.delayed(const Duration(milliseconds: 300), () {
      List<Map<String, dynamic>> newGradients = List.generate(9, (_) {
        final colors =
            GradientGeneratorFunctions.getDynamicRandomGradientColors(
          colorCount: 2,
          isDarkMode: themeController.isDarkMode.value,
        );

        return {
          "colors": colors,
          "name":
              GradientGeneratorFunctions.generateGradientName(colors: colors),
        };
      });

      // Sử dụng addAll để thêm nhiều phần tử một lần duy nhất
      gradients.addAll(newGradients);
      isLoading.value = false;
    });
  }

  // Load more colors function
  void loadMoreColors() {
    if (isLoading.value) return;
    isLoading.value = true;

    Future.delayed(const Duration(milliseconds: 300), () {
      List<Color> newColors = List.generate(9, (_) {
        return GradientGeneratorFunctions.generateRandomColor();
      });

      // Thêm màu mới
      colors.addAll(newColors);
      isLoading.value = false;
    });
  }
}

```

---


### Pages\Friends\Widgets\background_list_sheet.dart

```dart
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:tictactoe_gameapp/Configs/theme/colors.dart';
import 'package:tictactoe_gameapp/Data/chat_friend_controller.dart';
import 'package:tictactoe_gameapp/Models/Functions/color_string_reverse_function.dart';
import 'package:tictactoe_gameapp/Pages/Friends/Widgets/background_list_controller.dart';

class BackgroundListSheet extends StatelessWidget {
  final ChatFriendController chatFriendController;
  final ScrollController scrollController;
  const BackgroundListSheet(
      {super.key,
      required this.scrollController,
      required this.chatFriendController});

  @override
  Widget build(BuildContext context) {
    final InfiniteGradientGridController controller =
        Get.put(InfiniteGradientGridController(isGradient: true));
    return Padding(
      padding: const EdgeInsets.all(10.0),
      child: Column(
        children: [
          Row(
            children: [
              IconButton(
                onPressed: () => Get.back(),
                icon: const Icon(
                  Icons.arrow_back_rounded,
                  size: 35,
                ),
              ),
              const SizedBox(
                width: 20,
              ),
              const Text(
                "Theme",
                style: TextStyle(
                  fontSize: 20,
                  fontWeight: FontWeight.bold,
                ),
              )
            ],
          ),
          const SizedBox(
            height: 10,
          ),
          Expanded(
            child: NotificationListener<ScrollNotification>(
              onNotification: (ScrollNotification scrollInfo) {
                if (!controller.isLoading.value &&
                    scrollInfo.metrics.pixels >=
                        scrollInfo.metrics.maxScrollExtent * 0.9) {
                  controller.loadMoreGradients();
                }
                return true;
              },
              child: Obx(() => GridView.builder(
                    controller: scrollController,
                    gridDelegate:
                        const SliverGridDelegateWithFixedCrossAxisCount(
                      crossAxisCount: 3,
                      childAspectRatio: 0.4,
                      mainAxisSpacing: 20,
                      crossAxisSpacing: 20,
                    ),
                    itemCount: controller.gradients.length +
                        (controller.isLoading.value ? 1 : 0),
                    itemBuilder: (context, index) {
                      if (index < controller.gradients.length) {
                        final colors = controller.gradients[index]["colors"]
                            as List<Color>;
                        final name =
                            controller.gradients[index]["name"] as String;
                        return index == 0
                            ? Material(
                                child: InkWell(
                                  borderRadius: BorderRadius.circular(12),
                                  splashColor: colors.first,
                                  onTap: () async {
                                    await chatFriendController
                                        .setDefaultThemeForChatRoom();
                                  },
                                  child: Column(
                                    children: [
                                      Ink(
                                          height: 200,
                                          width: 150,
                                          decoration: BoxDecoration(
                                            color: bgColor,
                                            borderRadius:
                                                BorderRadius.circular(12),
                                          ),
                                          child: Padding(
                                            padding: const EdgeInsets.all(5.0),
                                            child: Column(
                                              children: [
                                                const Text(
                                                  "Previewing...",
                                                  style: TextStyle(
                                                      fontWeight:
                                                          FontWeight.bold),
                                                ),
                                                const SizedBox(
                                                  height: 20,
                                                ),
                                                Align(
                                                  alignment: Alignment.topLeft,
                                                  child: Container(
                                                    width: 100,
                                                    height: 50,
                                                    padding:
                                                        const EdgeInsets.all(
                                                            5.0),
                                                    decoration: BoxDecoration(
                                                      borderRadius:
                                                          BorderRadius.circular(
                                                              20),
                                                      color: Colors.greenAccent,
                                                    ),
                                                    child: const Text("Hello."),
                                                  ),
                                                ),
                                                const SizedBox(
                                                  height: 10,
                                                ),
                                                Align(
                                                  alignment: Alignment.topRight,
                                                  child: Container(
                                                    width: 100,
                                                    height: 50,
                                                    padding:
                                                        const EdgeInsets.all(
                                                            5.0),
                                                    alignment:
                                                        Alignment.topRight,
                                                    decoration: BoxDecoration(
                                                      borderRadius:
                                                          BorderRadius.circular(
                                                              20),
                                                      color: Colors.blueAccent,
                                                    ),
                                                    child: const Text(
                                                      "What's up?",
                                                      style: TextStyle(
                                                        color: Colors.black,
                                                      ),
                                                    ),
                                                  ),
                                                ),
                                              ],
                                            ),
                                          )),
                                      const SizedBox(
                                        height: 10,
                                      ),
                                      const Text(
                                        "Default",
                                        textAlign: TextAlign.center,
                                        style: TextStyle(
                                          fontSize: 15,
                                          color: Colors.black,
                                          fontWeight: FontWeight.bold,
                                        ),
                                      )
                                    ],
                                  ),
                                ),
                              )
                            : Material(
                                child: InkWell(
                                  borderRadius: BorderRadius.circular(12),
                                  splashColor: colors.first,
                                  onTap: () async {
                                    await chatFriendController
                                        .setThemeForChatRoom(
                                      colors: colors
                                          .map((color) =>
                                              ColorStringReverseFunction
                                                  .colorToHex(color))
                                          .toList(),
                                    );
                                  },
                                  child: Column(
                                    children: [
                                      Ink(
                                          height: 200,
                                          width: 150,
                                          decoration: BoxDecoration(
                                            gradient: LinearGradient(
                                              colors: colors,
                                              begin: Alignment.topLeft,
                                              end: Alignment.bottomRight,
                                            ),
                                            borderRadius:
                                                BorderRadius.circular(12),
                                          ),
                                          child: Padding(
                                            padding: const EdgeInsets.all(5.0),
                                            child: Column(
                                              children: [
                                                const Text("Previewing..."),
                                                const SizedBox(
                                                  height: 20,
                                                ),
                                                Align(
                                                  alignment: Alignment.topLeft,
                                                  child: Container(
                                                    width: 100,
                                                    height: 50,
                                                    padding:
                                                        const EdgeInsets.all(
                                                            5.0),
                                                    decoration: BoxDecoration(
                                                      borderRadius:
                                                          BorderRadius.circular(
                                                              20),
                                                      color: Colors.white,
                                                    ),
                                                    child: const Text("Hello."),
                                                  ),
                                                ),
                                                const SizedBox(
                                                  height: 10,
                                                ),
                                                Align(
                                                  alignment: Alignment.topRight,
                                                  child: Container(
                                                    width: 100,
                                                    height: 50,
                                                    padding:
                                                        const EdgeInsets.all(
                                                            5.0),
                                                    alignment:
                                                        Alignment.topRight,
                                                    decoration: BoxDecoration(
                                                      borderRadius:
                                                          BorderRadius.circular(
                                                              20),
                                                      color: colors.first,
                                                    ),
                                                    child: const Text(
                                                      "What's up?",
                                                      style: TextStyle(
                                                        color: Colors.white,
                                                      ),
                                                    ),
                                                  ),
                                                ),
                                              ],
                                            ),
                                          )),
                                      const SizedBox(
                                        height: 10,
                                      ),
                                      Text(
                                        name,
                                        textAlign: TextAlign.center,
                                        style: TextStyle(
                                          fontSize: 15,
                                          color: colors.first,
                                          fontWeight: FontWeight.bold,
                                        ),
                                      )
                                    ],
                                  ),
                                ),
                              );
                      } else {
                        return const SizedBox();
                      }
                    },
                  )),
            ),
          ),
        ],
      ),
    );
  }
}

```

---


### Pages\Friends\Widgets\chat_friend_item.dart

```dart
import 'dart:convert';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_chat_bubble/chat_bubble.dart';
import 'package:get/get.dart';
import 'package:tictactoe_gameapp/Components/belong_to_users/avatar_user_widget.dart';
import 'package:tictactoe_gameapp/Components/gifphy/display_gif_widget.dart';
import 'package:tictactoe_gameapp/Components/shimmers/messages_placeholder_widget.dart';
import 'package:tictactoe_gameapp/Configs/messages.dart';
import 'package:tictactoe_gameapp/Configs/paint_draws/bubble_chat_painter.dart';
import 'package:tictactoe_gameapp/Data/chat_friend_controller.dart';
import 'package:tictactoe_gameapp/Data/fetch_firestore_database.dart';
import 'package:tictactoe_gameapp/Models/Functions/hyperlink_text_function.dart';
import 'package:tictactoe_gameapp/Models/Functions/time_functions.dart';
import 'package:tictactoe_gameapp/Models/message_friend_model.dart';
import 'package:tictactoe_gameapp/Models/user_model.dart';

class ChatFriendItem extends StatelessWidget {
  final UserModel userFriend;
  final String currentUserId;
  final FirestoreController firestoreController;
  final ChatFriendController chatController;
  final List<Color> color;
  final ThemeData theme;

  const ChatFriendItem({
    super.key,
    required this.userFriend,
    required this.currentUserId,
    required this.chatController,
    required this.firestoreController,
    required this.theme,
    required this.color,
  });
  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        Obx(() => chatController.isLoadingMore.value
            ? Center(
                child: Container(
                  decoration: BoxDecoration(
                    color: Colors.white,
                    borderRadius: BorderRadius.circular(100),
                  ),
                  child: const CircularProgressIndicator(
                    color: Colors.blue,
                  ),
                ),
              )
            : const SizedBox()),
        Expanded(
          child: Obx(() {
            if (chatController.filtermessages.isEmpty &&
                chatController.isLoadingMore.value) {
              return Column(
                children: [
                  ListView.builder(
                    itemCount: 5, // Số lượng placeholder hiển thị
                    shrinkWrap: true,
                    physics: const NeverScrollableScrollPhysics(),
                    itemBuilder: (context, index) {
                      return const MessagesPlaceholderWidget(
                        isMe: false,
                      );
                    },
                  ),
                  ListView.builder(
                    itemCount: 5, // Số lượng placeholder hiển thị
                    shrinkWrap: true,
                    physics: const NeverScrollableScrollPhysics(),
                    itemBuilder: (context, index) {
                      return const MessagesPlaceholderWidget(
                        isMe: true,
                      );
                    },
                  ),
                ],
              );
            } else if (chatController.filtermessages.isEmpty) {
              return Center(
                child: Container(
                  decoration: BoxDecoration(
                    color: Colors.white,
                    borderRadius: BorderRadius.circular(100),
                  ),
                  child: const CircularProgressIndicator(
                    color: Colors.blue,
                  ),
                ),
              );
            }
            return NotificationListener<ScrollNotification>(
              onNotification: (ScrollNotification scrollInfo) {
                if (scrollInfo.metrics.pixels ==
                        scrollInfo.metrics.maxScrollExtent &&
                    !chatController.isLoadingMore.value) {
                  chatController.loadMessages();
                }
                return true;
              },
              child: Stack(
                children: [
                  ListView.builder(
                    controller: chatController.scrollController,
                    itemCount: chatController.filtermessages.length,
                    reverse: true,
                    itemBuilder: (context, index) {
                      final message = chatController.filtermessages[index];
                      final isMe =
                          message.senderId == chatController.currentUserId;
                      return _buildMessageBubble(
                          context, userFriend, message, isMe, index);
                    },
                  ),
                  SizedBox(
                    height: double.maxFinite,
                    width: double.infinity,
                    child: Obx(
                      () => chatController.isSearching.value
                          ? Positioned(
                              top: 0,
                              child: TextField(
                                onChanged: (value) {
                                  chatController.updateSearchText(value);
                                },
                                decoration: InputDecoration(
                                  labelText: 'Search messages',
                                  labelStyle: theme.textTheme.bodyLarge!
                                      .copyWith(color: Colors.blueGrey),
                                  border: OutlineInputBorder(
                                    borderRadius: BorderRadius.circular(30),
                                    borderSide: const BorderSide(
                                        color: Colors.blueAccent),
                                  ),
                                  prefixIcon: IconButton(
                                    onPressed: () {},
                                    icon: const Icon(Icons.search),
                                  ),
                                  prefixIconColor: Colors.blueGrey,
                                ),
                              ),
                            )
                          : const SizedBox(),
                    ),
                  ),
                ],
              ),
            );
          }),
        ),
      ],
    );
  }

  Widget _buildMessageBubble(
    BuildContext context,
    UserModel userFriend,
    MessageFriendModel message,
    bool isMe,
    int index,
  ) {
    // Kiểm tra nếu người gửi tin nhắn trước đó giống người hiện tại
    bool showAvatar = true;
    if (index < chatController.filtermessages.length - 1) {
      final previousMessage = chatController.filtermessages[index + 1];
      if (previousMessage.senderId == message.senderId) {
        showAvatar = false;
      }
    }
    return GestureDetector(
      onTap: () {
        _showMessageActions(message, chatController);
      },
      child: Row(
        mainAxisAlignment:
            isMe ? MainAxisAlignment.end : MainAxisAlignment.start,
        crossAxisAlignment:
            isMe ? CrossAxisAlignment.center : CrossAxisAlignment.start,
        children: [
          if (!isMe && showAvatar)
            AvatarUserWidget(
              radius: 25,
              imagePath: userFriend.image!,
              gradientColors: userFriend.avatarFrame,
            ),
          if (!isMe && !showAvatar) const SizedBox(width: 50),
          Flexible(
            child: ChatBubble(
              alignment: isMe ? Alignment.topRight : Alignment.topLeft,
              clipper: isMe
                  ? ChatBubbleClipper3(type: BubbleType.sendBubble)
                  : ChatBubbleClipper8(type: BubbleType.receiverBubble),
              padding: const EdgeInsets.all(0),
              margin: const EdgeInsets.only(top: 5),
              backGroundColor: _checkColors(isMe, color).last,
              child: Container(
                margin: const EdgeInsets.symmetric(vertical: 5, horizontal: 10),
                decoration: BoxDecoration(
                  borderRadius: BorderRadius.circular(15),
                  // gradient: LinearGradient(
                  //   colors: _checkColors(isMe, color),
                  // ),
                ),
                child: ClipRRect(
                  borderRadius: BorderRadius.circular(15),
                  child: BubbleBackground(
                    colors: _checkColors(isMe, color),
                    child: Padding(
                      padding: const EdgeInsets.all(10),
                      child: Column(
                        crossAxisAlignment: isMe
                            ? CrossAxisAlignment.end
                            : CrossAxisAlignment.start,
                        children: [
                          SelectableText.rich(
                            TextSpan(
                              children: HyperlinkTextFunction.buildMessageText(
                                context,
                                text: message.content!,
                                color: _checkColor(isMe: isMe, colors: color),
                                previewUrlMode: true,
                                colors: color,
                              ),
                            ),
                            style: TextStyle(
                              color: _checkColor(isMe: isMe, colors: color),
                            ),
                          ),
                          message.imagePath != null && message.imagePath != ""
                              ? GestureDetector(
                                  onTap: () {
                                    Get.dialog(
                                      Dialog(
                                        backgroundColor: Colors.transparent,
                                        insetPadding: const EdgeInsets.all(10),
                                        child: GestureDetector(
                                          onTap: () => Get.back(),
                                          child: InteractiveViewer(
                                            boundaryMargin:
                                                const EdgeInsets.all(8),
                                            minScale: 0.0005,
                                            maxScale: 3,
                                            child: Container(
                                              width: double.infinity,
                                              height: 200,
                                              alignment: Alignment.topCenter,
                                              decoration: BoxDecoration(
                                                image: DecorationImage(
                                                  image: MemoryImage(
                                                    base64Decode(
                                                      message.imagePath!,
                                                    ),
                                                  ),
                                                  fit: BoxFit.fitWidth,
                                                ),
                                              ),
                                            ),
                                          ),
                                        ),
                                      ),
                                    );
                                  },
                                  child: ClipRRect(
                                    borderRadius: BorderRadius.circular(10),
                                    child: Image.memory(
                                      base64Decode(
                                        message.imagePath!,
                                      ),
                                    ),
                                  ),
                                )
                              : const SizedBox(),
                          message.gif != null
                              ? DisplayGifWidget(gifUrl: message.gif!)
                              : const SizedBox(),
                          const SizedBox(height: 5),
                          Text(
                            TimeFunctions.displayTime(message.timestamp!),
                            style: TextStyle(
                                color: isMe
                                    ? color.length == 2 &&
                                            color[0] == Colors.transparent &&
                                            color[1] == Colors.transparent
                                        ? Colors.blueGrey.shade600
                                        : Colors.white54
                                    : Colors.blueGrey,
                                fontSize: 10),
                          ),
                        ],
                      ),
                    ),
                  ),
                ),
              ),
            ),
          ),
          if (isMe) const SizedBox(width: 5),
        ],
      ),
    );
  }

  void _showMessageActions(
    MessageFriendModel message,
    ChatFriendController chatController,
  ) {
    Get.bottomSheet(
      Container(
        height: 100,
        padding: const EdgeInsets.symmetric(vertical: 10),
        width: double.infinity,
        decoration: const BoxDecoration(
          color: Colors.white,
        ),
        child: Row(
          mainAxisAlignment: MainAxisAlignment.spaceEvenly,
          children: [
            Column(
              children: [
                IconButton(
                    onPressed: () {
                      // chatController.sendMessage(
                      //     'Replying to: ${message.messageId}',
                      //     replyToMessageId: message.messageId);
                      Get.back();
                    },
                    icon: const Icon(
                      Icons.reply,
                      size: 35,
                      color: Colors.blueAccent,
                    )),
                const Text('Reply'),
              ],
            ),
            Column(
              children: [
                IconButton(
                    onPressed: () async {
                      await chatController.deleteMessage(message.messageId!);
                      Get.back();
                    },
                    icon: const Icon(
                      Icons.delete,
                      size: 35,
                      color: Colors.blueAccent,
                    )),
                const Text('Delete'),
              ],
            ),
            Column(
              children: [
                IconButton(
                    onPressed: () {
                      chatController.shareMessage(
                          message.content!, 'targetUserId');
                      Get.back();
                    },
                    icon: const Icon(
                      Icons.share,
                      size: 35,
                      color: Colors.blueAccent,
                    )),
                const Text('Share'),
              ],
            ),
            Column(
              children: [
                IconButton(
                    onPressed: () async => await Clipboard.setData(
                                ClipboardData(
                                    text: message.content ?? "https://"))
                            .then(
                          (value) => successMessage('Copied to Clipboard'),
                        ),
                    icon: const Icon(
                      Icons.menu,
                      size: 35,
                      color: Colors.blueAccent,
                    )),
                const Text('Copy'),
              ],
            ),
          ],
        ),
      ),
      elevation: 5.0,
    );
  }

  List<Color> _checkColors(bool isMe, List<Color> colors) {
    if (isMe) {
      if ((colors.length == 2 &&
          colors[0] == Colors.transparent &&
          colors[1] == Colors.transparent)) {
        return [
          Colors.lightBlue,
          Colors.lightBlueAccent,
        ];
      } else {
        return colors;
      }
    } else {
      return [Colors.greenAccent, Colors.lightGreenAccent];
    }
  }

  Color _checkColor({required bool isMe, required List<Color> colors}) {
    if (isMe) {
      if ((colors.length == 2 &&
          colors[0] == Colors.transparent &&
          colors[1] == Colors.transparent)) {
        return Colors.black;
      } else {
        return Colors.white;
      }
    } else {
      return Colors.black;
    }
  }
}

class BubbleBackground extends StatelessWidget {
  const BubbleBackground({
    super.key,
    required this.colors,
    this.child,
  });

  final List<Color> colors;
  final Widget? child;

  @override
  Widget build(BuildContext context) {
    return CustomPaint(
      painter: BubbleChatPainter(
        scrollable: Scrollable.of(context),
        bubbleContext: context,
        colors: colors,
      ),
      child: child,
    );
  }
}

```

---


### Pages\Friends\Widgets\messages_widget.dart

```dart
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:tictactoe_gameapp/Components/belong_to_users/avatar_user_widget.dart';
import 'package:tictactoe_gameapp/Controller/MainHome/notify_in_main_controller.dart';
import 'package:tictactoe_gameapp/Data/fetch_firestore_database.dart';
import 'package:tictactoe_gameapp/Models/Functions/time_functions.dart';
import 'package:tictactoe_gameapp/Models/message_friend_model.dart';
import 'package:tictactoe_gameapp/Models/user_model.dart';
import 'package:tictactoe_gameapp/Pages/Friends/chat_with_friend_page.dart';
import 'package:tictactoe_gameapp/Pages/Friends/listen_latest_messages_controller.dart';
import 'package:tictactoe_gameapp/Components/shimmers/chats_placeholder_widget.dart';
import 'package:tictactoe_gameapp/Pages/Society/About/user_about_page.dart';

class MessagesWidget extends StatelessWidget {
  final ListenLatestMessagesController listenLatestMessagesController;
  final FirestoreController firestoreController;
  final NotifyInMainController notifyInMainController;
  final ThemeData theme;
  const MessagesWidget(
      {super.key,
      required this.firestoreController,
      required this.theme,
      required this.listenLatestMessagesController,
      required this.notifyInMainController});

  @override
  Widget build(BuildContext context) {
    return Obx(() {
      if (listenLatestMessagesController.isFetching.value) {
        return const ChatsPlaceholderWidget();
      } else {
        if (firestoreController.filterfriendsList.isEmpty) {
          return Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              Text(
                "Are you an introvert?",
                style: theme.textTheme.headlineMedium,
              ),
              Text(
                "Find matching friends",
                style: theme.textTheme.bodyMedium,
              ),
            ],
          );
        } else {
          var friends = firestoreController.filterfriendsList.toList();
          return ListView.builder(
            physics: const BouncingScrollPhysics(),
            itemCount: friends.length,
            itemBuilder: (context, index) {
              var friend = friends[index];
              MessageFriendModel? latestMessage = listenLatestMessagesController
                  .latestMessages
                  .firstWhereOrNull((msg) =>
                      msg.receiverId == friend.id || msg.senderId == friend.id);

              return Dismissible(
                key: Key(friend.id!),
                direction: DismissDirection.endToStart,
                background: _backgroundDismissible(firestoreController, friend),
                confirmDismiss: (direction) async {
                  await Future.delayed(const Duration(seconds: 5));
                  return false;
                },
                child: InkWell(
                  onTap: () {
                    Get.to(ChatWithFriendPage(
                      userFriend: friend,
                      notifyInMainController: notifyInMainController,
                    ));
                  },
                  borderRadius: BorderRadius.circular(20),
                  child: Padding(
                    padding: const EdgeInsets.symmetric(
                        horizontal: 10, vertical: 15),
                    child: Row(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Hero(
                          tag: 'friendAvatar-${friend.id}',
                          transitionOnUserGestures: true,
                          child: AvatarUserWidget(
                            radius: 35,
                            imagePath: friend.image!,
                          ),
                        ),
                        const SizedBox(width: 10),
                        Expanded(
                          child: Column(
                            crossAxisAlignment: CrossAxisAlignment.start,
                            children: [
                              Text(friend.name!,
                                  style: theme.textTheme.bodyLarge),
                              const SizedBox(height: 5),
                              latestMessage != null
                                  ? Text(
                                      latestMessage.content!,
                                      overflow: TextOverflow.ellipsis,
                                      maxLines: 2,
                                    )
                                  : const Text(
                                      "Hello friend ! How are you? ",
                                      overflow: TextOverflow.ellipsis,
                                      maxLines: 1,
                                      style: TextStyle(
                                        color: Colors.grey,
                                      ),
                                    ),
                            ],
                          ),
                        ),
                        friend.lastActive == null
                            ? const Text(
                                "12:14 AM",
                                style: TextStyle(
                                  color: Colors.blueGrey,
                                  fontSize: 15,
                                ),
                              )
                            : Text(
                                TimeFunctions.displayTime(friend.lastActive!),
                                style: const TextStyle(
                                  color: Colors.blueGrey,
                                  fontSize: 15,
                                ),
                              ),
                      ],
                    ),
                  ),
                ),
              );
            },
          );
        }
      }
    });
  }

  Widget _backgroundDismissible(
      FirestoreController firestoreController, UserModel friend) {
    return Container(
        padding: const EdgeInsets.symmetric(horizontal: 20),
        color: Colors.transparent,
        child: Row(
          mainAxisAlignment: MainAxisAlignment.spaceEvenly,
          children: [
            const SizedBox(width: 10),
            IconButton(
                onPressed: () {
                  Get.to(
                      UserAboutPage(
                        unknownableUser: friend,
                      ),
                      transition: Transition.leftToRightWithFade);
                },
                icon: const Icon(
                  Icons.info_rounded,
                )),
            const Icon(
              Icons.pin_drop,
              color: Colors.blue,
              size: 35,
            ),
            const Icon(
              Icons.notifications_off,
              color: Colors.blue,
              size: 35,
            ),
            IconButton(
                onPressed: () async {
                  await Get.dialog(
                    AlertDialog(
                      title: const Text("Confirm"),
                      content: const Text("Do you want to delete this friend?"),
                      actions: <Widget>[
                        TextButton(
                          onPressed: () {
                            Get.back();
                          },
                          child: const Text("Cancel"),
                        ),
                        TextButton(
                          onPressed: () {
                            firestoreController.removeFriend(friend.id!);
                          },
                          child: const Text("Delete"),
                        ),
                      ],
                    ),
                  );
                },
                icon: const Icon(
                  Icons.delete,
                  color: Colors.red,
                  size: 35,
                )), // Icon delete
          ],
        ));
  }
}

```

---


### Pages\Friends\Widgets\notes_widget.dart

```dart
import 'package:cached_network_image/cached_network_image.dart';
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:tictactoe_gameapp/Controller/MainHome/notify_in_main_controller.dart';
import 'package:tictactoe_gameapp/Data/fetch_firestore_database.dart';
import 'package:tictactoe_gameapp/Models/Functions/time_functions.dart';

class NotesWidget extends StatelessWidget {
  final ThemeData theme;
  final NotifyInMainController notifyInMainController;
  final FirestoreController firestoreController;
  const NotesWidget(
      {super.key,
      required this.theme,
      required this.notifyInMainController,
      required this.firestoreController});

  @override
  Widget build(BuildContext context) {
    return Obx(() {
      return ListView.builder(
        itemCount: notifyInMainController.filteredFriendRequests.length,
        itemBuilder: (context, index) {
          var friendRequests =
              notifyInMainController.filteredFriendRequests.toList();
          var friendRequest = friendRequests[index];
          return Padding(
            padding: const EdgeInsets.symmetric(horizontal: 10, vertical: 15),
            child: Row(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                CircleAvatar(
                  backgroundImage: CachedNetworkImageProvider(
                      friendRequest.senderModel!.image!),
                  radius: 35,
                ),
                const SizedBox(width: 10),
                Expanded(
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text(friendRequest.senderModel!.name!,
                          style: theme.textTheme.bodyLarge),
                      const Text(
                        "have sent a friend request",
                        overflow: TextOverflow.ellipsis,
                        maxLines: 2,
                        style: TextStyle(
                          color: Colors.grey,
                        ),
                      ),
                    ],
                  ),
                ),
                Column(
                  children: [
                    friendRequest.timestamp == null
                        ? const Text(
                            "12:14 AM",
                            style: TextStyle(
                              color: Colors.blueGrey,
                              fontSize: 13,
                            ),
                          )
                        : Text(
                            TimeFunctions.displayTime(friendRequest.timestamp!),
                            style: const TextStyle(
                              color: Colors.blueGrey,
                              fontSize: 13,
                            ),
                          ),
                    Row(
                      children: [
                        IconButton(
                          onPressed: () async {
                            await notifyInMainController
                                .deleteFriendRequest(friendRequest.id!);
                          },
                          icon: const Icon(
                            Icons.cancel_outlined,
                            color: Colors.redAccent,
                            size: 30,
                          ),
                        ),
                        IconButton(
                          onPressed: () async {
                            await firestoreController.addFriend(
                                friendRequest.senderId!,
                                friendRequest.receiverId!);
                            await firestoreController.addFriend(
                                friendRequest.receiverId!,
                                friendRequest.senderId!);
                            await notifyInMainController
                                .deleteFriendRequest(friendRequest.id!);
                          },
                          icon: const Icon(
                            Icons.done_outline_outlined,
                            color: Colors.green,
                            size: 30,
                          ),
                        ),
                      ],
                    )
                  ],
                )
              ],
            ),
          );
        },
      );
    });
  }
}

```

---


### Pages\Friends\Widgets\Agoras_widget\agora_background_sheet.dart

```dart
import 'dart:io';

import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:image_picker/image_picker.dart';
import 'package:tictactoe_gameapp/Components/belong_to_users/avatar_user_widget.dart';
import 'package:tictactoe_gameapp/Controller/profile_controller.dart';
import 'package:tictactoe_gameapp/Pages/Friends/Widgets/background_list_controller.dart';

class AgoraBackgroundSheet extends StatelessWidget {
  final ScrollController scrollController;
  final String imageAvatar;
  const AgoraBackgroundSheet(
      {super.key, required this.scrollController, required this.imageAvatar});

  @override
  Widget build(BuildContext context) {
    final InfiniteGradientGridController controller =
        Get.put(InfiniteGradientGridController(isGradient: false));
    RxString imagePath = "".obs;
    XFile? image;
    return Padding(
      padding: const EdgeInsets.all(10.0),
      child: Column(
        children: [
          SingleChildScrollView(
            scrollDirection: Axis.horizontal,
            child: Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                IconButton(
                  onPressed: () => Get.back(),
                  icon: const Icon(
                    Icons.arrow_back_rounded,
                    size: 35,
                  ),
                ),
                const Text(
                  "Virtual Background",
                  style: TextStyle(
                    fontSize: 20,
                    fontWeight: FontWeight.bold,
                  ),
                ),
                Row(
                  children: [
                    IconButton(
                      onPressed: () async {
                        final ProfileController profileController = Get.find();

                        image = await profileController
                            .pickFileX(ImageSource.camera);
                        if (image != null) {
                          imagePath.value = image!.path;
                        } else {
                          imagePath.value = "";
                        }
                      },
                      icon: const Icon(
                        Icons.camera_alt_rounded,
                        size: 30,
                      ),
                    ),
                    IconButton(
                      onPressed: () async {
                        final ProfileController profileController = Get.find();

                        image = await profileController
                            .pickFileX(ImageSource.gallery);
                        if (image != null) {
                          imagePath.value = image!.path;
                        } else {
                          imagePath.value = "";
                        }
                      },
                      icon: const Icon(
                        Icons.image_rounded,
                        size: 30,
                      ),
                    ),
                    IconButton(
                      onPressed: () {
                        imagePath.value = "";
                      },
                      icon: const Icon(
                        Icons.refresh_rounded,
                        size: 30,
                      ),
                    ),
                  ],
                )
              ],
            ),
          ),
          const SizedBox(
            height: 10,
          ),
          Expanded(
            child: NotificationListener<ScrollNotification>(
              onNotification: (ScrollNotification scrollInfo) {
                if (!controller.isLoading.value &&
                    scrollInfo.metrics.pixels >=
                        scrollInfo.metrics.maxScrollExtent * 0.9) {
                  controller.loadMoreColors();
                }
                return true;
              },
              child: Obx(() => GridView.builder(
                    controller: scrollController,
                    gridDelegate:
                        const SliverGridDelegateWithFixedCrossAxisCount(
                      crossAxisCount: 3,
                      childAspectRatio: 0.55,
                      mainAxisSpacing: 20,
                      crossAxisSpacing: 20,
                    ),
                    itemCount: controller.colors.length +
                        (controller.isLoading.value ? 1 : 0),
                    itemBuilder: (context, index) {
                      if (index < controller.colors.length) {
                        final color = controller.colors[index];

                        return index == 0
                            ? Material(
                                child: InkWell(
                                  borderRadius: BorderRadius.circular(12),
                                  splashColor: Colors.black,
                                  onTap: () async {},
                                  child: Ink(
                                    height: 200,
                                    width: 150,
                                    decoration: BoxDecoration(
                                        color: Colors.white,
                                        borderRadius: BorderRadius.circular(12),
                                        border: Border.all(
                                            color: Colors.black, width: 3)),
                                    child: Obx(() => imagePath.value.isNotEmpty
                                        ? ClipRRect(
                                            borderRadius:
                                                BorderRadius.circular(5),
                                            child: Image.file(
                                              File(
                                                imagePath.value,
                                              ),
                                              fit: BoxFit.cover,
                                            ),
                                          )
                                        : const SizedBox()),
                                  ),
                                ),
                              )
                            : Material(
                                child: InkWell(
                                  borderRadius: BorderRadius.circular(12),
                                  splashColor: Colors.white,
                                  onTap: () async {},
                                  child: Column(
                                    children: [
                                      Ink(
                                        height: 200,
                                        width: 150,
                                        decoration: BoxDecoration(
                                          color: color,
                                          borderRadius:
                                              BorderRadius.circular(12),
                                        ),
                                      ),
                                    ],
                                  ),
                                ),
                              );
                      } else {
                        return const SizedBox();
                      }
                    },
                  )),
            ),
          ),
        ],
      ),
    );
  }
}

```

---


### Pages\Friends\Widgets\Agoras_widget\beauty_filter_option_controller.dart

```dart
import 'package:get/get.dart';
import 'package:agora_rtc_engine/agora_rtc_engine.dart';

class BeautyFiltersController extends GetxController {
  final RxBool isEnabled = false.obs;
  final RxDouble lighteningLevel = 0.5.obs;
  final RxDouble smoothnessLevel = 0.5.obs;
  final RxDouble rednessLevel = 0.1.obs;

  final RtcEngine agoraEngine;

  BeautyFiltersController({required this.agoraEngine});

  void applyBeautyFilter() {
    final beautyOptions = BeautyOptions(
      lighteningLevel: lighteningLevel.value,
      smoothnessLevel: smoothnessLevel.value,
      rednessLevel: rednessLevel.value,
    );

    agoraEngine.setBeautyEffectOptions(
      enabled: isEnabled.value,
      options: beautyOptions,
    );
  }

  void updateLightening(double value) {
    lighteningLevel.value = value;
    applyBeautyFilter();
  }

  void updateSmoothness(double value) {
    smoothnessLevel.value = value;
    applyBeautyFilter();
  }

  void updateRedness(double value) {
    rednessLevel.value = value;
    applyBeautyFilter();
  }

  void toggleEnable(bool value) {
    isEnabled.value = value;
    applyBeautyFilter();
  }
}

```

---


### Pages\Friends\Widgets\Agoras_widget\beauty_filter_option_sheet.dart

```dart
import 'package:agora_rtc_engine/agora_rtc_engine.dart';
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:tictactoe_gameapp/Pages/Friends/Widgets/Agoras_widget/beauty_filter_option_controller.dart';

class BeautyFiltersSheet extends StatelessWidget {
  final RtcEngine agoraEngine;
  const BeautyFiltersSheet({super.key, required this.agoraEngine});

  @override
  Widget build(BuildContext context) {
    final BeautyFiltersController controller =
        Get.put(BeautyFiltersController(agoraEngine: agoraEngine));
    return Column(
      children: [
        // Toggle Switch for enabling/disabling beauty filter
        Obx(() => SwitchListTile(
              activeColor: Colors.blue,
              title: const Text("Enable Beauty Filter"),
              value: controller.isEnabled.value,
              onChanged: (value) => controller.toggleEnable(value),
            )),
        // Lightening slider
        Obx(() => _buildSlider(
              label: "Lightening",
              value: controller.lighteningLevel.value,
              onChanged: controller.isEnabled.value
                  ? (value) => controller.updateLightening(value)
                  : null, // Disable interaction when isEnabled is false
              enabled: controller.isEnabled.value,
            )),
        // Smoothness slider
        Obx(() => _buildSlider(
              label: "Smoothness",
              value: controller.smoothnessLevel.value,
              onChanged: controller.isEnabled.value
                  ? (value) => controller.updateSmoothness(value)
                  : null,
              enabled: controller.isEnabled.value,
            )),
        // Redness slider
        Obx(() => _buildSlider(
              label: "Redness",
              value: controller.rednessLevel.value,
              onChanged: controller.isEnabled.value
                  ? (value) => controller.updateRedness(value)
                  : null,
              enabled: controller.isEnabled.value,
            )),
      ],
    );
  }

  Widget _buildSlider({
    required String label,
    required double value,
    required ValueChanged<double>? onChanged,
    required bool enabled,
  }) {
    return Padding(
      padding: const EdgeInsets.all(8.0),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(
            label,
            style: TextStyle(
              color: enabled ? Colors.black : Colors.grey, // Change text color
            ),
          ),
          Slider(
            value: value,
            min: 0.0,
            max: 1.0,
            onChanged: onChanged,
            activeColor:
                enabled ? Colors.blue : Colors.grey, // Change active color
            inactiveColor: Colors.grey, // Set inactive color
          ),
        ],
      ),
    );
  }
}

```

---


### Pages\GamePage\Console\Breakout_Game\breakout_gamelobby_page.dart

```dart
import 'package:cyber_punk_tool_kit_ui/cyber_punk_tool_kit_ui.dart';
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:tictactoe_gameapp/Configs/assets_path.dart';
// ignore: implementation_imports
import 'package:cyber_punk_tool_kit_ui/src/containers/cyber_container_two.dart';
import 'package:tictactoe_gameapp/Pages/GamePage/Console/Breakout_Game/breakout_gameplay_controller.dart';
import 'package:tictactoe_gameapp/Pages/GamePage/Console/Breakout_Game/breakout_gameplay_page.dart';

class BreakoutGamelobbyPage extends StatelessWidget {
  const BreakoutGamelobbyPage({super.key});

  @override
  Widget build(BuildContext context) {
    Rxn<Level> selectedLevel = Rxn<Level>();
    RxnInt selectedMode = RxnInt();
    RxnString selectedImageIndex = RxnString();
    final List<String> imagePaths = [
      GifsPath.chloe1,
      GifsPath.chatbotGif,
      GifsPath.lightGif,
      GifsPath.cyberpunk,
      GifsPath.transitionGif,
    ];
    const TextStyle textStyle = TextStyle(
      color: Colors.black,
      fontFamily: "Orbitron",
      fontWeight: FontWeight.w600,
      fontSize: 20,
    );

    return Scaffold(
      // appBar: AppBar(title: const Text('Sudoku Lobby', style: textStyle)),
      body: Stack(
        children: [
          CyberContainerTwo(
            width: MediaQuery.sizeOf(context).width,
            height: MediaQuery.sizeOf(context).height,
            child: SingleChildScrollView(
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  CyberContainerOne(
                    horizontalPadding: 50,
                    bottomPadding: 40,
                    child: Obx(() => DecoratedBox(
                          decoration: BoxDecoration(
                            image: DecorationImage(
                              fit: BoxFit.fill,
                              image: AssetImage(selectedImageIndex.value ??
                                  GifsPath.cyberpunk),
                            ),
                          ),
                        )),
                  ),
                  const SizedBox(
                    height: 20,
                  ),
                  const Text('Select Difficulty', style: textStyle),
                  SingleChildScrollView(
                    scrollDirection: Axis.horizontal,
                    child: Row(
                      mainAxisAlignment: MainAxisAlignment.center,
                      children: Level.values.map((level) {
                        return InkWell(
                          splashColor: Colors.blueAccent,
                          borderRadius: BorderRadius.circular(10),
                          onTap: () => selectedLevel.value = level,
                          child: Obx(() => Container(
                                padding: const EdgeInsets.all(10),
                                margin: const EdgeInsets.all(10),
                                decoration: selectedLevel.value != null &&
                                        selectedLevel.value == level
                                    ? BoxDecoration(
                                        color: Colors.white,
                                        borderRadius: BorderRadius.circular(10),
                                        border: Border.all(
                                            color: Colors.blueAccent, width: 5),
                                      )
                                    : BoxDecoration(
                                        color: Colors.grey,
                                        borderRadius: BorderRadius.circular(10),
                                        border: Border.all(
                                            color: Colors.white, width: 3),
                                      ),
                                child: Text(
                                  level.name.capitalizeFirst!,
                                  style: const TextStyle(
                                    color: Colors.black,
                                    fontFamily: "Orbitron",
                                    fontWeight: FontWeight.w600,
                                    fontSize: 15,
                                  ),
                                ),
                              )),
                        );
                      }).toList(),
                    ),
                  ),
                  const SizedBox(height: 20),
                  const Text('Select Board Size', style: textStyle),
                  SingleChildScrollView(
                    scrollDirection: Axis.horizontal,
                    child: Row(
                      mainAxisAlignment: MainAxisAlignment.center,
                      children: [4, 9, 16, 25].map((size) {
                        return InkWell(
                          splashColor: Colors.blueAccent,
                          borderRadius: BorderRadius.circular(10),
                          onTap: () => selectedMode.value = size,
                          child: Obx(() => Container(
                                padding: const EdgeInsets.all(10),
                                margin: const EdgeInsets.all(10),
                                decoration: selectedMode.value != null &&
                                        selectedMode.value == size
                                    ? BoxDecoration(
                                        color: Colors.white,
                                        borderRadius: BorderRadius.circular(10),
                                        border: Border.all(
                                            color: Colors.blueAccent, width: 5),
                                      )
                                    : BoxDecoration(
                                        color: Colors.grey,
                                        borderRadius: BorderRadius.circular(10),
                                        border: Border.all(
                                            color: Colors.white, width: 3),
                                      ),
                                child: Text(
                                  '${size}x$size',
                                  style: const TextStyle(
                                    color: Colors.black,
                                    fontFamily: "Orbitron",
                                    fontWeight: FontWeight.w600,
                                    fontSize: 15,
                                  ),
                                ),
                              )),
                        );
                      }).toList(),
                    ),
                  ),
                  const SizedBox(height: 20),
                  const Text('Select A Map', style: textStyle),
                  SizedBox(
                    height: 100,
                    child: SingleChildScrollView(
                      scrollDirection: Axis.horizontal,
                      child: Row(
                        children: List.generate(imagePaths.length, (index) {
                          return GestureDetector(
                            onTap: () =>
                                selectedImageIndex.value = imagePaths[index],
                            child: Obx(() {
                              return Container(
                                margin:
                                    const EdgeInsets.symmetric(horizontal: 10),
                                decoration: BoxDecoration(
                                  border: Border.all(
                                    color: selectedImageIndex.value != null &&
                                            selectedImageIndex.value ==
                                                imagePaths[index]
                                        ? Colors.blue
                                        : Colors.white,
                                    width: 5,
                                  ),
                                ),
                                child: Image.asset(
                                  imagePaths[index],
                                  width: 100,
                                  height: 100,
                                  fit: BoxFit.cover,
                                ),
                              );
                            }),
                          );
                        }),
                      ),
                    ),
                  ),
                  const SizedBox(height: 20),
                  Obx(() => selectedMode.value != null &&
                          selectedLevel.value != null &&
                          selectedImageIndex.value != null
                      ? InkWell(
                          onTap: () => Get.to(() => BreakoutGame(
                                level: selectedLevel.value!,
                                backgroundUrl: selectedImageIndex.value!,
                              ),transition: Transition.zoom),
                          child: Ink(
                            height: 50,
                            width: 100,
                            decoration: BoxDecoration(
                              color: Colors.blueAccent,
                              borderRadius: BorderRadius.circular(10),
                            ),
                            child: const Center(
                              child: Text(
                                "PLAY",
                                style: textStyle,
                              ),
                            ),
                          ),
                        )
                      : Ink(
                          height: 50,
                          width: 100,
                          decoration: BoxDecoration(
                            color: const Color.fromARGB(255, 12, 5, 5),
                            borderRadius: BorderRadius.circular(10),
                          ),
                          child: const Center(
                            child: Text("PLAY", style: textStyle),
                          ),
                        ))
                ],
              ),
            ),
          ),
          Positioned(
            top: 10,
            right: 10,
            child: CyberButton(
              onTap: () {},
              width: 100,
              height: 50,
              primaryColorBigContainer: Colors.redAccent,
              secondaryColorBigContainer: Colors.yellowAccent,
              child: const Text(
                'Menu',
                style: TextStyle(
                  color: Colors.white,
                  fontFamily: "Orbitron",
                  fontWeight: FontWeight.w400,
                ),
              ),
            ),
          ),
          Positioned(
            top: 10,
            left: 10,
            child: CyberButton(
              onTap: () {
                Get.back();
              },
              width: 100,
              height: 50,
              primaryColorBigContainer: Colors.redAccent,
              secondaryColorBigContainer: Colors.yellowAccent,
              child: const Text(
                'Back',
                style: TextStyle(
                  color: Colors.white,
                  fontFamily: "Orbitron",
                  fontWeight: FontWeight.w400,
                ),
              ),
            ),
          )
        ],
      ),
    );
  }
}

```

---


### Pages\GamePage\Console\Breakout_Game\breakout_gameplay_controller.dart

```dart
import 'dart:async';
import 'dart:math';
import 'package:flutter/widgets.dart';
import 'package:get/get.dart';
import 'package:tictactoe_gameapp/Configs/constants.dart';
import 'package:tictactoe_gameapp/Controller/Music/effective_music_controller.dart';

enum Level { easy, medium, hard, expert }

class BallController extends GetxController {
  RxDouble ballX = 0.0.obs;
  RxDouble ballY = 0.0.obs;
  RxDouble ballSpeedX = 0.01.obs;
  RxDouble ballSpeedY = 0.01.obs;
  RxDouble ballSpeedMultiplier = 1.1.obs; // Tăng tốc độ theo level

  void updatePosition() {
    ballX.value += ballSpeedX.value * ballSpeedMultiplier.value;
    ballY.value += ballSpeedY.value * ballSpeedMultiplier.value;

    // Va chạm với tường
    if (ballX.value <= 0 || ballX.value >= 1) {
      reverseXDirection();
    }
    if (ballY.value <= 0) {
      reverseYDirection();
    }
  }

  void reverseXDirection() {
    ballSpeedX.value = -ballSpeedX.value;
  }

  void reverseYDirection() {
    ballSpeedY.value = -ballSpeedY.value;
  }

  void adjustBallDirectionOnPaddle(double hitPosition, double paddleWidth) {
    double offsetFromCenter = (hitPosition - 0.5) * 2; // -1 đến 1
    ballSpeedX.value += offsetFromCenter * 0.02; // Tăng góc xiên
    ballSpeedY.value = -ballSpeedY.value; // Đảo hướng trục Y
  }

  void resetBallPosition(double initialSpeed) {
    ballX.value = 0.0; // Giữa màn hình
    ballY.value = 0.0; // Giữa màn hình
    ballSpeedX.value = initialSpeed; // Tốc độ ban đầu
    ballSpeedY.value = -initialSpeed; // Hướng bóng đi lên
    ballSpeedMultiplier.value = 1.0;
  }
}

class PaddleController extends GetxController {
  RxDouble paddleX = 0.5.obs;
  double paddleWidth = 0.25; // Điều chỉnh kích thước paddle theo level

  void movePaddle(double dx, double screenWidth) {
    paddleX.value += dx / screenWidth;
    if (paddleX.value < 0) paddleX.value = 0;
    if (paddleX.value > 1 - paddleWidth) paddleX.value = 1 - paddleWidth;
  }

  void resetPaddlePosition() {
    paddleX.value = 0.5;
  }
}

class Brick {
  RxBool isDestroyed = false.obs;
  final double x, y;
  final double width, height;
  final String hero;

  Brick(
      {required this.x,
      required this.y,
      this.width = 0.1,
      this.height = 0.05,
      required this.hero});
}

class BrickController extends GetxController {
  RxList<Brick> bricks = <Brick>[].obs;

  RxString currentHero = ''.obs; // Hero hiện tại

  // Tạo gạch với hero hiện tại
  void createBricks(int rows, int columns) {
    bricks.clear();
    for (int i = 0; i < rows; i++) {
      for (int j = 0; j < columns; j++) {
        bricks.add(Brick(
          x: j * 0.1,
          y: i * 0.05,
          hero: currentHero.value,
        ));
      }
    }
  }

  // Đổi hero ngẫu nhiên
  void pickRandomHero() {
    currentHero.value = listChampions[Random().nextInt(listChampions.length)];
  }

  // Thiết lập màn chơi mới
  void setupLevel(int level) {
    pickRandomHero(); // Đổi hero
    int rows = 3 + level; // Tăng hàng theo level
    int columns = 5 + level; // Tăng cột theo level
    createBricks(rows, columns);
  }

  // Kiểm tra va chạm
  bool checkCollision(double ballX, double ballY) {
    for (var brick in bricks) {
      if (!brick.isDestroyed.value) {
        // Xác định tọa độ của viên gạch
        final brickLeft = brick.x;
        final brickRight = brick.x + brick.width;
        final brickTop = brick.y;
        final brickBottom = brick.y + brick.height;

        // Xác định va chạm với bóng
        if (ballX >= brickLeft &&
            ballX <= brickRight &&
            ballY >= brickTop &&
            ballY <= brickBottom) {
          brick.isDestroyed.value = true; // Đánh dấu gạch bị phá
          return true; // Có va chạm
        }
      }
    }
    return false; // Không có va chạm
  }
}

class GameController extends GetxController {
  RxInt score = 0.obs;
  RxBool gameOver = false.obs;
  RxBool gameWon = false.obs;
  RxInt currentLevel = 1.obs;
  RxBool isPaused = false.obs;
  RxInt lives = 3.obs;

  late BallController ballController;
  late PaddleController paddleController;
  late BrickController brickController;
  late EffectiveMusicController effectiveMusicController;

  final Level level;
  GameController({required this.level});

  @override
  void onInit() {
    super.onInit();
    ballController = Get.find();
    paddleController = Get.find();
    brickController = Get.find();
    effectiveMusicController = Get.put(EffectiveMusicController());
    startGame();
  }

  Future<void> startGame() async {
    gameOver.value = false; // Đặt lại trạng thái game over
    gameWon.value = false; // Đặt lại trạng thái thắng game

    ballController
        .resetBallPosition(0.01 * currentLevel.value); // Tăng tốc bóng
    paddleController.resetPaddlePosition(); // Đặt lại vị trí paddle
    _configureGame(level: level); // Thiết lập game

    _gameLoop(); // Bắt đầu vòng lặp game
  }

  void _gameLoop() {
    if (gameOver.value || gameWon.value) {
      return; // Dừng vòng lặp nếu game kết thúc
    }

    if (!isPaused.value) {
      _updateGame(); // Cập nhật trạng thái game
    }

    // Tiếp tục vòng lặp ở khung hình tiếp theo
    WidgetsBinding.instance.addPostFrameCallback((_) {
      _gameLoop();
    });
  }

  Future<void> _updateGame() async {
    ballController.updatePosition();

    // Va chạm paddle
    if (ballController.ballY.value +
                ballController.ballSpeedY.value *
                    ballController.ballSpeedMultiplier.value >=
            0.95 &&
        ballController.ballX.value >= paddleController.paddleX.value &&
        ballController.ballX.value <=
            paddleController.paddleX.value + paddleController.paddleWidth) {
      double hitPosition =
          (ballController.ballX.value - paddleController.paddleX.value) /
              paddleController.paddleWidth;
      ballController.adjustBallDirectionOnPaddle(
          hitPosition, paddleController.paddleWidth);

      // Đặt lại vị trí bóng để tránh xuyên qua paddle
      ballController.ballY.value = 0.95;

      // Âm thanh hiệu ứng
      await effectiveMusicController.playSoundPlayer2();
    }

    // Va chạm gạch
    if (brickController.checkCollision(
        ballController.ballX.value, ballController.ballY.value)) {
      ballController.reverseYDirection();
      await effectiveMusicController.playSoundPlayer1();
      score.value++;

      // Kiểm tra nếu tất cả gạch đã bị phá
      if (brickController.bricks.every((brick) => brick.isDestroyed.value)) {
        gameWon.value = true;
        currentLevel.value++; // Tăng level
        startNextLevel(); // Chuyển sang level mới
        return;
      }
    }

    // Game over
    _onGameOver();
  }

  void startNextLevel() {
    gameWon.value = false; // Đặt lại trạng thái thắng game

    // Reset bóng và paddle
    ballController.resetBallPosition(0.01 * currentLevel.value);
    paddleController.resetPaddlePosition();

    // Thiết lập level mới
    _configureGame(level: level);

    // Tạo bricks mới
    brickController.setupLevel(currentLevel.value);

    // Tiếp tục game
    startGame();
  }

  void _configureGame({required Level level}) {
    switch (level) {
      case Level.easy:
        ballController.ballSpeedMultiplier.value =
            1.0 + (currentLevel.value * 0.1); // Tăng tốc độ theo level
        paddleController.paddleWidth = 0.35 -
            (currentLevel.value * 0.02).clamp(0.1, 0.35); // Paddle nhỏ dần
        brickController.setupLevel(currentLevel.value); // Nhiều gạch hơn
        break;
      case Level.medium:
        ballController.ballSpeedMultiplier.value =
            1.2 + (currentLevel.value * 0.1);
        paddleController.paddleWidth =
            0.25 - (currentLevel.value * 0.02).clamp(0.1, 0.25);
        brickController.setupLevel(currentLevel.value);
        break;
      case Level.hard:
        ballController.ballSpeedMultiplier.value =
            1.5 + (currentLevel.value * 0.1);
        paddleController.paddleWidth =
            0.2 - (currentLevel.value * 0.02).clamp(0.1, 0.2);
        brickController.setupLevel(currentLevel.value);
        break;
      case Level.expert:
        ballController.ballSpeedMultiplier.value =
            2.0 + (currentLevel.value * 0.1);
        paddleController.paddleWidth =
            0.15 - (currentLevel.value * 0.02).clamp(0.1, 0.15);
        brickController.setupLevel(currentLevel.value);
        break;
    }
  }

  // void _configureGame({
  //   required Level level,
  // }) {
  //   switch (level) {
  //     case Level.easy:
  //       ballController.ballSpeedMultiplier.value = 1.0;
  //       paddleController.paddleWidth = 0.35; // Paddle lớn hơn
  //       brickController.setupLevel(1); // Ít gạch
  //       break;
  //     case Level.medium:
  //       ballController.ballSpeedMultiplier.value = 1.2;
  //       paddleController.paddleWidth = 0.25;
  //       brickController.setupLevel(2);
  //       break;
  //     case Level.hard:
  //       ballController.ballSpeedMultiplier.value = 1.5;
  //       paddleController.paddleWidth = 0.2;
  //       brickController.setupLevel(3);
  //       break;
  //     case Level.expert:
  //       ballController.ballSpeedMultiplier.value = 2.0;
  //       paddleController.paddleWidth = 0.15; // Paddle nhỏ nhất
  //       brickController.setupLevel(4); // Nhiều gạch nhất
  //       break;
  //   }
  // }

  void _onGameOver() {
    if (ballController.ballY.value >= 1) {
      if (lives.value > 0) {
        lives.value--;
        // ballController.resetBallPosition(0.01 * currentLevel.value);
        startGame();
      } else {
        gameOver.value = true;
      }
    }
  }

  void togglePause() {
    isPaused.value = !isPaused.value;
  }

  void resetGame() {
    score.value = 0;
    currentLevel.value = 1;
    startGame();
  }
}

```

---


### Pages\GamePage\Console\Breakout_Game\breakout_gameplay_page.dart

```dart
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:tictactoe_gameapp/Pages/GamePage/Console/Minesweeper_Game/minesweeper_game_page.dart';
import 'package:tictactoe_gameapp/Pages/GamePage/Console/Breakout_Game/breakout_gameplay_controller.dart';

class BreakoutGame extends StatelessWidget {
  final Level level;
  final String backgroundUrl;

  const BreakoutGame(
      {super.key, required this.level, required this.backgroundUrl});

  @override
  Widget build(BuildContext context) {
    final BallController ballController = Get.put(BallController());
    final PaddleController paddleController = Get.put(PaddleController());
    final BrickController brickController = Get.put(BrickController());
    final GameController gameController = Get.put(GameController(level: level));

    final width = MediaQuery.of(context).size.width;
    final height = MediaQuery.of(context).size.height;
    const TextStyle textStyleBig = TextStyle(
      color: Colors.black,
      fontFamily: "Orbitron",
      fontWeight: FontWeight.w600,
      fontSize: 20,
    );

    return Scaffold(
      appBar: AppBar(
        title: const Text('BreakOut Game Heroes', style: textStyleBig),
        actions: [
          IconButton(
              onPressed: gameController.resetGame,
              icon: const Icon(
                Icons.refresh_rounded,
                size: 30,
              )),
          Obx(
            () => IconButton(
                onPressed: () => gameController.isPaused.toggle(),
                icon: !gameController.isPaused.value
                    ? const Icon(
                        Icons.pause_rounded,
                        size: 30,
                      )
                    : const Icon(
                        Icons.play_arrow_rounded,
                        size: 30,
                      )),
          ),
        ],
      ),
      body: GestureDetector(
        onPanUpdate: (details) {
          paddleController.movePaddle(details.delta.dx, width);
        },
        child: Stack(
          children: [
            Container(
              width: double.infinity,
              height: double.infinity,
              decoration: BoxDecoration(
                image: DecorationImage(
                  image: AssetImage(backgroundUrl),
                  fit: BoxFit.cover,
                ),
              ),
            ),
            Column(
              children: [
                Row(
                  mainAxisAlignment: MainAxisAlignment.spaceEvenly,
                  children: [
                    Obx(() => Text(
                          "Lives: ${gameController.lives.value}",
                          style: textStyleBig.copyWith(color: Colors.white),
                        )),
                    Obx(() => Text(
                          "Score: ${gameController.score.value}",
                          style: textStyleBig.copyWith(color: Colors.white),
                        )),
                    Obx(() => Text(
                          "Level: ${gameController.currentLevel.value}",
                          style: textStyleBig.copyWith(color: Colors.white),
                        )),
                  ],
                ),
                Expanded(
                  child: Stack(
                    children: [
                      // Bóng
                      Obx(() => Positioned(
                            left: ballController.ballX.value * width,
                            top: ballController.ballY.value * height,
                            child: const Ball(),
                          )),

                      // Paddle
                      Obx(() => Positioned(
                            left: paddleController.paddleX.value * width,
                            bottom: 0,
                            child: Paddle(
                                width: paddleController.paddleWidth * width),
                          )),

                      // Gạch
                      Obx(() => Stack(
                            children: brickController.bricks
                                .where((brick) => !brick.isDestroyed.value)
                                .map((brick) => Positioned(
                                      left: brick.x * width,
                                      top: brick.y * height,
                                      child: BrickWidget(
                                        width: brick.width * width,
                                        height: brick.height * height,
                                        hero: brick.hero,
                                      ),
                                    ))
                                .toList(),
                          )),

                      // Điểm số và trạng thái game

                      // Thông báo thắng/thua
                      Obx(() => gameController.gameOver.value
                          ? Center(
                              child: Text(
                                gameController.gameWon.value
                                    ? "You Win!"
                                    : "Game Over!",
                                style: const TextStyle(
                                    fontSize: 32,
                                    fontWeight: FontWeight.bold,
                                    color: Colors.red),
                              ),
                            )
                          : const SizedBox.shrink()),
                    ],
                  ),
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }
}

class Ball extends StatelessWidget {
  const Ball({super.key});

  @override
  Widget build(BuildContext context) {
    return Container(
      width: 20,
      height: 20,
      decoration: const BoxDecoration(
        shape: BoxShape.circle,
        gradient: LinearGradient(
          colors: [Colors.lightBlueAccent, Colors.blue, Colors.lightBlue],
        ),
      ),
    );
  }
}

class Paddle extends StatelessWidget {
  final double width;

  const Paddle({super.key, required this.width});

  @override
  Widget build(BuildContext context) {
    return Container(
      width: width,
      height: 20,
      decoration: const BoxDecoration(
        color: Colors.blue,
        borderRadius: BorderRadius.only(
          bottomRight: Radius.circular(50),
          bottomLeft: Radius.circular(50),
        ),
      ),
    );
  }
}

class BrickWidget extends StatelessWidget {
  final double width;
  final double height;
  final String hero;

  const BrickWidget(
      {super.key,
      required this.width,
      required this.height,
      required this.hero});

  @override
  Widget build(BuildContext context) {
    return SizedBox(
      width: width,
      height: height,
      child: ClipPath(
        clipper: HexagonClipper(),
        child: Image.asset(hero),
      ),
    );
  }

  
}

```

---


### Pages\GamePage\Console\Bubble_Shooter\bubble_shooter_gameplay_page.dart

```dart
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:tictactoe_gameapp/Pages/GamePage/Console/Bubble_Shooter/controllers/bubble_shooter_gameplay_controller.dart';
import 'package:tictactoe_gameapp/Pages/GamePage/Console/Bubble_Shooter/views/bubble_grid_ui.dart';
import 'package:tictactoe_gameapp/Pages/GamePage/Console/Bubble_Shooter/views/components/animated_combo_message.dart';
import 'package:tictactoe_gameapp/Pages/GamePage/Console/Bubble_Shooter/views/components/animated_score_display.dart';
import 'package:tictactoe_gameapp/Pages/GamePage/Console/Bubble_Shooter/views/components/bubble_background.dart';
import 'package:tictactoe_gameapp/Pages/GamePage/Console/Bubble_Shooter/views/components/bubble_collision_ripple.dart';
import 'package:tictactoe_gameapp/Pages/GamePage/Console/Bubble_Shooter/views/components/countdown_widget.dart';
import 'package:tictactoe_gameapp/Pages/GamePage/Console/Bubble_Shooter/views/components/game_state_overlay.dart';
import 'package:tictactoe_gameapp/Pages/GamePage/Console/Bubble_Shooter/views/components/powerup_button.dart';
import 'package:tictactoe_gameapp/Pages/GamePage/Console/Bubble_Shooter/views/components/screen_shake_widget.dart';
import 'package:tictactoe_gameapp/Pages/GamePage/Console/Bubble_Shooter/views/components/shooter_area.dart';
import 'package:tictactoe_gameapp/Pages/GamePage/Console/Bubble_Shooter/views/components/shooting_path_overlay.dart';

class BubbleShooterGame extends StatelessWidget {
  final String level;

  const BubbleShooterGame({super.key, this.level = 'Medium'});

  @override
  Widget build(BuildContext context) {
    final BubbleShooterController controller = Get.put(
      BubbleShooterController(
        level: level,
      ),
    );

    return Scaffold(
      appBar: AppBar(
        title: const Text(
          'Bubble Shooter',
          style: TextStyle(
            fontFamily: "Orbitron",
            fontWeight: FontWeight.w600,
            fontSize: 20,
          ),
        ),
        actions: [
          // Điểm số với hiệu ứng
          Obx(() => Padding(
                padding: const EdgeInsets.symmetric(horizontal: 8.0),
                child: Center(
                  child: AnimatedScoreDisplay(
                    score: controller.score.value,
                    previousScore:
                        controller.score.value - 10, // Giả định điểm trước đó
                    style: const TextStyle(
                      fontFamily: "Orbitron",
                      fontWeight: FontWeight.w600,
                      fontSize: 16,
                      color: Colors.white,
                    ),
                  ),
                ),
              )),
          IconButton(
            onPressed: () => controller.resetGame(),
            icon: const Icon(
              Icons.refresh_rounded,
              size: 26,
            ),
          ),
          Obx(() => IconButton(
                onPressed: () {
                  if (controller.isGamePaused.value) {
                    controller.resumeGame();
                  } else {
                    controller.pauseGame();
                  }
                },
                icon: Icon(
                  controller.isGamePaused.value
                      ? Icons.play_arrow_rounded
                      : Icons.pause_rounded,
                  size: 26,
                ),
              )),
        ],
      ),
      body: SafeArea(
        child: ScreenShakeWidget(
          isShaking: false, // Kích hoạt khi có combo lớn
          child: Stack(
            children: [
              // Nền đẹp hơn
              const BubbleBackground(),

              // Game content
              Column(
                children: [
                  // Game information
                  Padding(
                    padding: const EdgeInsets.symmetric(
                        horizontal: 16.0, vertical: 8.0),
                    child: Row(
                      mainAxisAlignment: MainAxisAlignment.spaceBetween,
                      children: [
                        Row(
                          children: [
                            const Icon(Icons.star,
                                color: Colors.amber, size: 20),
                            const SizedBox(width: 4),
                            Obx(() => Text(
                                  'Level: ${controller.currentLevel.value}',
                                  style: const TextStyle(
                                    fontFamily: "Orbitron",
                                    fontWeight: FontWeight.w600,
                                    fontSize: 16,
                                  ),
                                )),
                          ],
                        ),
                        Obx(() {
                          final message = controller.comboMessage.value;
                          return message.isNotEmpty
                              ? AnimatedComboMessage(message: message)
                              : const SizedBox.shrink();
                        }),
                      ],
                    ),
                  ),

                  // Power-up bar
                  Padding(
                    padding: const EdgeInsets.symmetric(
                        horizontal: 16.0, vertical: 4.0),
                    child: Row(
                      mainAxisAlignment: MainAxisAlignment.spaceEvenly,
                      children: [
                        PowerupButton(
                          icon: Icons.flash_on,
                          label: 'Bomb',
                          onPressed: () {
                            // Kích hoạt power-up bom
                          },
                        ),
                        PowerupButton(
                          icon: Icons.colorize,
                          label: 'Color',
                          onPressed: () {
                            // Kích hoạt power-up đổi màu
                          },
                        ),
                        PowerupButton(
                          icon: Icons.ac_unit,
                          label: 'Freeze',
                          onPressed: () {
                            // Kích hoạt power-up đóng băng
                          },
                          isActive: false, // Chưa mở khóa
                        ),
                      ],
                    ),
                  ),

                  // Bubble grid area
                  Expanded(
                    flex: 75,
                    child: Container(
                      decoration: BoxDecoration(
                        border: Border.all(color: Colors.blue.withOpacity(0.2)),
                        borderRadius: BorderRadius.circular(12),
                      ),
                      margin: const EdgeInsets.all(4.0),
                      child: BubbleGridUI(controller: controller),
                    ),
                  ),

                  // Shooter area
                  Expanded(
                    flex: 25,
                    child: Container(
                      margin: const EdgeInsets.only(top: 4.0),
                      child: ShooterArea(controller: controller),
                    ),
                  ),
                ],
              ),

              // Path overlay
              Obx(() {
                return controller.isShowingPath.value
                    ? ShootingPathOverlay(controller: controller)
                    : const SizedBox.shrink();
              }),

              // Countdown timer khi sắp thêm hàng mới
              Obx(() {
                // Hiển thị đếm ngược khi sắp đến lượt thêm hàng mới
                if (controller.shootCount.value > 0 &&
                    controller.shootCount.value % controller.newRowInterval ==
                        controller.newRowInterval - 1) {
                  return Positioned(
                    top: 100,
                    right: 20,
                    child: CountdownWidget(
                      seconds: 3, // Đếm ngược 3 giây
                      onComplete: () {
                        // Không cần làm gì vì controller đã tự động thêm hàng
                      },
                    ),
                  );
                }
                return const SizedBox.shrink();
              }),

              // Game state messages
              Obx(() {
                if (controller.gameOver.value) {
                  return const GameStateOverlay(
                    message: 'GAME OVER',
                    color: Colors.red,
                  );
                } else if (controller.victory.value) {
                  return const GameStateOverlay(
                    message: 'VICTORY!',
                    color: Colors.green,
                  );
                } else if (controller.isGamePaused.value) {
                  return const GameStateOverlay(
                    message: 'PAUSED',
                    color: Colors.blue,
                  );
                } else {
                  return const SizedBox.shrink();
                }
              }),

              // Collision effect - hiệu ứng khi va chạm
              // Được hiển thị khi bóng va chạm với lưới
              Obx(() {
                if (controller.shotBubble.value == null &&
                    controller.isBusy.value) {
                  // Vị trí va chạm (ví dụ)
                  final collisionPosition = Offset(
                    MediaQuery.of(context).size.width / 2,
                    MediaQuery.of(context).size.height / 3,
                  );

                  return BubbleCollisionRipple(position: collisionPosition);
                }
                return const SizedBox.shrink();
              }),
            ],
          ),
        ),
      ),
    );
  }
}

```

---


### Pages\GamePage\Console\Bubble_Shooter\bubble_shooter_lobby_page.dart.dart

```dart
import 'package:cyber_punk_tool_kit_ui/cyber_punk_tool_kit_ui.dart';
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:tictactoe_gameapp/Configs/assets_path.dart';
// ignore: implementation_imports
import 'package:cyber_punk_tool_kit_ui/src/containers/cyber_container_two.dart';
import 'package:tictactoe_gameapp/Pages/GamePage/Console/Bubble_Shooter/bubble_shooter_gameplay_page.dart';

class BubbleShooterLobbyPage extends StatelessWidget {
  const BubbleShooterLobbyPage({super.key});

  @override
  Widget build(BuildContext context) {
    Rxn<String> selectedLevel = Rxn<String>();
    RxnInt selectedMode = RxnInt();
    RxnString selectedImageIndex = RxnString();
    final List<String> imagePaths = [
      GifsPath.chloe1,
      GifsPath.chatbotGif,
      GifsPath.lightGif,
      GifsPath.cyberpunk,
      GifsPath.transitionGif,
    ];
    const TextStyle textStyle = TextStyle(
      color: Colors.black,
      fontFamily: "Orbitron",
      fontWeight: FontWeight.w600,
      fontSize: 20,
    );

    return Scaffold(
      // appBar: AppBar(title: const Text('Sudoku Lobby', style: textStyle)),
      body: Stack(
        children: [
          CyberContainerTwo(
            width: MediaQuery.sizeOf(context).width,
            height: MediaQuery.sizeOf(context).height,
            child: SingleChildScrollView(
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  CyberContainerOne(
                    horizontalPadding: 50,
                    bottomPadding: 40,
                    child: Obx(() => DecoratedBox(
                          decoration: BoxDecoration(
                            image: DecorationImage(
                              fit: BoxFit.fill,
                              image: AssetImage(selectedImageIndex.value ??
                                  GifsPath.cyberpunk),
                            ),
                          ),
                        )),
                  ),
                  const SizedBox(
                    height: 20,
                  ),
                  const Text('Select Difficulty', style: textStyle),
                  SingleChildScrollView(
                    scrollDirection: Axis.horizontal,
                    child: Row(
                      mainAxisAlignment: MainAxisAlignment.center,
                      children: ["Easy","Medium","Hard","Expert"].map((level) {
                        return InkWell(
                          splashColor: Colors.blueAccent,
                          borderRadius: BorderRadius.circular(10),
                          onTap: () => selectedLevel.value = level,
                          child: Obx(() => Container(
                                padding: const EdgeInsets.all(10),
                                margin: const EdgeInsets.all(10),
                                decoration: selectedLevel.value != null &&
                                        selectedLevel.value == level
                                    ? BoxDecoration(
                                        color: Colors.white,
                                        borderRadius: BorderRadius.circular(10),
                                        border: Border.all(
                                            color: Colors.blueAccent, width: 5),
                                      )
                                    : BoxDecoration(
                                        color: Colors.grey,
                                        borderRadius: BorderRadius.circular(10),
                                        border: Border.all(
                                            color: Colors.white, width: 3),
                                      ),
                                child: Text(
                                  level,
                                  style: const TextStyle(
                                    color: Colors.black,
                                    fontFamily: "Orbitron",
                                    fontWeight: FontWeight.w600,
                                    fontSize: 15,
                                  ),
                                ),
                              )),
                        );
                      }).toList(),
                    ),
                  ),
                  const SizedBox(height: 20),
                  const Text('Select Board Size', style: textStyle),
                  SingleChildScrollView(
                    scrollDirection: Axis.horizontal,
                    child: Row(
                      mainAxisAlignment: MainAxisAlignment.center,
                      children: [4, 9, 16, 25].map((size) {
                        return InkWell(
                          splashColor: Colors.blueAccent,
                          borderRadius: BorderRadius.circular(10),
                          onTap: () => selectedMode.value = size,
                          child: Obx(() => Container(
                                padding: const EdgeInsets.all(10),
                                margin: const EdgeInsets.all(10),
                                decoration: selectedMode.value != null &&
                                        selectedMode.value == size
                                    ? BoxDecoration(
                                        color: Colors.white,
                                        borderRadius: BorderRadius.circular(10),
                                        border: Border.all(
                                            color: Colors.blueAccent, width: 5),
                                      )
                                    : BoxDecoration(
                                        color: Colors.grey,
                                        borderRadius: BorderRadius.circular(10),
                                        border: Border.all(
                                            color: Colors.white, width: 3),
                                      ),
                                child: Text(
                                  '${size}x$size',
                                  style: const TextStyle(
                                    color: Colors.black,
                                    fontFamily: "Orbitron",
                                    fontWeight: FontWeight.w600,
                                    fontSize: 15,
                                  ),
                                ),
                              )),
                        );
                      }).toList(),
                    ),
                  ),
                  const SizedBox(height: 20),
                  const Text('Select A Map', style: textStyle),
                  SizedBox(
                    height: 100,
                    child: SingleChildScrollView(
                      scrollDirection: Axis.horizontal,
                      child: Row(
                        children: List.generate(imagePaths.length, (index) {
                          return GestureDetector(
                            onTap: () =>
                                selectedImageIndex.value = imagePaths[index],
                            child: Obx(() {
                              return Container(
                                margin:
                                    const EdgeInsets.symmetric(horizontal: 10),
                                decoration: BoxDecoration(
                                  border: Border.all(
                                    color: selectedImageIndex.value != null &&
                                            selectedImageIndex.value ==
                                                imagePaths[index]
                                        ? Colors.blue
                                        : Colors.white,
                                    width: 5,
                                  ),
                                ),
                                child: Image.asset(
                                  imagePaths[index],
                                  width: 100,
                                  height: 100,
                                  fit: BoxFit.cover,
                                ),
                              );
                            }),
                          );
                        }),
                      ),
                    ),
                  ),
                  const SizedBox(height: 20),
                  Obx(() => selectedMode.value != null &&
                          selectedLevel.value != null &&
                          selectedImageIndex.value != null
                      ? InkWell(
                          onTap: () => Get.to(
                              () => BubbleShooterGame(
                                    level: selectedLevel.value!,
                                  ),
                              transition: Transition.zoom),
                          child: Ink(
                            height: 50,
                            width: 100,
                            decoration: BoxDecoration(
                              color: Colors.blueAccent,
                              borderRadius: BorderRadius.circular(10),
                            ),
                            child: const Center(
                              child: Text(
                                "PLAY",
                                style: textStyle,
                              ),
                            ),
                          ),
                        )
                      : Ink(
                          height: 50,
                          width: 100,
                          decoration: BoxDecoration(
                            color: const Color.fromARGB(255, 12, 5, 5),
                            borderRadius: BorderRadius.circular(10),
                          ),
                          child: const Center(
                            child: Text("PLAY", style: textStyle),
                          ),
                        ))
                ],
              ),
            ),
          ),
          Positioned(
            top: 10,
            right: 10,
            child: CyberButton(
              onTap: () {},
              width: 100,
              height: 50,
              primaryColorBigContainer: Colors.redAccent,
              secondaryColorBigContainer: Colors.yellowAccent,
              child: const Text(
                'Menu',
                style: TextStyle(
                  color: Colors.white,
                  fontFamily: "Orbitron",
                  fontWeight: FontWeight.w400,
                ),
              ),
            ),
          ),
          Positioned(
            top: 10,
            left: 10,
            child: CyberButton(
              onTap: () {
                Get.back();
              },
              width: 100,
              height: 50,
              primaryColorBigContainer: Colors.redAccent,
              secondaryColorBigContainer: Colors.yellowAccent,
              child: const Text(
                'Back',
                style: TextStyle(
                  color: Colors.white,
                  fontFamily: "Orbitron",
                  fontWeight: FontWeight.w400,
                ),
              ),
            ),
          )
        ],
      ),
    );
  }
}

```

---


### Pages\GamePage\Console\Bubble_Shooter\controllers\bubble_shooter_gameplay_controller.dart

```dart
import 'dart:async';
import 'dart:math';
import 'dart:ui';
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:tictactoe_gameapp/Configs/constants.dart';
import 'package:tictactoe_gameapp/Pages/GamePage/Console/Bubble_Shooter/model/bubble_models.dart';

class BubbleShooterController extends GetxController {
  // Game variables
  late final List<String> selectedChamp; // Danh sách hero được chọn ngẫu nhiên
  var shooterPosition = const Offset(0.5, 0.9).obs; // Vị trí trụ bắn
  var bubbles = <Bubble>[].obs; // Bóng đang bay
  var activeBubble = Bubble.random(listChampions).obs; // Bóng sẵn sàng để bắn
  var nextBubble = Bubble.random(listChampions).obs; // Bóng tiếp theo
  var grid = Rx<BubbleGrid>(BubbleGrid());
  var score = 0.obs;
  var comboMessage = ''.obs;
  var gameOver = false.obs;
  var victory = false.obs;
  var isGamePaused = false.obs;
  var shootCount = 0.obs; // Số lần bắn
  var currentLevel = 1.obs;
  var shotBubble = Rx<Bubble?>(null); // Bóng đang được bắn

  // Hiệu ứng
  var showAnimation = false.obs;
  var animatingBubbles = <Bubble>[].obs;
  var bubbleAnimation = false.obs; // Trạng thái hiệu ứng bóng di chuyển
  var animationProgress = 0.0.obs; // Tiến trình animation (0.0 - 1.0)

  // Game settings
  final int newRowInterval; // Số lần bắn để thêm hàng mới
  final String level;
  var isBusy = false.obs; // Tránh bắn nhiều lần liên tiếp
  var lastTarget = Offset(0.5, 0.5).obs; // Lưu vị trí nhắm cuối cùng

  Timer? _gameLoopTimer;
  Timer? _bubbleFallTimer;
  Timer? _animationTimer;

  // Path drawing
  var targetPosition = const Offset(0.5, 0.5).obs; // Vị trí mục tiêu được chọn
  var pathPoints = <Offset>[].obs; // Các điểm trên đường bắn
  var isShowingPath = false.obs; // Có đang hiển thị đường bắn hay không
  var aimingAngle = (-pi / 2).obs; // Góc nhắm hiện tại (mặc định hướng lên)

  // Grid settings
  final double gridHeightFactor = 0.75; // Tỷ lệ chiều cao lưới so với màn hình

  BubbleShooterController({required this.level, this.newRowInterval = 5});

  @override
  void onInit() {
    super.onInit();
    _initializeGame();
    _startGameLoop();
  }

  void _initializeGame() {
    selectedChamp = _getRandomChampions(_getNumberOfHeroesForLevel(level));

    // Thiết lập kích thước lưới dựa trên cấp độ
    int rows, columns;
    switch (level) {
      case 'Medium':
        rows = 12;
        columns = 9;
        break;
      case 'Hard':
        rows = 15;
        columns = 10;
        break;
      case 'Expert':
        rows = 18;
        columns = 11;
        break;
      default:
        rows = 10;
        columns = 8;
    }

    grid.value = BubbleGrid(rows: rows, columns: columns);
    grid.value.initializeGrid(selectedChamp);
    bubbles.clear(); // Đảm bảo danh sách bóng trống trước khi thêm mới
    bubbles.value = grid.value.getAllBubbles();

    activeBubble.value = Bubble.random(selectedChamp);
    nextBubble.value = Bubble.random(selectedChamp);

    gameOver.value = false;
    victory.value = false;
    score.value = 0;
    shootCount.value = 0;
    currentLevel.value = 1;
    shotBubble.value = null;
    isShowingPath.value = false;

    // Reset animation
    bubbleAnimation.value = false;
    animationProgress.value = 0.0;
  }

  void _startGameLoop() {
    _gameLoopTimer = Timer.periodic(const Duration(milliseconds: 16), (timer) {
      if (!isGamePaused.value) {
        updateBubbles(0.016);
        _checkGameState();
      }
    });
  }

  int _getNumberOfHeroesForLevel(String level) {
    switch (level) {
      case 'Medium':
        return 5; // Số hero cho level Medium
      case 'Hard':
        return 7; // Số hero cho level Hard
      case 'Expert':
        return 9; // Số hero cho level Expert
      default:
        return 4; // Số hero cho level Easy
    }
  }

  List<String> _getRandomChampions(int numOfHeroes) {
    final random = Random();
    final shuffled = List.of(listChampions)..shuffle(random);
    return shuffled.take(numOfHeroes).toList();
  }

  // Cải tiến tính toán đường đi với phản hồi mượt mà hơn
  void calculateShootingPath(Offset target) {
    if (isBusy.value || bubbleAnimation.value) return;

    isShowingPath.value = true;
    lastTarget.value = target; // Lưu lại vị trí nhắm cuối cùng

    // Chỉ lấy hướng, không quan tâm đến độ dài của vector
    final dx = target.dx - shooterPosition.value.dx;
    final dy = target.dy - shooterPosition.value.dy;

    // Giới hạn góc bắn (không cho bắn xuống dưới)
    // Nếu điểm đích ở dưới shooter, điều chỉnh lại
    if (dy > 0) {
      if (dx > 0) {
        // Bắn sang phải ngang level
        target = Offset(1.0, shooterPosition.value.dy);
      } else if (dx < 0) {
        // Bắn sang trái ngang level
        target = Offset(0.0, shooterPosition.value.dy);
      } else {
        // Nếu ở chính giữa, bắn thẳng lên
        target = Offset(shooterPosition.value.dx, 0.0);
      }
    }

    // Tính toán lại góc dựa trên vị trí đã điều chỉnh
    final adjustedDx = target.dx - shooterPosition.value.dx;
    final adjustedDy = target.dy - shooterPosition.value.dy;

    if (adjustedDx != 0 || adjustedDy != 0) {
      final newAngle = atan2(-adjustedDy, adjustedDx);
      aimingAngle.value = newAngle;
      targetPosition.value = target;

      // Cập nhật góc cho active bubble
      activeBubble.update((bubble) {
        if (bubble != null) {
          bubble.angle = newAngle;
        }
      });

      // Tính toán đường đi
      _calculatePathPoints();
    }
  }

  void _calculatePathPoints() {
    final points = <Offset>[];
    final shooterPos = shooterPosition.value;
    points.add(shooterPos);

    var currentPos = shooterPos;
    var angle = aimingAngle.value;
    final step = 0.01; // Bước nhỏ hơn để đường đi mịn hơn

    // Giả lập đường đi của bóng với tối đa 200 điểm (để tránh quá tải)
    for (int i = 0; i < 200; i++) {
      final dx = cos(angle) * step;
      final dy = sin(angle) * step;

      final newX = currentPos.dx + dx;
      final newY = currentPos.dy + dy;

      // Kiểm tra va chạm với biên trái/phải
      if (newX <= 0.02 || newX >= 0.98) {
        // Đổi hướng ngang khi va chạm
        angle = pi - angle;
        currentPos = Offset(
          currentPos.dx + cos(angle) * step,
          currentPos.dy + sin(angle) * step,
        );
      } else {
        currentPos = Offset(newX, newY);
      }

      points.add(currentPos);

      // Kiểm tra và dừng nếu đến đỉnh màn hình
      if (currentPos.dy <= 0.05) break;

      // Kiểm tra va chạm với bóng hiện có
      final collideWithBubble = _checkPathCollision(currentPos);
      if (collideWithBubble) {
        break;
      }
    }

    pathPoints.assignAll(points);
    update(); // Cập nhật giao diện
  }

  bool _checkPathCollision(Offset position) {
    // Giả lập kiểm tra va chạm đơn giản với các bóng trong lưới
    final bubbleRadius = grid.value.bubbleRadius;

    for (int row = 0; row < grid.value.rows; row++) {
      for (int col = 0; col < grid.value.columns; col++) {
        if (grid.value.grid[row][col] != null) {
          // Tính toán vị trí tương đối của bóng trong lưới
          final isEvenRow = row % 2 == 0;
          final offsetX = isEvenRow ? 0.0 : bubbleRadius;

          final bubbleCenter = Offset(
            offsetX + col * (bubbleRadius * 2) + bubbleRadius,
            row * (bubbleRadius * 2) + bubbleRadius,
          );

          final distance = (bubbleCenter - position).distance;
          if (distance < (bubbleRadius * 1.5)) {
            return true;
          }
        }
      }
    }

    return false;
  }

  // Phương thức bắn bóng cải tiến
  void shootBubble() {
    if (isBusy.value ||
        gameOver.value ||
        victory.value ||
        bubbleAnimation.value) return;

    isShowingPath.value = false;
    isBusy.value = true;
    bubbleAnimation.value = true;
    animationProgress.value = 0.0;

    // Bắt đầu animation bắn
    final bubble = Bubble(
      heroAsset: activeBubble.value.heroAsset,
      color: activeBubble.value.color,
      angle: aimingAngle.value,
      position: shooterPosition.value,
    );

    shotBubble.value = bubble;

    // Animation bắn bóng
    _animationTimer = Timer.periodic(const Duration(milliseconds: 16), (timer) {
      if (animationProgress.value < 1.0) {
        animationProgress.value += 0.05; // Điều chỉnh tốc độ animation

        // Tính toán vị trí mới của bóng dựa trên đường đi
        final pathIndex =
            (animationProgress.value * (pathPoints.length - 1)).floor();
        if (pathIndex < pathPoints.length) {
          bubble.position = pathPoints[pathIndex];
          update();
        }
      } else {
        // Kết thúc animation và kiểm tra va chạm
        timer.cancel();
        _animationTimer = null;
        bubbleAnimation.value = false;

        // Xử lý va chạm và đặt bóng vào lưới
        final collisionCell = grid.value.checkCollision(bubble);
        if (collisionCell != null) {
          grid.update((g) {
            if (g != null) {
              g.grid[collisionCell.row][collisionCell.col] = bubble;
              bubble.row = collisionCell.row;
              bubble.col = collisionCell.col;
              bubble.gridPosition = collisionCell;
            }
          });

          checkForMatches(bubble);
        }

        // Chuẩn bị bóng mới
        activeBubble.value = nextBubble.value;
        nextBubble.value = Bubble.random(selectedChamp);

        // Tăng số lần bắn
        shootCount.value++;
        if (shootCount.value % newRowInterval == 0) {
          _scheduledAddNewRow();
        }

        shotBubble.value = null;
        isBusy.value = false;

        // Hiển thị lại đường dẫn cho bóng kế tiếp
        calculateShootingPath(lastTarget.value);
      }
    });
  }

  void _scheduledAddNewRow() {
    // Thêm độ trễ trước khi thêm hàng mới
    Future.delayed(const Duration(seconds: 1), () {
      if (!gameOver.value && !victory.value) {
        grid.update((g) {
          g?.addNewRow(selectedChamp);
        });

        // Cập nhật lại danh sách bóng hiển thị
        bubbles.clear();
        bubbles.assignAll(grid.value.getAllBubbles());

        // Hiệu ứng khi thêm hàng mới
        Get.snackbar(
          'Cảnh báo!',
          'Một hàng bong bóng mới đã xuất hiện!',
          backgroundColor: Colors.orange,
          colorText: Colors.white,
          duration: const Duration(seconds: 1),
        );
      }
    });
  }

  // Cập nhật vị trí bóng trong game loop
  void updateBubbles(double dt) {
    // Chỉ cập nhật vị trí nếu không đang trong animation tự động
    if (shotBubble.value != null && !bubbleAnimation.value) {
      final bubble = shotBubble.value!;
      bubble.updatePosition(dt);

      final collisionCell = grid.value.checkCollision(bubble);
      if (collisionCell != null) {
        grid.update((g) {
          if (g != null) {
            g.grid[collisionCell.row][collisionCell.col] = bubble;
            bubble.row = collisionCell.row;
            bubble.col = collisionCell.col;
            bubble.gridPosition = collisionCell;
          }
        });

        shotBubble.value = null;
        checkForMatches(bubble);
        isBusy.value = false;
      }

      // Xóa bóng nếu nó ra khỏi màn hình trên cùng
      if (bubble.position.dy <= 0.02) {
        shotBubble.value = null;
        isBusy.value = false;
      }
    }

    update();
  }

  // Cải tiến kiểm tra và xử lý bóng cùng màu
  void checkForMatches(Bubble bubble) {
    final matches = grid.value.findMatches(bubble);

    if (matches.isNotEmpty) {
      // Hiệu ứng trước khi xóa
      animatingBubbles.assignAll(matches);
      showAnimation.value = true;

      // Thêm điểm
      final matchPoints = matches.length * 10;
      score.value += matchPoints;

      // Hiển thị combo message
      comboMessage.value = _getComboMessage(matches.length);
      Future.delayed(const Duration(seconds: 2), () {
        if (comboMessage.value == _getComboMessage(matches.length)) {
          comboMessage.value = '';
        }
      });

      // Xóa bóng sau hiệu ứng
      Future.delayed(const Duration(milliseconds: 600), () {
        showAnimation.value = false;

        grid.update((g) => g?.removeBubbles(matches));

        // Kiểm tra và xóa bóng không kết nối
        final detachedBubbles = grid.value.findDetachedBubbles();
        if (detachedBubbles.isNotEmpty) {
          // Thêm điểm cho bóng rơi
          score.value += detachedBubbles.length * 20;

          // Hiển thị hiệu ứng rơi cho detached bubbles
          animatingBubbles.assignAll(detachedBubbles);
          showAnimation.value = true;

          Future.delayed(const Duration(milliseconds: 600), () {
            showAnimation.value = false;
            grid.update((g) => g?.removeBubbles(detachedBubbles));

            // Cập nhật lại danh sách bóng
            bubbles.clear();
            bubbles.assignAll(grid.value.getAllBubbles());
          });
        } else {
          // Cập nhật danh sách bóng
          bubbles.clear();
          bubbles.assignAll(grid.value.getAllBubbles());
        }
      });
    } else {
      // Cập nhật danh sách bóng nếu không có match
      bubbles.clear();
      bubbles.assignAll(grid.value.getAllBubbles());
    }
  }

  String _getComboMessage(int length) {
    if (length >= 3 && length < 5) return 'Nice!';
    if (length >= 5 && length < 8) return 'Great!';
    if (length >= 8 && length < 12) return 'Awesome!';
    if (length >= 12) return 'Incredible!';
    return '';
  }

  void _checkGameState() {
    // Kiểm tra thắng
    if (grid.value.isVictory()) {
      victory.value = true;
      currentLevel.value++;
      _showGameEndMessage(true);
    }

    // Kiểm tra thua
    if (grid.value.isGameOver()) {
      gameOver.value = true;
      _showGameEndMessage(false);
    }
  }

  void _showGameEndMessage(bool isVictory) {
    if (isVictory) {
      Get.defaultDialog(
          title: 'Victory!',
          middleText: 'You cleared all bubbles! Score: ${score.value}',
          textConfirm: 'Next Level',
          confirmTextColor: Colors.white,
          onConfirm: () {
            Get.back();
            loadNextLevel();
          });
    } else {
      Get.defaultDialog(
          title: 'Game Over',
          middleText: 'The bubbles reached the bottom! Score: ${score.value}',
          textConfirm: 'Restart',
          confirmTextColor: Colors.white,
          onConfirm: () {
            Get.back();
            resetGame();
          });
    }
  }

  void pauseGame() {
    isGamePaused.value = true;
  }

  void resumeGame() {
    isGamePaused.value = false;
  }

  void resetGame() {
    // Hủy timers nếu đang chạy
    _animationTimer?.cancel();
    _animationTimer = null;

    _initializeGame();
    isGamePaused.value = false;
  }

  void loadNextLevel() {
    // Hủy timers nếu đang chạy
    _animationTimer?.cancel();
    _animationTimer = null;

    // Increase difficulty
    grid.value =
        BubbleGrid(rows: grid.value.rows + 1, columns: grid.value.columns);
    grid.value.initializeGrid(selectedChamp);

    // Reset game state but keep score
    gameOver.value = false;
    victory.value = false;
    isGamePaused.value = false;
    shootCount.value = 0;
    shotBubble.value = null;
    isShowingPath.value = false;
    bubbleAnimation.value = false;
    animationProgress.value = 0.0;

    // Get new bubbles
    activeBubble.value = Bubble.random(selectedChamp);
    nextBubble.value = Bubble.random(selectedChamp);

    // Update bubble list
    bubbles.clear();
    bubbles.assignAll(grid.value.getAllBubbles());
  }

  @override
  void onClose() {
    _gameLoopTimer?.cancel();
    _bubbleFallTimer?.cancel();
    _animationTimer?.cancel();
    super.onClose();
  }
}

```

---


### Pages\GamePage\Console\Bubble_Shooter\model\bubble_models.dart

```dart
import 'dart:math';
import 'dart:ui';

class Bubble {
  late String heroAsset;
  late Offset position;
  late double angle;
  late double speed;
  late String color;
  int row = -1;
  int col = -1;

  // GridPosition for snapping calculations
  GridPosition? gridPosition;

  // Animation properties
  double scale = 1.0;
  double opacity = 1.0;
  bool isAnimating = false;
  AnimationType animationType = AnimationType.none;

  Bubble({
    required this.heroAsset,
    this.position = const Offset(0.5, 0.9),
    this.angle = -pi / 2, // Mặc định hướng lên trên
    this.speed = 0.5,
    required this.color,
    this.scale = 1.0,
    this.opacity = 1.0,
  });

  factory Bubble.random(List<String> availableChampions) {
    final random = Random();
    final champIndex = random.nextInt(availableChampions.length);
    final champion = availableChampions[champIndex];

    return Bubble(
      heroAsset: champion,
      color: champion,
    );
  }

  void updatePosition(double deltaTime) {
    final dx = cos(angle) * speed * deltaTime;
    final dy = sin(angle) * speed * deltaTime;

    // Kiểm tra va chạm với biên trái/phải
    final newX = position.dx + dx;
    if (newX <= 0.05 || newX >= 0.95) {
      // Đổi hướng ngang khi va chạm
      angle = pi - angle;
      position = Offset(
        position.dx + cos(angle) * speed * deltaTime,
        position.dy + sin(angle) * speed * deltaTime,
      );
    } else {
      position = Offset(position.dx + dx, position.dy + dy);
    }
  }

  // Phương thức copy với thuộc tính mới
  Bubble copyWith({
    String? heroAsset,
    Offset? position,
    double? angle,
    double? speed,
    String? color,
    int? row,
    int? col,
    GridPosition? gridPosition,
    double? scale,
    double? opacity,
    bool? isAnimating,
    AnimationType? animationType,
  }) {
    final bubble = Bubble(
      heroAsset: heroAsset ?? this.heroAsset,
      position: position ?? this.position,
      angle: angle ?? this.angle,
      speed: speed ?? this.speed,
      color: color ?? this.color,
      scale: scale ?? this.scale,
      opacity: opacity ?? this.opacity,
    );

    bubble.row = row ?? this.row;
    bubble.col = col ?? this.col;
    bubble.gridPosition = gridPosition ?? this.gridPosition;
    bubble.isAnimating = isAnimating ?? this.isAnimating;
    bubble.animationType = animationType ?? this.animationType;

    return bubble;
  }

  @override
  String toString() {
    return 'Bubble(color: $color, position: $position)';
  }
}

// Enum để theo dõi loại animation của bóng
enum AnimationType {
  none,
  shoot,
  match,
  detach,
  appear,
}

class GridPosition {
  int row;
  int col;

  GridPosition(this.row, this.col);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    return other is GridPosition && other.row == row && other.col == col;
  }

  @override
  int get hashCode => row.hashCode ^ col.hashCode;

  @override
  String toString() => 'GridPosition($row, $col)';
}

class BubbleGrid {
  late List<List<Bubble?>> grid;
  final int rows;
  final int columns;
  final double bubbleRadius = 0.05; // Bán kính tương đối của bóng

  BubbleGrid({this.rows = 10, this.columns = 10}) {
    grid = List.generate(rows, (_) => List.filled(columns, null));
  }

  void initializeGrid(List<String> availableChampions) {
    final random = Random();

    // Chỉ điền đầy 3 hàng đầu tiên
    for (int row = 0; row < 3; row++) {
      for (int col = 0; col < columns; col++) {
        final champIndex = random.nextInt(availableChampions.length);
        final champion = availableChampions[champIndex];

        final bubble = Bubble(
          heroAsset: champion,
          color: champion,
        );

        bubble.row = row;
        bubble.col = col;
        bubble.gridPosition = GridPosition(row, col);
        bubble.animationType = AnimationType.appear;

        grid[row][col] = bubble;
      }
    }
  }

  // Lấy tất cả bóng từ lưới
  List<Bubble> getAllBubbles() {
    final result = <Bubble>[];
    for (int row = 0; row < rows; row++) {
      for (int col = 0; col < columns; col++) {
        if (grid[row][col] != null) {
          result.add(grid[row][col]!);
        }
      }
    }
    return result;
  }

  GridPosition? checkCollision(Bubble bubble) {
    // Chuyển đổi vị trí tương đối thành vị trí lưới
    final row = (bubble.position.dy / (bubbleRadius * 2)).floor();
    final col = (bubble.position.dx / (bubbleRadius * 2)).floor();

    // Kiểm tra nếu bóng đã ở trên cùng (va chạm với đỉnh lưới)
    if (bubble.position.dy <= bubbleRadius) {
      final col = min(columns - 1,
          max(0, (bubble.position.dx / (bubbleRadius * 2)).floor()));
      return _findNearestEmptyCell(0, col);
    }

    // Kiểm tra các vị trí lân cận
    for (int r = max(0, row - 1); r <= min(rows - 1, row + 1); r++) {
      for (int c = max(0, col - 1); c <= min(columns - 1, col + 1); c++) {
        if (grid[r][c] != null) {
          // Tính khoảng cách giữa hai tâm bóng
          final isEvenRow = r % 2 == 0;
          final offsetX = isEvenRow ? 0.0 : bubbleRadius;

          final gridBubblePos = Offset(
            offsetX + c * (bubbleRadius * 2) + bubbleRadius,
            r * (bubbleRadius * 2) + bubbleRadius,
          );

          final distance = (gridBubblePos - bubble.position).distance;

          // Nếu khoảng cách nhỏ hơn 2 lần bán kính, có va chạm
          if (distance < (bubbleRadius * 1.8)) {
            // Tìm ô trống gần nhất để đặt bóng
            return _findNearestEmptyCell(r, c);
          }
        }
      }
    }

    return null;
  }

  GridPosition? _findNearestEmptyCell(int row, int col) {
    // Nếu ô hiện tại trống, dùng nó
    if (row >= 0 &&
        row < rows &&
        col >= 0 &&
        col < columns &&
        grid[row][col] == null) {
      return GridPosition(row, col);
    }

    // Kiểm tra các ô lân cận
    final directions = [
      [-1, 0], [1, 0], [0, -1], [0, 1], // Trên, dưới, trái, phải
      [-1, -1], [-1, 1], [1, -1], [1, 1], // Các góc
    ];

    for (final dir in directions) {
      final newRow = row + dir[0];
      final newCol = col + dir[1];

      if (newRow >= 0 &&
          newRow < rows &&
          newCol >= 0 &&
          newCol < columns &&
          grid[newRow][newCol] == null) {
        return GridPosition(newRow, newCol);
      }
    }

    return null;
  }

  void addBubble(Bubble bubble) {
    final collisionCell = checkCollision(bubble);
    if (collisionCell != null) {
      final row = collisionCell.row;
      final col = collisionCell.col;

      if (row >= 0 && row < rows && col >= 0 && col < columns) {
        bubble.row = row;
        bubble.col = col;
        bubble.gridPosition = GridPosition(row, col);
        grid[row][col] = bubble;
      }
    }
  }

  // Tìm các bóng cùng màu kết nối với nhau
  List<Bubble> findMatches(Bubble bubble) {
    if (bubble.gridPosition == null) return [];

    final row = bubble.gridPosition!.row;
    final col = bubble.gridPosition!.col;
    final color = bubble.color;

    final visited = <GridPosition>{};
    final matches = <Bubble>[];

    // Thuật toán DFS để tìm các bóng cùng màu
    _exploreMatches(row, col, color, visited, matches);

    // Trả về kết quả nếu có ít nhất 3 bóng
    return matches.length >= 3 ? matches : [];
  }

  void _exploreMatches(int row, int col, String color,
      Set<GridPosition> visited, List<Bubble> matches) {
    if (row < 0 || row >= rows || col < 0 || col >= columns) return;

    final pos = GridPosition(row, col);
    if (visited.contains(pos)) return;

    final bubble = grid[row][col];
    if (bubble == null || bubble.color != color) return;

    visited.add(pos);
    matches.add(bubble);

    // Kiểm tra 6 hướng trong lưới hexagonal
    final directions = isEvenRow(row)
        ? [
            [-1, 0],
            [-1, 1],
            [0, 1],
            [1, 1],
            [1, 0],
            [0, -1]
          ] // Hàng chẵn
        : [
            [-1, -1],
            [-1, 0],
            [0, 1],
            [1, 0],
            [1, -1],
            [0, -1]
          ]; // Hàng lẻ

    for (final dir in directions) {
      _exploreMatches(row + dir[0], col + dir[1], color, visited, matches);
    }
  }

  // Kiểm tra xem một hàng có phải là hàng chẵn không
  bool isEvenRow(int row) {
    return row % 2 == 0;
  }

  // Tìm các bóng không kết nối với đỉnh lưới
  List<Bubble> findDetachedBubbles() {
    final connectedToTop = <GridPosition>{};

    // Thêm tất cả các bóng ở hàng đầu tiên
    for (int col = 0; col < columns; col++) {
      if (grid[0][col] != null) {
        _exploreBubbleConnection(0, col, connectedToTop);
      }
    }

    // Tìm tất cả các bóng không kết nối
    final detachedBubbles = <Bubble>[];
    for (int row = 0; row < rows; row++) {
      for (int col = 0; col < columns; col++) {
        if (grid[row][col] != null) {
          final pos = GridPosition(row, col);
          if (!connectedToTop.contains(pos)) {
            final bubble = grid[row][col]!;
            bubble.animationType = AnimationType.detach;
            detachedBubbles.add(bubble);
          }
        }
      }
    }

    return detachedBubbles;
  }

  void _exploreBubbleConnection(int row, int col, Set<GridPosition> visited) {
    if (row < 0 || row >= rows || col < 0 || col >= columns) return;

    final pos = GridPosition(row, col);
    if (visited.contains(pos)) return;

    final bubble = grid[row][col];
    if (bubble == null) return;

    visited.add(pos);

    // Kiểm tra 6 hướng trong lưới hexagonal
    final directions = isEvenRow(row)
        ? [
            [-1, 0],
            [-1, 1],
            [0, 1],
            [1, 1],
            [1, 0],
            [0, -1]
          ] // Hàng chẵn
        : [
            [-1, -1],
            [-1, 0],
            [0, 1],
            [1, 0],
            [1, -1],
            [0, -1]
          ]; // Hàng lẻ

    for (final dir in directions) {
      _exploreBubbleConnection(row + dir[0], col + dir[1], visited);
    }
  }

  // Xóa các bóng được chỉ định khỏi lưới
  void removeBubbles(List<Bubble> bubblesToRemove) {
    for (final bubble in bubblesToRemove) {
      if (bubble.gridPosition != null) {
        final row = bubble.gridPosition!.row;
        final col = bubble.gridPosition!.col;

        if (row >= 0 && row < rows && col >= 0 && col < columns) {
          grid[row][col] = null;
        }
      }
    }
  }

  // Kiểm tra xem game đã kết thúc chưa
  bool isGameOver() {
    // Kiểm tra xem có bóng nào ở hàng cuối cùng hay không
    for (int col = 0; col < columns; col++) {
      if (grid[rows - 1][col] != null) {
        return true;
      }
    }
    return false;
  }

  // Kiểm tra xem người chơi đã thắng chưa
  bool isVictory() {
    // Kiểm tra xem còn bóng nào trên lưới hay không
    for (int row = 0; row < rows; row++) {
      for (int col = 0; col < columns; col++) {
        if (grid[row][col] != null) {
          return false;
        }
      }
    }
    return true;
  }

  // Thêm một hàng bóng mới vào đầu lưới
  void addNewRow(List<String> availableChampions) {
    // Dịch chuyển tất cả các hàng xuống dưới
    for (int row = rows - 1; row > 0; row--) {
      grid[row] = List.from(grid[row - 1]);

      // Cập nhật vị trí hàng cho các bóng
      for (int col = 0; col < columns; col++) {
        if (grid[row][col] != null) {
          grid[row][col]!.row = row;
          grid[row][col]!.gridPosition = GridPosition(row, col);
        }
      }
    }

    // Thêm hàng mới vào đầu
    final random = Random();
    for (int col = 0; col < columns; col++) {
      final champIndex = random.nextInt(availableChampions.length);
      final champion = availableChampions[champIndex];

      final bubble = Bubble(
        heroAsset: champion,
        color: champion,
      );

      bubble.row = 0;
      bubble.col = col;
      bubble.gridPosition = GridPosition(0, col);
      bubble.animationType = AnimationType.appear;

      grid[0][col] = bubble;
    }
  }
}

```

---


### Pages\GamePage\Console\Bubble_Shooter\utils\combo_calculator.dart

```dart


// Tiện ích tính điểm combo
import 'dart:math';

import 'package:flutter/material.dart';

class ComboCalculator {
  static int calculateComboScore(int baseScore, int comboMultiplier) {
    return baseScore * max(1, comboMultiplier);
  }

  static String getComboText(int comboCount) {
    if (comboCount <= 1) return '';
    if (comboCount <= 3) return 'Combo x$comboCount';
    if (comboCount <= 5) return 'Super Combo x$comboCount';
    if (comboCount <= 8) return 'Ultra Combo x$comboCount';
    return 'MASTER COMBO x$comboCount';
  }

  static Color getComboColor(int comboCount) {
    if (comboCount <= 1) return Colors.white;
    if (comboCount <= 3) return Colors.blue;
    if (comboCount <= 5) return Colors.green;
    if (comboCount <= 8) return Colors.orange;
    return Colors.purple;
  }
}

```

---


### Pages\GamePage\Console\Bubble_Shooter\utils\device_detector.dart

```dart
// Tiện ích phát hiện thiết bị
import 'dart:math';

import 'package:flutter/material.dart';

class DeviceDetector {
  static bool isSmallScreen(BuildContext context) {
    final size = MediaQuery.of(context).size;
    return size.width < 360 || size.height < 640;
  }

  static bool isTablet(BuildContext context) {
    final size = MediaQuery.of(context).size;
    final diagonal = sqrt(size.width * size.width + size.height * size.height);
    return diagonal > 1100;
  }

  static double getBubbleSizeForDevice(BuildContext context, int columns) {
    final width = MediaQuery.of(context).size.width;
    final calculatedSize = width / columns;

    if (isTablet(context)) {
      return min(calculatedSize, 60.0);
    } else if (isSmallScreen(context)) {
      return calculatedSize * 0.9;
    } else {
      return calculatedSize;
    }
  }
}

```

---


### Pages\GamePage\Console\Bubble_Shooter\utils\game_storage.dart

```dart

// Tiện ích lưu trữ
class GameStorage {
  // Lưu điểm cao
  static Future<void> saveHighScore(int score) async {
    // Thực hiện lưu điểm cao
  }

  // Lấy điểm cao
  static Future<int> getHighScore() async {
    // Lấy điểm cao từ lưu trữ
    return 0;
  }

  // Lưu cấp độ đã mở khóa
  static Future<void> saveUnlockedLevel(int level) async {
    // Thực hiện lưu cấp độ
  }

  // Lấy cấp độ đã mở khóa
  static Future<int> getUnlockedLevel() async {
    // Lấy cấp độ từ lưu trữ
    return 1;
  }

  // Lưu trạng thái game
  static Future<void> saveGameState(Map<String, dynamic> gameState) async {
    // Thực hiện lưu trạng thái
  }

  // Lấy trạng thái game
  static Future<Map<String, dynamic>?> getGameState() async {
    // Lấy trạng thái từ lưu trữ
    return null;
  }
}

```

---


### Pages\GamePage\Console\Bubble_Shooter\utils\haptic_manager.dart

```dart
// Tiện ích rung
class HapticManager {
  static bool isHapticEnabled = true;

  static void vibrate() {
    if (!isHapticEnabled) return;
    // Rung nhẹ
  }

  static void heavyVibrate() {
    if (!isHapticEnabled) return;
    // Rung mạnh
  }

  static void toggleHaptic() {
    isHapticEnabled = !isHapticEnabled;
  }
}

```

---


### Pages\GamePage\Console\Bubble_Shooter\utils\sound_manager.dart

```dart
// Tiện ích âm thanh
class SoundManager {
  static bool isSoundEnabled = true;

  // Mô phỏng các hàm phát âm thanh
  static void playShootSound() {
    if (!isSoundEnabled) return;
    // Phát âm thanh bắn
  }

  static void playPopSound() {
    if (!isSoundEnabled) return;
    // Phát âm thanh nổ
  }

  static void playMatchSound(int count) {
    if (!isSoundEnabled) return;
    // Phát âm thanh match, khác nhau dựa trên số lượng bóng
  }

  static void playVictorySound() {
    if (!isSoundEnabled) return;
    // Phát âm thanh chiến thắng
  }

  static void playGameOverSound() {
    if (!isSoundEnabled) return;
    // Phát âm thanh thua cuộc
  }

  static void toggleSound() {
    isSoundEnabled = !isSoundEnabled;
  }
}
```

---


### Pages\GamePage\Console\Bubble_Shooter\views\bubble_grid_ui.dart

```dart
import 'dart:math';
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:tictactoe_gameapp/Pages/GamePage/Console/Bubble_Shooter/model/bubble_models.dart';
import 'package:tictactoe_gameapp/Pages/GamePage/Console/Bubble_Shooter/controllers/bubble_shooter_gameplay_controller.dart';
import 'package:tictactoe_gameapp/Pages/GamePage/Console/Bubble_Shooter/views/components/bubble_widget.dart';
import 'package:tictactoe_gameapp/Pages/GamePage/Console/Bubble_Shooter/utils/device_detector.dart';
import 'package:tictactoe_gameapp/Pages/GamePage/Console/Bubble_Shooter/views/components/particle_system.dart';
import 'package:tictactoe_gameapp/Pages/GamePage/Console/Bubble_Shooter/views/components/effects/trail_effect.dart';
import 'package:tictactoe_gameapp/Pages/GamePage/Console/Bubble_Shooter/views/components/falling_bubble_physics.dart';
import 'package:tictactoe_gameapp/Pages/GamePage/Console/Bubble_Shooter/views/components/glowing_bubble.dart';
import 'package:tictactoe_gameapp/Pages/GamePage/Console/Bubble_Shooter/views/components/pulsing_bubble_hint.dart';

class BubbleGridUI extends StatelessWidget {
  final BubbleShooterController controller;

  const BubbleGridUI({super.key, required this.controller});

  @override
  Widget build(BuildContext context) {
    final gridHeight =
        MediaQuery.of(context).size.height * controller.gridHeightFactor;
    final gridWidth = MediaQuery.of(context).size.width;

    return Obx(() {
      final gridBubbles = controller.grid.value.grid;
      final animatingBubbles = controller.animatingBubbles;
      final showAnimation = controller.showAnimation.value;

      // Tính toán kích thước bóng dựa trên số cột và thiết bị
      final bubbleSize =
          DeviceDetector.getBubbleSizeForDevice(context, gridBubbles[0].length);

      return LayoutBuilder(
        builder: (context, constraints) {
          return Stack(
            children: [
              // Lưới cố định - Sử dụng RepaintBoundary cho hiệu suất tốt hơn
              RepaintBoundary(
                child: SingleChildScrollView(
                  physics: const NeverScrollableScrollPhysics(),
                  child: ConstrainedBox(
                    constraints: BoxConstraints(maxHeight: gridHeight),
                    child: Column(
                      mainAxisSize: MainAxisSize.min,
                      children: List.generate(
                        min(gridBubbles.length,
                            (gridHeight / bubbleSize).floor()),
                        (rowIndex) {
                          final row = gridBubbles[rowIndex];
                          // Add offset for even rows (hexagonal grid)
                          final rowOffset =
                              rowIndex % 2 == 0 ? 0.0 : bubbleSize / 2;
                          return SizedBox(
                            height: bubbleSize,
                            child: SingleChildScrollView(
                              scrollDirection: Axis.horizontal,
                              physics: const NeverScrollableScrollPhysics(),
                              child: Row(
                                mainAxisAlignment: MainAxisAlignment.center,
                                children: [
                                  SizedBox(width: rowOffset),
                                  ...List.generate(row.length, (colIndex) {
                                    final bubble = row[colIndex];
                                    if (bubble != null) {
                                      // Skip if bubble is animating
                                      if (showAnimation &&
                                          animatingBubbles.any((animBubble) =>
                                              animBubble.row == rowIndex &&
                                              animBubble.col == colIndex)) {
                                        return SizedBox(
                                            width: bubbleSize,
                                            height: bubbleSize);
                                      }
                                      final canMatch =
                                          _canBubbleMatch(bubble, gridBubbles);

                                      return PulsingBubbleHint(
                                        isHinting: canMatch &&
                                            controller.shootCount.value % 5 ==
                                                0, // Gợi ý sau mỗi 5 lần bắn
                                        child: BubbleWidget(
                                          bubble: bubble,
                                          size: bubbleSize,
                                          animationType: bubble.animationType,
                                        ),
                                      );
                                    } else {
                                      return SizedBox(
                                          width: bubbleSize,
                                          height: bubbleSize);
                                    }
                                  }),
                                ],
                              ),
                            ),
                          );
                        },
                      ),
                    ),
                  ),
                ),
              ),

              // Bóng đang bay - chỉ hiển thị khi không có animation
              if (!controller.bubbleAnimation.value &&
                  controller.shotBubble.value != null)
                Positioned(
                  left: controller.shotBubble.value!.position.dx * gridWidth -
                      bubbleSize / 2,
                  top: controller.shotBubble.value!.position.dy * gridHeight -
                      bubbleSize / 2,
                  child: Stack(
                    children: [
                      // Trail effect - hiệu ứng vệt sáng khi bóng bay
                      Positioned(
                        left: -gridWidth,
                        top: -gridHeight,
                        child: TrailEffect(
                          trailPoints: [
                            Offset(
                                controller.shotBubble.value!.position.dx *
                                        gridWidth +
                                    bubbleSize / 2,
                                controller.shotBubble.value!.position.dy *
                                        gridHeight +
                                    bubbleSize / 2),
                            Offset(
                                controller.shotBubble.value!.position.dx *
                                        gridWidth -
                                    cos(controller.shotBubble.value!.angle) *
                                        30 +
                                    bubbleSize / 2,
                                controller.shotBubble.value!.position.dy *
                                        gridHeight -
                                    sin(controller.shotBubble.value!.angle) *
                                        30 +
                                    bubbleSize / 2),
                          ],
                          color: Colors.white.withOpacity(0.5),
                          width: 4,
                        ),
                      ),

                      // Bóng
                      BubbleWidget(
                        bubble: controller.shotBubble.value!,
                        size: bubbleSize,
                        animationType: AnimationType.shoot,
                      ),
                    ],
                  ),
                ),

              // Hiệu ứng bóng đang bay với animation
              if (controller.bubbleAnimation.value &&
                  controller.shotBubble.value != null)
                Obx(() {
                  final progress = controller.animationProgress.value;
                  final pathPoints = controller.pathPoints;

                  if (pathPoints.isEmpty) return const SizedBox.shrink();

                  final pathIndex = min(
                    (progress * (pathPoints.length - 1)).floor(),
                    pathPoints.length - 1,
                  );

                  final position = pathPoints[pathIndex];

                  // Tạo các điểm đường đi gần đây để vẽ vệt sáng
                  final recentPoints = pathIndex > 5
                      ? pathPoints.sublist(pathIndex - 5, pathIndex + 1)
                      : pathPoints.sublist(0, pathIndex + 1);

                  final trailPoints = recentPoints
                      .map((point) => Offset(
                            point.dx * gridWidth + bubbleSize / 2,
                            point.dy * gridHeight + bubbleSize / 2,
                          ))
                      .toList();

                  return Stack(
                    children: [
                      // Vệt sáng
                      if (trailPoints.length > 1)
                        TrailEffect(
                          trailPoints: trailPoints,
                          color: Colors.white.withOpacity(0.5),
                          width: 3,
                        ),

                      // Bóng với hiệu ứng
                      AnimatedPositioned(
                        duration: const Duration(milliseconds: 50),
                        curve: Curves.linear,
                        left: position.dx * gridWidth - bubbleSize / 2,
                        top: position.dy * gridHeight - bubbleSize / 2,
                        child: GlowingBubble(
                          glowColor: Colors.white,
                          child: BubbleWidget(
                            bubble: controller.shotBubble.value!,
                            size: bubbleSize,
                            scale: 1.0 +
                                sin(progress * pi * 3) *
                                    0.1, // Thêm hiệu ứng nhấp nháy khi bóng bay
                            animationType: AnimationType.shoot,
                          ),
                        ),
                      ),
                    ],
                  );
                }),

              // Hiệu ứng bóng nổ hoặc rơi
              if (showAnimation)
                ...animatingBubbles.map((bubble) {
                  // Xác định vị trí của bóng trong lưới
                  final rowIndex = bubble.row;
                  final colIndex = bubble.col;
                  final rowOffset = rowIndex % 2 == 0 ? 0.0 : bubbleSize / 2;

                  // Tính vị trí của bóng trong lưới
                  final initialLeft = rowOffset + colIndex * bubbleSize;
                  final initialTop = rowIndex * bubbleSize;

                  if (bubble.animationType == AnimationType.detach) {
                    // Hiệu ứng rơi với vật lý thực
                    return FallingBubblePhysics(
                      bubble: bubble,
                      size: bubbleSize,
                      onComplete: () {
                        // Animation hoàn tất
                      },
                    );
                  } else if (bubble.animationType == AnimationType.match) {
                    // Hiệu ứng match/pop
                    return Stack(
                      children: [
                        // Bóng nổ
                        TweenAnimationBuilder(
                          tween: Tween<double>(begin: 0, end: 1),
                          duration: const Duration(milliseconds: 600),
                          builder: (context, value, child) {
                            return Positioned(
                              left: initialLeft,
                              top: initialTop,
                              child: Opacity(
                                opacity: 1.0 - value,
                                child: Transform.scale(
                                  scale: 1.0 + value * 0.8,
                                  child: BubbleWidget(
                                    bubble: bubble,
                                    size: bubbleSize,
                                    animationType: AnimationType.match,
                                  ),
                                ),
                              ),
                            );
                          },
                        ),

                        // Hiệu ứng particles
                        TweenAnimationBuilder(
                          tween: Tween<double>(begin: 0, end: 1),
                          duration: const Duration(milliseconds: 600),
                          builder: (context, value, child) {
                            if (value < 0.1) return const SizedBox.shrink();

                            return Positioned(
                              left: initialLeft + bubbleSize / 2,
                              top: initialTop + bubbleSize / 2,
                              child: ParticleSystem(
                                center: Offset.zero,
                                color: _getBubbleColor(bubble.color),
                                particleCount: 15,
                                size: 4,
                              ),
                            );
                          },
                        ),
                      ],
                    );
                  } else {
                    // Hiệu ứng mặc định
                    return TweenAnimationBuilder(
                      tween: Tween<double>(begin: 0, end: 1),
                      duration: const Duration(milliseconds: 600),
                      builder: (context, value, child) {
                        return Positioned(
                          left: initialLeft,
                          top: initialTop,
                          child: Opacity(
                            opacity: 1.0 - value,
                            child: Transform.scale(
                              scale: 1.0 + value * 0.5,
                              child: BubbleWidget(
                                bubble: bubble,
                                size: bubbleSize,
                                animationType: bubble.animationType,
                              ),
                            ),
                          ),
                        );
                      },
                    );
                  }
                }),
            ],
          );
        },
      );
    });
  }

  // Hàm kiểm tra bóng có thể match hay không
  bool _canBubbleMatch(Bubble bubble, List<List<Bubble?>> grid) {
    // Giả lập, trong thực tế sẽ cần thuật toán phù hợp
    final row = bubble.row;
    final col = bubble.col;
    final color = bubble.color;

    // Kiểm tra xem có ít nhất 2 bóng cùng màu kề nhau không
    int sameColorCount = 0;

    // Directions để kiểm tra các ô lân cận
    final directions = controller.grid.value.isEvenRow(row)
        ? [
            [-1, 0],
            [-1, 1],
            [0, 1],
            [1, 1],
            [1, 0],
            [0, -1]
          ] // Hàng chẵn
        : [
            [-1, -1],
            [-1, 0],
            [0, 1],
            [1, 0],
            [1, -1],
            [0, -1]
          ]; // Hàng lẻ

    for (final dir in directions) {
      final newRow = row + dir[0];
      final newCol = col + dir[1];

      if (newRow >= 0 &&
          newRow < grid.length &&
          newCol >= 0 &&
          newCol < grid[0].length &&
          grid[newRow][newCol] != null) {
        if (grid[newRow][newCol]?.color == color) {
          sameColorCount++;

          // Nếu có ít nhất 2 bóng cùng màu kề nhau, có thể tạo thành match
          if (sameColorCount >= 2) {
            return true;
          }
        }
      }
    }

    return false;
  }

  // Chuyển đổi tên màu thành Color
  Color _getBubbleColor(String colorName) {
    // Trong thực tế cần một map giữa tên champion và màu
    switch (colorName.toLowerCase()) {
      case 'aatrox':
        return Colors.red;
      case 'ahri':
        return Colors.orange;
      case 'akali':
        return Colors.green;
      case 'alistar':
        return Colors.purple;
      case 'amumu':
        return Colors.yellow;
      case 'anivia':
        return Colors.blue;
      case 'annie':
        return Colors.red[300]!;
      case 'ashe':
        return Colors.blue[300]!;
      default:
        return Colors.grey;
    }
  }
}

```

---


### Pages\GamePage\Console\Bubble_Shooter\views\components\animated_bubble_scale.dart

```dart

// Hiệu ứng nút bấm
import 'package:flutter/material.dart';

class BounceButton extends StatefulWidget {
  final Widget child;
  final VoidCallback onTap;

  const BounceButton({
    super.key,
    required this.child,
    required this.onTap,
  });

  @override
  State<BounceButton> createState() => _BounceButtonState();
}

class _BounceButtonState extends State<BounceButton>
    with SingleTickerProviderStateMixin {
  late AnimationController _controller;
  late Animation<double> _animation;

  @override
  void initState() {
    super.initState();
    _controller = AnimationController(
      vsync: this,
      duration: const Duration(milliseconds: 200),
    );

    _animation = Tween<double>(begin: 1.0, end: 0.9).animate(
      CurvedAnimation(
        parent: _controller,
        curve: Curves.easeInOut,
      ),
    );
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return GestureDetector(
      onTapDown: (_) => _controller.forward(),
      onTapUp: (_) {
        _controller.reverse();
        widget.onTap();
      },
      onTapCancel: () => _controller.reverse(),
      child: AnimatedBuilder(
        animation: _animation,
        builder: (context, child) {
          return Transform.scale(
            scale: _animation.value,
            child: child,
          );
        },
        child: widget.child,
      ),
    );
  }
}


// Hiệu ứng phóng to khi bắn bóng
class AnimatedBubbleScale2 extends StatelessWidget {
  final Widget child;
  final bool isActive;

  const AnimatedBubbleScale2({
    super.key,
    required this.child,
    required this.isActive,
  });

  @override
  Widget build(BuildContext context) {
    return TweenAnimationBuilder(
      tween: Tween<double>(
        begin: isActive ? 0.8 : 1.0,
        end: isActive ? 1.2 : 1.0,
      ),
      duration: const Duration(milliseconds: 300),
      curve: Curves.elasticOut,
      builder: (context, value, child) {
        return Transform.scale(
          scale: value,
          child: child,
        );
      },
      child: child,
    );
  }
}
```

---


### Pages\GamePage\Console\Bubble_Shooter\views\components\animated_combo_message.dart

```dart
// Widget hiển thị thông báo combo với hiệu ứng
import 'package:flutter/material.dart';

class AnimatedComboMessage extends StatelessWidget {
  final String message;

  const AnimatedComboMessage({super.key, required this.message});

  @override
  Widget build(BuildContext context) {
    return TweenAnimationBuilder(
      tween: Tween<double>(begin: 0, end: 1),
      duration: const Duration(milliseconds: 300),
      builder: (context, value, child) {
        return Opacity(
          opacity: value,
          child: Transform.scale(
            scale: 0.5 + (value * 0.5),
            child: Container(
              padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
              decoration: BoxDecoration(
                color: _getColorForMessage(message).withOpacity(0.2),
                borderRadius: BorderRadius.circular(20),
                border: Border.all(
                  color: _getColorForMessage(message).withOpacity(0.5),
                  width: 2,
                ),
                boxShadow: [
                  BoxShadow(
                    color: _getColorForMessage(message).withOpacity(0.3),
                    blurRadius: 10,
                    spreadRadius: 1,
                  ),
                ],
              ),
              child: Text(
                message,
                style: TextStyle(
                  fontFamily: "Orbitron",
                  fontWeight: FontWeight.bold,
                  fontSize: 24,
                  color: _getColorForMessage(message),
                  shadows: [
                    Shadow(
                      blurRadius: 3.0,
                      color: Colors.black.withOpacity(0.5),
                      offset: const Offset(2, 2),
                    ),
                  ],
                ),
              ),
            ),
          ),
        );
      },
    );
  }

  Color _getColorForMessage(String msg) {
    switch (msg) {
      case 'Nice!':
        return Colors.blue;
      case 'Great!':
        return Colors.green;
      case 'Awesome!':
        return Colors.orange;
      case 'Incredible!':
        return Colors.purple;
      default:
        return Colors.white;
    }
  }
}

```

---


### Pages\GamePage\Console\Bubble_Shooter\views\components\animated_score_display.dart

```dart

// Widget để hiển thị điểm số với hiệu ứng nhảy số
import 'package:flutter/material.dart';

class AnimatedScoreDisplay extends StatelessWidget {
  final int score;
  final int previousScore;
  final TextStyle style;

  const AnimatedScoreDisplay({
    super.key,
    required this.score,
    required this.previousScore,
    this.style = const TextStyle(
      fontFamily: 'Orbitron',
      fontSize: 18,
      fontWeight: FontWeight.bold,
      color: Colors.white,
    ),
  });

  @override
  Widget build(BuildContext context) {
    return TweenAnimationBuilder<int>(
      tween: IntTween(begin: previousScore, end: score),
      duration: const Duration(milliseconds: 800),
      curve: Curves.easeOutCubic,
      builder: (context, value, child) {
        return Text(
          value.toString(),
          style: style,
        );
      },
    );
  }
}

```

---


### Pages\GamePage\Console\Bubble_Shooter\views\components\bubble_background.dart

```dart
// Hiệu ứng nền đẹp hơn
import 'dart:math';

import 'package:flutter/material.dart';

class BubbleBackground extends StatelessWidget {
  final Color startColor;
  final Color endColor;

  const BubbleBackground({
    super.key,
    this.startColor = const Color(0xFFE0F7FF),
    this.endColor = const Color(0xFF88C9FF),
  });

  @override
  Widget build(BuildContext context) {
    return Stack(
      children: [
        // Gradient background
        Container(
          decoration: BoxDecoration(
            gradient: LinearGradient(
              begin: Alignment.topCenter,
              end: Alignment.bottomCenter,
              colors: [startColor, endColor],
            ),
          ),
        ),

        // Decorative bubbles
        ...List.generate(20, (index) {
          final random = Random();
          final size = 20.0 + random.nextDouble() * 30.0;

          return Positioned(
            left: random.nextDouble() * MediaQuery.of(context).size.width,
            top: random.nextDouble() * MediaQuery.of(context).size.height,
            child: Opacity(
              opacity: 0.05 + random.nextDouble() * 0.1,
              child: Container(
                width: size,
                height: size,
                decoration: const BoxDecoration(
                  color: Colors.white,
                  shape: BoxShape.circle,
                ),
              ),
            ),
          );
        }),
      ],
    );
  }
}

```

---


### Pages\GamePage\Console\Bubble_Shooter\views\components\bubble_collision_ripple.dart

```dart

// Hiệu ứng gợn sóng khi bóng chạm vào grid
import 'package:flutter/material.dart';

class BubbleCollisionRipple extends StatelessWidget {
  final Offset position;

  const BubbleCollisionRipple({
    super.key,
    required this.position,
  });

  @override
  Widget build(BuildContext context) {
    return TweenAnimationBuilder<double>(
      tween: Tween<double>(begin: 0.0, end: 1.0),
      duration: const Duration(milliseconds: 400),
      builder: (context, value, child) {
        return Positioned(
          left: position.dx - 30 * value,
          top: position.dy - 30 * value,
          child: Opacity(
            opacity: 1.0 - value,
            child: Container(
              width: 60 * value,
              height: 60 * value,
              decoration: BoxDecoration(
                shape: BoxShape.circle,
                border: Border.all(
                  color: Colors.white,
                  width: 2,
                ),
              ),
            ),
          ),
        );
      },
    );
  }
}


```

---


### Pages\GamePage\Console\Bubble_Shooter\views\components\bubble_widget.dart

```dart
import 'package:flutter/material.dart';
import 'package:tictactoe_gameapp/Pages/GamePage/Console/Bubble_Shooter/model/bubble_models.dart';

// Widget hiển thị từng bóng riêng lẻ với hiệu ứng
class BubbleWidget extends StatelessWidget {
  final Bubble bubble;
  final double size;
  final double scale;
  final AnimationType animationType;

  const BubbleWidget({
    super.key,
    required this.bubble,
    required this.size,
    this.scale = 1.0,
    this.animationType = AnimationType.none,
  });

  @override
  Widget build(BuildContext context) {
    // Xác định hiệu ứng dựa trên loại animation
    Widget bubbleContent = Container(
      width: size,
      height: size,
      padding: const EdgeInsets.all(1.5),
      child: CircleAvatar(
        backgroundImage: AssetImage(bubble.heroAsset),
      ),
    );

    // Thêm các hiệu ứng animation dựa trên loại
    switch (animationType) {
      case AnimationType.appear:
        return TweenAnimationBuilder(
          tween: Tween<double>(begin: 0, end: 1),
          duration: const Duration(milliseconds: 400),
          builder: (context, value, child) {
            return Opacity(
              opacity: value,
              child: Transform.scale(
                scale: 0.5 + value * 0.5,
                child: bubbleContent,
              ),
            );
          },
        );
      case AnimationType.shoot:
        return Transform.scale(
          scale: scale,
          child: Container(
            width: size,
            height: size,
            decoration: BoxDecoration(
              shape: BoxShape.circle,
              boxShadow: [
                BoxShadow(
                  color: Colors.white.withOpacity(0.5),
                  blurRadius: 10,
                  spreadRadius: 2,
                ),
              ],
            ),
            padding: const EdgeInsets.all(1.5),
            child: CircleAvatar(
              backgroundImage: AssetImage(bubble.heroAsset),
            ),
          ),
        );
      case AnimationType.match:
      case AnimationType.detach:
        // Những hiệu ứng này được xử lý bên ngoài widget này
        return bubbleContent;
      default:
        // Hiệu ứng mặc định: hiển thị bình thường
        return Transform.scale(
          scale: scale,
          child: bubbleContent,
        );
    }
  }
}

```

---


### Pages\GamePage\Console\Bubble_Shooter\views\components\countdown_widget.dart

```dart

// Hiệu ứng đếm ngược khi thêm hàng mới
import 'package:flutter/material.dart';

class CountdownWidget extends StatelessWidget {
  final int seconds;
  final VoidCallback onComplete;

  const CountdownWidget({
    super.key,
    required this.seconds,
    required this.onComplete,
  });

  @override
  Widget build(BuildContext context) {
    return TweenAnimationBuilder<double>(
      tween: Tween<double>(begin: seconds.toDouble(), end: 0),
      duration: Duration(seconds: seconds),
      onEnd: onComplete,
      builder: (context, value, child) {
        final remainingSeconds = value.ceil();

        return Container(
          padding: const EdgeInsets.all(16),
          decoration: BoxDecoration(
            color: Colors.red.withOpacity(0.7),
            shape: BoxShape.circle,
            boxShadow: [
              BoxShadow(
                color: Colors.black.withOpacity(0.3),
                blurRadius: 10,
                spreadRadius: 2,
              ),
            ],
          ),
          child: Text(
            '$remainingSeconds',
            style: const TextStyle(
              fontFamily: 'Orbitron',
              fontSize: 24,
              fontWeight: FontWeight.bold,
              color: Colors.white,
            ),
          ),
        );
      },
    );
  }
}
```

---


### Pages\GamePage\Console\Bubble_Shooter\views\components\falling_bubble_physics.dart

```dart
// Hiệu ứng bóng rơi với vật lý
import 'dart:math';

import 'package:flutter/material.dart';
import 'package:tictactoe_gameapp/Pages/GamePage/Console/Bubble_Shooter/model/bubble_models.dart';

class FallingBubblePhysics extends StatefulWidget {
  final Bubble bubble;
  final double size;
  final VoidCallback onComplete;

  const FallingBubblePhysics({
    super.key,
    required this.bubble,
    required this.size,
    required this.onComplete,
  });

  @override
  State<FallingBubblePhysics> createState() => _FallingBubblePhysicsState();
}

class _FallingBubblePhysicsState extends State<FallingBubblePhysics>
    with SingleTickerProviderStateMixin {
  late AnimationController _controller;
  late Offset _startPosition;
  late Offset _velocity;
  late double _angularVelocity;
  late double _rotation;
  Offset _currentPosition = Offset.zero;

  @override
  void initState() {
    super.initState();

    final random = Random();
    _startPosition = Offset(
      widget.bubble.col * widget.size,
      widget.bubble.row * widget.size,
    );
    _currentPosition = _startPosition;

    // Random initial velocity
    _velocity = Offset(
      (random.nextDouble() * 2 - 1) * 5,
      -random.nextDouble() * 3,
    );

    // Random rotation
    _angularVelocity = (random.nextDouble() * 2 - 1) * 0.2;
    _rotation = 0;

    _controller = AnimationController(
      vsync: this,
      duration: Duration(milliseconds: 800 + random.nextInt(400)),
    );

    _controller.addListener(_updatePosition);
    _controller.forward().then((_) => widget.onComplete());
  }

  void _updatePosition() {
    if (!mounted) return;

    // Apply gravity
    _velocity = Offset(_velocity.dx, _velocity.dy + 0.5);

    // Update position
    _currentPosition = Offset(
      _currentPosition.dx + _velocity.dx,
      _currentPosition.dy + _velocity.dy,
    );

    // Update rotation
    _rotation += _angularVelocity;

    setState(() {});
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Positioned(
      left: _currentPosition.dx,
      top: _currentPosition.dy,
      child: Transform.rotate(
        angle: _rotation,
        child: Opacity(
          opacity: 1.0 - _controller.value * 0.5,
          child: Container(
            width: widget.size,
            height: widget.size,
            padding: const EdgeInsets.all(1.5),
            child: CircleAvatar(
              backgroundImage: AssetImage(widget.bubble.heroAsset),
            ),
          ),
        ),
      ),
    );
  }
}
```

---


### Pages\GamePage\Console\Bubble_Shooter\views\components\game_state_overlay.dart

```dart

// Widget hiển thị overlay trạng thái game (pause, win, lose)
import 'package:flutter/material.dart';

class GameStateOverlay extends StatelessWidget {
  final String message;
  final Color color;

  const GameStateOverlay({
    super.key,
    required this.message,
    required this.color,
  });

  @override
  Widget build(BuildContext context) {
    return TweenAnimationBuilder(
      tween: Tween<double>(begin: 0, end: 1),
      duration: const Duration(milliseconds: 400),
      builder: (context, value, child) {
        return Container(
          color: Colors.black.withOpacity(0.6 * value),
          child: Center(
            child: Transform.scale(
              scale: value,
              child: Container(
                padding:
                    const EdgeInsets.symmetric(horizontal: 32, vertical: 16),
                decoration: BoxDecoration(
                  color: color.withOpacity(0.8),
                  borderRadius: BorderRadius.circular(12),
                  boxShadow: [
                    BoxShadow(
                      color: Colors.black.withOpacity(0.5),
                      blurRadius: 15,
                      spreadRadius: 5,
                    ),
                  ],
                  border: Border.all(
                    color: Colors.white.withOpacity(0.5),
                    width: 2,
                  ),
                ),
                child: Column(
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    Text(
                      message,
                      style: const TextStyle(
                        fontFamily: "Orbitron",
                        fontWeight: FontWeight.bold,
                        fontSize: 36,
                        color: Colors.white,
                        shadows: [
                          Shadow(
                            blurRadius: 3.0,
                            color: Colors.black,
                            offset: Offset(2, 2),
                          ),
                        ],
                      ),
                    ),
                    if (message == 'PAUSED')
                      const Padding(
                        padding: EdgeInsets.only(top: 16.0),
                        child: Text(
                          'Tap to continue',
                          style: TextStyle(
                            fontFamily: "Orbitron",
                            color: Colors.white,
                            fontSize: 16,
                          ),
                        ),
                      ),
                  ],
                ),
              ),
            ),
          ),
        );
      },
    );
  }
}
```

---


### Pages\GamePage\Console\Bubble_Shooter\views\components\glowing_bubble.dart

```dart

// Widget để tạo hiệu ứng tỏa sáng
import 'package:flutter/material.dart';

class GlowingBubble extends StatefulWidget {
  final Widget child;
  final Color glowColor;

  const GlowingBubble({
    super.key,
    required this.child,
    this.glowColor = Colors.white,
  });

  @override
  State<GlowingBubble> createState() => _GlowingBubbleState();
}

class _GlowingBubbleState extends State<GlowingBubble>
    with SingleTickerProviderStateMixin {
  late AnimationController _controller;
  late Animation<double> _animation;

  @override
  void initState() {
    super.initState();
    _controller = AnimationController(
      vsync: this,
      duration: const Duration(milliseconds: 1500),
    );

    _animation = Tween<double>(begin: 2.0, end: 15.0).animate(
      CurvedAnimation(
        parent: _controller,
        curve: Curves.easeInOut,
      ),
    );

    _controller.repeat(reverse: true);
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return AnimatedBuilder(
      animation: _animation,
      builder: (context, child) {
        return Container(
          decoration: BoxDecoration(
            shape: BoxShape.circle,
            boxShadow: [
              BoxShadow(
                color: widget.glowColor.withOpacity(0.5),
                blurRadius: _animation.value,
                spreadRadius: _animation.value / 3,
              ),
            ],
          ),
          child: widget.child,
        );
      },
    );
  }
}
```

---


### Pages\GamePage\Console\Bubble_Shooter\views\components\particle_system.dart

```dart
import 'dart:math';
import 'package:flutter/material.dart';

// Hiệu ứng particle cho animation
class ParticleSystem extends StatelessWidget {
  final Offset center;
  final Color color;
  final int particleCount;
  final double size;

  const ParticleSystem({
    super.key,
    required this.center,
    required this.color,
    this.particleCount = 10,
    this.size = 5.0,
  });

  @override
  Widget build(BuildContext context) {
    return Stack(
      children: List.generate(particleCount, (i) {
        final random = Random();
        final angle = random.nextDouble() * 2 * pi;
        final velocity = 50 + random.nextDouble() * 100;
        final size = this.size * (0.5 + random.nextDouble() * 0.5);

        return TweenAnimationBuilder(
          tween: Tween<double>(begin: 0, end: 1),
          duration: Duration(milliseconds: 500 + random.nextInt(500)),
          builder: (context, value, child) {
            return Positioned(
              left: center.dx + cos(angle) * velocity * value - size / 2,
              top: center.dy + sin(angle) * velocity * value - size / 2,
              child: Opacity(
                opacity: 1 - value,
                child: Container(
                  width: size,
                  height: size,
                  decoration: BoxDecoration(
                    color: color,
                    shape: BoxShape.circle,
                  ),
                ),
              ),
            );
          },
        );
      }),
    );
  }
}


```

---


### Pages\GamePage\Console\Bubble_Shooter\views\components\powerup_button.dart

```dart

// Hiệu ứng nút power-up
import 'package:flutter/material.dart';

class PowerupButton extends StatefulWidget {
  final IconData icon;
  final String label;
  final VoidCallback onPressed;
  final bool isActive;

  const PowerupButton({
    super.key,
    required this.icon,
    required this.label,
    required this.onPressed,
    this.isActive = true,
  });

  @override
  State<PowerupButton> createState() => _PowerupButtonState();
}

class _PowerupButtonState extends State<PowerupButton>
    with SingleTickerProviderStateMixin {
  late AnimationController _controller;
  late Animation<double> _scaleAnimation;
  late Animation<double> _glowAnimation;

  @override
  void initState() {
    super.initState();
    _controller = AnimationController(
      vsync: this,
      duration: const Duration(milliseconds: 300),
    );

    _scaleAnimation = Tween<double>(begin: 1.0, end: 0.9).animate(
      CurvedAnimation(
        parent: _controller,
        curve: Curves.easeInOut,
      ),
    );

    _glowAnimation = Tween<double>(begin: 0.0, end: 5.0).animate(
      CurvedAnimation(
        parent: _controller,
        curve: Curves.easeInOut,
      ),
    );
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return GestureDetector(
      onTapDown: widget.isActive ? (_) => _controller.forward() : null,
      onTapUp: widget.isActive
          ? (_) {
              _controller.reverse();
              widget.onPressed();
            }
          : null,
      onTapCancel: widget.isActive ? () => _controller.reverse() : null,
      child: Opacity(
        opacity: widget.isActive ? 1.0 : 0.5,
        child: AnimatedBuilder(
          animation: _controller,
          builder: (context, child) {
            return Transform.scale(
              scale: _scaleAnimation.value,
              child: Container(
                padding: const EdgeInsets.all(8),
                decoration: BoxDecoration(
                  color: Colors.blue[700],
                  borderRadius: BorderRadius.circular(12),
                  boxShadow: [
                    BoxShadow(
                      color: Colors.blue.withOpacity(0.5),
                      blurRadius: _glowAnimation.value,
                      spreadRadius: _glowAnimation.value / 2,
                    ),
                  ],
                ),
                child: Column(
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    Icon(
                      widget.icon,
                      color: Colors.white,
                      size: 24,
                    ),
                    const SizedBox(height: 4),
                    Text(
                      widget.label,
                      style: const TextStyle(
                        color: Colors.white,
                        fontSize: 12,
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                  ],
                ),
              ),
            );
          },
        ),
      ),
    );
  }
}

```

---


### Pages\GamePage\Console\Bubble_Shooter\views\components\pulsing_bubble_hint.dart

```dart
// Hiệu ứng bóng nhấp nháy để gợi ý
import 'package:flutter/material.dart';

class PulsingBubbleHint extends StatefulWidget {
  final Widget child;
  final bool isHinting;

  const PulsingBubbleHint({
    super.key,
    required this.child,
    required this.isHinting,
  });

  @override
  State<PulsingBubbleHint> createState() => _PulsingBubbleHintState();
}

class _PulsingBubbleHintState extends State<PulsingBubbleHint>
    with SingleTickerProviderStateMixin {
  late AnimationController _controller;
  late Animation<double> _animation;

  @override
  void initState() {
    super.initState();
    _controller = AnimationController(
      vsync: this,
      duration: const Duration(milliseconds: 800),
    );

    _animation = Tween<double>(begin: 1.0, end: 1.3).animate(
      CurvedAnimation(
        parent: _controller,
        curve: Curves.easeInOut,
      ),
    );

    if (widget.isHinting) {
      _controller.repeat(reverse: true);
    }
  }

  @override
  void didUpdateWidget(PulsingBubbleHint oldWidget) {
    super.didUpdateWidget(oldWidget);

    if (widget.isHinting && !oldWidget.isHinting) {
      _controller.repeat(reverse: true);
    } else if (!widget.isHinting && oldWidget.isHinting) {
      _controller.stop();
      _controller.reset();
    }
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return AnimatedBuilder(
      animation: _animation,
      builder: (context, child) {
        return Transform.scale(
          scale: widget.isHinting ? _animation.value : 1.0,
          child: child,
        );
      },
      child: widget.child,
    );
  }
}

```

---


### Pages\GamePage\Console\Bubble_Shooter\views\components\screen_shake_widget.dart

```dart

// Hiệu ứng rung màn hình
import 'dart:math';

import 'package:flutter/material.dart';

class ScreenShakeWidget extends StatefulWidget {
  final Widget child;
  final bool isShaking;
  final double intensity;

  const ScreenShakeWidget({
    super.key,
    required this.child,
    this.isShaking = false,
    this.intensity = 5.0,
  });

  @override
  State<ScreenShakeWidget> createState() => _ScreenShakeWidgetState();
}

class _ScreenShakeWidgetState extends State<ScreenShakeWidget>
    with SingleTickerProviderStateMixin {
  late AnimationController _controller;
  late Animation<Offset> _animation;

  @override
  void initState() {
    super.initState();
    _controller = AnimationController(
      vsync: this,
      duration: const Duration(milliseconds: 500),
    );

    _animation = Tween<Offset>(
      begin: Offset.zero,
      end: Offset.zero,
    ).animate(_controller);
  }

  @override
  void didUpdateWidget(ScreenShakeWidget oldWidget) {
    super.didUpdateWidget(oldWidget);

    if (widget.isShaking && !oldWidget.isShaking) {
      _startShaking();
    } else if (!widget.isShaking && oldWidget.isShaking) {
      _stopShaking();
    }
  }

  void _startShaking() {
    final random = Random();

    _animation = TweenSequence<Offset>([
      for (int i = 0; i < 5; i++)
        TweenSequenceItem(
          tween: Tween<Offset>(
            begin: Offset.zero,
            end: Offset(
              (random.nextDouble() * 2 - 1) * widget.intensity / 100,
              (random.nextDouble() * 2 - 1) * widget.intensity / 100,
            ),
          ),
          weight: 1,
        ),
    ]).animate(_controller);

    _controller.forward(from: 0);
  }

  void _stopShaking() {
    _controller.stop();
    _animation = Tween<Offset>(
      begin: _animation.value,
      end: Offset.zero,
    ).animate(
      CurvedAnimation(
        parent: _controller,
        curve: Curves.easeOutQuad,
      ),
    );

    _controller.forward(from: 0);
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return AnimatedBuilder(
      animation: _animation,
      builder: (context, child) {
        return Transform.translate(
          offset: _animation.value,
          child: child,
        );
      },
      child: widget.child,
    );
  }
}
```

---


### Pages\GamePage\Console\Bubble_Shooter\views\components\shooter_area.dart

```dart
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:tictactoe_gameapp/Pages/GamePage/Console/Bubble_Shooter/model/bubble_models.dart';
import 'package:tictactoe_gameapp/Pages/GamePage/Console/Bubble_Shooter/controllers/bubble_shooter_gameplay_controller.dart';
import 'package:tictactoe_gameapp/Pages/GamePage/Console/Bubble_Shooter/views/components/animated_bubble_scale.dart';

class ShooterArea extends StatelessWidget {
  final BubbleShooterController controller;

  const ShooterArea({super.key, required this.controller});

  @override
  Widget build(BuildContext context) {
    return GestureDetector(
      onPanUpdate: (details) {
        if (!controller.isGamePaused.value &&
            !controller.gameOver.value &&
            !controller.victory.value &&
            !controller.isBusy.value) {
          final target = Offset(
            details.localPosition.dx / MediaQuery.of(context).size.width,
            details.localPosition.dy / MediaQuery.of(context).size.height,
          );
          controller.calculateShootingPath(target);
        }
      },
      onPanEnd: (_) {
        if (!controller.isGamePaused.value &&
            !controller.gameOver.value &&
            !controller.victory.value &&
            controller.isShowingPath.value &&
            !controller.isBusy.value) {
          controller.shootBubble();
        }
      },
      child: Container(
        color: Colors.transparent,
        child: Stack(
          alignment: Alignment.bottomCenter,
          children: [
            // Shooter base
            Positioned(
              bottom: 0,
              child: Container(
                width: 80,
                height: 40,
                decoration: BoxDecoration(
                  color: Colors.grey[800],
                  borderRadius: const BorderRadius.only(
                    topLeft: Radius.circular(40),
                    topRight: Radius.circular(40),
                  ),
                ),
              ),
            ),
            
            // Current bubble
            Positioned(
              bottom: 30,
              child: Obx(() => 
                AnimatedBubbleScale2(
                  isActive: controller.isShowingPath.value,
                  child: CurrentBubbleWidget(bubble: controller.activeBubble.value),
                ),
              ),
            ),
            
            // Next bubble indicator
            Positioned(
              bottom: 10,
              right: 20,
              child: Row(
                children: [
                  const Text(
                    'Next:',
                    style: TextStyle(
                      fontWeight: FontWeight.bold,
                      color: Colors.white,
                    ),
                  ),
                  const SizedBox(width: 8),
                  Obx(() => NextBubbleWidget(bubble: controller.nextBubble.value)),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }
}

class CurrentBubbleWidget extends StatelessWidget {
  final Bubble bubble;

  const CurrentBubbleWidget({super.key, required this.bubble});

  @override
  Widget build(BuildContext context) {
    return Container(
      width: 50,
      height: 50,
      padding: const EdgeInsets.all(2),
      decoration: BoxDecoration(
        shape: BoxShape.circle,
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.3),
            blurRadius: 5,
            spreadRadius: 1,
          ),
        ],
      ),
      child: CircleAvatar(
        backgroundImage: AssetImage(bubble.heroAsset),
      ),
    );
  }
}

class NextBubbleWidget extends StatelessWidget {
  final Bubble bubble;

  const NextBubbleWidget({super.key, required this.bubble});

  @override
  Widget build(BuildContext context) {
    return Container(
      width: 30,
      height: 30,
      padding: const EdgeInsets.all(1),
      decoration: BoxDecoration(
        shape: BoxShape.circle,
        border: Border.all(color: Colors.white, width: 1),
      ),
      child: CircleAvatar(
        backgroundImage: AssetImage(bubble.heroAsset),
      ),
    );
  }
}
```

---


### Pages\GamePage\Console\Bubble_Shooter\views\components\shooting_path_overlay.dart

```dart
import 'dart:math';
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:tictactoe_gameapp/Pages/GamePage/Console/Bubble_Shooter/controllers/bubble_shooter_gameplay_controller.dart';

class ShootingPathOverlay extends StatelessWidget {
  final BubbleShooterController controller;

  const ShootingPathOverlay({super.key, required this.controller});

  @override
  Widget build(BuildContext context) {
    final gridHeight =
        MediaQuery.of(context).size.height * controller.gridHeightFactor;

    // Direct access to the observable list using .value
    return GetBuilder<BubbleShooterController>(
        id: 'path', // Optional: Use an ID to only rebuild when needed
        builder: (ctrl) {
          // Make sure we're accessing the actual observable value
          final points = ctrl.pathPoints;

          return CustomPaint(
            size: Size.infinite,
            painter: ShootingPathPainter(
              pathPoints: points,
              screenSize: MediaQuery.of(context).size,
              gridHeight: gridHeight,
            ),
          );
        });
  }
}

class ShootingPathPainter extends CustomPainter {
  final List<Offset> pathPoints;
  final Size screenSize;
  final double gridHeight;

  ShootingPathPainter({
    required this.pathPoints,
    required this.screenSize,
    required this.gridHeight,
  });

  @override
  void paint(Canvas canvas, Size size) {
    if (pathPoints.isEmpty) return;

    final path = Path();
    final dotPath = Path();
    const dotRadius = 2.5;

    // Tạo các điểm tuyệt đối trên đường đạn
    final absolutePoints = pathPoints
        .map((point) => Offset(
              point.dx * screenSize.width,
              point.dy * gridHeight,
            ))
        .toList();

    // Vẽ đường mũi tên
    path.moveTo(absolutePoints.first.dx, absolutePoints.first.dy);

    // Chỉ lấy một phần của đường đạn để làm đường nhắm
    final displayPoints = absolutePoints.length > 10
        ? absolutePoints.sublist(0, min(absolutePoints.length, 20))
        : absolutePoints;

    // Vẽ các chấm trên đường nhắm
    for (int i = 1; i < displayPoints.length; i += 4) {
      final point = displayPoints[i];
      dotPath.addOval(Rect.fromCircle(center: point, radius: dotRadius));
    }

    // Vẽ mũi tên ở đầu đường nhắm
    if (displayPoints.length > 5) {
      final lastPoint = displayPoints[displayPoints.length - 1];
      final secondLastPoint = displayPoints[displayPoints.length - 5];
      final angle = atan2(
        lastPoint.dy - secondLastPoint.dy,
        lastPoint.dx - secondLastPoint.dx,
      );

      // Vẽ mũi tên
      final arrowPath = Path();
      arrowPath.moveTo(lastPoint.dx, lastPoint.dy);
      arrowPath.lineTo(
        lastPoint.dx - 15 * cos(angle - 0.3),
        lastPoint.dy - 15 * sin(angle - 0.3),
      );
      arrowPath.moveTo(lastPoint.dx, lastPoint.dy);
      arrowPath.lineTo(
        lastPoint.dx - 15 * cos(angle + 0.3),
        lastPoint.dy - 15 * sin(angle + 0.3),
      );

      final arrowPaint = Paint()
        ..color = Colors.white.withOpacity(0.9)
        ..style = PaintingStyle.stroke
        ..strokeWidth = 2
        ..strokeCap = StrokeCap.round;

      canvas.drawPath(arrowPath, arrowPaint);
    }

    // Vẽ các chấm
    final dotPaint = Paint()
      ..color = Colors.white.withOpacity(0.8)
      ..style = PaintingStyle.fill;

    canvas.drawPath(dotPath, dotPaint);
  }

  @override
  bool shouldRepaint(covariant ShootingPathPainter oldDelegate) {
    return oldDelegate.pathPoints != pathPoints ||
        oldDelegate.screenSize != screenSize ||
        oldDelegate.gridHeight != gridHeight;
  }
}

```

---


### Pages\GamePage\Console\Bubble_Shooter\views\components\tutorial_overlay.dart

```dart

// Tutorial overlay
import 'package:flutter/material.dart';

class TutorialOverlay extends StatelessWidget {
  final VoidCallback onComplete;
  final int step;

  const TutorialOverlay({
    super.key,
    required this.onComplete,
    this.step = 0,
  });

  @override
  Widget build(BuildContext context) {
    // Tutorial steps
    final steps = [
      {
        'title': 'Welcome to Bubble Shooter!',
        'content': 'Match 3 or more same-colored bubbles to clear them.',
        'position': const Offset(0.5, 0.5), // Center
      },
      {
        'title': 'Aiming',
        'content': 'Drag to aim and release to shoot',
        'position': const Offset(0.5, 0.9), // Bottom center
      },
      {
        'title': 'Clear Bubbles',
        'content': 'Clear all bubbles to win the level',
        'position': const Offset(0.5, 0.3), // Top center
      },
      {
        'title': 'Watch Out!',
        'content': 'New rows will appear periodically',
        'position': const Offset(0.5, 0.1), // Top
      },
    ];

    if (step >= steps.length) {
      return const SizedBox.shrink();
    }

    final currentStep = steps[step];
    final position = currentStep['position'] as Offset;

    return GestureDetector(
      onTap: () {
        onComplete();
      },
      child: Container(
        color: Colors.black.withOpacity(0.7),
        child: Stack(
          children: [
            Positioned(
              left: position.dx * MediaQuery.of(context).size.width - 150,
              top: position.dy * MediaQuery.of(context).size.height - 100,
              child: Container(
                width: 300,
                padding: const EdgeInsets.all(16),
                decoration: BoxDecoration(
                  color: Colors.white,
                  borderRadius: BorderRadius.circular(12),
                  boxShadow: [
                    BoxShadow(
                      color: Colors.black.withOpacity(0.3),
                      blurRadius: 10,
                      spreadRadius: 2,
                    ),
                  ],
                ),
                child: Column(
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    Text(
                      currentStep['title'] as String,
                      style: const TextStyle(
                        fontFamily: 'Orbitron',
                        fontSize: 20,
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                    const SizedBox(height: 8),
                    Text(
                      currentStep['content'] as String,
                      textAlign: TextAlign.center,
                      style: const TextStyle(
                        fontSize: 16,
                      ),
                    ),
                    const SizedBox(height: 16),
                    Row(
                      mainAxisAlignment: MainAxisAlignment.center,
                      children: [
                        for (int i = 0; i < steps.length; i++)
                          Container(
                            width: i == step ? 12 : 8,
                            height: i == step ? 12 : 8,
                            margin: const EdgeInsets.symmetric(horizontal: 4),
                            decoration: BoxDecoration(
                              color: i == step ? Colors.blue : Colors.grey,
                              shape: BoxShape.circle,
                            ),
                          ),
                      ],
                    ),
                    const SizedBox(height: 16),
                    const Text(
                      'Tap to continue',
                      style: TextStyle(
                        fontStyle: FontStyle.italic,
                        color: Colors.grey,
                      ),
                    ),
                  ],
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }
}

```

---


### Pages\GamePage\Console\Bubble_Shooter\views\components\effects\ripple_effect.dart

```dart
import 'package:flutter/material.dart';

class RippleEffect extends StatelessWidget {
  final Offset center;
  final Color color;

  const RippleEffect({
    super.key,
    required this.center,
    required this.color,
  });

  @override
  Widget build(BuildContext context) {
    return TweenAnimationBuilder(
      tween: Tween<double>(begin: 0, end: 1),
      duration: const Duration(milliseconds: 500),
      builder: (context, value, child) {
        return Positioned(
          left: center.dx - 50 * value,
          top: center.dy - 50 * value,
          child: Opacity(
            opacity: 1 - value,
            child: Container(
              width: 100 * value,
              height: 100 * value,
              decoration: BoxDecoration(
                shape: BoxShape.circle,
                border: Border.all(
                  color: color.withOpacity(0.5),
                  width: 2,
                ),
              ),
            ),
          ),
        );
      },
    );
  }
}
```

---


### Pages\GamePage\Console\Bubble_Shooter\views\components\effects\trail_effect.dart

```dart
import 'package:flutter/material.dart';

class TrailEffect extends StatelessWidget {
  final List<Offset> trailPoints;
  final Color color;
  final double width;

  const TrailEffect({
    super.key,
    required this.trailPoints,
    required this.color,
    this.width = 2.0,
  });

  @override
  Widget build(BuildContext context) {
    return CustomPaint(
      painter: TrailPainter(
        trailPoints: trailPoints,
        color: color,
        width: width,
      ),
    );
  }
}

class TrailPainter extends CustomPainter {
  final List<Offset> trailPoints;
  final Color color;
  final double width;

  TrailPainter({
    required this.trailPoints,
    required this.color,
    required this.width,
  });

  @override
  void paint(Canvas canvas, Size size) {
    if (trailPoints.length < 2) return;

    final paint = Paint()
      ..color = color
      ..style = PaintingStyle.stroke
      ..strokeWidth = width
      ..strokeCap = StrokeCap.round;

    final path = Path();
    path.moveTo(trailPoints.first.dx, trailPoints.first.dy);

    for (int i = 1; i < trailPoints.length; i++) {
      path.lineTo(trailPoints[i].dx, trailPoints[i].dy);
    }

    canvas.drawPath(path, paint);
  }

  @override
  bool shouldRepaint(covariant TrailPainter oldDelegate) {
    return oldDelegate.trailPoints != trailPoints ||
        oldDelegate.color != color ||
        oldDelegate.width != width;
  }
}
```

---


### Pages\GamePage\Console\General_Widgets\gaming_button_custom.dart

```dart
import 'package:flutter/material.dart';

class GamingButton extends StatelessWidget {
  final String text;
  final VoidCallback onPressed;

  const GamingButton({super.key, required this.text, required this.onPressed});

  @override
  Widget build(BuildContext context) {
    return GestureDetector(
      onTap: onPressed,
      child: Container(
        margin: const EdgeInsets.all(10),
        decoration: BoxDecoration(
          gradient: const LinearGradient(
            colors: [Colors.purple, Colors.blue],
            begin: Alignment.topLeft,
            end: Alignment.bottomRight,
          ),
          boxShadow: [
            BoxShadow(
              color: Colors.black.withOpacity(0.4),
              offset: const Offset(4, 4),
              blurRadius: 6,
            ),
            BoxShadow(
              color: Colors.white.withOpacity(0.2),
              offset: const Offset(-4, -4),
              blurRadius: 6,
            ),
          ],
          borderRadius: BorderRadius.circular(15),
        ),
        child: Center(
          child: Padding(
            padding: const EdgeInsets.symmetric(vertical: 15, horizontal: 30),
            child: Text(
              text,
              style: TextStyle(
                color: Colors.white,
                fontSize: 20,
                fontWeight: FontWeight.bold,
                shadows: [
                  Shadow(
                    color: Colors.black.withOpacity(0.5),
                    offset: const Offset(2, 2),
                    blurRadius: 4,
                  ),
                ],
              ),
            ),
          ),
        ),
      ),
    );
  }
}

class GlowButton extends StatelessWidget {
  final String text;
  final VoidCallback onPressed;

  const GlowButton({super.key, required this.text, required this.onPressed});

  @override
  Widget build(BuildContext context) {
    return GestureDetector(
      onTap: onPressed,
      child: Container(
        decoration: BoxDecoration(
          borderRadius: BorderRadius.circular(12),
          gradient: const LinearGradient(
            colors: [Colors.deepOrange, Colors.yellow],
            begin: Alignment.topLeft,
            end: Alignment.bottomRight,
          ),
          boxShadow: [
            BoxShadow(
              color: Colors.orangeAccent.withOpacity(0.8),
              blurRadius: 20,
              spreadRadius: 1,
            ),
          ],
        ),
        child: Center(
          child: Padding(
            padding: const EdgeInsets.symmetric(vertical: 15, horizontal: 30),
            child: Text(
              text,
              style: const TextStyle(
                fontSize: 20,
                color: Colors.white,
                fontWeight: FontWeight.bold,
                shadows: [
                  Shadow(
                    color: Colors.yellowAccent,
                    blurRadius: 10,
                  ),
                ],
              ),
            ),
          ),
        ),
      ),
    );
  }
}

class AnimatedGamingButton extends StatefulWidget {
  final String text;
  final VoidCallback onPressed;

  const AnimatedGamingButton(
      {super.key, required this.text, required this.onPressed});

  @override
  State<AnimatedGamingButton> createState() => _AnimatedGamingButtonState();
}

class _AnimatedGamingButtonState extends State<AnimatedGamingButton>
    with SingleTickerProviderStateMixin {
  double scale = 1.0;

  @override
  Widget build(BuildContext context) {
    return GestureDetector(
      onTapDown: (_) => setState(() => scale = 0.9),
      onTapUp: (_) => setState(() => scale = 1.0),
      onTap: widget.onPressed,
      child: AnimatedScale(
        scale: scale,
        duration: const Duration(milliseconds: 100),
        child: Container(
          decoration: BoxDecoration(
            borderRadius: BorderRadius.circular(15),
            gradient: const LinearGradient(
              colors: [Colors.cyan, Colors.indigo],
              begin: Alignment.topLeft,
              end: Alignment.bottomRight,
            ),
            boxShadow: [
              BoxShadow(
                color: Colors.blueAccent.withOpacity(0.6),
                blurRadius: 15,
                offset: const Offset(0, 5),
              ),
            ],
          ),
          child: Center(
            child: Padding(
              padding: const EdgeInsets.symmetric(vertical: 15, horizontal: 30),
              child: Text(
                widget.text,
                style: const TextStyle(
                  fontSize: 20,
                  color: Colors.white,
                  fontWeight: FontWeight.bold,
                  shadows: [
                    Shadow(
                      color: Colors.indigoAccent,
                      blurRadius: 10,
                    ),
                  ],
                ),
              ),
            ),
          ),
        ),
      ),
    );
  }
}

class CircularGamingButton extends StatelessWidget {
  final IconData icon;
  final VoidCallback onPressed;

  const CircularGamingButton(
      {super.key, required this.icon, required this.onPressed});

  @override
  Widget build(BuildContext context) {
    return GestureDetector(
      onTap: onPressed,
      child: Container(
        padding: const EdgeInsets.all(10),
        decoration: BoxDecoration(
          shape: BoxShape.circle,
          gradient: const RadialGradient(
            colors: [Colors.red, Colors.deepPurple],
            center: Alignment.center,
            radius: 0.9,
          ),
          boxShadow: [
            BoxShadow(
              color: Colors.redAccent.withOpacity(0.7),
              blurRadius: 15,
              offset: const Offset(0, 5),
            ),
          ],
        ),
        child: Center(
          child: Icon(
            icon,
            size: 30,
            color: Colors.white,
          ),
        ),
      ),
    );
  }
}

class GamingButtonStack extends StatelessWidget {
  final String text;
  final VoidCallback onPressed;

  const GamingButtonStack({
    super.key,
    required this.text,
    required this.onPressed,
  });

  @override
  Widget build(BuildContext context) {
    return GestureDetector(
      onTap: onPressed,
      child: Stack(
        children: [
          // Shadow Layer (đặt bên dưới nút chính)
          Container(
            margin: const EdgeInsets.only(top: 8, left: 8),
            width: 200,
            height: 60,
            decoration: BoxDecoration(
              color: Colors.black.withOpacity(0.8),
              borderRadius: BorderRadius.circular(12),
            ),
          ),
          // Main Button (Container chính)
          Container(
            width: 200,
            height: 60,
            decoration: BoxDecoration(
              gradient: const LinearGradient(
                colors: [Colors.purple, Colors.blue],
                begin: Alignment.topLeft,
                end: Alignment.bottomRight,
              ),
              borderRadius: BorderRadius.circular(12),
              boxShadow: [
                BoxShadow(
                  color: Colors.purple.withOpacity(0.4),
                  blurRadius: 15,
                  spreadRadius: 1,
                  offset: const Offset(0, 5),
                ),
              ],
            ),
            alignment: Alignment.center,
            child: Text(
              text,
              style: TextStyle(
                color: Colors.white,
                fontWeight: FontWeight.bold,
                fontSize: 18,
                shadows: [
                  Shadow(
                    color: Colors.black.withOpacity(0.5),
                    blurRadius: 5,
                  ),
                ],
              ),
            ),
          ),
        ],
      ),
    );
  }
}

```

---


### Pages\GamePage\Console\General_Widgets\gaming_dialogs.dart

```dart
import 'package:flutter/material.dart';
import 'package:get/get.dart';

Future<bool> showExitConfirmationDialog() async {
  final result = await Get.dialog<bool>(
    AlertDialog(
      title: const Text('Thoát Game'),
      content: const Text('Bạn có chắc muốn thoát game đang chơi không?'),
      actions: [
        TextButton(
          onPressed: () => Get.back(result: false),
          child: const Text('Tiếp tục chơi'),
        ),
        TextButton(
          onPressed: () => Get.back(result: true),
          child: const Text('Thoát'),
        ),
      ],
    ),
    barrierDismissible: false,
  );
  return result ?? false;
}
```

---


### Pages\GamePage\Console\HeroMerge_Game\hero_merge_controller.dart

```dart
import 'dart:async';
import 'dart:math';
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:tictactoe_gameapp/Configs/constants.dart';
import 'package:tictactoe_gameapp/Data/fetch_firestore_database.dart';

class HeroMergeController extends GetxController {
  Rx<GameBoardModel> gameBoard =
      Rx<GameBoardModel>(GameBoardModel(rows: 0, columns: 0));
  RxInt score = 0.obs;
  Rx<BlockModel?> nextBlock = Rx<BlockModel?>(null); // Hero đang rơi
  Rx<BlockModel?> upcomingBlock =
      Rx<BlockModel?>(null); // Hero kế tiếp (preview)
  RxInt currentColumn = 0.obs;
  RxDouble blockPositionY = 0.0.obs;
  List<Map<String, dynamic>> previousState = [];
  RxBool isDragging = false.obs;
  RxBool isPaused = false.obs;
  Timer? dropTimer;
  Map<int, String> numberToHero = {};

  late int rows;
  late int columns;
  late int level;
  double containerHeight = 500.0;

  final FirestoreController firestoreController =
      Get.find<FirestoreController>();

  final Map<int, double> levelSpeeds = {
    1: 2.0,
    2: 4.0,
    3: 6.0,
    4: 8.0,
    5: 10.0,
  };

  final Map<int, List<int>> levelToValues = {
    1: [2, 4, 8, 16],
    2: [2, 4, 8, 16, 32],
    3: [2, 4, 8, 16, 32, 64],
    4: [2, 4, 8, 16, 32, 64, 128],
    5: [2, 4, 8, 16, 32, 64, 128, 256],
  };

  HeroMergeController({
    required this.rows,
    required this.columns,
    required this.level,
  }) {
    rows = rows.clamp(3, 10);
    columns = columns.clamp(3, 7);
    level = level.clamp(1, 5);
    _initializeHeroMapping();
    _initializeGame();
  }

  void _initializeHeroMapping() {
    numberToHero.clear();
    final random = Random();
    List<String> shuffledHeroes = List.from(listChampions)..shuffle(random);
    List<int> values = levelToValues[level]!;

    for (int i = 0; i < values.length; i++) {
      if (i < shuffledHeroes.length) {
        numberToHero[values[i]] = shuffledHeroes[i];
      } else {
        numberToHero[values[i]] =
            listChampions[random.nextInt(listChampions.length)];
      }
    }
    print("Initialized hero mapping for level $level: $numberToHero");
  }

  String getHeroForValue(int value) {
    if (!numberToHero.containsKey(value)) {
      final random = Random();
      numberToHero[value] = listChampions[random.nextInt(listChampions.length)];
      print(
          "Unexpected value $value not mapped, assigned random hero: ${numberToHero[value]}");
    }
    return numberToHero[value]!;
  }

  void _initializeGame() {
    dropTimer?.cancel();
    gameBoard.value = GameBoardModel(rows: rows, columns: columns);
    currentColumn.value = columns ~/ 2;
    score.value = 0;
    previousState.clear();
    nextBlock.value = null;
    upcomingBlock.value = null;
    isDragging.value = false;
    isPaused.value = false;
    blockPositionY.value = 0.0;
    _generateInitialBlocks();
  }

  void _generateInitialBlocks() {
    List<int> values = levelToValues[level]!;
    int nextValue = values[Random().nextInt(values.length)];
    int upcomingValue = values[Random().nextInt(values.length)];
    nextBlock.value =
        BlockModel(value: nextValue, hero: getHeroForValue(nextValue));
    upcomingBlock.value =
        BlockModel(value: upcomingValue, hero: getHeroForValue(upcomingValue));
    blockPositionY.value = 0.0;
    currentColumn.value = columns ~/ 2;
    isDragging.value = false;
    print(
        "Generated initial blocks - Next: ${nextBlock.value!.value}, ${nextBlock.value!.hero} | Upcoming: ${upcomingBlock.value!.value}, ${upcomingBlock.value!.hero}");
  }

  void _generateNextBlock() {
    nextBlock.value = upcomingBlock.value;
    List<int> values = levelToValues[level]!;
    int value = values[Random().nextInt(values.length)];
    upcomingBlock.value =
        BlockModel(value: value, hero: getHeroForValue(value));
    blockPositionY.value = 0.0;
    currentColumn.value = columns ~/ 2;
    isDragging.value = false;
    print(
        "Generated next block - Next: ${nextBlock.value!.value}, ${nextBlock.value!.hero} | Upcoming: ${upcomingBlock.value!.value}, ${upcomingBlock.value!.hero}");
  }

  void _startBlockDrop() {
    dropTimer?.cancel();
    double speed = levelSpeeds[level] ?? 2.0;
    dropTimer = Timer.periodic(const Duration(milliseconds: 50), (timer) {
      if (!isDragging.value && !isPaused.value) {
        blockPositionY.value += speed;
        if (blockPositionY.value >= containerHeight - 70) {
          _placeBlock();
          timer.cancel();
        }
      }
    });
  }

  void dragBlock(int newColumn) {
    if (newColumn >= 0 && newColumn < columns) {
      currentColumn.value = newColumn;
      isDragging.value = true;
    }
  }

  void releaseBlock() {
    isDragging.value = false;
    _placeBlock();
  }

  void tapToDrop(int columnIndex) {
    currentColumn.value = columnIndex;
    blockPositionY.value = containerHeight - 70;
    _placeBlock();
  }

  void _placeBlock() {
    savePreviousState();
    int col = currentColumn.value;
    int targetRow = -1;

    for (int row = 0; row < rows; row++) {
      if (gameBoard.value.grid[row][col].value == null) {
        targetRow = row;
        break;
      }
    }

    if (targetRow != -1) {
      gameBoard.value.grid[targetRow][col].value = nextBlock.value;
      _mergeColumn(col);
      gameBoard.refresh();
      _generateNextBlock();
      _startBlockDrop();
    } else if (isGameOver()) {
      _addCoinsOnGameOver();
      _showGameOverDialog();
    }
  }

  void _mergeColumn(int col) {
    bool hasMerged;
    do {
      hasMerged = false;
      List<BlockModel?> tempColumn =
          List.from(gameBoard.value.grid.map((row) => row[col].value));
      int writePos = 0;

      for (int readPos = 0; readPos < rows; readPos++) {
        if (tempColumn[readPos] == null) continue;

        if (writePos > 0 &&
            tempColumn[writePos - 1] != null &&
            tempColumn[writePos - 1]!.value == tempColumn[readPos]!.value &&
            tempColumn[writePos - 1]!.hero == tempColumn[readPos]!.hero) {
          // Kiểm tra cả hero
          tempColumn[writePos - 1]!.value *= 2;
          tempColumn[writePos - 1]!.mergeCount = max(
                  tempColumn[writePos - 1]!.mergeCount,
                  tempColumn[readPos]!.mergeCount) +
              1;
          score.value += tempColumn[writePos - 1]!.value;
          hasMerged = true;
          tempColumn[readPos] = null;
          print(
              "Merged blocks: [${tempColumn[writePos - 1]!.value},${tempColumn[writePos - 1]!.mergeCount},${tempColumn[writePos - 1]!.hero}]");
        } else {
          tempColumn[writePos] = tempColumn[readPos];
          writePos++;
        }
      }

      for (int row = 0; row < rows; row++) {
        gameBoard.value.grid[row][col].value =
            row < writePos ? tempColumn[row] : null;
      }
      print(
          "Merged column $col: ${tempColumn.map((b) => b != null ? '${b.value},${b.mergeCount},${b.hero}' : 'null').toList()}");
    } while (hasMerged);
  }

  bool isGameOver() {
    for (int col = 0; col < columns; col++) {
      if (gameBoard.value.grid[rows - 1][col].value != null) return true;
    }
    return false;
  }

  void _addCoinsOnGameOver() async {
    int coinsEarned = (score.value ~/ 100) * 10;
    await firestoreController.incrementCoinsAndWins(coinsEarned);
  }

  void _showGameOverDialog() {
    int coinsEarned = (score.value ~/ 100) * 10;
    Get.defaultDialog(
      barrierDismissible: false,
      title: "Game Over",
      titleStyle: const TextStyle(
          fontSize: 30, fontWeight: FontWeight.bold, color: Colors.red),
      content: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          const Text("No more moves!", style: TextStyle(fontSize: 18)),
          Text("Score: ${score.value}", style: const TextStyle(fontSize: 16)),
          Text("Coins Earned: $coinsEarned",
              style: const TextStyle(fontSize: 16, color: Colors.green)),
          const SizedBox(height: 20),
          Row(
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            children: [
              ElevatedButton(
                onPressed: () {
                  refreshGame();
                  Get.back();
                },
                child: const Text("Play Again"),
              ),
              ElevatedButton(
                onPressed: () => Get.offAllNamed("/mainHome"),
                child: const Text("Exit"),
              ),
            ],
          ),
        ],
      ),
    );
  }

  void savePreviousState() {
    previousState.add({
      'gameBoard': Rx<GameBoardModel>(GameBoardModel.clone(gameBoard.value)),
      'nextBlock':
          nextBlock.value != null ? BlockModel.clone(nextBlock.value!) : null,
      'upcomingBlock': upcomingBlock.value != null
          ? BlockModel.clone(upcomingBlock.value!)
          : null,
      'blockPositionY': blockPositionY.value,
      'score': score.value,
    });
    if (previousState.length > 1) previousState.removeAt(0);
  }

  void undoMove() {
    if (previousState.isNotEmpty && !isPaused.value) {
      dropTimer?.cancel();
      var lastState = previousState.last;
      for (int row = 0; row < rows; row++) {
        for (int col = 0; col < columns; col++) {
          gameBoard.value.grid[row][col].value =
              lastState['gameBoard'].value.grid[row][col].value != null
                  ? BlockModel.clone(
                      lastState['gameBoard'].value.grid[row][col].value!)
                  : null;
        }
      }
      nextBlock.value = lastState['nextBlock'] != null
          ? BlockModel.clone(lastState['nextBlock'])
          : null;
      upcomingBlock.value = lastState['upcomingBlock'] != null
          ? BlockModel.clone(lastState['upcomingBlock'])
          : null;
      blockPositionY.value = lastState['blockPositionY'];
      score.value = lastState['score'];
      previousState.removeLast();
      gameBoard.refresh();
      _startBlockDrop();
    }
  }

  void togglePause() {
    isPaused.value = !isPaused.value;
    if (isPaused.value) {
      dropTimer?.cancel();
      Get.dialog(
        AlertDialog(
          title: const Text("Paused",
              style: TextStyle(fontSize: 24, fontWeight: FontWeight.bold)),
          content: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              ElevatedButton(
                onPressed: () {
                  Get.back();
                  togglePause();
                },
                child: const Text("Resume"),
              ),
              ElevatedButton(
                onPressed: () {
                  Get.back();
                  refreshGame();
                },
                child: const Text("Restart"),
              ),
              ElevatedButton(
                onPressed: () => Get.offAllNamed("/mainHome"),
                child: const Text("Exit"),
              ),
            ],
          ),
        ),
        barrierDismissible: false,
      );
    } else {
      _startBlockDrop();
    }
  }

  void refreshGame() {
    dropTimer?.cancel();
    _initializeHeroMapping();
    _initializeGame();
    gameBoard.refresh();
    nextBlock.refresh();
    upcomingBlock.refresh();
    blockPositionY.value = 0.0;
    Future.microtask(() {
      _startBlockDrop();
      print(
          "RefreshGame: Animation started, blockPositionY=${blockPositionY.value}");
    });
  }

  @override
  void onInit() {
    super.onInit();
    Future.microtask(() => _startBlockDrop());
  }

  @override
  void onClose() {
    dropTimer?.cancel();
    super.onClose();
  }
}

class BlockModel {
  int value;
  int mergeCount;
  String hero;

  BlockModel({required this.value, this.mergeCount = 0, required this.hero});

  BlockModel.clone(BlockModel other)
      : value = other.value,
        mergeCount = other.mergeCount,
        hero = other.hero;
}

class GameBoardModel {
  List<List<Rx<BlockModel?>>> grid;
  int rows;
  int columns;

  GameBoardModel({required this.rows, required this.columns})
      : grid = List.generate(
            rows, (_) => List.generate(columns, (_) => Rx<BlockModel?>(null)));

  GameBoardModel.clone(GameBoardModel other)
      : rows = other.rows,
        columns = other.columns,
        grid = other.grid
            .map((row) => row
                .map((block) => block.value != null
                    ? Rx<BlockModel?>(BlockModel.clone(block.value!))
                    : Rx<BlockModel?>(null))
                .toList())
            .toList();
}

```

---


### Pages\GamePage\Console\HeroMerge_Game\hero_merge_gamelobby_page.dart

```dart
import 'package:cyber_punk_tool_kit_ui/cyber_punk_tool_kit_ui.dart';
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:tictactoe_gameapp/Configs/assets_path.dart';
// ignore: implementation_imports
import 'package:cyber_punk_tool_kit_ui/src/containers/cyber_container_two.dart';
import 'package:tictactoe_gameapp/Pages/GamePage/Console/HeroMerge_Game/hero_merge_gameplay_page.dart';

class HeroMergeGamelobbyPage extends StatelessWidget {
  const HeroMergeGamelobbyPage({super.key});

  @override
  Widget build(BuildContext context) {
    Rxn<int> selectedLevel = Rxn<int>();
    RxnInt selectedMode = RxnInt();
    RxnString selectedImageIndex = RxnString();
    final List<String> imagePaths = [
      GifsPath.chloe1,
      GifsPath.chatbotGif,
      GifsPath.lightGif,
      GifsPath.cyberpunk,
      GifsPath.transitionGif,
    ];
    const TextStyle textStyle = TextStyle(
      color: Colors.black,
      fontFamily: "Orbitron",
      fontWeight: FontWeight.w600,
      fontSize: 20,
    );
    final Map<String, int> levelMapping = {
      'Easy': 1,
      'Medium': 2,
      'Hard': 3,
      'Expert': 4,
      'Legendary': 5,
    };
    final List<String> levels = levelMapping.keys.toList();
    final List<Map<String, dynamic>> boardConfigs = [
      {'mode': 'Small', 'size': '5x5', 'rows': 5, 'columns': 5},
      {'mode': 'Medium', 'size': '6x5', 'rows': 6, 'columns': 5},
      {'mode': 'Large', 'size': '7x5', 'rows': 7, 'columns': 5},
      {'mode': 'Extra Large', 'size': '8x6', 'rows': 8, 'columns': 6},
      {'mode': 'Epic', 'size': '10x7', 'rows': 10, 'columns': 7},
    ];
    return Scaffold(
      // appBar: AppBar(title: const Text('Sudoku Lobby', style: textStyle)),
      body: Stack(
        children: [
          CyberContainerTwo(
            width: MediaQuery.sizeOf(context).width,
            height: MediaQuery.sizeOf(context).height,
            child: SingleChildScrollView(
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  CyberContainerOne(
                    horizontalPadding: 50,
                    bottomPadding: 40,
                    child: Obx(() => DecoratedBox(
                          decoration: BoxDecoration(
                            image: DecorationImage(
                              fit: BoxFit.fill,
                              image: AssetImage(selectedImageIndex.value ??
                                  GifsPath.cyberpunk),
                            ),
                          ),
                        )),
                  ),
                  const SizedBox(
                    height: 20,
                  ),
                  const Text('Select Level', style: textStyle),
                  SingleChildScrollView(
                    scrollDirection: Axis.horizontal,
                    child: Row(
                      mainAxisAlignment: MainAxisAlignment.center,
                      children: levels.map((levelName) {
                        return InkWell(
                          splashColor: Colors.blueAccent,
                          borderRadius: BorderRadius.circular(10),
                          onTap: () =>
                              selectedLevel.value = levelMapping[levelName],
                          child: Obx(() => Container(
                                padding: const EdgeInsets.all(10),
                                margin: const EdgeInsets.all(10),
                                decoration: selectedLevel.value != null &&
                                        selectedLevel.value ==
                                            levelMapping[levelName]
                                    ? BoxDecoration(
                                        color: Colors.white,
                                        borderRadius: BorderRadius.circular(10),
                                        border: Border.all(
                                            color: Colors.blueAccent, width: 5),
                                      )
                                    : BoxDecoration(
                                        color: Colors.grey,
                                        borderRadius: BorderRadius.circular(10),
                                        border: Border.all(
                                            color: Colors.white, width: 3),
                                      ),
                                child: Text(
                                  levelName,
                                  style: const TextStyle(
                                    color: Colors.black,
                                    fontFamily: "Orbitron",
                                    fontWeight: FontWeight.w600,
                                    fontSize: 15,
                                  ),
                                ),
                              )),
                        );
                      }).toList(),
                    ),
                  ),
                  const SizedBox(height: 20),
                  const Text('Select Board Size', style: textStyle),
                  SingleChildScrollView(
                    scrollDirection: Axis.horizontal,
                    child: Row(
                      mainAxisAlignment: MainAxisAlignment.center,
                      children: boardConfigs.map((config) {
                        return InkWell(
                          splashColor: Colors.blueAccent,
                          borderRadius: BorderRadius.circular(10),
                          onTap: () =>
                              selectedMode.value = boardConfigs.indexOf(config),
                          child: Obx(() => Container(
                                padding: const EdgeInsets.all(10),
                                margin: const EdgeInsets.all(10),
                                decoration: selectedMode.value != null &&
                                        selectedMode.value ==
                                            boardConfigs.indexOf(config)
                                    ? BoxDecoration(
                                        color: Colors.white,
                                        borderRadius: BorderRadius.circular(10),
                                        border: Border.all(
                                            color: Colors.blueAccent, width: 5),
                                      )
                                    : BoxDecoration(
                                        color: Colors.grey,
                                        borderRadius: BorderRadius.circular(10),
                                        border: Border.all(
                                            color: Colors.white, width: 3),
                                      ),
                                child: Text(
                                  config["size"],
                                  style: const TextStyle(
                                    color: Colors.black,
                                    fontFamily: "Orbitron",
                                    fontWeight: FontWeight.w600,
                                    fontSize: 15,
                                  ),
                                ),
                              )),
                        );
                      }).toList(),
                    ),
                  ),
                  const SizedBox(height: 20),
                  const Text('Select A Map', style: textStyle),
                  SizedBox(
                    height: 100,
                    child: SingleChildScrollView(
                      scrollDirection: Axis.horizontal,
                      child: Row(
                        children: List.generate(imagePaths.length, (index) {
                          return GestureDetector(
                            onTap: () =>
                                selectedImageIndex.value = imagePaths[index],
                            child: Obx(() {
                              return Container(
                                margin:
                                    const EdgeInsets.symmetric(horizontal: 10),
                                decoration: BoxDecoration(
                                  border: Border.all(
                                    color: selectedImageIndex.value != null &&
                                            selectedImageIndex.value ==
                                                imagePaths[index]
                                        ? Colors.blue
                                        : Colors.white,
                                    width: 5,
                                  ),
                                ),
                                child: Image.asset(
                                  imagePaths[index],
                                  width: 100,
                                  height: 100,
                                  fit: BoxFit.cover,
                                ),
                              );
                            }),
                          );
                        }),
                      ),
                    ),
                  ),
                  const SizedBox(height: 20),
                  Obx(() => selectedMode.value != null &&
                          selectedLevel.value != null &&
                          selectedImageIndex.value != null
                      ? InkWell(
                          onTap: () => Get.to(
                              () => HeroMergeGameplayPage(
                                    rows: boardConfigs[selectedMode.value!]
                                        ["rows"],
                                    columns: boardConfigs[selectedMode.value!]
                                        ["columns"],
                                    level: selectedLevel.value!,
                                    backgroundUrl: selectedImageIndex.value!,
                                  ),
                              transition: Transition.zoom),
                          child: Ink(
                            height: 50,
                            width: 100,
                            decoration: BoxDecoration(
                              color: Colors.blueAccent,
                              borderRadius: BorderRadius.circular(10),
                            ),
                            child: const Center(
                              child: Text(
                                "PLAY",
                                style: textStyle,
                              ),
                            ),
                          ),
                        )
                      : Ink(
                          height: 50,
                          width: 100,
                          decoration: BoxDecoration(
                            color: const Color.fromARGB(255, 12, 5, 5),
                            borderRadius: BorderRadius.circular(10),
                          ),
                          child: const Center(
                            child: Text("PLAY", style: textStyle),
                          ),
                        ))
                ],
              ),
            ),
          ),
          Positioned(
            top: 10,
            right: 10,
            child: CyberButton(
              onTap: () {},
              width: 100,
              height: 50,
              primaryColorBigContainer: Colors.redAccent,
              secondaryColorBigContainer: Colors.yellowAccent,
              child: const Text(
                'Menu',
                style: TextStyle(
                  color: Colors.white,
                  fontFamily: "Orbitron",
                  fontWeight: FontWeight.w400,
                ),
              ),
            ),
          ),
          Positioned(
            top: 10,
            left: 10,
            child: CyberButton(
              onTap: () {
                Get.back();
              },
              width: 100,
              height: 50,
              primaryColorBigContainer: Colors.redAccent,
              secondaryColorBigContainer: Colors.yellowAccent,
              child: const Text(
                'Back',
                style: TextStyle(
                  color: Colors.white,
                  fontFamily: "Orbitron",
                  fontWeight: FontWeight.w400,
                ),
              ),
            ),
          )
        ],
      ),
    );
  }
}

```

---


### Pages\GamePage\Console\HeroMerge_Game\hero_merge_gameplay_page.dart

```dart
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:tictactoe_gameapp/Pages/GamePage/Console/HeroMerge_Game/hero_merge_controller.dart';

class HeroMergeGameplayPage extends StatelessWidget {
  final int rows;
  final int columns;
  final int level;
  final String backgroundUrl;

  const HeroMergeGameplayPage({
    super.key,
    required this.rows,
    required this.columns,
    required this.level,
    required this.backgroundUrl,
  });

  @override
  Widget build(BuildContext context) {
    final controller = Get.put(
        HeroMergeController(rows: rows, columns: columns, level: level));
    const TextStyle textStyle = TextStyle(
      color: Colors.black,
      fontFamily: "Orbitron",
      fontWeight: FontWeight.bold,
      fontSize: 20,
    );

    return Scaffold(
      appBar: AppBar(
        leading: IconButton(
          onPressed: () => Get.back(),
          icon: const Icon(Icons.arrow_back_ios_new_rounded,
              size: 30, color: Colors.blue),
        ),
        title: Column(
          children: [
            const Text("Hero Merge", style: textStyle),
            Obx(() => Text("Score: ${controller.score.value}",
                style: textStyle.copyWith(fontSize: 15))),
          ],
        ),
        actions: [
          IconButton(
            icon: const Icon(Icons.rotate_left_rounded,
                size: 30, color: Colors.white),
            onPressed: controller.undoMove,
          ),
          IconButton(
            icon: const Icon(Icons.refresh_rounded,
                size: 30, color: Colors.white),
            onPressed: controller.refreshGame,
          ),
          IconButton(
            icon: Obx(() => Icon(
                  controller.isPaused.value
                      ? Icons.play_arrow_rounded
                      : Icons.pause_rounded,
                  size: 30,
                  color: Colors.white,
                )),
            onPressed: controller.togglePause,
          ),
        ],
      ),
      body: Column(
        children: [
          Container(
            height: 500,
            width: double.infinity,
            decoration: BoxDecoration(
              color: Colors.blueGrey,
              borderRadius: BorderRadius.circular(10),
            ),
            child: Stack(
              children: [
                Obx(() => Row(
                      children: List.generate(controller.columns, (col) {
                        return Expanded(
                          child: GestureDetector(
                            onTap: () => controller.tapToDrop(col),
                            child: Container(
                              decoration: BoxDecoration(
                                border:
                                    Border.all(color: Colors.black, width: 2),
                                color: Colors.grey[200],
                              ),
                              child: Stack(
                                children: List.generate(controller.rows, (row) {
                                  final block = controller
                                      .gameBoard.value.grid[row][col].value;
                                  final blockHeight = 500 / controller.rows;
                                  final blockWidth =
                                      MediaQuery.of(context).size.width /
                                          controller.columns;
                                  return Positioned(
                                    top: (controller.rows - 1 - row) *
                                        blockHeight,
                                    child: Container(
                                      height: blockHeight,
                                      width: blockWidth,
                                      decoration: BoxDecoration(
                                        border: Border.all(
                                            color: Colors.black, width: 2),
                                      ),
                                      child: block != null
                                          ? AnimatedContainer(
                                              duration: const Duration(
                                                  milliseconds: 300),
                                              curve: Curves.easeInOut,
                                              transform: Matrix4.identity()
                                                ..scale(block.mergeCount > 0
                                                    ? 1.1
                                                    : 1.0),
                                              decoration: BoxDecoration(
                                                border: Border.all(
                                                  color: block.mergeCount > 0
                                                      ? Colors.yellow
                                                      : Colors.black,
                                                  width: block.mergeCount > 0
                                                      ? 4
                                                      : 2,
                                                ),
                                              ),
                                              child: Stack(
                                                children: [
                                                  Image.asset(
                                                    block.hero,
                                                    fit: BoxFit.cover,
                                                    width: blockWidth,
                                                    height: blockHeight,
                                                    key: ValueKey(
                                                        "${row}_${col}_${block.value}_${block.mergeCount}"),
                                                  ),
                                                  if (block.mergeCount > 0)
                                                    Positioned(
                                                      top: 2,
                                                      right: 2,
                                                      child: Container(
                                                        padding:
                                                            const EdgeInsets
                                                                .all(4),
                                                        decoration:
                                                            const BoxDecoration(
                                                          color: Colors.red,
                                                          shape:
                                                              BoxShape.circle,
                                                        ),
                                                        child: Text(
                                                          "${block.mergeCount}",
                                                          style:
                                                              const TextStyle(
                                                                  color: Colors
                                                                      .white,
                                                                  fontSize: 12),
                                                        ),
                                                      ),
                                                    ),
                                                ],
                                              ),
                                            )
                                          : const SizedBox.shrink(),
                                    ),
                                  );
                                }),
                              ),
                            ),
                          ),
                        );
                      }),
                    )),
                Obx(() {
                  final blockHeight = 500 / controller.rows;
                  final blockWidth =
                      MediaQuery.of(context).size.width / controller.columns;
                  return AnimatedPositioned(
                    duration: const Duration(milliseconds: 50),
                    curve: Curves.linear,
                    top: controller.blockPositionY.value,
                    left: blockWidth * controller.currentColumn.value,
                    child: GestureDetector(
                      onHorizontalDragUpdate: (details) {
                        int newColumn =
                            (details.globalPosition.dx / blockWidth).floor();
                        controller.dragBlock(newColumn);
                      },
                      onHorizontalDragEnd: (_) => controller.releaseBlock(),
                      child: Container(
                        height: blockHeight,
                        width: blockWidth,
                        decoration: BoxDecoration(
                          border: Border.all(color: Colors.black, width: 2),
                        ),
                        child: controller.nextBlock.value != null
                            ? Image.asset(
                                controller.nextBlock.value!.hero,
                                fit: BoxFit.cover,
                                width: blockWidth,
                                height: blockHeight,
                                key: ValueKey(
                                    "next_${controller.nextBlock.value!.value}_${controller.nextBlock.value!.hero}"),
                              )
                            : const SizedBox.shrink(),
                      ),
                    ),
                  );
                }),
              ],
            ),
          ),
          Obx(() => Padding(
                padding: const EdgeInsets.all(8.0),
                child: Row(
                  mainAxisAlignment: MainAxisAlignment.center,
                  children: [
                    const Text("Next: ", style: textStyle),
                    controller.upcomingBlock.value !=
                            null // Hiển thị upcomingBlock thay vì nextBlock
                        ? Image.asset(
                            controller.upcomingBlock.value!.hero,
                            width: 50,
                            height: 50,
                            fit: BoxFit.cover,
                            key: ValueKey(
                                "preview_${controller.upcomingBlock.value!.value}_${controller.upcomingBlock.value!.hero}"),
                          )
                        : const SizedBox.shrink(),
                  ],
                ),
              )),
        ],
      ),
    );
  }
}

```

---


### Pages\GamePage\Console\Match3_Game\match3_gameplay_controller.dart

```dart
import 'dart:math';
import 'package:confetti/confetti.dart';
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:tictactoe_gameapp/Configs/constants.dart';

class Match3Controller extends GetxController with GetTickerProviderStateMixin {
  late int gridSize;
  late RxList<RxList<RxInt>> grid;
  late List<String> activeHeroes;
  final RxInt score = 0.obs;
  late RxBool isAnimating = false.obs;
  RxMap<String, int> selectedItem = RxMap<String, int>();
  late String difficultyLevel;
  late final ConfettiController confettiController;

  late AnimationController animationController;

  var progressColor = Colors.blue.obs;
  final int durationPlay;
  RxInt timeLeft = 95.obs;

  Match3Controller({
    required this.gridSize,
    required this.difficultyLevel,
    required this.durationPlay,
  });

  @override
  void onInit() {
    super.onInit();
    initializeHeroes();
    initializeGrid();
    confettiController =
        ConfettiController(duration: const Duration(seconds: 5));

    animationController = AnimationController(
      vsync: this,
      duration: Duration(seconds: durationPlay),
    );
    listenerCountdown();
    animationController.forward();
  }

  @override
  void onClose() {
    confettiController.dispose();
    animationController.dispose();
    super.onClose();
  }

  void listenerCountdown() {
    // Đăng ký listener để cập nhật timeLeft dựa trên animationController
    animationController.addListener(() {
      // Cập nhật timeLeft dựa trên tiến trình animation
      timeLeft.value =
          (durationPlay - animationController.value * durationPlay).round();

      // Thay đổi màu viền dựa trên thời gian còn lại
      if (timeLeft.value <= durationPlay / 3 || timeLeft.value == 0) {
        progressColor.value = Colors.red; // Dưới 30 giây: Màu đỏ
      } else if (timeLeft.value <= durationPlay / 2) {
        progressColor.value = Colors.orange; // Dưới 60 giây: Màu vàng
      } else {
        progressColor.value = Colors.blue; // Trên 60 giây: Màu xanh
      }

      // Kiểm tra nếu hết thời gian thì dừng animation
      if (animationController.isCompleted) {
        animationController.stop();
      }
    });
  }

  // Tạo danh sách hero
  void initializeHeroes() {
    int heroCount = _getHeroCountByLevel();
    if (heroCount > listChampions.length) return;

    // Copy danh sách các hero để tránh ảnh hưởng tới danh sách gốc
    List<String> allHeroes = List.from(listChampions);

    // Xáo trộn danh sách
    allHeroes.shuffle();

    // Lấy heroCount phần tử đầu tiên
    activeHeroes = allHeroes.sublist(0, heroCount);
  }

  int _getHeroCountByLevel() {
    switch (difficultyLevel) {
      case 'Easy':
        return max(3, gridSize ~/ 2);
      case 'Medium':
        return max(5, gridSize ~/ 2 + 2);
      case 'Hard':
        return max(7, gridSize ~/ 2 + 4);
      case 'Expert':
        return max(9, gridSize ~/ 2 + 6);
      default:
        return 5;
    }
  }

  // Khởi tạo lưới ban đầu
  void initializeGrid() {
    grid = List.generate(
      gridSize,
      (i) => List.generate(gridSize, (j) => 0.obs).obs,
    ).obs;

    for (int i = 0; i < gridSize; i++) {
      for (int j = 0; j < gridSize; j++) {
        do {
          grid[i][j].value = Random().nextInt(activeHeroes.length);
        } while (_isPartOfMatch(i, j));
      }
    }
  }

  // Kiểm tra chuỗi hợp lệ
  bool _isPartOfMatch(int x, int y) {
    return _isMatchInDirection(x, y, dx: 1, dy: 0) ||
        _isMatchInDirection(x, y, dx: 0, dy: 1);
  }

  bool _isMatchInDirection(int x, int y, {required int dx, required int dy}) {
    int value = grid[x][y].value;
    int count = 1;

    for (int step = 1; step < 3; step++) {
      int nx = x - dx * step;
      int ny = y - dy * step;

      if (nx < 0 || ny < 0 || nx >= gridSize || ny >= gridSize) break;
      if (grid[nx][ny].value == value) {
        count++;
      } else {
        break;
      }
    }

    return count >= 3;
  }

  // Set ô được chọn
  void setSelectedItem(int x, int y) {
    if (isAnimating.value) return;
    selectedItem.value = {'x': x, 'y': y};
  }

  // Xử lý thả ô
  void handleDrop(int x, int y) {
    if (isAnimating.value || selectedItem.isEmpty) return;

    int x1 = selectedItem['x']!;
    int y1 = selectedItem['y']!;

    if ((x1 == x && (y1 - y).abs() == 1) || (y1 == y && (x1 - x).abs() == 1)) {
      _swap(x1, y1, x, y);

      if (_checkMatches()) {
        _findAndDestroyMatches();
      } else {
        _swap(x1, y1, x, y); // Hoàn tác nếu không hợp lệ
      }
    }

    selectedItem.clear();
  }

  void _swap(int x1, int y1, int x2, int y2) {
    final temp = grid[x1][y1].value;
    grid[x1][y1].value = grid[x2][y2].value;
    grid[x2][y2].value = temp;
  }

  // Kiểm tra các chuỗi hợp lệ
  bool _checkMatches() {
    for (int i = 0; i < gridSize; i++) {
      for (int j = 0; j < gridSize; j++) {
        if (_isPartOfMatch(i, j)) return true;
      }
    }
    return false;
  }

  RxList<List<int>> destroyedCells = <List<int>>[].obs;

  // Tìm và phá hủy chuỗi
  void _findAndDestroyMatches() async {
    isAnimating.value = true;
    confettiController.play();
    List<List<int>> matches = _findMatches();
    destroyedCells.clear();
    destroyedCells.addAll(matches);
    for (var cell in matches) {
      grid[cell[0]][cell[1]].value = -1; // Đánh dấu phá hủy
    }

    score.value += matches.length * 10; // Tăng điểm
    await _dropCells();

    if (_checkMatches()) {
      _findAndDestroyMatches();
    } else {
      isAnimating.value = false;
    }

    if (isGameOver()) {
      _showGameOverDialog();
    }
  }

  List<List<int>> _findMatches() {
    Set<List<int>> matches = {};

    for (int i = 0; i < gridSize; i++) {
      for (int j = 0; j < gridSize; j++) {
        if (_isPartOfMatch(i, j)) {
          matches.addAll(_findMatchCoordinates(i, j));
        }
      }
    }

    return matches.toList();
  }

  List<List<int>> _findMatchCoordinates(int x, int y) {
    List<List<int>> cells = [];
    int value = grid[x][y].value;

    // Theo hàng
    for (int j = y; j >= 0 && grid[x][j].value == value; j--) {
      cells.add([x, j]);
    }
    for (int j = y + 1; j < gridSize && grid[x][j].value == value; j++) {
      cells.add([x, j]);
    }

    // Theo cột
    for (int i = x; i >= 0 && grid[i][y].value == value; i--) {
      cells.add([i, y]);
    }
    for (int i = x + 1; i < gridSize && grid[i][y].value == value; i++) {
      cells.add([i, y]);
    }

    return cells;
  }

  bool isGameOver() {
    for (int i = 0; i < gridSize; i++) {
      for (int j = 0; j < gridSize; j++) {
        // Kiểm tra khả năng swap hợp lệ với ô bên cạnh
        if (j + 1 < gridSize) {
          _swap(i, j, i, j + 1);
          if (_checkMatches()) {
            _swap(i, j, i, j + 1); // Hoàn tác swap
            return false;
          }
          _swap(i, j, i, j + 1); // Hoàn tác swap
        }

        // Kiểm tra khả năng swap hợp lệ với ô bên dưới
        if (i + 1 < gridSize) {
          _swap(i, j, i + 1, j);
          if (_checkMatches()) {
            _swap(i, j, i + 1, j); // Hoàn tác swap
            return false;
          }
          _swap(i, j, i + 1, j); // Hoàn tác swap
        }
      }
    }
    return true;
  }

  Future<void> _dropCells() async {
    List<int> affectedColumns = _getAffectedColumns();
    for (int j in affectedColumns) {
      int emptyCount = 0;
      for (int i = gridSize - 1; i >= 0; i--) {
        if (grid[i][j].value == -1) {
          emptyCount++;
        } else if (emptyCount > 0) {
          grid[i + emptyCount][j].value = grid[i][j].value;
          grid[i][j].value = -1;
        }
      }

      for (int i = 0; i < emptyCount; i++) {
        grid[i][j].value = Random().nextInt(activeHeroes.length);
      }
    }

    await Future.delayed(const Duration(milliseconds: 150));
  }

  List<int> _getAffectedColumns() {
    Set<int> columns = {};
    for (int i = 0; i < gridSize; i++) {
      for (int j = 0; j < gridSize; j++) {
        if (grid[i][j].value == -1) {
          columns.add(j);
        }
      }
    }
    return columns.toList();
  }

  void resetGame() {
    // 1. Dừng các hoạt ảnh đang chạy (nếu có)
    confettiController.stop();
    isAnimating.value = false;

    // 2. Đặt lại điểm số và trạng thái khác
    score.value = 0;
    animationController.reset();
    animationController.forward();
    grid.clear();
    initializeHeroes();
    initializeGrid();

    update();
  }

  void refreshHeroes() {
    // Chỉ thay đổi hero trong lưới mà không reset trạng thái khác
    for (int i = 0; i < gridSize; i++) {
      for (int j = 0; j < gridSize; j++) {
        grid[i][j].value = Random().nextInt(activeHeroes.length);
      }
    }
    initializeGrid();
    // Cập nhật giao diện
    update();
  }

  void _showGameOverDialog() {
    Get.defaultDialog(
      title: "Game Over",
      middleText: "No more valid moves!",
      textConfirm: "Restart",
      onConfirm: () {
        resetGame();
        Get.back();
      },
      textCancel: "Exit",
      onCancel: () {
        Get.offNamed("mainHome");
      },
    );
  }
}

```

---


### Pages\GamePage\Console\Match3_Game\match3_gameplay_page.dart

```dart
import 'package:confetti/confetti.dart';
import 'package:dotted_border/dotted_border.dart';
import 'package:flutter/material.dart';
import 'package:flutter_animate/flutter_animate.dart';
import 'package:get/get.dart';
import 'package:tictactoe_gameapp/Configs/constants.dart';
import 'package:tictactoe_gameapp/Configs/paint_draws/star_confetti_draws.dart';
import 'package:tictactoe_gameapp/Models/Functions/time_functions.dart';
import 'package:tictactoe_gameapp/Pages/GamePage/Console/General_Widgets/gaming_dialogs.dart';
import 'package:tictactoe_gameapp/Pages/GamePage/Console/Match3_Game/match3_gameplay_controller.dart';

class Match3GamePlayPage extends StatelessWidget {
  final String controllerTag = UniqueKey().toString();
  late final Match3Controller controller;
  final String selectedLevel;
  final int size;
  final String map;
  Match3GamePlayPage(
      {super.key,
      required this.selectedLevel,
      required this.size,
      required this.map}) {
    controller = Get.put(
        Match3Controller(
          gridSize: size,
          difficultyLevel: selectedLevel,
          durationPlay: 1200,
        ),
        tag: controllerTag);
  }

  @override
  Widget build(BuildContext context) {
    final width = MediaQuery.of(context).size.width;
    const TextStyle textStyleBig = TextStyle(
      color: Colors.black,
      fontFamily: "Orbitron",
      fontWeight: FontWeight.w600,
      fontSize: 20,
    );
    const TextStyle textStyleMedium = TextStyle(
      color: Colors.black,
      fontFamily: "Orbitron",
      fontWeight: FontWeight.w400,
      fontSize: 16,
    );
    return PopScope(
      canPop: false,
      onPopInvoked: (didPop) async {
        if (didPop) return;
        if (controller.timeLeft.value != 0) {
          final shouldExit = await showExitConfirmationDialog();
          if (shouldExit) {
            Get.delete<Match3Controller>(tag: controllerTag);
            Get.back();
          }
        } else {
          Get.delete<Match3Controller>(tag: controllerTag);
          Get.back();
        }
      },
      child: Scaffold(
        appBar: AppBar(
          title: const Text('Match Heroes Game', style: textStyleBig),
          actions: [
            IconButton(
                onPressed: () async {
                  bool? confirm = await showDialog<bool>(
                    context: context,
                    builder: (context) => AlertDialog(
                      title: const Text("Confirm Reset"),
                      content: const Text(
                          "Are you sure you want to reset the game?"),
                      actions: [
                        TextButton(
                          onPressed: () => Navigator.pop(context, false),
                          child: const Text("Cancel"),
                        ),
                        TextButton(
                          onPressed: () => Navigator.pop(context, true),
                          child: const Text("Reset"),
                        ),
                      ],
                    ),
                  );

                  if (confirm == true) {
                    controller.resetGame();
                  }
                },
                icon: const Icon(
                  Icons.watch_later_outlined,
                  size: 30,
                )),
            IconButton(
                onPressed: () async {
                  bool? confirm = await showDialog<bool>(
                    context: context,
                    builder: (context) => AlertDialog(
                      title: const Text("Confirm Reset"),
                      content: const Text(
                          "Are you sure you want to refresh  heroes?"),
                      actions: [
                        TextButton(
                          onPressed: () => Navigator.pop(context, false),
                          child: const Text("Cancel"),
                        ),
                        TextButton(
                          onPressed: () => Navigator.pop(context, true),
                          child: const Text("Reset"),
                        ),
                      ],
                    ),
                  );

                  if (confirm == true) {
                    controller.refreshHeroes();
                  }
                },
                icon: const Icon(
                  Icons.refresh_rounded,
                  size: 30,
                ))
          ],
        ),
        body: SingleChildScrollView(
          child: Column(
            children: [
              Obx(() => Container(
                    padding: const EdgeInsets.all(8.0),
                    decoration: BoxDecoration(
                        color: controller.isAnimating.value
                            ? Colors.lightBlueAccent
                            : Colors.white,
                        borderRadius: BorderRadius.circular(10)),
                    child: Obx(
                      () => Text('Score: ${controller.score.value}',
                          style: textStyleMedium),
                    ),
                  )),
              const SizedBox(
                height: 10,
              ),
              Row(
                children: [
                  Obx(() {
                    double progress = controller.animationController.value;
                    Color progressColor = controller.progressColor.value;
                    return Padding(
                      padding: const EdgeInsets.all(7),
                      child: Stack(
                        alignment: Alignment.center,
                        children: [
                          // Vòng tròn hiển thị trạng thái đếm ngược
                          SizedBox(
                            width: 100,
                            height: 100,
                            child: CircularProgressIndicator(
                              value: progress,
                              strokeWidth: 10, // Độ dày của đường viền
                              valueColor: AlwaysStoppedAnimation<Color>(
                                  progressColor), // Màu của viền
                              backgroundColor:
                                  Colors.grey.shade300, // Màu nền của viền
                            ),
                          ),
                          // Text hiển thị thời gian còn lại
                          Text(
                            TimeFunctions.getFormattedTime(controller.timeLeft),
                            style: textStyleBig,
                          ),
                        ],
                      ),
                    );
                  }),
                  Expanded(
                    child: Container(
                        width: double.maxFinite,
                        height: 100,
                        padding: const EdgeInsets.symmetric(
                            vertical: 5, horizontal: 5),
                        decoration: BoxDecoration(
                            color: Colors.blueGrey,
                            borderRadius: BorderRadius.circular(12),
                            border: Border.all(color: Colors.white, width: 5)),
                        child: ListView.builder(
                            scrollDirection: Axis.horizontal,
                            itemCount: controller.activeHeroes.length,
                            itemBuilder: (context, index) {
                              String heroImage = controller.activeHeroes[index];
                              return Padding(
                                padding:
                                    const EdgeInsets.symmetric(horizontal: 8.0),
                                child: ClipRRect(
                                  borderRadius: BorderRadius.circular(10),
                                  child: Image.asset(
                                    heroImage,
                                    width: 50,
                                  ),
                                ),
                              );
                            })).animate().scaleXY(
                        duration: const Duration(seconds: 1)),
                  ),
                ],
              ),
              const SizedBox(
                height: 10,
              ),
              Container(
                decoration: BoxDecoration(
                    image: DecorationImage(
                        image: AssetImage(map), fit: BoxFit.fitWidth)),
                height: width,
                child: DottedBorder(
                  borderType: BorderType.RRect,
                  color: Colors.lightBlue,
                  strokeWidth: 5,
                  dashPattern: const [10, 5],
                  child: InteractiveViewer(
                      panEnabled: false, // Cho phép kéo thả
                      scaleEnabled: true, // Cho phép phóng to, thu nhỏ
                      minScale: 0.0000000000001, // Tỷ lệ thu nhỏ tối thiểu
                      maxScale: 4.0, // Tỷ lệ phóng to tối đa
                      boundaryMargin: const EdgeInsets.all(double.infinity),
                      child: GridView.builder(
                        gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(
                          crossAxisCount: controller.gridSize,
                        ),
                        itemCount: controller.gridSize * controller.gridSize,
                        itemBuilder: (context, index) {
                          int x = index ~/ controller.gridSize;
                          int y = index % controller.gridSize;
                          return Obx(() {
                            int value = controller.grid[x][y].value;
                            String heroImage = controller.activeHeroes[value];
                            bool isDestroyed = controller.destroyedCells
                                .any((cell) => cell[0] == x && cell[1] == y);

                            return Stack(
                              clipBehavior: Clip.none,
                              children: [
                                DragTarget<Map<String, int>>(
                                  onWillAcceptWithDetails: (details) {
                                    int x1 = details.data['x'] ?? -1;
                                    int y1 = details.data['y'] ?? -1;
                                    return (x1 == x && (y1 - y).abs() == 1) ||
                                        (y1 == y && (x1 - x).abs() == 1);
                                  },
                                  onAcceptWithDetails: (data) {
                                    controller.handleDrop(x, y);
                                  },
                                  builder:
                                      (context, candidateData, rejectedData) {
                                    return Draggable<Map<String, int>>(
                                      data: {'x': x, 'y': y},
                                      onDragStarted: () {
                                        controller.setSelectedItem(x, y);
                                      },
                                      feedback: Material(
                                        borderRadius: BorderRadius.circular(10),
                                        child: ClipRRect(
                                          borderRadius:
                                              BorderRadius.circular(10),
                                          child: Image.asset(heroImage,
                                              width: 50, height: 50),
                                        ),
                                      ),
                                      childWhenDragging: Container(
                                        margin: const EdgeInsets.all(2),
                                        decoration: BoxDecoration(
                                            color:
                                                Colors.white.withOpacity(0.5),
                                            borderRadius:
                                                BorderRadius.circular(10),
                                            border: Border.all(
                                              color:
                                                  Colors.black.withOpacity(0.8),
                                              width: 2.5,
                                            )),
                                      ),
                                      child: Obx(() => controller
                                                  .timeLeft.value !=
                                              0
                                          ? Container(
                                              margin: const EdgeInsets.all(1),
                                              decoration: BoxDecoration(
                                                  borderRadius:
                                                      BorderRadius.circular(10),
                                                  border: Border.all(
                                                    color: Colors.white
                                                        .withOpacity(0.7),
                                                    width: 2.5,
                                                  )),
                                              child: ClipRRect(
                                                borderRadius:
                                                    BorderRadius.circular(10),
                                                child: Image.asset(
                                                  heroImage,
                                                ),
                                              ),
                                            )
                                          : Container(
                                              margin: const EdgeInsets.all(1),
                                              decoration: BoxDecoration(
                                                borderRadius:
                                                    BorderRadius.circular(10),
                                                color: Colors.white
                                                    .withOpacity(0.7),
                                              ),
                                              child: const SizedBox.expand(),
                                            )),
                                    );
                                  },
                                ),
                                controller.isAnimating.value && isDestroyed
                                    ? Align(
                                        key: Key("$x-$y"),
                                        alignment: Alignment.center,
                                        child: ConfettiWidget(
                                          confettiController:
                                              controller.confettiController,
                                          blastDirectionality:
                                              BlastDirectionality.explosive,
                                          shouldLoop: false,
                                          colors: const [
                                            Colors.green,
                                            Colors.blue,
                                            Colors.pink,
                                            Colors.orange,
                                            Colors.purple
                                          ], // manually specify the colors to be used
                                          numberOfParticles: 10,
                                          createParticlePath: (size) {
                                            // Tạo hạt với các hình dạng khác nhau
                                            return DrawPath.drawStarOfficial(
                                                size);
                                          },
                                        ),
                                      )
                                    : const SizedBox.shrink(),
                              ],
                            );
                          })
                              .animate()
                              .scale(duration: duration750)
                              .fadeIn(duration: duration750);
                        },
                      )),
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }
}

```

---


### Pages\GamePage\Console\Match3_Game\match3_lobby_page.dart

```dart
import 'package:cyber_punk_tool_kit_ui/cyber_punk_tool_kit_ui.dart';
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:tictactoe_gameapp/Configs/assets_path.dart';
// ignore: implementation_imports
import 'package:cyber_punk_tool_kit_ui/src/containers/cyber_container_two.dart';
import 'package:tictactoe_gameapp/Pages/GamePage/Console/Match3_Game/match3_gameplay_page.dart';

class Match3LobbyPage extends StatelessWidget {
  const Match3LobbyPage({super.key});

  @override
  Widget build(BuildContext context) {
    Rxn<String> selectedLevel = Rxn<String>();
    RxnInt selectedMode = RxnInt();
    RxnString selectedImageIndex = RxnString();
    final List<String> imagePaths = [
      ImagePath.map1,
      ImagePath.map2,
      ImagePath.map4,
      ImagePath.map5,
      ImagePath.map6,
      ImagePath.map7,
      ImagePath.map8,
      ImagePath.map9,
      ImagePath.map10,
    ];
    final List<String> level = ["Easy", "Medium", "Hard", "Expert"];
    const TextStyle textStyle = TextStyle(
      color: Colors.black,
      fontFamily: "Orbitron",
      fontWeight: FontWeight.w600,
      fontSize: 20,
    );

    return Scaffold(
      // appBar: AppBar(title: const Text('Sudoku Lobby', style: textStyle)),
      body: Stack(
        children: [
          CyberContainerTwo(
            width: MediaQuery.sizeOf(context).width,
            height: MediaQuery.sizeOf(context).height,
            child: SingleChildScrollView(
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  CyberContainerOne(
                    horizontalPadding: 50,
                    bottomPadding: 40,
                    child: Obx(() => DecoratedBox(
                          decoration: BoxDecoration(
                            image: DecorationImage(
                              fit: BoxFit.fill,
                              image: AssetImage(selectedImageIndex.value ??
                                  GifsPath.cyberpunk),
                            ),
                          ),
                        )),
                  ),
                  const SizedBox(
                    height: 20,
                  ),
                  const Text('Select Difficulty', style: textStyle),
                  SingleChildScrollView(
                    scrollDirection: Axis.horizontal,
                    child: Row(
                      mainAxisAlignment: MainAxisAlignment.center,
                      children: level.map((level) {
                        return InkWell(
                          splashColor: Colors.blueAccent,
                          borderRadius: BorderRadius.circular(10),
                          onTap: () => selectedLevel.value = level,
                          child: Obx(() => Container(
                                padding: const EdgeInsets.all(10),
                                margin: const EdgeInsets.all(10),
                                decoration: selectedLevel.value != null &&
                                        selectedLevel.value == level
                                    ? BoxDecoration(
                                        color: Colors.white,
                                        borderRadius: BorderRadius.circular(10),
                                        border: Border.all(
                                            color: Colors.blueAccent, width: 5),
                                      )
                                    : BoxDecoration(
                                        color: Colors.grey,
                                        borderRadius: BorderRadius.circular(10),
                                        border: Border.all(
                                            color: Colors.white, width: 3),
                                      ),
                                child: Text(
                                  level.capitalizeFirst!,
                                  style: const TextStyle(
                                    color: Colors.black,
                                    fontFamily: "Orbitron",
                                    fontWeight: FontWeight.w600,
                                    fontSize: 15,
                                  ),
                                ),
                              )),
                        );
                      }).toList(),
                    ),
                  ),
                  const SizedBox(height: 20),
                  const Text('Select Board Size', style: textStyle),
                  SingleChildScrollView(
                    scrollDirection: Axis.horizontal,
                    child: Row(
                      mainAxisAlignment: MainAxisAlignment.center,
                      children: [8, 10, 12, 14, 16, 20].map((size) {
                        return InkWell(
                          splashColor: Colors.blueAccent,
                          borderRadius: BorderRadius.circular(10),
                          onTap: () => selectedMode.value = size,
                          child: Obx(() => Container(
                                padding: const EdgeInsets.all(10),
                                margin: const EdgeInsets.all(10),
                                decoration: selectedMode.value != null &&
                                        selectedMode.value == size
                                    ? BoxDecoration(
                                        color: Colors.white,
                                        borderRadius: BorderRadius.circular(10),
                                        border: Border.all(
                                            color: Colors.blueAccent, width: 5),
                                      )
                                    : BoxDecoration(
                                        color: Colors.grey,
                                        borderRadius: BorderRadius.circular(10),
                                        border: Border.all(
                                            color: Colors.white, width: 3),
                                      ),
                                child: Text(
                                  '${size}x$size',
                                  style: const TextStyle(
                                    color: Colors.black,
                                    fontFamily: "Orbitron",
                                    fontWeight: FontWeight.w600,
                                    fontSize: 15,
                                  ),
                                ),
                              )),
                        );
                      }).toList(),
                    ),
                  ),
                  const SizedBox(height: 20),
                  const Text('Select A Map', style: textStyle),
                  SizedBox(
                    height: 100,
                    child: SingleChildScrollView(
                      scrollDirection: Axis.horizontal,
                      child: Row(
                        children: List.generate(imagePaths.length, (index) {
                          return GestureDetector(
                            onTap: () =>
                                selectedImageIndex.value = imagePaths[index],
                            child: Obx(() {
                              return Container(
                                margin:
                                    const EdgeInsets.symmetric(horizontal: 10),
                                decoration: BoxDecoration(
                                  border: Border.all(
                                    color: selectedImageIndex.value != null &&
                                            selectedImageIndex.value ==
                                                imagePaths[index]
                                        ? Colors.blue
                                        : Colors.white,
                                    width: 5,
                                  ),
                                ),
                                child: Image.asset(
                                  imagePaths[index],
                                  width: 100,
                                  height: 100,
                                  fit: BoxFit.cover,
                                ),
                              );
                            }),
                          );
                        }),
                      ),
                    ),
                  ),
                  const SizedBox(height: 20),
                  Obx(() => selectedMode.value != null &&
                          selectedLevel.value != null &&
                          selectedImageIndex.value != null
                      ? InkWell(
                          onTap: () => Get.to(
                              () => Match3GamePlayPage(
                                    selectedLevel: selectedLevel.value!,
                                    size: selectedMode.value!,
                                    map: selectedImageIndex.value!,
                                  ),
                              transition: Transition.zoom),
                          child: Ink(
                            height: 50,
                            width: 100,
                            decoration: BoxDecoration(
                              color: Colors.blueAccent,
                              borderRadius: BorderRadius.circular(10),
                            ),
                            child: const Center(
                              child: Text(
                                "PLAY",
                                style: textStyle,
                              ),
                            ),
                          ),
                        )
                      : Ink(
                          height: 50,
                          width: 100,
                          decoration: BoxDecoration(
                            color: const Color.fromARGB(255, 12, 5, 5),
                            borderRadius: BorderRadius.circular(10),
                          ),
                          child: const Center(
                            child: Text("PLAY", style: textStyle),
                          ),
                        ))
                ],
              ),
            ),
          ),
          Positioned(
            top: 10,
            right: 10,
            child: CyberButton(
              onTap: () {},
              width: 100,
              height: 50,
              primaryColorBigContainer: Colors.redAccent,
              secondaryColorBigContainer: Colors.yellowAccent,
              child: const Text(
                'Menu',
                style: TextStyle(
                  color: Colors.white,
                  fontFamily: "Orbitron",
                  fontWeight: FontWeight.w400,
                ),
              ),
            ),
          ),
          Positioned(
            top: 10,
            left: 10,
            child: CyberButton(
              onTap: () {
                Get.back();
              },
              width: 100,
              height: 50,
              primaryColorBigContainer: Colors.redAccent,
              secondaryColorBigContainer: Colors.yellowAccent,
              child: const Text(
                'Back',
                style: TextStyle(
                  color: Colors.white,
                  fontFamily: "Orbitron",
                  fontWeight: FontWeight.w400,
                ),
              ),
            ),
          )
        ],
      ),
    );
  }
}

```

---


### Pages\GamePage\Console\Minesweeper_Game\minesweeper_gamelobby_page.dart

```dart
import 'package:cyber_punk_tool_kit_ui/cyber_punk_tool_kit_ui.dart';
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:tictactoe_gameapp/Configs/assets_path.dart';
// ignore: implementation_imports
import 'package:cyber_punk_tool_kit_ui/src/containers/cyber_container_two.dart';
import 'package:tictactoe_gameapp/Pages/GamePage/Console/Minesweeper_Game/minesweeper_game_controller.dart';
import 'package:tictactoe_gameapp/Pages/GamePage/Console/Minesweeper_Game/minesweeper_game_page.dart';

class MinesweeperGamelobbyPage extends StatelessWidget {
  const MinesweeperGamelobbyPage({super.key});

  @override
  Widget build(BuildContext context) {
    Rxn<GameLevel> selectedLevel = Rxn<GameLevel>();
    RxnInt selectedMode = RxnInt();
    RxnString selectedImageIndex = RxnString();
    final List<String> imagePaths = [
      GifsPath.chloe1,
      GifsPath.chatbotGif,
      GifsPath.lightGif,
      GifsPath.cyberpunk,
      GifsPath.transitionGif,
    ];
    const TextStyle textStyle = TextStyle(
      color: Colors.black,
      fontFamily: "Orbitron",
      fontWeight: FontWeight.w600,
      fontSize: 20,
    );
    final List<Map<String, dynamic>> boardConfigs = [
      {'mode': 'Small', 'size': '8x4', 'rows': 8, 'columns': 4},
      {'mode': 'Medium', 'size': '10x5', 'rows': 10, 'columns': 5},
      {'mode': 'Large', 'size': '12x6', 'rows': 12, 'columns': 6},
      {'mode': 'Extra Large', 'size': '14x7', 'rows': 14, 'columns': 7},
      {'mode': 'Epic', 'size': '10x7', '16x8': 16, 'columns': 8},
    ];

    return Scaffold(
      // appBar: AppBar(title: const Text('Sudoku Lobby', style: textStyle)),
      body: Stack(
        children: [
          CyberContainerTwo(
            width: MediaQuery.sizeOf(context).width,
            height: MediaQuery.sizeOf(context).height,
            child: SingleChildScrollView(
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  CyberContainerOne(
                    horizontalPadding: 50,
                    bottomPadding: 40,
                    child: Obx(() => DecoratedBox(
                          decoration: BoxDecoration(
                            image: DecorationImage(
                              fit: BoxFit.fill,
                              image: AssetImage(selectedImageIndex.value ??
                                  GifsPath.cyberpunk),
                            ),
                          ),
                        )),
                  ),
                  const SizedBox(
                    height: 20,
                  ),
                  const Text('Select Difficulty', style: textStyle),
                  SingleChildScrollView(
                    scrollDirection: Axis.horizontal,
                    child: Row(
                      mainAxisAlignment: MainAxisAlignment.center,
                      children: GameLevel.values.map((level) {
                        return InkWell(
                          splashColor: Colors.blueAccent,
                          borderRadius: BorderRadius.circular(10),
                          onTap: () => selectedLevel.value = level,
                          child: Obx(() => Container(
                                padding: const EdgeInsets.all(10),
                                margin: const EdgeInsets.all(10),
                                decoration: selectedLevel.value != null &&
                                        selectedLevel.value == level
                                    ? BoxDecoration(
                                        color: Colors.white,
                                        borderRadius: BorderRadius.circular(10),
                                        border: Border.all(
                                            color: Colors.blueAccent, width: 5),
                                      )
                                    : BoxDecoration(
                                        color: Colors.grey,
                                        borderRadius: BorderRadius.circular(10),
                                        border: Border.all(
                                            color: Colors.white, width: 3),
                                      ),
                                child: Text(
                                  level.name.capitalizeFirst!,
                                  style: const TextStyle(
                                    color: Colors.black,
                                    fontFamily: "Orbitron",
                                    fontWeight: FontWeight.w600,
                                    fontSize: 15,
                                  ),
                                ),
                              )),
                        );
                      }).toList(),
                    ),
                  ),
                  const SizedBox(height: 20),
                  const Text('Select Board Size', style: textStyle),
                  SingleChildScrollView(
                    scrollDirection: Axis.horizontal,
                    child: Row(
                      mainAxisAlignment: MainAxisAlignment.center,
                      children: boardConfigs.map((config) {
                        return InkWell(
                          splashColor: Colors.blueAccent,
                          borderRadius: BorderRadius.circular(10),
                          onTap: () =>
                              selectedMode.value = boardConfigs.indexOf(config),
                          child: Obx(() => Container(
                                padding: const EdgeInsets.all(10),
                                margin: const EdgeInsets.all(10),
                                decoration: selectedMode.value != null &&
                                        selectedMode.value ==
                                            boardConfigs.indexOf(config)
                                    ? BoxDecoration(
                                        color: Colors.white,
                                        borderRadius: BorderRadius.circular(10),
                                        border: Border.all(
                                            color: Colors.blueAccent, width: 5),
                                      )
                                    : BoxDecoration(
                                        color: Colors.grey,
                                        borderRadius: BorderRadius.circular(10),
                                        border: Border.all(
                                            color: Colors.white, width: 3),
                                      ),
                                child: Text(
                                  config["size"],
                                  style: const TextStyle(
                                    color: Colors.black,
                                    fontFamily: "Orbitron",
                                    fontWeight: FontWeight.w600,
                                    fontSize: 15,
                                  ),
                                ),
                              )),
                        );
                      }).toList(),
                    ),
                  ),
                  const SizedBox(height: 20),
                  const Text('Select A Map', style: textStyle),
                  SizedBox(
                    height: 100,
                    child: SingleChildScrollView(
                      scrollDirection: Axis.horizontal,
                      child: Row(
                        children: List.generate(imagePaths.length, (index) {
                          return GestureDetector(
                            onTap: () =>
                                selectedImageIndex.value = imagePaths[index],
                            child: Obx(() {
                              return Container(
                                margin:
                                    const EdgeInsets.symmetric(horizontal: 10),
                                decoration: BoxDecoration(
                                  border: Border.all(
                                    color: selectedImageIndex.value != null &&
                                            selectedImageIndex.value ==
                                                imagePaths[index]
                                        ? Colors.blue
                                        : Colors.white,
                                    width: 5,
                                  ),
                                ),
                                child: Image.asset(
                                  imagePaths[index],
                                  width: 100,
                                  height: 100,
                                  fit: BoxFit.cover,
                                ),
                              );
                            }),
                          );
                        }),
                      ),
                    ),
                  ),
                  const SizedBox(height: 20),
                  Obx(() => selectedMode.value != null &&
                          selectedLevel.value != null &&
                          selectedImageIndex.value != null
                      ? InkWell(
                          onTap: () => Get.to(
                            () => MinesweeperGame(
                              rows: boardConfigs[selectedMode.value!]["rows"],
                              columns: boardConfigs[selectedMode.value!]
                                  ["columns"],
                              cellSize: 30,
                              level: selectedLevel.value!,
                            ),
                          ),
                          child: Ink(
                            height: 50,
                            width: 100,
                            decoration: BoxDecoration(
                              color: Colors.blueAccent,
                              borderRadius: BorderRadius.circular(10),
                            ),
                            child: const Center(
                              child: Text(
                                "PLAY",
                                style: textStyle,
                              ),
                            ),
                          ),
                        )
                      : Ink(
                          height: 50,
                          width: 100,
                          decoration: BoxDecoration(
                            color: const Color.fromARGB(255, 12, 5, 5),
                            borderRadius: BorderRadius.circular(10),
                          ),
                          child: const Center(
                            child: Text("PLAY", style: textStyle),
                          ),
                        ))
                ],
              ),
            ),
          ),
          Positioned(
            top: 10,
            right: 10,
            child: CyberButton(
              onTap: () {},
              width: 100,
              height: 50,
              primaryColorBigContainer: Colors.redAccent,
              secondaryColorBigContainer: Colors.yellowAccent,
              child: const Text(
                'Menu',
                style: TextStyle(
                  color: Colors.white,
                  fontFamily: "Orbitron",
                  fontWeight: FontWeight.w400,
                ),
              ),
            ),
          ),
          Positioned(
            top: 10,
            left: 10,
            child: CyberButton(
              onTap: () {
                Get.back();
              },
              width: 100,
              height: 50,
              primaryColorBigContainer: Colors.redAccent,
              secondaryColorBigContainer: Colors.yellowAccent,
              child: const Text(
                'Back',
                style: TextStyle(
                  color: Colors.white,
                  fontFamily: "Orbitron",
                  fontWeight: FontWeight.w400,
                ),
              ),
            ),
          )
        ],
      ),
    );
  }
}

```

---


### Pages\GamePage\Console\Minesweeper_Game\minesweeper_game_controller.dart

```dart
import 'dart:async';
import 'dart:math';
import 'package:get/get.dart';
import 'package:tictactoe_gameapp/Configs/assets_path.dart';
import 'package:tictactoe_gameapp/Configs/constants.dart';
import 'package:tictactoe_gameapp/Data/fetch_firestore_database.dart';

class MinesweeperController extends GetxController {
  RxList<List<HexCell>> board = RxList<List<HexCell>>();
  late int rows;
  late int columns;
  late int mineCount;
  late GameLevel level;
  var gameOver = false.obs;
  var gameWon = false.obs;
  RxInt timeLeft = 0.obs; // Thời gian còn lại (giây)
  Timer? _timer;

  final List<String> heroImages = listChampions;
  final String placeholderImage = GifsPath.loadingGif;

  void initializeBoard(int rows, int columns, GameLevel level) {
    this.rows = rows;
    this.columns = columns;
    this.level = level;
    mineCount = levelConfigs[level]!.mineCount;
    timeLeft.value = levelConfigs[level]!.timeLimit;
    _resetBoard();
    _startTimer();
  }

  void _resetBoard() {
    board.value = List.generate(
      rows,
      (row) => List.generate(columns, (col) {
        final randomImage = heroImages[Random().nextInt(heroImages.length)];
        return HexCell(row, col, image: randomImage);
      }),
    );

    _placeMines(mineCount);
    _calculateAdjacentMines();

    gameOver.value = false;
    gameWon.value = false;
    board.refresh();
  }

  void resetGame() {
    _stopTimer();
    timeLeft.value = levelConfigs[level]!.timeLimit;
    _resetBoard();
    _startTimer();
  }

  void _startTimer() {
    _stopTimer(); // Hủy timer cũ trước khi tạo mới
    _timer = Timer.periodic(const Duration(seconds: 1), (timer) {
      if (!gameOver.value && timeLeft.value > 0) {
        timeLeft.value--;
      } else if (timeLeft.value <= 0) {
        timer.cancel(); // Hủy timer từ chính callback
        gameOver.value = true;
      }
    });
  }

  void _stopTimer() {
    _timer?.cancel();
    _timer = null; // Đặt lại null để tránh tham chiếu cũ
  }

  void _placeMines(int mineCount) {
    final random = Random();
    int placedMines = 0;

    while (placedMines < mineCount) {
      int row = random.nextInt(rows);
      int col = random.nextInt(columns);

      if (!board[row][col].isMine.value) {
        board[row][col].isMine.value = true;
        placedMines++;
      }
    }
  }

  void _calculateAdjacentMines() {
    for (int row = 0; row < rows; row++) {
      for (int col = 0; col < columns; col++) {
        if (!board[row][col].isMine.value) {
          board[row][col].adjacentMines.value = _countAdjacentMines(row, col);
        } else {
          board[row][col].adjacentMines.value = 0;
        }
      }
    }
  }

  int _countAdjacentMines(int row, int col) {
    int count = 0;
    for (var delta in _hexNeighbors(row)) {
      int newRow = row + delta[0];
      int newCol = col + delta[1];
      if (_isValidCell(newRow, newCol) && board[newRow][newCol].isMine.value) {
        count++;
      }
    }
    return count;
  }

  bool _isValidCell(int row, int col) {
    return row >= 0 && col >= 0 && row < rows && col < columns;
  }

  List<List<int>> _hexNeighbors(int row) {
    if (row % 2 == 0) {
      return [
        [-1, 0],
        [-1, 1],
        [0, -1],
        [0, 1],
        [1, 0],
        [1, 1],
      ];
    } else {
      return [
        [-1, -1],
        [-1, 0],
        [0, -1],
        [0, 1],
        [1, -1],
        [1, 0],
      ];
    }
  }

  void revealCell(int row, int col) {
    if (!board[row][col].isRevealed.value && !gameOver.value) {
      board[row][col].isRevealed.value = true;

      if (board[row][col].isMine.value) {
        gameOver.value = true;
        _stopTimer();
      } else {
        board[row][col].image.value = placeholderImage;
        if (board[row][col].adjacentMines.value == 0) {
          _revealAdjacentCells(row, col);
        }
      }

      _checkWinCondition();
    }
  }

  void _revealAdjacentCells(int row, int col) {
    for (var delta in _hexNeighbors(row)) {
      int newRow = row + delta[0];
      int newCol = col + delta[1];
      if (_isValidCell(newRow, newCol) &&
          !board[newRow][newCol].isRevealed.value &&
          !board[newRow][newCol].isMine.value) {
        revealCell(newRow, newCol);
      }
    }
  }

  void toggleFlag(int row, int col) {
    if (!board[row][col].isRevealed.value && !gameOver.value) {
      board[row][col].isFlagged.value = !board[row][col].isFlagged.value;
    }
  }

  void _checkWinCondition() {
    for (int row = 0; row < rows; row++) {
      for (int col = 0; col < columns; col++) {
        if (!board[row][col].isMine.value &&
            !board[row][col].isRevealed.value) {
          return;
        }
      }
    }
    gameWon.value = true;
    gameOver.value = true;
    _stopTimer();
    _awardCoins();
  }

  void _awardCoins() {
    int coinsEarned;
    switch (level) {
      case GameLevel.easy:
        coinsEarned = 10;
        break;
      case GameLevel.medium:
        coinsEarned = 20;
        break;
      case GameLevel.hard:
        coinsEarned = 30;
        break;
      case GameLevel.extreme:
        coinsEarned = 50;
        break;
      case GameLevel.legendary:
        coinsEarned = 100;
        break;
    }
    Get.find<FirestoreController>().incrementCoinsAndWins(coinsEarned);
  }

  @override
  void onClose() {
    _stopTimer();
    super.onClose();
  }
}

class HexCell {
  final int row;
  final int col;
  final RxBool isMine = false.obs;
  final RxBool isRevealed = false.obs;
  final RxBool isFlagged = false.obs;
  final RxInt adjacentMines = 0.obs;
  RxString image;

  HexCell(this.row, this.col, {required String image}) : image = image.obs;
}

enum GameLevel {
  easy,
  medium,
  hard,
  extreme,
  legendary,
}

class LevelConfig {
  final int mineCount;
  final int timeLimit; // Thời gian giới hạn tính bằng giây

  LevelConfig(this.mineCount, this.timeLimit);
}

final Map<GameLevel, LevelConfig> levelConfigs = {
  GameLevel.easy: LevelConfig(10, 300), // 10 mìn, 5 phút
  GameLevel.medium: LevelConfig(20, 240), // 20 mìn, 4 phút
  GameLevel.hard: LevelConfig(30, 180), // 30 mìn, 3 phút
  GameLevel.extreme: LevelConfig(50, 120), // 50 mìn, 2 phút
  GameLevel.legendary: LevelConfig(80, 60), // 80 mìn, 1 phút
};

```

---


### Pages\GamePage\Console\Minesweeper_Game\minesweeper_game_page.dart

```dart
import 'dart:math';
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:tictactoe_gameapp/Pages/GamePage/Console/General_Widgets/gaming_dialogs.dart';
import 'package:tictactoe_gameapp/Pages/GamePage/Console/Minesweeper_Game/minesweeper_game_controller.dart';

class MinesweeperGame extends StatelessWidget {
  final String controllerTag = UniqueKey().toString(); // Lưu tag ở đây
  late final MinesweeperController controller; // Sẽ khởi tạo trong constructor
  final int rows;
  final int columns;
  final double cellSize;
  final GameLevel level;

  MinesweeperGame({
    super.key,
    required this.rows,
    required this.columns,
    required this.cellSize,
    required this.level,
  }) {
    controller = Get.put(MinesweeperController(),
        tag: controllerTag); // Gán controller với tag
    controller.initializeBoard(rows, columns, level);
  }

  @override
  Widget build(BuildContext context) {
    final double hexWidth = sqrt(3) * cellSize;
    final double hexHeight = 2 * cellSize;
    const TextStyle textStyleBig = TextStyle(
      color: Colors.black,
      fontFamily: "Orbitron",
      fontWeight: FontWeight.w600,
      fontSize: 20,
    );
    return PopScope(
      canPop: false,
      onPopInvoked: (didPop) async {
        if (didPop) return;
        if (!controller.gameOver.value) {
          final shouldExit = await showExitConfirmationDialog();
          if (shouldExit) {
            Get.delete<MinesweeperController>(tag: controllerTag);
            Get.back();
          }
        } else {
          Get.delete<MinesweeperController>(tag: controllerTag);
          Get.back();
        }
      },
      child: Scaffold(
        appBar: AppBar(
          // leading: IconButton(
          //   onPressed: () async {
          //     await Get.delete<MinesweeperController>().then((_) => Get.back());
          //   },
          //   icon: const Icon(Icons.arrow_back_ios_new_rounded),
          // ),
          title: Text('Minesweeper Hex - ${level.name.capitalize}'),
          actions: [
            IconButton(
              icon: const Icon(Icons.refresh),
              onPressed: () {
                controller.resetGame();
              },
              tooltip: 'Reset Game',
            ),
          ],
        ),
        body: Center(
          child: SingleChildScrollView(
            child: Column(
              children: [
                const SizedBox(height: 20),
                // Hiển thị bộ đếm thời gian
                Obx(() => Text(
                      TimeFunctions.getFormattedTime(controller.timeLeft.value),
                      style: textStyleBig,
                    )),
                const SizedBox(height: 10),
                // Thông báo game over hoặc thắng
                Obx(() {
                  if (controller.gameOver.value) {
                    WidgetsBinding.instance.addPostFrameCallback((_) {
                      Get.dialog(
                        AlertDialog(
                          title: Text(controller.gameWon.value
                              ? 'Bạn Thắng!'
                              : 'Game Over'),
                          content: Text(controller.gameWon.value
                              ? 'Chúc mừng bạn đã dò hết mìn!'
                              : controller.timeLeft.value <= 0
                                  ? 'Hết thời gian! Boom!'
                                  : 'Bạn đã chọn trúng hero cầm boom!'),
                          actions: [
                            TextButton(
                              onPressed: () {
                                Get.back();
                                controller.resetGame();
                              },
                              child: const Text('Chơi lại'),
                            ),
                          ],
                        ),
                        barrierDismissible: false,
                      );
                    });
                  }
                  return const SizedBox.shrink();
                }),
                // Lưới lục giác
                Obx(() => SizedBox(
                      width: columns * hexWidth + hexWidth / 2,
                      height: rows * hexHeight * 0.75 + hexHeight / 4,
                      child: Stack(
                        children: [
                          CustomPaint(
                            size: Size(
                              columns * hexWidth + hexWidth / 2,
                              rows * hexHeight * 0.75 + hexHeight / 4,
                            ),
                            painter: HexGridPainter(
                                rows: rows,
                                columns: columns,
                                cellSize: cellSize),
                          ),
                          for (int row = 0; row < rows; row++)
                            for (int col = 0; col < columns; col++)
                              Positioned(
                                left:
                                    col * hexWidth + (row % 2) * (hexWidth / 2),
                                top: row * (hexHeight * 0.75),
                                child: HexCellWidget(
                                  cell: controller.board[row][col],
                                  cellSize: cellSize,
                                  minesweeperController: controller,
                                ),
                              ),
                        ],
                      ),
                    )),
              ],
            ),
          ),
        ),
      ),
    );
  }
}

class HexCellWidget extends StatelessWidget {
  final MinesweeperController minesweeperController;
  final HexCell cell;
  final double cellSize;

  const HexCellWidget(
      {super.key,
      required this.cell,
      required this.cellSize,
      required this.minesweeperController});

  @override
  Widget build(BuildContext context) {
    return GestureDetector(
      onTap: () {
        minesweeperController.revealCell(cell.row, cell.col);
      },
      child: Obx(() => ClipPath(
            clipper: HexagonClipper(),
            child: Container(
              width: sqrt(3) * cellSize,
              height: 2 * cellSize,
              decoration: BoxDecoration(
                image: DecorationImage(
                  image: AssetImage(cell.image.value),
                  fit: BoxFit.cover,
                ),
              ),
              child: cell.isRevealed.value &&
                      !cell.isMine.value &&
                      cell.adjacentMines.value > 0
                  ? Center(
                      child: Text(
                        '${cell.adjacentMines.value}',
                        style: const TextStyle(
                          color: Colors.black,
                          fontWeight: FontWeight.bold,
                          fontSize: 18,
                        ),
                      ),
                    )
                  : null,
            ),
          )),
    );
  }
}

class HexGridPainter extends CustomPainter {
  final int rows;
  final int columns;
  final double cellSize;

  HexGridPainter({
    required this.rows,
    required this.columns,
    required this.cellSize,
  });

  @override
  void paint(Canvas canvas, Size size) {
    final paint = Paint()
      ..color = Colors.grey.withOpacity(0.5)
      ..style = PaintingStyle.stroke
      ..strokeWidth = 1;

    final double hexWidth = sqrt(3) * cellSize;
    final double hexHeight = 2 * cellSize;

    for (int row = 0; row < rows; row++) {
      for (int col = 0; col < columns; col++) {
        final dx = col * hexWidth + (row % 2) * (hexWidth / 2);
        final dy = row * hexHeight * 0.75;
        final hexPath =
            _createHexagonPath(dx + hexWidth / 2, dy + hexHeight / 2, cellSize);
        canvas.drawPath(hexPath, paint);
      }
    }
  }

  Path _createHexagonPath(double centerX, double centerY, double size) {
    final path = Path();
    for (int i = 0; i < 6; i++) {
      final angle = (pi / 3) * i - (pi / 6);
      final x = centerX + size * cos(angle);
      final y = centerY + size * sin(angle);
      if (i == 0) {
        path.moveTo(x, y);
      } else {
        path.lineTo(x, y);
      }
    }
    path.close();
    return path;
  }

  @override
  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;
}

class HexagonClipper extends CustomClipper<Path> {
  @override
  Path getClip(Size size) {
    final path = Path();
    final centerX = size.width / 2;
    final centerY = size.height / 2;
    final radius = size.width / 2;

    for (int i = 0; i < 6; i++) {
      final angle = (pi / 3) * i - (pi / 6);
      final x = centerX + radius * cos(angle);
      final y = centerY + radius * sin(angle);
      if (i == 0) {
        path.moveTo(x, y);
      } else {
        path.lineTo(x, y);
      }
    }
    path.close();
    return path;
  }

  @override
  bool shouldReclip(CustomClipper<Path> oldClipper) => false;
}

// Hàm giả lập TimeFunctions (bạn có thể thay bằng hàm thật của bạn)
class TimeFunctions {
  static String getFormattedTime(int seconds) {
    final minutes = (seconds ~/ 60).toString().padLeft(2, '0');
    final secs = (seconds % 60).toString().padLeft(2, '0');
    return '$minutes:$secs';
  }
}

```

---


### Pages\GamePage\Console\sodoku_game\dynamic_sodoku_controller.dart

```dart
import 'dart:math';
import 'package:get/get.dart';
import 'package:tictactoe_gameapp/Configs/constants.dart';
import 'package:tictactoe_gameapp/Configs/messages.dart';

class Sudoku {
  final List<int> puzzle;
  final List<int> solution;

  Sudoku({required this.puzzle, required this.solution});

  static Sudoku generate(Levels level, {int size = 9}) {
    final totalCells = size * size;

    // Bảng hoàn chỉnh (giải pháp)
    List<int> solution = List.filled(totalCells, -1);
    _fillGrid(solution, size);

    // Bảng bị xóa ô (dựa theo độ khó)
    List<int> puzzle = List.of(solution);
    _removeCellsForDifficulty(puzzle, level, size);

    return Sudoku(puzzle: puzzle, solution: solution);
  }

  // Điền các số hợp lệ vào bảng
  static void _fillGrid(List<int> grid, int size, {int maxRetries = 5}) {
    final helper = SudokuHelper(size);
    int subgridSize = sqrt(size).toInt();

    if (subgridSize * subgridSize != size) {
      throw Exception('Kích thước không hợp lệ: $size');
    }

    for (int i = 0; i < grid.length; i++) {
      grid[i] = -1; // Đặt giá trị ban đầu
    }

    if (!_solve(grid, size, subgridSize, helper)) {
      if (maxRetries > 0) {
        _fillGrid(grid, size, maxRetries: maxRetries - 1);
      } else {
        throw Exception('Không thể tạo bảng sau nhiều lần thử.');
      }
    }
  }

  static void _fillSubgrid(
      List<int> grid, int startRow, int startCol, int size, int subgridSize) {
    final random = Random();
    List<int> numbers = List.generate(size, (index) => index + 1)
      ..shuffle(random);

    for (int row = 0; row < subgridSize; row++) {
      for (int col = 0; col < subgridSize; col++) {
        int calculatedIndex = (startRow + row) * size + (startCol + col);

        bool numberPlaced = false;
        for (int num in numbers) {
          if (_isValid(
              grid, startRow + row, startCol + col, num, size, subgridSize)) {
            grid[calculatedIndex] = num;
            numbers.remove(num);
            numberPlaced = true;
            break;
          }
        }

        // Nếu không thể đặt số, khởi động lại subgrid này.
        if (!numberPlaced) {
          grid.fillRange(0, grid.length, -1);
          return;
        }
      }
    }
  }

  // Backtracking để điền số hợp lệ vào bảng
  static bool _solve(
      List<int> grid, int size, int subgridSize, SudokuHelper helper) {
    int emptyIndex = grid.indexOf(-1);
    if (emptyIndex == -1) return true;

    int row = emptyIndex ~/ size;
    int col = emptyIndex % size;
    int subgrid = (row ~/ subgridSize) * subgridSize + (col ~/ subgridSize);

    for (int num = 1; num <= size; num++) {
      if (!helper.rows[row].contains(num) &&
          !helper.cols[col].contains(num) &&
          !helper.subgrids[subgrid].contains(num)) {
        grid[emptyIndex] = num;
        helper.rows[row].add(num);
        helper.cols[col].add(num);
        helper.subgrids[subgrid].add(num);

        if (_solve(grid, size, subgridSize, helper)) return true;

        // Quay lui
        grid[emptyIndex] = -1;
        helper.rows[row].remove(num);
        helper.cols[col].remove(num);
        helper.subgrids[subgrid].remove(num);
      }
    }

    return false;
  }

  static bool _isValid(
      List<int> grid, int row, int col, int num, int size, int subgridSize) {
    // Kiểm tra hàng.
    for (int c = 0; c < size; c++) {
      if (grid[row * size + c] == num) {
        return false;
      }
    }

    // Kiểm tra cột.
    for (int r = 0; r < size; r++) {
      if (grid[r * size + col] == num) {
        return false;
      }
    }

    // Kiểm tra subgrid.
    int startRow = (row ~/ subgridSize) * subgridSize;
    int startCol = (col ~/ subgridSize) * subgridSize;

    for (int r = 0; r < subgridSize; r++) {
      for (int c = 0; c < subgridSize; c++) {
        if (grid[(startRow + r) * size + (startCol + c)] == num) {
          return false;
        }
      }
    }

    return true;
  }

  // Xóa các ô khỏi bảng dựa theo độ khó
  static void _removeCellsForDifficulty(
      List<int> grid, Levels level, int size) {
    final random = Random();
    int totalCells = grid.length;

    // Số ô cần xóa dựa vào cấp độ khó
    int cellsToRemove = (totalCells * _difficultyFactor(level)).toInt();

    for (int i = 0; i < cellsToRemove; i++) {
      int index;
      do {
        index = random.nextInt(totalCells);
      } while (grid[index] == -1); // Đảm bảo ô chưa bị xóa

      grid[index] = -1; // Xóa ô
    }
  }

  // Hệ số dựa trên độ khó
  static double _difficultyFactor(Levels level) {
    switch (level) {
      case Levels.easy:
        return 0.4; // 40% ô bị xóa
      case Levels.medium:
        return 0.6; // 60% ô bị xóa
      case Levels.hard:
        return 0.75; // 75% ô bị xóa
      case Levels.expert:
        return 0.85;
      default:
        return 0.5; // Mặc định trung bình
    }
  }
}

// Định nghĩa các cấp độ khó
enum Levels { easy, medium, hard, expert }

class SudokuGamePlayController extends GetxController {
  // Các biến trạng thái
  RxList<int> puzzle = <int>[].obs;
  RxList<int> solution = <int>[].obs;
  RxBool isSolved = false.obs;
  RxList<String> selectedHeroes = <String>[].obs; // Danh sách hero được chọn
  var selectedHeroIndex = (-1).obs;

  RxList<List<int>> undoStack = RxList(); // Stack cho Undo
  RxList<List<int>> redoStack = RxList(); // Stack cho Redo

  // Cấu hình bảng
  final Levels selectedLevel; // Độ khó
  final int size; // Kích thước bảng (vd: 9, 11, 13)
  SudokuGamePlayController({required this.selectedLevel, required this.size});

  @override
  void onInit() {
    super.onInit();
    generateNewGame();
    ever(puzzle,
        (_) => checkCompletion()); // Kiểm tra hoàn thành khi bảng thay đổi
  }

  // Tạo game mới
  void generateNewGame() {
    Sudoku sudoku = Sudoku.generate(selectedLevel, size: size);

    puzzle.value = sudoku.puzzle;
    solution.value = sudoku.solution;

    // Chọn hero ngẫu nhiên tương ứng với kích thước bảng
    selectedHeroes.value = _getRandomHeroes(size);
    isSolved.value = false;
  }

  // Chọn ngẫu nhiên danh sách hero
  List<String> _getRandomHeroes(int count) {
    final random = Random();
    final shuffled = List.of(listChampions)..shuffle(random);
    return shuffled.take(count).toList(); // Chọn số lượng hero tương ứng
  }

  // Điền số vào ô
  void updateCell(int index, int number) {
    undoStack.add(List.of(puzzle)); // Lưu trạng thái hiện tại vào Undo
    redoStack.clear(); // Xóa redo stack sau mỗi thay đổi
    puzzle[index] = number;
  }

  // Undo thao tác
  void undo() {
    if (undoStack.isNotEmpty) {
      redoStack.add(List.of(puzzle)); // Lưu trạng thái hiện tại vào Redo
      puzzle.value = undoStack.removeLast();
    }
  }

  // Redo thao tác
  void redo() {
    if (redoStack.isNotEmpty) {
      undoStack.add(List.of(puzzle)); // Lưu trạng thái hiện tại vào Undo
      puzzle.value = redoStack.removeLast();
    }
  }

  // Kiểm tra hoàn thành
  void checkCompletion() {
    isSolved.value = _isPuzzleSolved();
    if (isSolved.value) {
      successMessage('Congratulation! You solved the Sudoku!');
    }
  }

  bool _isPuzzleSolved() {
    for (int i = 0; i < puzzle.length; i++) {
      if (puzzle[i] != solution[i]) return false;
    }

    // Kiểm tra thêm tính hợp lệ của hàng, cột, subgrid
    int subgridSize = sqrt(size).toInt();
    for (int row = 0; row < size; row++) {
      for (int col = 0; col < size; col++) {
        int num = puzzle[row * size + col];
        if (!Sudoku._isValid(puzzle, row, col, num, size, subgridSize)) {
          return false;
        }
      }
    }

    return true;
  }

  // Giải toàn bộ bảng
  void solveSudoku() {
    if (!_isPuzzleSolved()) {
      undoStack.add(List.of(puzzle)); // Lưu trạng thái hiện tại.
      puzzle.value = List.of(solution); // Điền toàn bộ đáp án.
      isSolved.value = true;
    }
  }

  // Điền gợi ý cho một ô
  void hintForSpecify(int index) {
    if (puzzle[index] == -1) {
      undoStack.add(List.of(puzzle)); // Lưu trạng thái trước khi gợi ý.
      puzzle[index] = solution[index]; // Điền đáp án đúng.
    }
    Get.back();
  }

  // Điền gợi ý cho một ô
  void hintForRandom() {
    // Tìm vị trí đầu tiên còn trống trong bảng (giá trị -1)
    int index = puzzle.indexWhere((value) => value == -1);

    // Nếu còn ô trống, cung cấp gợi ý
    if (index != -1) {
      undoStack.add(List.of(puzzle)); // Lưu trạng thái hiện tại vào Undo stack
      puzzle[index] = solution[index]; // Điền số đúng từ solution vào puzzle
    } else {
      // Nếu không còn ô trống
      errorMessage('No empty cells available for hints!');
    }
  }

  // Đặt lại bảng
  void resetGame() {
    generateNewGame();
    undoStack.clear();
    redoStack.clear();
  }
}

class SudokuHelper {
  final List<Set<int>> rows;
  final List<Set<int>> cols;
  final List<Set<int>> subgrids;

  SudokuHelper(int size)
      : rows = List.generate(size, (_) => <int>{}),
        cols = List.generate(size, (_) => <int>{}),
        subgrids = List.generate(size, (_) => <int>{});
}

```

---


### Pages\GamePage\Console\sodoku_game\sodoku_gamelobby_page.dart

```dart
import 'package:cyber_punk_tool_kit_ui/cyber_punk_tool_kit_ui.dart';
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:tictactoe_gameapp/Configs/assets_path.dart';
import 'package:tictactoe_gameapp/Pages/GamePage/Console/sodoku_game/dynamic_sodoku_controller.dart';
// ignore: implementation_imports
import 'package:cyber_punk_tool_kit_ui/src/containers/cyber_container_two.dart';
import 'sodoku_gameplay_page.dart';

class SodokuGamelobbyPage extends StatelessWidget {
  const SodokuGamelobbyPage({super.key});

  @override
  Widget build(BuildContext context) {
    Rxn<Levels> selectedLevel = Rxn<Levels>();
    RxnInt selectedMode = RxnInt();
    RxnString selectedImageIndex = RxnString();
    final List<String> imagePaths = [
      ImagePath.map1,
      ImagePath.map2,
      ImagePath.map4,
      ImagePath.map5,
      ImagePath.map6,
      ImagePath.map7,
      ImagePath.map8,
      ImagePath.map9,
      ImagePath.map10,
    ];
    const TextStyle textStyle = TextStyle(
      color: Colors.black,
      fontFamily: "Orbitron",
      fontWeight: FontWeight.w600,
      fontSize: 20,
    );

    return Scaffold(
      // appBar: AppBar(title: const Text('Sudoku Lobby', style: textStyle)),
      body: Stack(
        children: [
          CyberContainerTwo(
            width: MediaQuery.sizeOf(context).width,
            height: MediaQuery.sizeOf(context).height,
            child: SingleChildScrollView(
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  CyberContainerOne(
                    horizontalPadding: 50,
                    bottomPadding: 40,
                    child: Obx(() => DecoratedBox(
                          decoration: BoxDecoration(
                            image: DecorationImage(
                              fit: BoxFit.fill,
                              image: AssetImage(selectedImageIndex.value ??
                                  GifsPath.cyberpunk),
                            ),
                          ),
                        )),
                  ),
                  const SizedBox(
                    height: 20,
                  ),
                  const Text('Select Difficulty', style: textStyle),
                  SingleChildScrollView(
                    scrollDirection: Axis.horizontal,
                    child: Row(
                      mainAxisAlignment: MainAxisAlignment.center,
                      children: Levels.values.map((level) {
                        return InkWell(
                          splashColor: Colors.blueAccent,
                          borderRadius: BorderRadius.circular(10),
                          onTap: () => selectedLevel.value = level,
                          child: Obx(() => Container(
                                padding: const EdgeInsets.all(10),
                                margin: const EdgeInsets.all(10),
                                decoration: selectedLevel.value != null &&
                                        selectedLevel.value == level
                                    ? BoxDecoration(
                                        color: Colors.white,
                                        borderRadius: BorderRadius.circular(10),
                                        border: Border.all(
                                            color: Colors.blueAccent, width: 5),
                                      )
                                    : BoxDecoration(
                                        color: Colors.grey,
                                        borderRadius: BorderRadius.circular(10),
                                        border: Border.all(
                                            color: Colors.white, width: 3),
                                      ),
                                child: Text(
                                  level.name.capitalizeFirst!,
                                  style: const TextStyle(
                                    color: Colors.black,
                                    fontFamily: "Orbitron",
                                    fontWeight: FontWeight.w600,
                                    fontSize: 15,
                                  ),
                                ),
                              )),
                        );
                      }).toList(),
                    ),
                  ),
                  const SizedBox(height: 20),
                  const Text('Select Board Size', style: textStyle),
                  SingleChildScrollView(
                    scrollDirection: Axis.horizontal,
                    child: Row(
                      mainAxisAlignment: MainAxisAlignment.center,
                      children: [4, 9, 16, 25].map((size) {
                        return InkWell(
                          splashColor: Colors.blueAccent,
                          borderRadius: BorderRadius.circular(10),
                          onTap: () => selectedMode.value = size,
                          child: Obx(() => Container(
                                padding: const EdgeInsets.all(10),
                                margin: const EdgeInsets.all(10),
                                decoration: selectedMode.value != null &&
                                        selectedMode.value == size
                                    ? BoxDecoration(
                                        color: Colors.white,
                                        borderRadius: BorderRadius.circular(10),
                                        border: Border.all(
                                            color: Colors.blueAccent, width: 5),
                                      )
                                    : BoxDecoration(
                                        color: Colors.grey,
                                        borderRadius: BorderRadius.circular(10),
                                        border: Border.all(
                                            color: Colors.white, width: 3),
                                      ),
                                child: Text(
                                  '${size}x$size',
                                  style: const TextStyle(
                                    color: Colors.black,
                                    fontFamily: "Orbitron",
                                    fontWeight: FontWeight.w600,
                                    fontSize: 15,
                                  ),
                                ),
                              )),
                        );
                      }).toList(),
                    ),
                  ),
                  const SizedBox(height: 20),
                  const Text('Select A Map', style: textStyle),
                  SizedBox(
                    height: 100,
                    child: SingleChildScrollView(
                      scrollDirection: Axis.horizontal,
                      child: Row(
                        children: List.generate(imagePaths.length, (index) {
                          return GestureDetector(
                            onTap: () =>
                                selectedImageIndex.value = imagePaths[index],
                            child: Obx(() {
                              return Container(
                                margin:
                                    const EdgeInsets.symmetric(horizontal: 10),
                                decoration: BoxDecoration(
                                  border: Border.all(
                                    color: selectedImageIndex.value != null &&
                                            selectedImageIndex.value ==
                                                imagePaths[index]
                                        ? Colors.blue
                                        : Colors.white,
                                    width: 5,
                                  ),
                                ),
                                child: Image.asset(
                                  imagePaths[index],
                                  width: 100,
                                  height: 100,
                                  fit: BoxFit.cover,
                                ),
                              );
                            }),
                          );
                        }),
                      ),
                    ),
                  ),
                  const SizedBox(height: 20),
                  Obx(() => selectedMode.value != null &&
                          selectedLevel.value != null &&
                          selectedImageIndex.value != null
                      ? InkWell(
                          onTap: () => Get.to(() => SudokuGamePlayPage(
                                selectedLevel: selectedLevel.value!,
                                size: selectedMode.value!,
                                map: selectedImageIndex.value!,
                              )),
                          child: Ink(
                            height: 50,
                            width: 100,
                            decoration: BoxDecoration(
                              color: Colors.blueAccent,
                              borderRadius: BorderRadius.circular(10),
                            ),
                            child: const Center(
                              child: Text(
                                "PLAY",
                                style: textStyle,
                              ),
                            ),
                          ),
                        )
                      : Ink(
                          height: 50,
                          width: 100,
                          decoration: BoxDecoration(
                            color: const Color.fromARGB(255, 12, 5, 5),
                            borderRadius: BorderRadius.circular(10),
                          ),
                          child: const Center(
                            child: Text("PLAY", style: textStyle),
                          ),
                        ))
                ],
              ),
            ),
          ),
          Positioned(
            top: 10,
            right: 10,
            child: CyberButton(
              onTap: () {},
              width: 100,
              height: 50,
              primaryColorBigContainer: Colors.redAccent,
              secondaryColorBigContainer: Colors.yellowAccent,
              child: const Text(
                'Menu',
                style: TextStyle(
                  color: Colors.white,
                  fontFamily: "Orbitron",
                  fontWeight: FontWeight.w400,
                ),
              ),
            ),
          ),
          Positioned(
            top: 10,
            left: 10,
            child: CyberButton(
              onTap: () {
                Get.back();
              },
              width: 100,
              height: 50,
              primaryColorBigContainer: Colors.redAccent,
              secondaryColorBigContainer: Colors.yellowAccent,
              child: const Text(
                'Back',
                style: TextStyle(
                  color: Colors.white,
                  fontFamily: "Orbitron",
                  fontWeight: FontWeight.w400,
                ),
              ),
            ),
          )
        ],
      ),
    );
  }
}

```

---


### Pages\GamePage\Console\sodoku_game\sodoku_gameplay_page.dart

```dart
import 'package:cyber_punk_tool_kit_ui/cyber_punk_tool_kit_ui.dart';
import 'package:dotted_border/dotted_border.dart';
import 'package:flutter/material.dart';
import 'package:flutter_animate/flutter_animate.dart';
import 'package:get/get.dart';
import 'package:tictactoe_gameapp/Configs/constants.dart';
import 'package:tictactoe_gameapp/Pages/GamePage/Console/General_Widgets/gaming_button_custom.dart';
import 'package:tictactoe_gameapp/Pages/GamePage/Console/sodoku_game/dynamic_sodoku_controller.dart';

class SudokuGamePlayPage extends StatelessWidget {
  final Levels selectedLevel;
  final int size;
  final String map;

  const SudokuGamePlayPage({
    super.key,
    required this.selectedLevel,
    required this.size,
    required this.map,
  });

  @override
  Widget build(BuildContext context) {
    // final SudokuController controller =
    //     Get.put(SudokuController(selectedLevel: selectedLevel));
    final SudokuGamePlayController controller = Get.put(
        SudokuGamePlayController(selectedLevel: selectedLevel, size: size));
    final width = MediaQuery.of(context).size.width;
    const TextStyle textStyleBig = TextStyle(
      color: Colors.black,
      fontFamily: "Orbitron",
      fontWeight: FontWeight.w600,
      fontSize: 20,
    );
    const TextStyle textStyleMedium = TextStyle(
      color: Colors.white,
      fontFamily: "Orbitron",
      fontWeight: FontWeight.w400,
      fontSize: 16,
    );
    return Scaffold(
      appBar: AppBar(
        title: const Text('Sudoku Game Heroes', style: textStyleBig),
        actions: const [
          Icon(
            Icons.menu_rounded,
            size: 30,
          )
        ],
      ),
      body: Column(
        children: [
          Obx(() {
            if (controller.puzzle.isEmpty || controller.solution.isEmpty) {
              return const Center(child: CircularProgressIndicator());
            }
            return Column(
              children: [
                Container(
                  decoration: BoxDecoration(
                      image: DecorationImage(
                          image: AssetImage(map), fit: BoxFit.fitWidth)),
                  height: width,
                  child: DottedBorder(
                    borderType: BorderType.RRect,
                    color: Colors.blueAccent,
                    strokeWidth: 5,
                    dashPattern: const [10, 5],
                    child: InteractiveViewer(
                      panEnabled: true, // Cho phép kéo thả
                      scaleEnabled: true, // Cho phép phóng to, thu nhỏ
                      minScale: 0.0000000000001, // Tỷ lệ thu nhỏ tối thiểu
                      maxScale: 4.0, // Tỷ lệ phóng to tối đa
                      boundaryMargin: const EdgeInsets.all(double.infinity),
                      child: GridView.builder(
                        shrinkWrap: true,
                        gridDelegate:
                            SliverGridDelegateWithFixedCrossAxisCount(
                          crossAxisCount: size,
                          childAspectRatio: 1,
                        ),
                        physics: const NeverScrollableScrollPhysics(),
                        itemCount: size * size,
                        itemBuilder: (context, index) {
                          final value = controller.puzzle[index];
                          final isEditable = controller.puzzle[index] == -1;
    
                          // Hero được ánh xạ từ số
                          final hero = value == -1
                              ? null
                              : controller.selectedHeroes[value - 1];
    
                          return GestureDetector(
                            onTap: isEditable
                                ? () {
                                    if (controller.selectedHeroIndex.value !=
                                        -1) {
                                      controller.updateCell(
                                          index,
                                          controller.selectedHeroIndex.value +
                                              1);
                                      controller.selectedHeroIndex.value = -1;
                                    } else {
                                      Get.defaultDialog(
                                        title: "Tip",
                                        titleStyle: textStyleBig,
                                        content: const Text(
                                          "Do you want to tip this tile?",
                                          style: TextStyle(
                                              color: Colors.black,
                                              fontFamily: "Orbitron",
                                              fontWeight: FontWeight.w400,
                                              fontSize: 17),
                                        ),
                                        confirm: CyberButton(
                                          onTap: () => controller
                                              .hintForSpecify(index),
                                          primaryColorBigContainer:
                                              Colors.green,
                                          secondaryColorBigContainer:
                                              Colors.blue,
                                          child: const Text(
                                            'Confirm',
                                            style: textStyleMedium,
                                          ),
                                        ),
                                        cancel: CyberButton(
                                          onTap: () {
                                            Get.back();
                                          },
                                          primaryColorBigContainer:
                                              Colors.red,
                                          secondaryColorBigContainer:
                                              Colors.redAccent,
                                          child: const Text(
                                            'Cancel',
                                            style: textStyleMedium,
                                          ),
                                        ),
                                      );
                                    }
                                  }
                                : null,
                            child: Container(
                              margin: const EdgeInsets.all(1),
                              decoration: BoxDecoration(
                                color: isEditable
                                    ? Colors.white.withOpacity(0.4)
                                    : Colors.grey.shade300,
                                border: Border.all(
                                    color: Colors.white.withOpacity(0.6)),
                              ),
                              alignment: Alignment.center,
                              child: hero == null
                                  ? const SizedBox.shrink()
                                  : Image.asset(
                                      hero,
                                      fit: BoxFit.cover,
                                    ),
                            ),
                          )
                              .animate()
                              .scale(duration: duration750)
                              .fadeIn(duration: duration750);
                        },
                      ),
                    ),
                  ),
                ),
                const SizedBox(height: 20),
                SizedBox(
                  height: 70,
                  child: ListView.builder(
                      scrollDirection: Axis.horizontal,
                      itemCount: controller.selectedHeroes.length,
                      itemBuilder: (context, index) {
                        final hero = controller.selectedHeroes[index];
                        return GestureDetector(
                          onTap: () =>
                              controller.selectedHeroIndex.value = index,
                          child: Obx(() {
                            bool isSelected =
                                controller.selectedHeroIndex.value == index;
                            return AnimatedContainer(
                              duration: const Duration(milliseconds: 300),
                              curve: Curves.easeOut,
                              decoration: BoxDecoration(
                                border: Border.all(
                                  color: isSelected
                                      ? Colors.blueAccent
                                      : Colors.transparent,
                                  width: 5,
                                ),
                              ),
                              child: Image.asset(hero),
                            );
                          }),
                        );
                      }),
                )
              ],
            );
          }),
          const SizedBox(
            height: 10,
          ),
          Expanded(
            child: SingleChildScrollView(
              child: Column(
                children: [
                  SizedBox(
                    height: 50,
                    child: Row(
                      mainAxisAlignment: MainAxisAlignment.center,
                      children: [
                        CircularGamingButton(
                          icon: Icons.undo_rounded,
                          onPressed: controller.undo,
                        ),
                        const SizedBox(
                          width: 20,
                        ),
                        CircularGamingButton(
                          icon: Icons.tips_and_updates_rounded,
                          onPressed: controller.hintForRandom,
                        ),
                        const SizedBox(
                          width: 20,
                        ),
                        CircularGamingButton(
                          icon: Icons.redo_rounded,
                          onPressed: controller.redo,
                        ),
                      ],
                    ),
                  ),
                  const SizedBox(
                    height: 10,
                  ),
                  Column(
                    mainAxisAlignment: MainAxisAlignment.center,
                    children: [
                      CyberButton(
                        onTap: controller.generateNewGame,
                        width: 200,
                        height: 50,
                        primaryColorBigContainer: Colors.orange,
                        secondaryColorBigContainer: Colors.purple,
                        child: const Text(
                          'New Game',
                          style: textStyleMedium,
                        ),
                      ),
                      const SizedBox(
                        height: 10,
                      ),
                      SingleChildScrollView(
                        scrollDirection: Axis.horizontal,
                        child: Row(
                          mainAxisAlignment: MainAxisAlignment.spaceAround,
                          children: [
                            CyberButton(
                              onTap: controller.solveSudoku,
                              width: 200,
                              height: 50,
                              primaryColorBigContainer: Colors.greenAccent,
                              secondaryColorBigContainer: Colors.blueAccent,
                              child: const Text(
                                'Solve',
                                style: textStyleMedium,
                              ),
                            ),
                            CyberButton(
                              onTap: () {
                                controller.checkCompletion();
                                if (controller.isSolved.value) {
                                  Get.snackbar(
                                      'Success', 'You solved the Sudoku!');
                                } else {
                                  Get.snackbar('Incomplete',
                                      'The Sudoku is not solved yet.');
                                }
                              },
                              width: 200,
                              height: 50,
                              primaryColorBigContainer: Colors.redAccent,
                              secondaryColorBigContainer: Colors.yellowAccent,
                              child: const Text(
                                'Check',
                                style: textStyleMedium,
                              ),
                            ),
                          ],
                        ),
                      )
                    ],
                  ),
                ],
              ),
            ),
          ),
        ],
      ),
    );
  }
}

```

---


### Pages\GamePage\PlayerGame\body_multi_player.dart

```dart
import 'package:flutter/material.dart';
import 'package:flutter_svg/svg.dart';
import 'package:get/get.dart';
import 'package:tictactoe_gameapp/Components/ingame_user_card.dart';
import 'package:tictactoe_gameapp/Configs/assets_path.dart';
import 'package:tictactoe_gameapp/Models/room_model.dart';
import 'package:tictactoe_gameapp/Controller/Console/play_with_player_controller.dart';
import 'package:tictactoe_gameapp/Models/user_model.dart';
import 'package:tictactoe_gameapp/Pages/GamePage/PlayerGame/ui_playing_multi_board.dart';

class BodyMultiPlayer extends StatelessWidget {
  final String roomId;
  final PlayWithPlayerController playWithPlayerController;
  final UserModel userModel;
  const BodyMultiPlayer({
    super.key,
    required this.roomId,
    required this.playWithPlayerController,
    required this.userModel,
  });

  @override
  Widget build(BuildContext context) {
    final colorScheme = Theme.of(context).colorScheme;
    final w = MediaQuery.of(context).size.width;
    final UiPlayingMultiPlayerBoard uiPlayingMultiPlayerBoard =
        UiPlayingMultiPlayerBoard();

    return Obx(() {
      final RoomModel? roomData = playWithPlayerController.roomModel.value;
      if (roomData == null) {
        return Column(
          children: [
            const Center(
              child: CircularProgressIndicator(
                strokeWidth: 5.0,
                color: Colors.blueAccent,
              ),
            ),
            const SizedBox(
              height: 20,
            ),
            Text(
              "No data",
              style: Theme.of(context).textTheme.headlineLarge,
            ),
          ],
        );
      }
      WidgetsBinding.instance.addPostFrameCallback((_) {
        // await Future.delayed(const Duration(seconds: 2));
        if (roomData.winnerVariable != "" &&
            roomData.player1 != null &&
            roomData.player2 != null) {
          if (roomData.winnerVariable == "X" &&
              roomData.player1!.email == userModel.email) {
            playWithPlayerController.winnerDialog(
                roomData.winnerVariable!, roomData);
          } else if (roomData.winnerVariable == "O" &&
              roomData.player2!.email == userModel.email) {
            playWithPlayerController.winnerDialog(
                roomData.winnerVariable!, roomData);
          } else {
            playWithPlayerController.defeatDialog(
                roomData.winnerVariable!, roomData);
          }
        }
        if (roomData.player1 != null && roomData.player2 != null) {
          if (roomData.player1!.quickMess != null ||
              roomData.player2!.quickMess != null) {
            playWithPlayerController.removeMessage(roomData);
          }
        }
        if (roomData.player1 != null && roomData.player2 != null) {
          if (roomData.player1!.quickEmote != null ||
              roomData.player2!.quickEmote != null) {
            playWithPlayerController.removeEmote(roomData);
          }
        }
      });

      return Column(
        children: [
          const SizedBox(height: 50),
          Row(
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            children: [
              roomData.player1 != null
                  ? Column(
                      children: [
                        Stack(
                          clipBehavior: Clip.none,
                          children: [
                            InGameUserCard(
                              icon: IconsPath.xIcon,
                              name: roomData.player1!.name!,
                              imageUrl: roomData.player1!.image!,
                              color:
                                  roomData.isXturn! ? Colors.red : Colors.white,
                              coins: roomData.player1!.totalCoins ?? "0",
                            ),
                            roomData.player1!.quickMess != null
                                ? Positioned(
                                    right: -20,
                                    child: Container(
                                      height: 100,
                                      width: 100,
                                      alignment: Alignment.center,
                                      padding: const EdgeInsets.all(12.0),
                                      decoration: BoxDecoration(
                                        color: Colors.red.withOpacity(0.9),
                                        borderRadius: const BorderRadius.only(
                                          topRight: Radius.circular(30),
                                          bottomLeft: Radius.circular(30),
                                          bottomRight: Radius.circular(30),
                                        ),
                                        boxShadow: const [
                                          BoxShadow(
                                            color: Colors.black12,
                                            blurRadius: 4,
                                            offset: Offset(2, 2),
                                          ),
                                        ],
                                      ),
                                      child: SingleChildScrollView(
                                        child: Text(
                                          roomData.player1!.quickMess ?? "",
                                          style: const TextStyle(
                                            color: Colors.white,
                                            fontSize: 14,
                                          ),
                                        ),
                                      ),
                                    ),
                                  )
                                : const SizedBox(),
                            roomData.player1!.quickEmote != null
                                ? Positioned(
                                    right: -20,
                                    child: Container(
                                      height: 100,
                                      width: 100,
                                      alignment: Alignment.center,
                                      padding: const EdgeInsets.all(12.0),
                                      decoration: BoxDecoration(
                                        color: Colors.red.withOpacity(0.9),
                                        borderRadius: const BorderRadius.only(
                                          topRight: Radius.circular(50),
                                          bottomLeft: Radius.circular(50),
                                          bottomRight: Radius.circular(50),
                                        ),
                                        boxShadow: const [
                                          BoxShadow(
                                            color: Colors.black12,
                                            blurRadius: 4,
                                            offset: Offset(2, 2),
                                          ),
                                        ],
                                      ),
                                      child: ClipRRect(
                                        borderRadius:
                                            BorderRadius.circular(100),
                                        child: Image.asset(
                                          roomData.player1!.quickEmote!,
                                          width: 70,
                                        ),
                                      ),
                                    ),
                                  )
                                : const SizedBox(),
                          ],
                        ),
                        const SizedBox(height: 10),
                        Container(
                          padding: const EdgeInsets.symmetric(
                              vertical: 5, horizontal: 5),
                          decoration: BoxDecoration(
                            color:
                                Theme.of(context).colorScheme.primaryContainer,
                            borderRadius: BorderRadius.circular(10),
                          ),
                          child: Column(
                            children: [
                              Row(
                                children: [
                                  SvgPicture.asset(
                                    IconsPath.wonIcon,
                                  ),
                                  const SizedBox(width: 10),
                                  Text("WON : ${roomData.player1!.totalWins}")
                                ],
                              ),
                              const SizedBox(height: 10),
                              Row(
                                children: [
                                  IconButton(
                                    onPressed: () {
                                      playWithPlayerController
                                          .chatFeature(context);
                                    },
                                    icon: const Icon(Icons.messenger_outline),
                                  ),
                                  IconButton(
                                    onPressed: () {},
                                    icon: const Icon(Icons.mic_none),
                                  ),
                                  IconButton(
                                    onPressed: () {
                                      playWithPlayerController.emoteFeature(
                                          context, roomData);
                                    },
                                    icon: const Icon(
                                        Icons.emoji_emotions_outlined),
                                  ),
                                ],
                              ),
                            ],
                          ),
                        )
                      ],
                    )
                  : Column(
                      children: [
                        IconButton(
                          onPressed: () {
                            Get.toNamed("mainHome");
                          },
                          icon: const Icon(
                            Icons.arrow_back_rounded,
                            size: 35,
                          ),
                        ),
                        const Text("Leave the room")
                      ],
                    ),
              roomData.player2 != null
                  ? Column(
                      children: [
                        Stack(
                          clipBehavior: Clip.none,
                          children: [
                            InGameUserCard(
                              icon: IconsPath.oIcon,
                              name: roomData.player2!.name!,
                              imageUrl: roomData.player2!.image!,
                              color: roomData.isXturn!
                                  ? Colors.white
                                  : Colors.blue,
                              coins: roomData.player2!.totalCoins??"0",
                            ),
                            roomData.player2!.quickMess != null
                                ? Positioned(
                                    left: -20,
                                    child: Container(
                                      height: 100,
                                      width: 100,
                                      alignment: Alignment.center,
                                      padding: const EdgeInsets.all(12.0),
                                      decoration: BoxDecoration(
                                        color: Colors.blue.withOpacity(0.9),
                                        borderRadius: const BorderRadius.only(
                                          topLeft: Radius.circular(30),
                                          bottomLeft: Radius.circular(30),
                                          bottomRight: Radius.circular(30),
                                        ),
                                        boxShadow: const [
                                          BoxShadow(
                                            color: Colors.black12,
                                            blurRadius: 4,
                                            offset: Offset(2, 2),
                                          ),
                                        ],
                                      ),
                                      child: SingleChildScrollView(
                                        child: Text(
                                          roomData.player2!.quickMess ?? "",
                                          style: const TextStyle(
                                            color: Colors.white,
                                            fontSize: 14,
                                          ),
                                        ),
                                      ),
                                    ),
                                  )
                                : const SizedBox(),
                            roomData.player2!.quickEmote != null
                                ? Positioned(
                                    left: -20,
                                    child: Container(
                                      height: 100,
                                      width: 100,
                                      alignment: Alignment.center,
                                      padding: const EdgeInsets.all(12.0),
                                      decoration: BoxDecoration(
                                        color: Colors.blue.withOpacity(0.9),
                                        borderRadius: const BorderRadius.only(
                                          topLeft: Radius.circular(50),
                                          bottomLeft: Radius.circular(50),
                                          bottomRight: Radius.circular(50),
                                        ),
                                        boxShadow: const [
                                          BoxShadow(
                                            color: Colors.black12,
                                            blurRadius: 4,
                                            offset: Offset(2, 2),
                                          ),
                                        ],
                                      ),
                                      child: ClipRRect(
                                        borderRadius:
                                            BorderRadius.circular(100),
                                        child: Image.asset(
                                          roomData.player2!.quickEmote!,
                                          width: 70,
                                        ),
                                      ),
                                    ),
                                  )
                                : const SizedBox(),
                          ],
                        ),
                        const SizedBox(height: 10),
                        Container(
                          padding: const EdgeInsets.symmetric(
                              vertical: 5, horizontal: 5),
                          decoration: BoxDecoration(
                            color:
                                Theme.of(context).colorScheme.primaryContainer,
                            borderRadius: BorderRadius.circular(10),
                          ),
                          child: Column(
                            children: [
                              Row(
                                children: [
                                  SvgPicture.asset(
                                    IconsPath.wonIcon,
                                  ),
                                  const SizedBox(width: 10),
                                  Text("WON : ${roomData.player2!.totalWins}")
                                ],
                              ),
                              const SizedBox(height: 10),
                              Row(
                                children: [
                                  IconButton(
                                    onPressed: () {
                                      playWithPlayerController
                                          .chatFeature(context);
                                    },
                                    icon: const Icon(Icons.messenger_outline),
                                  ),
                                  IconButton(
                                    onPressed: () {},
                                    icon: const Icon(Icons.mic_none),
                                  ),
                                  IconButton(
                                    onPressed: () {
                                      playWithPlayerController.emoteFeature(
                                          context, roomData);
                                    },
                                    icon: const Icon(
                                        Icons.emoji_emotions_outlined),
                                  ),
                                ],
                              ),
                            ],
                          ),
                        )
                      ],
                    )
                  : Column(
                      children: [
                        IconButton(
                          onPressed: () {
                            Get.toNamed("mainHome");
                          },
                          icon: const Icon(
                            Icons.arrow_back_rounded,
                            size: 35,
                          ),
                        ),
                        const Text("Leave the room")
                      ],
                    ),
            ],
          ),
          const SizedBox(height: 10),
          uiPlayingMultiPlayerBoard.buildGameBoard(
              w,
              playWithPlayerController,
              context,
              roomId,
              roomData,
              playWithPlayerController.board.length,
              userModel),
          const SizedBox(height: 10),
          uiPlayingMultiPlayerBoard.buildTurnIndicator(
            colorScheme,
            roomData,
            playWithPlayerController,
          ),
        ],
      );
    });
  }
}

```

---


### Pages\GamePage\PlayerGame\multi_player.dart

```dart
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:tictactoe_gameapp/Controller/profile_controller.dart';
import 'package:tictactoe_gameapp/Pages/GamePage/PlayerGame/body_multi_player.dart';
import 'package:tictactoe_gameapp/Controller/Console/play_with_player_controller.dart';

class MultiPlayer extends StatelessWidget {
  final String roomId;
  const MultiPlayer({super.key, required this.roomId});

  @override
  Widget build(BuildContext context) {
    final PlayWithPlayerController playWithPlayerController =
        Get.put<PlayWithPlayerController>(PlayWithPlayerController());
    playWithPlayerController.getRoomDetails(roomId);
    final ProfileController profileController = Get.put<ProfileController>(ProfileController());
    final user = profileController.user!;
    // final MusicController musicController = Get.find();
    // WidgetsBinding.instance.addPostFrameCallback((_) {
    //   musicController.stopMusicOnScreen7();
    // });
    return Scaffold(
      body: SafeArea(
        child: Padding(
          padding: const EdgeInsets.all(10),
          child: SingleChildScrollView(
            child: BodyMultiPlayer(
              roomId: roomId,
              playWithPlayerController: playWithPlayerController,
              userModel: user,
            ),
          ),
        ),
      ),
    );
  }
}

```

---


### Pages\GamePage\PlayerGame\ui_playing_multi_board.dart

```dart
import 'package:dotted_border/dotted_border.dart';
import 'package:flutter/material.dart';
import 'package:flutter_animate/flutter_animate.dart';
import 'package:tictactoe_gameapp/Configs/constants.dart';
import 'package:tictactoe_gameapp/Configs/messages.dart';
import 'package:tictactoe_gameapp/Models/room_model.dart';
import 'package:tictactoe_gameapp/Models/user_model.dart';
import 'package:tictactoe_gameapp/Pages/GamePage/Widgets/core/line_painter.dart';
import 'package:tictactoe_gameapp/Controller/Console/play_with_player_controller.dart';

class UiPlayingMultiPlayerBoard {
  Widget buildGameBoard(
    double width,
    PlayWithPlayerController controller,
    BuildContext context,
    String roomId,
    RoomModel roomData,
    int gridSize,
    UserModel user,
  ) {
    return DottedBorder(
      borderType: BorderType.RRect,
      color: Theme.of(context).colorScheme.primary,
      padding: const EdgeInsets.all(3),
      strokeWidth: 5,
      dashPattern: const [10, 5],
      radius: const Radius.circular(20),
      child: Stack(
        children: [
          ClipRRect(
            borderRadius: BorderRadius.circular(20),
            child: Image.asset(roomData.pickedMap!),
          ),
          Container(
            alignment: Alignment.center,
            margin: const EdgeInsets.all(5),
            width: width,
            height: width - 33,
            decoration: BoxDecoration(
              color: Colors.transparent,
              borderRadius: BorderRadius.circular(20),
            ),
            child: Stack(
              children: [
                InteractiveViewer(
                  panEnabled: true,
                  scaleEnabled: true,
                  minScale: 0.0000000000001,
                  maxScale: 4.0,
                  boundaryMargin: const EdgeInsets.all(double.infinity),
                  child: SizedBox(
                    width: gridSize * 50,
                    height: gridSize * 50,
                    child: GridView.builder(
                      physics: const NeverScrollableScrollPhysics(),
                      gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(
                        crossAxisCount: gridSize,
                        childAspectRatio: 1.0,
                      ),
                      itemCount: gridSize * gridSize,
                      itemBuilder: (context, index) {
                        int row = index ~/ gridSize;
                        int col = index % gridSize;
                        // Xác định xem người chơi là player1 hay player2
                        bool isPlayer1 = (roomData.player1 != null
                                ? roomData.player1!.email
                                : "") ==
                            user.email;
                        bool isPlayer2 = (roomData.player2 != null
                                ? roomData.player2!.email
                                : "") ==
                            user.email;
                        bool isPlayerTurn = (controller.isXtime.value &&
                                roomData.isXturn! &&
                                isPlayer1) ||
                            (!controller.isXtime.value &&
                                !roomData.isXturn! &&
                                isPlayer2);
                        bool isDisabled =
                            controller.board[row][col] != '' || !isPlayerTurn;
                        return InkWell(
                          onTap: () async {
                            if (!isDisabled) {
                              await controller.updateData(roomData, row, col);
                            } else {
                              errorMessage(
                                  'This cell is disabled or not your turn');
                            }
                          },
                          child: Container(
                            margin: const EdgeInsets.all(0.5),
                            decoration: BoxDecoration(
                              color: _getTileColor(
                                controller,
                                row,
                                col,
                                context,
                              ),
                              // borderRadius: _getBorderRadius(index, gridSize),
                            ),
                            child: Center(
                              child: _buildTileContent(
                                controller.board[row][col],
                                context,
                                roomData,
                              ),
                            ),
                          ),
                        );
                      },
                    ),
                  ),
                ),
                // if (roomData.winnerVariable != '')
                //   CustomPaint(
                //     painter: LinePainter(
                //         controller.winningLineCoordinates,
                //         gridSize,
                //         roomData.winnerVariable == 'X'
                //             ? Colors.lightBlueAccent
                //             : Colors.yellowAccent),
                //     size: Size(gridSize * 50, gridSize * 50),
                //   ),
              ],
            ),
          ),
        ],
      ),
    );
  }

  Color _getTileColor(PlayWithPlayerController controller, int row, int col,
      BuildContext context) {
    String value = controller.board[row][col];
    if (value == "X") {
      return Theme.of(context).colorScheme.primary.withOpacity(0.3);
    } else if (value == "O") {
      return Theme.of(context).colorScheme.secondary.withOpacity(0.3);
    } else {
      return Theme.of(context).colorScheme.primaryContainer.withOpacity(0.6);
    }
  }

  Widget _buildTileContent(
    String value,
    BuildContext context,
    RoomModel roomData,
  ) {
    if (value == "X") {
      return Image.asset(roomData.champX!).animate().fadeIn(duration: duration750);
    } else if (value == "O") {
      return Image.asset(roomData.champO!).animate().scale(duration: duration750);
    } else {
      return const SizedBox();
    }
  }

  Widget buildTurnIndicator(
    ColorScheme colorScheme,
    RoomModel roomData,
    PlayWithPlayerController controller,
  ) {
    return Row(
      mainAxisAlignment: MainAxisAlignment.center,
      children: [
        AnimatedContainer(
          duration: const Duration(milliseconds: 500),
          padding: const EdgeInsets.symmetric(vertical: 10, horizontal: 10),
          decoration: BoxDecoration(
            color: controller.isXtime.value
                ? colorScheme.primary.withOpacity(0.5)
                : colorScheme.secondary,
            borderRadius: BorderRadius.circular(20),
            border: Border.all(
              color: controller.isXtime.value ? Colors.red : Colors.blue,
              width: 5,
            ),
          ),
          child: Row(
            children: [
              controller.isXtime.value
                  ? Image.asset(
                      roomData.champX!,
                      width: 40,
                      height: 40,
                    )
                  : Container(
                      width: 40,
                      height: 40,
                      decoration: const BoxDecoration(color: Colors.blueGrey),
                    ),
              const SizedBox(width: 10),
              controller.isXtime.value
                  ? Container(
                      width: 40,
                      height: 40,
                      decoration: const BoxDecoration(color: Colors.blueGrey),
                    )
                  : Image.asset(
                      roomData.champO!,
                      width: 40,
                      height: 40,
                    ),
            ],
          ),
        ),
      ],
    );
  }
}

```

---


### Pages\GamePage\Shop\shop_page.dart

```dart
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:tictactoe_gameapp/Configs/assets_path.dart';
import 'package:tictactoe_gameapp/Pages/GamePage/Shop/Widgets/champions_page.dart';
import 'package:tictactoe_gameapp/Pages/GamePage/Shop/Widgets/emotes_page.dart';
import 'package:tictactoe_gameapp/Pages/GamePage/Shop/Widgets/maps_page.dart';
import 'package:tictactoe_gameapp/Components/customized_widgets/draggble_fab_widget.dart';

class ShopPage extends StatelessWidget {
  const ShopPage({super.key});

  @override
  Widget build(BuildContext context) {
    return DefaultTabController(
      length: 4,
      child: Scaffold(
        appBar: AppBar(
          leading: IconButton(
              onPressed: () => Get.back(),
              icon: const Icon(
                Icons.arrow_back_ios_new_rounded,
                size: 30,
              )),
          title: const TabBar(
            labelColor: Colors.blueAccent,
            unselectedLabelColor: Colors.black,
            indicatorSize: TabBarIndicatorSize.tab,
            indicatorWeight: 5,
            indicatorColor: Colors.white,
            tabs: [
              Tab(icon: Icon(Icons.person_4), text: 'Champions'),
              Tab(icon: Icon(Icons.map), text: 'Maps'),
              Tab(icon: Icon(Icons.emoji_emotions), text: 'Emotes'),
              Tab(icon: Icon(Icons.emoji_events), text: '?'),
            ],
          ),
        ),
        body: Stack(
          children: [
            const TabBarView(
              children: [
                ChampionsPage(),
                MapsPage(),
                EmotesPage(),
                EmotesPage(),
                // EmotesPage(),
              ],
            ),
            DraggableFloatingActionButton(
              child: ClipRRect(
                  borderRadius: BorderRadius.circular(100),
                  child: Image.asset(GifsPath.chloe1)),
            ),
            // DraggableFloatingActionButton(
            //   child: const Icon(
            //     Icons.shopping_cart_rounded,
            //     color: Colors.white,
            //     size: 30,
            //   ),
            //   onPressed: () {
            //     printInfo(info: "hi");
            //   },
            // ),
          ],
        ),
      ),
    );
  }
}

```

---


### Pages\GamePage\Shop\Widgets\champions_page.dart

```dart
import 'package:flutter/material.dart';
import 'package:flutter_svg/svg.dart';
import 'package:get/get.dart';
import 'package:tictactoe_gameapp/Configs/assets_path.dart';
import 'package:tictactoe_gameapp/Configs/constants.dart';
import 'package:tictactoe_gameapp/Models/Functions/gradient_generator_functions.dart';
import 'package:tictactoe_gameapp/Models/champion_model.dart';

class ChampionsPage extends StatelessWidget {
  const ChampionsPage({super.key});

  @override
  Widget build(BuildContext context) {
    return Scrollbar(
      thickness: 10.0,
      child: Container(
        width: double.infinity,
        height: double.infinity,
        decoration: BoxDecoration(
          gradient: LinearGradient(
            colors: GradientGeneratorFunctions.getDynamicRandomGradientColors(),
            begin: Alignment.topLeft,
            end: Alignment.bottomRight,
          ),
        ),
        child: GridView.builder(
          scrollDirection: Axis.vertical,
          physics: const BouncingScrollPhysics(),
          gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(
            crossAxisCount: 3,
            mainAxisSpacing: 40,
            crossAxisSpacing: 20,
            childAspectRatio: 0.6,
          ),
          itemCount: listChampions.length,
          itemBuilder: (context, index) {
            return Column(
              children: [
                GestureDetector(
                  onTap: () {},
                  child: Container(
                    decoration: BoxDecoration(
                      border: Border.all(
                        color: Colors.blue,
                        width: 5,
                      ),
                    ),
                    child: Image.asset(
                      listChampions[index],
                      fit: BoxFit.cover,
                      width: 100,
                      height: 100,
                    ),
                  ),
                ),
                const SizedBox(
                  height: 5,
                ),
                Text(
                  ChampionModel.capitalize(listChampName[index + 1]),
                  style: Theme.of(context)
                      .textTheme
                      .bodyLarge!
                      .copyWith(color: Colors.white),
                ),
                const SizedBox(
                  height: 5,
                ),
                Container(
                  height: 40,
                  width: 120,
                  padding: const EdgeInsets.all(5.0),
                  decoration: BoxDecoration(
                    color: Colors.blueGrey,
                    borderRadius: BorderRadius.circular(20),
                  ),
                  child: Row(
                    mainAxisAlignment: MainAxisAlignment.spaceEvenly,
                    children: [
                      const Text(
                        "999 Coins",
                        style: TextStyle(
                          color: Colors.yellowAccent,
                          fontSize: 14,
                        ),
                      ),
                      SvgPicture.asset(IconsPath.coinIcon),
                    ],
                  ),
                )
              ],
            );
          },
        ),
      ),
    );
  }
}

```

---


### Pages\GamePage\Shop\Widgets\emotes_page.dart

```dart
import 'package:flutter/material.dart';
import 'package:flutter_svg/svg.dart';
import 'package:tictactoe_gameapp/Configs/assets_path.dart';
import 'package:tictactoe_gameapp/Configs/constants.dart';
import 'package:tictactoe_gameapp/Models/Functions/gradient_generator_functions.dart';

class EmotesPage extends StatelessWidget {
  const EmotesPage({super.key});

  @override
  Widget build(BuildContext context) {
    return Scrollbar(
      thickness: 10.0,
      child: Container(
        width: double.infinity,
        height: double.infinity,
        decoration: BoxDecoration(
          gradient: LinearGradient(
            colors: GradientGeneratorFunctions.getDynamicRandomGradientColors(),
            begin: Alignment.topLeft,
            end: Alignment.bottomRight,
          ),
        ),
        child: GridView.builder(
          scrollDirection: Axis.vertical,
          physics: const BouncingScrollPhysics(),
          gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(
            crossAxisCount: 3,
            mainAxisSpacing: 40,
            crossAxisSpacing: 20,
            childAspectRatio: 0.6,
          ),
          itemCount: emotes.length,
          itemBuilder: (context, index) {
            return Column(
              children: [
                GestureDetector(
                  onTap: () {},
                  child: Container(
                    decoration: BoxDecoration(
                      border: Border.all(
                        color: Colors.blue,
                        width: 5,
                      ),
                    ),
                    child: Image.asset(
                      emotes[index],
                      fit: BoxFit.cover,
                      width: 100,
                      height: 100,
                    ),
                  ),
                ),
                const SizedBox(
                  height: 5,
                ),
                Text(
                  "Emotes ${index + 1}",
                  style: Theme.of(context)
                      .textTheme
                      .bodyLarge!
                      .copyWith(color: Colors.white),
                ),
                const SizedBox(
                  height: 5,
                ),
                Container(
                  height: 40,
                  width: 120,
                  padding: const EdgeInsets.all(5.0),
                  decoration: BoxDecoration(
                    color: Colors.blueGrey,
                    borderRadius: BorderRadius.circular(20),
                  ),
                  child: Row(
                    mainAxisAlignment: MainAxisAlignment.spaceEvenly,
                    children: [
                      const Text(
                        "200 Coins",
                        style: TextStyle(
                          color: Colors.yellowAccent,
                          fontSize: 14,
                        ),
                      ),
                      SvgPicture.asset(IconsPath.coinIcon),
                    ],
                  ),
                )
              ],
            );
          },
        ),
      ),
    );
  }
}

```

---


### Pages\GamePage\Shop\Widgets\maps_page.dart

```dart
import 'package:flutter/material.dart';
import 'package:flutter_svg/svg.dart';
import 'package:tictactoe_gameapp/Configs/assets_path.dart';
import 'package:tictactoe_gameapp/Configs/constants.dart';
import 'package:tictactoe_gameapp/Models/Functions/gradient_generator_functions.dart';

class MapsPage extends StatelessWidget {
  const MapsPage({super.key});

  @override
  Widget build(BuildContext context) {
    return Scrollbar(
      thickness: 10.0,
      child: Container(
        width: double.infinity,
        height: double.infinity,
        decoration: BoxDecoration(
          gradient: LinearGradient(
            colors: GradientGeneratorFunctions.getDynamicRandomGradientColors(),
            begin: Alignment.topLeft,
            end: Alignment.bottomRight,
          ),
        ),
        child: GridView.builder(
          scrollDirection: Axis.vertical,
          physics: const BouncingScrollPhysics(),
          gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(
            crossAxisCount: 3,
            mainAxisSpacing: 40,
            crossAxisSpacing: 20,
            childAspectRatio: 0.6,
          ),
          itemCount: imagePaths.length,
          itemBuilder: (context, index) {
            return Column(
              children: [
                GestureDetector(
                  onTap: () {},
                  child: Container(
                    decoration: BoxDecoration(
                      border: Border.all(
                        color: Colors.blue,
                        width: 5,
                      ),
                    ),
                    child: Image.asset(
                      imagePaths[index],
                      fit: BoxFit.cover,
                      width: 100,
                      height: 100,
                    ),
                  ),
                ),
                const SizedBox(
                  height: 5,
                ),
                Text(
                  "Arena ${index + 1}",
                  style: Theme.of(context)
                      .textTheme
                      .bodyLarge!
                      .copyWith(color: Colors.white),
                ),
                const SizedBox(
                  height: 5,
                ),
                Container(
                  height: 40,
                  width: 120,
                  padding: const EdgeInsets.all(5.0),
                  decoration: BoxDecoration(
                    color: Colors.blueGrey,
                    borderRadius: BorderRadius.circular(20),
                  ),
                  child: Row(
                    mainAxisAlignment: MainAxisAlignment.spaceEvenly,
                    children: [
                      const Text(
                        "888 Coins",
                        style: TextStyle(
                          color: Colors.yellowAccent,
                          fontSize: 14,
                        ),
                      ),
                      SvgPicture.asset(IconsPath.coinIcon),
                    ],
                  ),
                )
              ],
            );
          },
        ),
      ),
    );
  }
}

```

---


### Pages\GamePage\SingleGame\play_with_bot_page.dart

```dart
import 'package:cached_network_image/cached_network_image.dart';
import 'package:flutter/material.dart';
import 'package:flutter_svg/flutter_svg.dart';
import 'package:get/get.dart';
import 'package:tictactoe_gameapp/Controller/Music/background_music_controller.dart';
import 'package:tictactoe_gameapp/Controller/Console/play_with_bot_controller.dart';
import 'package:tictactoe_gameapp/Controller/profile_controller.dart';
import 'package:tictactoe_gameapp/Pages/GamePage/SingleGame/ui_playing_board.dart';
import '../../../Configs/assets_path.dart';

class PlayWithBotPage extends StatelessWidget {
  const PlayWithBotPage({super.key});

  @override
  Widget build(BuildContext context) {
    final UiPlayingBoard uiPlayingBoard = UiPlayingBoard();
    final w = MediaQuery.of(context).size.width;
    final colorScheme = Theme.of(context).colorScheme;
    final PlayWithBotController controller = Get.put(PlayWithBotController());
    // final DottedBorderAnimationController animationController =
    //     Get.put(DottedBorderAnimationController());
    final user = Get.find<ProfileController>().user!;
    final BackgroundMusicController musicController = Get.find();
    WidgetsBinding.instance.addPostFrameCallback((_) {
      musicController.playMusicOnScreen6();
    });

    return Scaffold(
      resizeToAvoidBottomInset: true,
      body: SafeArea(
        child: Padding(
          padding: const EdgeInsets.all(10),
          child: SingleChildScrollView(
            child: Column(
              children: [
                Row(
                  mainAxisAlignment: MainAxisAlignment.spaceBetween,
                  children: [
                    Obx(
                      () => Container(
                        padding: const EdgeInsets.all(7),
                        decoration: BoxDecoration(
                          borderRadius: BorderRadius.circular(20),
                          border: controller.isXtime.value
                              ? Border.all(
                                  color: Colors.red,
                                  width: 7,
                                )
                              : Border.all(),
                        ),
                        child: Column(
                          children: [
                            CircleAvatar(
                              radius: 40,
                              child:
                                  user.image != null && user.image!.isNotEmpty
                                      ? CircleAvatar(
                                          backgroundImage:
                                              CachedNetworkImageProvider(
                                                  user.image!),
                                          maxRadius: 55,
                                        )
                                      : const Icon(Icons.person_2_outlined),
                            ),
                            const SizedBox(height: 10),
                            Container(
                              padding: const EdgeInsets.symmetric(
                                  vertical: 10, horizontal: 45),
                              decoration: BoxDecoration(
                                color: colorScheme.primary,
                                borderRadius: BorderRadius.circular(10),
                              ),
                              child: SvgPicture.asset(IconsPath.xIcon),
                            ),
                            const SizedBox(height: 10),
                            Container(
                              padding: const EdgeInsets.symmetric(
                                  vertical: 10, horizontal: 25),
                              decoration: BoxDecoration(
                                color: colorScheme.primaryContainer,
                                borderRadius: BorderRadius.circular(10),
                              ),
                              child: Row(
                                children: [
                                  SvgPicture.asset(
                                    IconsPath.wonIcon,
                                  ),
                                  const SizedBox(width: 10),
                                  Obx(
                                    () => Text("WON : ${controller.xScore}"),
                                  )
                                ],
                              ),
                            )
                          ],
                        ),
                      ),
                    ),
                    Obx(
                      () => Container(
                        padding: const EdgeInsets.all(7),
                        decoration: BoxDecoration(
                          borderRadius: BorderRadius.circular(20),
                          border: !controller.isXtime.value
                              ? Border.all(
                                  color: Colors.orange,
                                  width: 7,
                                )
                              : Border.all(),
                        ),
                        child: Column(
                          children: [
                            const CircleAvatar(
                              backgroundImage: AssetImage(GifsPath.androidGif),
                              radius: 40,
                            ),
                            const SizedBox(height: 10),
                            Container(
                              padding: const EdgeInsets.symmetric(
                                  vertical: 10, horizontal: 45),
                              decoration: BoxDecoration(
                                color: colorScheme.primary,
                                borderRadius: BorderRadius.circular(10),
                              ),
                              child: SvgPicture.asset(IconsPath.oIcon),
                            ),
                            const SizedBox(height: 10),
                            Container(
                              padding: const EdgeInsets.symmetric(
                                  vertical: 10, horizontal: 25),
                              decoration: BoxDecoration(
                                color: colorScheme.primaryContainer,
                                borderRadius: BorderRadius.circular(10),
                              ),
                              child: Row(
                                children: [
                                  SvgPicture.asset(
                                    IconsPath.wonIcon,
                                  ),
                                  const SizedBox(width: 10),
                                  Obx(
                                    () => Text("WON : ${controller.oScore}"),
                                  ),
                                ],
                              ),
                            )
                          ],
                        ),
                      ),
                    ),
                  ],
                ),
                const SizedBox(height: 30),
                uiPlayingBoard.buildGameBoard(w, controller, context),
                const SizedBox(height: 10),
                uiPlayingBoard.buildTurnIndicator(colorScheme, controller),
              ],
            ),
          ),
        ),
      ),
    );
  }
}

```

---


### Pages\GamePage\SingleGame\ui_playing_board.dart

```dart
import 'package:dotted_border/dotted_border.dart';
import 'package:flutter/material.dart';
import 'package:flutter_animate/flutter_animate.dart';
import 'package:get/get.dart';
import 'package:tictactoe_gameapp/Controller/Console/play_with_bot_controller.dart';
import 'package:tictactoe_gameapp/Pages/GamePage/Widgets/core/line_painter.dart';

class UiPlayingBoard {
  Widget buildGameBoard(
      double width, PlayWithBotController controller, BuildContext context) {
    return DottedBorder(
      borderType: BorderType.RRect,
      color: Theme.of(context).colorScheme.primary,
      padding: const EdgeInsets.all(3),
      strokeWidth: 5,
      dashPattern: const [10, 5],
      radius: const Radius.circular(20),
      child: Stack(
        children: [
          ClipRRect(
            borderRadius: BorderRadius.circular(20),
            child: Image.asset(controller.selectedImagePath.value),
          ),
          Container(
            alignment: Alignment.center,
            margin: const EdgeInsets.all(5),
            width: width,
            height: width - 33,
            decoration: BoxDecoration(
              color: Colors.transparent,
              borderRadius: BorderRadius.circular(20),
            ),
            child: Obx(
              () {
                int gridSize = controller.board.length;

                return Stack(
                  children: [
                    InteractiveViewer(
                      panEnabled: true, // Cho phép kéo thả
                      scaleEnabled: true, // Cho phép phóng to, thu nhỏ
                      minScale: 0.0000000000001, // Tỷ lệ thu nhỏ tối thiểu
                      maxScale: 4.0, // Tỷ lệ phóng to tối đa
                      boundaryMargin: const EdgeInsets.all(
                          double.infinity), // Cho phép kéo ra ngoài biên
                      child: SizedBox(
                        width: gridSize * 50, // Adjust width based on grid size
                        height:
                            gridSize * 50, // Adjust height based on grid size
                        child: GridView.builder(
                          physics:
                              const NeverScrollableScrollPhysics(), // Disable GridView's own scrolling
                          gridDelegate:
                              SliverGridDelegateWithFixedCrossAxisCount(
                            crossAxisCount: gridSize,
                            childAspectRatio: 1.0,
                          ),
                          itemCount: gridSize * gridSize,
                          itemBuilder: (context, index) {
                            int row = index ~/ gridSize;
                            int col = index % gridSize;
                            bool isDisabled = controller.board[row][col] != '';
                            return InkWell(
                              onTap: isDisabled
                                  ? null
                                  : () async {
                                      controller.makeMove(
                                        controller.selectedDifficultyText.value,
                                        row,
                                        col,
                                      );
                                    },
                              child: Container(
                                margin: const EdgeInsets.all(0.5),
                                decoration: BoxDecoration(
                                  color: _getTileColor(
                                      controller, row, col, context),
                                  // borderRadius: _getBorderRadius(index, gridSize),
                                ),
                                child: Center(
                                  child: _buildTileContent(
                                    controller.board[row][col],
                                    context,
                                    controller,
                                  ),
                                ),
                              ).animate().fadeIn(
                                  duration: const Duration(milliseconds: 750)),
                            );
                          },
                        ),
                      ),
                    ),
                    if (controller.winner.value != '')
                      CustomPaint(
                        painter: LinePainter(
                            controller.winningLineCoordinates,
                            gridSize,
                            controller.winner.value == 'X'
                                ? Colors.lightBlueAccent
                                : Colors.yellowAccent),
                        size: Size(gridSize * 50, gridSize * 50),
                      )
                          .animate()
                          .fadeIn(duration: const Duration(milliseconds: 750)),
                  ],
                );
              },
            ),
          ),
        ],
      ),
    );
  }

  Color _getTileColor(PlayWithBotController controller, int row, int col,
      BuildContext context) {
    String value = controller.board[row][col];
    if (value == "X") {
      return Theme.of(context).colorScheme.primary.withOpacity(0.3);
    } else if (value == "O") {
      return Theme.of(context).colorScheme.secondary.withOpacity(0.3);
    } else {
      return Theme.of(context).colorScheme.primaryContainer.withOpacity(0.6);
    }
  }

  BorderRadius getBorderRadius(int index, int length) {
    if (index == 0) {
      return const BorderRadius.only(topLeft: Radius.circular(20));
    } else if (index == length - 1) {
      return const BorderRadius.only(topRight: Radius.circular(20));
    } else if (index == length * (length - 1)) {
      return const BorderRadius.only(bottomLeft: Radius.circular(20));
    } else if (index == length * length - 1) {
      return const BorderRadius.only(bottomRight: Radius.circular(20));
    } else {
      return const BorderRadius.only();
    }
  }

  Widget _buildTileContent(
      String value, BuildContext context, PlayWithBotController controller) {
    if (value == "X") {
      return Image.asset(controller.selectedImageX.value)
          .animate()
          .fadeIn(duration: const Duration(milliseconds: 750));
    } else if (value == "O") {
      return Image.asset(controller.selectedImageO.value)
          .animate()
          .scale(duration: const Duration(milliseconds: 750));
    } else {
      return const SizedBox();
    }
  }

  Widget buildTurnIndicator(
      ColorScheme colorScheme, PlayWithBotController controller) {
    return Row(
      mainAxisAlignment: MainAxisAlignment.center,
      children: [
        Obx(
          () => AnimatedContainer(
            duration: const Duration(milliseconds: 500),
            padding: const EdgeInsets.symmetric(vertical: 10, horizontal: 25),
            decoration: BoxDecoration(
              color: controller.isXtime.value
                  ? colorScheme.primary
                  : colorScheme.secondary,
              borderRadius: BorderRadius.circular(20),
              border: Border.all(
                color: Colors.white,
                width: 5,
              ),
            ),
            child: Row(
              children: [
                Image.asset(
                  controller.isXtime.value
                      ? controller.selectedImageX.value
                      : controller.selectedImageO.value,
                  width: 50,
                  height: 50,
                ),
                const SizedBox(width: 10),
                Text(
                  "Turn",
                  style: TextStyle(
                    fontSize: 25,
                    color: colorScheme.primaryContainer,
                  ),
                ),
              ],
            ),
          ),
        )
      ],
    );
  }
}

```

---


### Pages\GamePage\Widgets\core\countdown_waiting_widget.dart

```dart
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:tictactoe_gameapp/Controller/Animations/countdown_animation_controller.dart';
import 'package:tictactoe_gameapp/Models/Functions/time_functions.dart';

class CountdownWaitingWidget extends StatelessWidget {
  const CountdownWaitingWidget({super.key});
  @override
  Widget build(BuildContext context) {
    final CountdownController countdownController =
        Get.put(CountdownController());

    return Obx(() {
      double progress = countdownController.animationController.value;
      Color progressColor = countdownController.progressColor.value;
      return Padding(
        padding: const EdgeInsets.symmetric(vertical: 10),
        child: Stack(
          alignment: Alignment.center,
          children: [
            // Vòng tròn hiển thị trạng thái đếm ngược
            SizedBox(
              width: 100,
              height: 100,
              child: CircularProgressIndicator(
                value: progress,
                strokeWidth: 10, // Độ dày của đường viền
                valueColor: AlwaysStoppedAnimation<Color>(
                    progressColor), // Màu của viền
                backgroundColor: Colors.grey.shade300, // Màu nền của viền
              ),
            ),
            // Text hiển thị thời gian còn lại
            Text(
              TimeFunctions.getFormattedTime(countdownController.timeLeft),
              style: TextStyle(
                fontSize: 30,
                color: countdownController.progressColor.value,
                fontWeight: FontWeight.bold,
              ),
            ),
          ],
        ),
      );
    });
  }
}

```

---


### Pages\GamePage\Widgets\core\line_painter.dart

```dart
import 'package:flutter/material.dart';

class LinePainter extends CustomPainter {
  final List<Offset> lineCoordinates;
  final int gridSize; // Số hàng/cột trong lưới
  final Color color;

  LinePainter(this.lineCoordinates, this.gridSize, this.color);

  @override
  void paint(Canvas canvas, Size size) {
    final paint = Paint()
      ..color = color
      ..strokeWidth = 5.0
      ..strokeCap = StrokeCap.round;

    if (lineCoordinates.isNotEmpty) {
      // Tính toán kích thước của mỗi ô trong lưới
      double cellWidth = size.width / gridSize;
      double cellHeight = size.height / gridSize;

      // Lấy tọa độ điểm đầu và điểm cuối
      Offset start = Offset(
        lineCoordinates.first.dy * cellWidth + cellWidth / 2,
        lineCoordinates.first.dx * cellHeight + cellHeight / 2,
      );
      Offset end = Offset(
        lineCoordinates.last.dy * cellWidth + cellWidth / 2,
        lineCoordinates.last.dx * cellHeight + cellHeight / 2,
      );

      // Vẽ đường gạch giữa hai điểm
      canvas.drawLine(start, end, paint);
    }
  }

  @override
  bool shouldRepaint(covariant CustomPainter oldDelegate) => true;
}

```

---


### Pages\HomePage\home_page.dart

```dart
import 'package:flutter/material.dart';
import 'package:flutter_animate/flutter_animate.dart';
import 'package:flutter_svg/flutter_svg.dart';
import 'package:tictactoe_gameapp/Components/belong_to_users/avatar_user_widget.dart';
import 'package:tictactoe_gameapp/Components/friend_zone/friend_zone_map_service.dart';
import 'package:tictactoe_gameapp/Components/primary_with_icon_button.dart';
import 'package:tictactoe_gameapp/Configs/assets_path.dart';
import 'package:get/get.dart';
import 'package:tictactoe_gameapp/Configs/constants.dart';
import 'package:tictactoe_gameapp/Controller/MainHome/notify_in_main_controller.dart';
import 'package:tictactoe_gameapp/Controller/Music/background_music_controller.dart';
import 'package:tictactoe_gameapp/Controller/Console/play_with_bot_controller.dart';
import 'package:tictactoe_gameapp/Controller/profile_controller.dart';
import 'package:tictactoe_gameapp/Controller/webview_controller.dart';
import 'package:tictactoe_gameapp/Data/fetch_firestore_database.dart';
import 'package:tictactoe_gameapp/Pages/Friends/listen_latest_messages_controller.dart';
import 'package:tictactoe_gameapp/Pages/HomePage/Bottom/bottom_button_custom.dart';
import 'package:tictactoe_gameapp/Pages/HomePage/Drawer/drawer_nav_bar.dart';
import 'package:tictactoe_gameapp/Pages/HomePage/Widgets/expansion_side_left.dart';
import 'package:tictactoe_gameapp/Pages/HomePage/Widgets/expansion_side_right.dart';
import 'package:tictactoe_gameapp/Pages/HomePage/Widgets/jajas_top_icon_widget.dart';
import 'package:tictactoe_gameapp/Pages/HomePage/Widgets/middle_custom_widget.dart';
import 'package:tictactoe_gameapp/Components/fortune_wheel/fortune_wheel_page.dart';
import 'package:tictactoe_gameapp/Components/daily_gift/daily_gift_page.dart';
import 'package:tictactoe_gameapp/Components/daily_mission/missions_page.dart';
import 'package:tictactoe_gameapp/Pages/HomePage/Widgets/looping_carousel_widget.dart';
import 'package:tictactoe_gameapp/Test/game_history/game_history_page.dart';

class HomePage extends StatelessWidget {
  const HomePage({super.key});

  @override
  Widget build(BuildContext context) {
    final WebViewControllers controller = Get.put(WebViewControllers());
    final ListenLatestMessagesController listenLatestMessagesController =
        Get.put(ListenLatestMessagesController());

    final NotifyInMainController notifyInMainController =
        controller.notifyInMainController;
    final GlobalKey<ScaffoldState> scaffoldKey = GlobalKey<ScaffoldState>();
    final theme = Theme.of(context);
    final BackgroundMusicController musicController =
        Get.find<BackgroundMusicController>();
    final FirestoreController firestoreController =
        Get.put(FirestoreController());
    final ProfileController profileController = Get.find<ProfileController>();
    final user = profileController.user!;

    return Scaffold(
      key: scaffoldKey,
      extendBodyBehindAppBar: false,
      drawer: DrawerNavBar(
        firestoreController: firestoreController,
        profileController: profileController,
        user: user,
        notifyInMainController: notifyInMainController,
      ),
      body: Stack(
        children: [
          const Positioned(
            bottom: 0,
            child: RotatedBox(
              quarterTurns: 2,
              child: LoopingCarousel(),
            ),
          ),
          const Positioned(
            top: 0,
            child: LoopingCarousel(),
          ),
          // const LoopingImageCarousel(),
          Positioned(
            right: 0,
            top: 30,
            child: Container(
              height: 45,
              width: 200,
              decoration: BoxDecoration(
                color: Colors.purpleAccent.shade400,
                borderRadius: const BorderRadius.only(
                  topLeft: Radius.circular(30),
                  bottomLeft: Radius.circular(10),
                ),
              ),
            ),
          ),
          Padding(
            padding: const EdgeInsets.only(
              right: 20,
              left: 20,
            ),
            child: Column(
              mainAxisAlignment: MainAxisAlignment.spaceAround,
              children: [
                Row(
                  mainAxisAlignment: MainAxisAlignment.spaceBetween,
                  children: [
                    Row(
                      children: [
                        user.image != null && user.image!.isNotEmpty
                            ? AvatarUserWidget(
                                radius: 30,
                                imagePath: user.image!,
                                gradientColors: user.avatarFrame ??
                                    ["#FF2196F3", "#FF42A5F5"],
                              )
                            : const Icon(Icons.person_2_outlined),
                        const SizedBox(width: 10),
                        Column(
                          children: [
                            Container(
                              padding: const EdgeInsets.symmetric(
                                  horizontal: 10, vertical: 5),
                              decoration: BoxDecoration(
                                color: Colors.lightBlueAccent[400],
                                borderRadius: const BorderRadius.only(
                                  topRight: Radius.circular(50),
                                  bottomRight: Radius.circular(10),
                                  topLeft: Radius.circular(30),
                                  bottomLeft: Radius.circular(30),
                                ),
                              ),
                              child: Row(
                                mainAxisAlignment:
                                    MainAxisAlignment.spaceBetween,
                                children: [
                                  const Text(
                                    "1000",
                                    style: TextStyle(
                                      color: Colors.white,
                                      fontSize: 16,
                                      fontWeight: FontWeight.bold,
                                    ),
                                  ),
                                  const SizedBox(width: 5),
                                  SvgPicture.asset(
                                    IconsPath.coinIcon,
                                    width: 20,
                                    colorFilter:
                                        const ColorFilter.linearToSrgbGamma(),
                                  ),
                                ],
                              ),
                            ),
                            const SizedBox(height: 2),
                            Container(
                              padding: const EdgeInsets.symmetric(
                                  horizontal: 10, vertical: 5),
                              decoration: BoxDecoration(
                                color: Colors.lightBlueAccent[400],
                                borderRadius: const BorderRadius.only(
                                  topRight: Radius.circular(10),
                                  bottomRight: Radius.circular(50),
                                  topLeft: Radius.circular(30),
                                  bottomLeft: Radius.circular(30),
                                ),
                              ),
                              child: Row(
                                mainAxisAlignment:
                                    MainAxisAlignment.spaceBetween,
                                children: [
                                  const Text(
                                    "1000",
                                    style: TextStyle(
                                      color: Colors.white,
                                      fontSize: 16,
                                      fontWeight: FontWeight.bold,
                                    ),
                                  ),
                                  const SizedBox(width: 5),
                                  SvgPicture.asset(
                                    IconsPath.coinIcon,
                                    width: 20,
                                    colorFilter:
                                        const ColorFilter.linearToSrgbGamma(),
                                  ),
                                ],
                              ),
                            ),
                          ],
                        ),
                      ],
                    ),
                    Expanded(
                      child: Row(
                        mainAxisAlignment: MainAxisAlignment.end,
                        children: [
                          Stack(
                            clipBehavior: Clip.none,
                            children: [
                              IconButton(
                                onPressed: () {
                                  Get.to(() => const GameHistoryPage(),
                                      transition: Transition.upToDown);
                                },
                                icon: const Icon(
                                  Icons.email,
                                  color: Colors.white,
                                  size: 30,
                                ),
                              ),
                              Positioned(
                                top: 0,
                                right: 0,
                                child: Container(
                                  height: 20,
                                  width: 20,
                                  alignment: Alignment.center,
                                  decoration: BoxDecoration(
                                      color: Colors.red,
                                      borderRadius: BorderRadius.circular(100)),
                                  child: Text(
                                    listenLatestMessagesController
                                        .latestMessages.length
                                        .toString(),
                                    style: const TextStyle(
                                      fontSize: 12,
                                      color: Colors.white,
                                      fontWeight: FontWeight.bold,
                                    ),
                                  ),
                                ),
                              )
                            ],
                          ),
                          const SizedBox(width: 10),
                          IconButton(
                            onPressed: () {
                              Get.toNamed("/settings");
                            },
                            icon: const Icon(
                              Icons.settings,
                              color: Colors.white,
                              size: 30,
                            ),
                          ),
                          const SizedBox(width: 10),
                          IconButton(
                            onPressed: () {
                              // musicController.boosterSoundEffect();
                              scaffoldKey.currentState!.openDrawer();
                            },
                            icon: const Icon(
                              Icons.storage_rounded,
                              color: Colors.lightBlueAccent,
                              size: 30,
                            ),
                          ),
                        ],
                      ),
                    )
                  ],
                ),
                const SizedBox(
                  height: 30,
                ),
                 SizedBox(height: 250, child: MiddleCustomWidget()),
                Column(
                  children: [
                    PrimaryIconWithButton(
                      buttonText: "Single Player",
                      color: theme.colorScheme.primary,
                      onTap: () {
                        final PlayWithBotController playWithBotController =
                            Get.put(PlayWithBotController());
                        playWithBotController.showMapPicker();
                      },
                      iconPath: IconsPath.user,
                    ),
                    const SizedBox(height: 30),
                    PrimaryIconWithButton(
                      buttonText: "Multi Player",
                      color: theme.colorScheme.primary,
                      onTap: () {
                        musicController.swordSoundEffect();
                        Get.toNamed("/room");
                      },
                      iconPath: IconsPath.group,
                    ),
                  ],
                ),
                Row(
                  mainAxisAlignment: MainAxisAlignment.spaceAround,
                  children: [
                    BottomButtonCustom(
                      onPressed: () {
                        musicController.buttonSoundEffect();
                        Get.toNamed("/updateProfile");
                      },
                      theme: theme,
                      icon: IconsPath.info,
                    ),
                    BottomButtonCustom(
                      onPressed: () {
                        musicController.buttonSoundEffect();
                        controller.openWebView(url: url2);
                      },
                      theme: theme,
                      icon: IconsPath.game,
                    ),
                    BottomButtonCustom(
                      onPressed: () {
                        musicController.buttonSoundEffect();
                        controller.openWebView(url: url1);
                      },
                      theme: theme,
                      icon: IconsPath.github,
                    ),
                    InkWell(
                      borderRadius: BorderRadius.circular(20),
                      onTap: () {
                        musicController.buttonSoundEffect();
                        Get.toNamed("/shoppage");
                      },
                      child: Container(
                        padding: const EdgeInsets.all(10),
                        decoration: BoxDecoration(
                          color: theme.colorScheme.secondary,
                          borderRadius: BorderRadius.circular(20),
                          border: Border.all(color: Colors.white, width: 3),
                          boxShadow: const [
                            BoxShadow(
                              spreadRadius: 2.0,
                              color: Colors.white,
                              blurRadius: 15.0,
                              offset: Offset(5, 5),
                            ),
                            BoxShadow(
                              spreadRadius: 2.0,
                              color: Colors.white,
                              blurRadius: 15.0,
                              offset: Offset(-5, -5),
                            ),
                          ],
                        ),
                        child: const Icon(
                          Icons.store,
                          size: 40,
                          color: Colors.white,
                        ),
                      ),
                    ),
                  ],
                )
              ],
            ),
          ),
          Positioned(
            top: 100,
            child: Padding(
              padding: const EdgeInsets.symmetric(horizontal: 10),
              child: SingleChildScrollView(
                scrollDirection: Axis.horizontal,
                child: Row(
                  children: [
                    JajasTopIconWidget(
                        onTap: () {
                          Get.dialog(
                            const Dialog(
                                    backgroundColor: Colors.transparent,
                                    child: DailyRewardPage())
                                .animate()
                                .scale(),
                            barrierDismissible: true,
                          );
                        },
                        icon: Jajas.banner,
                        name: "Daily"),
                    const SizedBox(
                      width: 20,
                    ),
                    JajasTopIconWidget(
                        onTap: _onTapCommingSoon,
                        icon: Jajas.event,
                        name: "Event"),
                    const SizedBox(
                      width: 20,
                    ),
                    JajasTopIconWidget(
                        onTap: () {
                          Get.dialog(
                            const Dialog(
                              backgroundColor: Colors.transparent,
                              child: FortuneWheelMain(),
                            ).animate().scale(),
                            barrierDismissible: false,
                          );
                        },
                        icon: Jajas.spinner,
                        name: "Spinner"),
                    const SizedBox(
                      width: 20,
                    ),
                    JajasTopIconWidget(
                        onTap: _onTapCommingSoon,
                        icon: Jajas.worldNews,
                        name: "Discovery"),
                    const SizedBox(
                      width: 20,
                    ),
                    JajasTopIconWidget(
                        onTap: _onTapCommingSoon,
                        icon: Jajas.clans,
                        name: "Clans"),
                    const SizedBox(
                      width: 20,
                    ),
                    JajasTopIconWidget(
                        onTap: () {}, icon: Jajas.tinder, name: "Tinder"),
                    const SizedBox(
                      width: 20,
                    ),
                    const SizedBox(
                      width: 20,
                    ),
                  ],
                ),
              ),
            ),
          ),
          Positioned(
            top: 180,
            right: 2,
            child: JajasTopIconWidget(
                onTap: () async => FriendZoneMapService.navigateFriendZoneMap(
                    user: user, firestoreController: firestoreController),
                icon: Jajas.mission,
                name: "Map"),
          ),
          Positioned(
            top: 180,
            left: 2,
            child: JajasTopIconWidget(
                onTap: () {
                  Get.dialog(
                    Dialog(
                      backgroundColor: Colors.transparent,
                      child: MissionsPage(
                        userId: user.id!,
                      ),
                    ).animate().scale(),
                  );
                },
                icon: Jajas.quest,
                name: "Missions"),
          ),
          const ExpansionSideWidgetLeft(),
          const ExpansionSideWidgetRight(),
        ],
      ),
    );
  }

  void _onTapCommingSoon() {
    Get.dialog(
      Dialog(
          backgroundColor: Colors.transparent,
          child: Center(
            child: Stack(
              clipBehavior: Clip.none,
              children: [
                ClipRRect(
                    borderRadius: BorderRadius.circular(20),
                    child: Image.asset(GifsPath.chatbotGif)),
                Positioned(
                  top: -20,
                  left: 50,
                  right: 50,
                  child: Container(
                    alignment: Alignment.center,
                    height: 50,
                    decoration: BoxDecoration(
                      color: Colors.lightBlueAccent,
                      borderRadius: BorderRadius.circular(20),
                      border: Border.all(color: Colors.purpleAccent, width: 5),
                    ),
                    child: const Text(
                      "Comming Soon...",
                      style: TextStyle(
                        color: Colors.white,
                        fontSize: 25,
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                  ),
                ),
              ],
            ),
          )).animate().scale(),
    );
  }
}

```

---


### Pages\HomePage\Bottom\bottom_button_custom.dart

```dart
import 'package:flutter/material.dart';
import 'package:flutter_svg/svg.dart';

class BottomButtonCustom extends StatelessWidget {
  final Function() onPressed;
  final ThemeData theme;
  final String icon;
  const BottomButtonCustom(
      {super.key,
      required this.onPressed,
      required this.theme,
      required this.icon});

  @override
  Widget build(BuildContext context) {
    return InkWell(
      borderRadius: BorderRadius.circular(20),
      onTap: onPressed,
      child: Container(
        padding: const EdgeInsets.all(10),
        decoration: BoxDecoration(
          color: theme.colorScheme.secondary,
          borderRadius: BorderRadius.circular(20),
          border: Border.all(color: Colors.white, width: 3),
          boxShadow: const [
            BoxShadow(
              spreadRadius: 2.0,
              color: Colors.white,
              blurRadius: 15.0,
              offset: Offset(5, 5),
            ),
            BoxShadow(
              spreadRadius: 2.0,
              color: Colors.white,
              blurRadius: 15.0,
              offset: Offset(-5, -5),
            ),
          ],
        ),
        child: SvgPicture.asset(
          icon,
          width: 40,
        ),
      ),
    );
  }
}

```

---


### Pages\HomePage\Bottom\bottom_nav_bar.dart

```dart
import 'package:flutter/material.dart';
import 'package:google_nav_bar/google_nav_bar.dart';
import 'package:tictactoe_gameapp/Configs/theme/colors.dart';

class BottomNavBar extends StatelessWidget {
  final int currentIndex;
  final Function(int) onTabChanged;
  const BottomNavBar(
      {super.key, required this.currentIndex, required this.onTabChanged});

  @override
  Widget build(BuildContext context) {
    Color primaryColor = Theme.of(context).colorScheme.primary;
    return Container(
      height: 60,
      decoration: BoxDecoration(
        color: primaryColor.withOpacity(0.8),
        // borderRadius: const BorderRadius.only(
        //   topLeft: Radius.circular(20),
        //   topRight: Radius.circular(20),
        // ),
      ),
      child: GNav(
        haptic: true, // haptic feedback
        tabBorderRadius: 25,
        tabActiveBorder:
            Border.all(color: Colors.green, width: 3), // tab button border
        tabBorder:
            Border.all(color: Colors.grey, width: 1), // tab button border
        tabShadow: [
          BoxShadow(
            color: Colors.transparent.withOpacity(0.2),
            blurRadius: 15,
            spreadRadius: 1.0,
          ),
        ], // tab button shadow
        curve: Curves.easeInOutCubic, // tab animation curves
        gap: 8, // the tab button gap between icon and text
        color: Colors.white, // unselected icon color
        activeColor: Colors.lightGreenAccent, // selected icon and text color
        iconSize: 27, // tab button icon size
        tabBackgroundColor:
            kSurfaceDarkColor.withOpacity(0.5), // selected tab background color
        padding: const EdgeInsets.symmetric(
            horizontal: 15, vertical: 7), // navigation bar padding
        tabs: const [
          GButton(
            icon: Icons.home_filled,
            text: 'Home',
          ),
          GButton(
            icon: Icons.chat_outlined,
            text: 'Chatting',
           
          ),
          GButton(
            icon: Icons.android_outlined,
            text: 'Joi',
          ),
          GButton(
            icon: Icons.widgets_outlined,
            text: 'Games',
          ),
          GButton(
            icon: Icons.newspaper_outlined,
            text: 'Society',
          ),
        ],
        selectedIndex: currentIndex,
        onTabChange: onTabChanged,
      ),
    );
  }
}

```

---


### Pages\HomePage\Bottom\button_nav_bar_curve.dart

```dart
import 'package:flutter/material.dart';
import 'package:curved_navigation_bar/curved_navigation_bar.dart';
import 'package:tictactoe_gameapp/Configs/assets_path.dart';

class CurvedBottomNavBar extends StatelessWidget {
  final int currentIndex;
  final Function(int) onTabChanged;
  const CurvedBottomNavBar(
      {super.key, required this.currentIndex, required this.onTabChanged});

  @override
  Widget build(BuildContext context) {
    return CurvedNavigationBar(
      key: GlobalKey(),
      index: currentIndex,
      height: 60,
      items: <Widget>[
        // Icon(Icons.android_outlined, size: 30, color: Colors.white),
        Container(
          padding: const EdgeInsets.all(1),
          decoration: BoxDecoration(
            border: Border.all(color: Colors.white, width: 3),
            borderRadius: BorderRadius.circular(100),
          ),
          child: ClipRRect(
            borderRadius: BorderRadius.circular(100),
            child: Image.asset(
              GifsPath.chloe1,
              width: 30,
              fit: BoxFit.cover,
            ),
          ),
        ),
        const Icon(Icons.chat_outlined, size: 30, color: Colors.white),
        const Icon(Icons.home_filled, size: 30, color: Colors.white),
        const Icon(Icons.video_collection_rounded,
            size: 30, color: Colors.white),
        const Icon(Icons.newspaper_outlined, size: 30, color: Colors.white),
      ],
      color: Colors.blue,
      buttonBackgroundColor: Colors.blueAccent,
      backgroundColor: Colors.white,
      animationCurve: Curves.easeInOut,
      animationDuration: const Duration(milliseconds: 750),
      onTap: onTabChanged,
    );
  }
}

```

---


### Pages\HomePage\Drawer\drawer_nav_bar.dart

```dart
import 'package:cached_network_image/cached_network_image.dart';
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:tictactoe_gameapp/Configs/assets_path.dart';
import 'package:tictactoe_gameapp/Controller/MainHome/notify_in_main_controller.dart';
import 'package:tictactoe_gameapp/Controller/profile_controller.dart';
import 'package:tictactoe_gameapp/Data/fetch_firestore_database.dart';
import 'package:tictactoe_gameapp/Models/user_model.dart';
import 'package:tictactoe_gameapp/Pages/HomePage/Drawer/Widgets/cham_ranking_drawer.dart';
import 'package:tictactoe_gameapp/Pages/HomePage/Drawer/Widgets/player_ranking_drawer.dart';

class DrawerNavBar extends StatelessWidget {
  final ProfileController profileController;
  final FirestoreController firestoreController;
  final UserModel user;
  final NotifyInMainController notifyInMainController;
  const DrawerNavBar(
      {super.key,
      required this.profileController,
      required this.firestoreController,
      required this.user,
      required this.notifyInMainController});

  @override
  Widget build(BuildContext context) {
    RxInt expandedIndex = (-1).obs;
    return Drawer(
      width: MediaQuery.of(context).size.width * 0.8,
      backgroundColor: Theme.of(context).colorScheme.surface,
      child: DefaultTabController(
        length: 2,
        child: Column(
          children: [
            Stack(
              children: [
                Image.asset(
                  GifsPath.lightGif,
                ),
                Positioned(
                  bottom: 0,
                  top: 0,
                  right: 0,
                  left: 0,
                  child: Column(
                    mainAxisAlignment: MainAxisAlignment.center,
                    children: [
                      Container(
                        decoration: BoxDecoration(
                            border: Border.all(
                                color: Colors.blue,
                                width: 5,
                                style: BorderStyle.solid),
                            shape: BoxShape.circle),
                        child: user.image != null && user.image!.isNotEmpty
                            ? CircleAvatar(
                                backgroundImage:
                                    CachedNetworkImageProvider(user.image!),
                                maxRadius: 55,
                              )
                            : const Icon(Icons.person_2_outlined),
                      ),
                      const SizedBox(
                        height: 5,
                      ),
                      Text(
                        user.name ?? "Anonymous",
                        style: Theme.of(context)
                            .textTheme
                            .titleLarge!
                            .copyWith(color: Colors.white),
                      ),
                      const Divider(
                        color: Colors.blueGrey,
                      ),
                      Text(
                        "Email: ${user.email ?? "${user.name}@gmail.com"}",
                        textAlign: TextAlign.center,
                        style: Theme.of(context)
                            .textTheme
                            .bodyMedium!
                            .copyWith(color: Colors.white),
                      ),
                    ],
                  ),
                ),
              ],
            ),
            const SizedBox(
              height: 5,
            ),
            Container(
              height: 80,
              width: double.infinity,
              decoration: BoxDecoration(
                color: Colors.lightBlueAccent,
                borderRadius: BorderRadius.circular(20),
                border: Border.all(color: Colors.deepPurpleAccent, width: 2),
              ),
              child: Row(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  Image.asset(
                    ImagePath.welcome3,
                    width: 70,
                  ),
                  const SizedBox(
                    width: 10,
                  ),
                  const Column(
                    mainAxisAlignment: MainAxisAlignment.center,
                    children: [
                      Text(
                        "RANKING",
                        textAlign: TextAlign.center,
                        style: TextStyle(
                          fontSize: 28,
                          color: Colors.white,
                          fontWeight: FontWeight.bold,
                        ),
                      ),
                      Text(
                        "Tic Tac Toe",
                        textAlign: TextAlign.center,
                        style: TextStyle(
                          fontSize: 15,
                          color: Colors.orangeAccent,
                          fontWeight: FontWeight.bold,
                        ),
                      ),
                    ],
                  ),
                ],
              ),
            ),
            const TabBar(
              labelColor: Colors.blueAccent,
              unselectedLabelColor: Colors.grey,
              indicatorSize: TabBarIndicatorSize.tab,
              indicatorColor: Colors.blueAccent,
              tabs: [
                Tab(icon: Icon(Icons.person), text: 'Players'),
                Tab(icon: Icon(Icons.leaderboard), text: 'Champions'),
              ],
            ),
            Expanded(
                child: TabBarView(
              children: [
                RankingPlayerPage(
                    notifyInMainController: notifyInMainController,
                    profileController: profileController,
                    firestoreController: firestoreController,
                    userModel: user,
                    expandedIndex: expandedIndex),
                RankingChampionPage(
                    profileController: profileController,
                    firestoreController: firestoreController,
                    user: user,
                    expandedIndex: expandedIndex),
              ],
            )),
          ],
        ),
      ),
    );
  }
}

```

---


### Pages\HomePage\Drawer\Widgets\cham_ranking_drawer.dart

```dart
import 'package:flutter/material.dart';
import 'package:flutter_svg/svg.dart';
import 'package:get/get.dart';
import 'package:tictactoe_gameapp/Configs/assets_path.dart';
import 'package:tictactoe_gameapp/Configs/constants.dart';
import 'package:tictactoe_gameapp/Controller/profile_controller.dart';
import 'package:tictactoe_gameapp/Data/fetch_firestore_database.dart';
import 'package:tictactoe_gameapp/Models/champion_model.dart';
import 'package:tictactoe_gameapp/Models/user_model.dart';

class RankingChampionPage extends StatelessWidget {
  final ProfileController profileController;
  final FirestoreController firestoreController;
  final UserModel user;
  final RxInt expandedIndex;
  const RankingChampionPage(
      {super.key,
      required this.profileController,
      required this.firestoreController,
      required this.user,
      required this.expandedIndex});

  @override
  Widget build(BuildContext context) {
    RxBool isLike = false.obs;
    RxBool isFriend = false.obs;
    return Obx(() {
      if (firestoreController.usersList.isEmpty) {
        return const Center(child: CircularProgressIndicator());
      }
      return Scrollbar(
        child: ListView.builder(
          physics: const BouncingScrollPhysics(),
          itemCount: listChampions.length,
          itemBuilder: (context, index) {
            var champ = listChampions[index];
            return Column(
              children: [
                Container(
                  margin: const EdgeInsets.only(bottom: 20),
                  decoration: BoxDecoration(
                    border: Border.all(color: Colors.white, width: 3),
                    boxShadow: const [
                      BoxShadow(
                        blurRadius: 3.0,
                        spreadRadius: 5.0,
                        color: Colors.lightBlueAccent,
                      ),
                    ],
                  ),
                  child: ExpansionTile(
                    onExpansionChanged: (bool expanded) {
                      if (expanded) {
                        expandedIndex.value = index;
                      } else if (expandedIndex.value == index) {
                        expandedIndex.value = -1;
                      }
                    },
                    iconColor: Colors.white,
                    collapsedIconColor: Colors.pink,
                    collapsedBackgroundColor: Colors.blue[200],
                    leading: Badge(
                      label: Text("${++index}"),
                      textColor: index == 1
                          ? Colors.red
                          : index == 2
                              ? Colors.yellow
                              : index == 3
                                  ? Colors.greenAccent
                                  : Colors.white,
                      backgroundColor: Colors.blue,
                      child: Column(
                        children: [
                          SvgPicture.asset(
                            IconsPath.wonIcon,
                            width: 40,
                            color: index == 1
                                ? Colors.redAccent
                                : index == 2
                                    ? Colors.yellowAccent
                                    : index == 3
                                        ? Colors.greenAccent
                                        : Colors.white,
                          ),
                          Text(
                            "00 wins",
                            style: TextStyle(
                              fontSize: 10,
                              color: index == 1
                                  ? Colors.redAccent
                                  : index == 2
                                      ? Colors.yellowAccent
                                      : index == 3
                                          ? Colors.greenAccent
                                          : Colors.white,
                            ),
                          ),
                        ],
                      ),
                    ),
                    trailing: Obx(
                      () => Icon(
                        expandedIndex.value == index
                            ? Icons.keyboard_arrow_up
                            : Icons.keyboard_arrow_down,
                      ),
                    ),
                    title: Row(
                      mainAxisAlignment: MainAxisAlignment.spaceBetween,
                      children: [
                        Row(
                          children: [
                            Image.asset(
                              champ,
                              width: 50,
                              height: 50,
                            ),
                            const SizedBox(width: 10),
                            Column(
                              crossAxisAlignment: CrossAxisAlignment.start,
                              children: [
                                Text(
                                  ChampionModel.capitalize(listChampName[index]),
                                  style: const TextStyle(
                                    fontWeight: FontWeight.bold,
                                    color: Colors.deepPurple,
                                    fontSize: 15,
                                  ),
                                ),
                                const Text(
                                  "Elo: 00",
                                  style: TextStyle(
                                    fontWeight: FontWeight.bold,
                                    color: Colors.yellowAccent,
                                    fontSize: 15,
                                  ),
                                ),
                              ],
                            ),
                          ],
                        ),
                      ],
                    ),
                    children: [
                      Text(
                        ChampionModel.capitalize(listChampName[index]),
                        maxLines: 2,
                        style: const TextStyle(
                          fontSize: 12,
                          color: Colors.white,
                        ),
                      ),
                      Row(
                        mainAxisAlignment: MainAxisAlignment.end,
                        children: [
                          Expanded(
                            child: Container(
                              alignment: Alignment.center,
                              height: 30,
                              decoration: BoxDecoration(
                                color: Colors.white,
                                borderRadius: BorderRadius.circular(20),
                                border: Border.all(
                                  color: Colors.blue,
                                  width: 3,
                                ),
                              ),
                              child: const Text(
                                "Chat with hero",
                                style: TextStyle(
                                  color: Colors.grey,
                                  fontSize: 13,
                                ),
                              ),
                            ),
                          ),
                          Obx(() => IconButton(
                                onPressed: () {
                                  isLike.value = !isLike.value;
                                },
                                icon: Icon(isLike.value
                                    ? Icons.favorite
                                    : Icons.favorite_border),
                              )),
                          Obx(() => IconButton(
                                onPressed: () {
                                  isFriend.value = !isFriend.value;
                                },
                                icon: Icon(isFriend.value
                                    ? Icons.person_add_alt_1
                                    : Icons.person_add_alt_1_outlined),
                              )),
                          IconButton(
                            onPressed: () {},
                            icon: const Icon(Icons.messenger_outline_sharp),
                          ),
                        ],
                      )
                    ],
                  ),
                ),
              ],
            );
          },
        ),
      );
    });
  }
}

```

---


### Pages\HomePage\Drawer\Widgets\player_ranking_drawer.dart

```dart
import 'package:cached_network_image/cached_network_image.dart';
import 'package:flutter/material.dart';
import 'package:flutter_svg/svg.dart';
import 'package:get/get.dart';
import 'package:tictactoe_gameapp/Configs/assets_path.dart';
import 'package:tictactoe_gameapp/Configs/messages.dart';
import 'package:tictactoe_gameapp/Controller/Animations/Overlays/profile_tooltip.dart';
import 'package:tictactoe_gameapp/Controller/MainHome/notify_in_main_controller.dart';
import 'package:tictactoe_gameapp/Controller/profile_controller.dart';
import 'package:tictactoe_gameapp/Data/fetch_firestore_database.dart';
import 'package:tictactoe_gameapp/Enums/popup_position.dart';
import 'package:tictactoe_gameapp/Models/user_model.dart';

class RankingPlayerPage extends StatelessWidget {
  final ProfileController profileController;
  final FirestoreController firestoreController;
  final UserModel userModel;
  final RxInt expandedIndex;
  final NotifyInMainController notifyInMainController;
  const RankingPlayerPage(
      {super.key,
      required this.profileController,
      required this.firestoreController,
      required this.userModel,
      required this.expandedIndex,
      required this.notifyInMainController});

  @override
  Widget build(BuildContext context) {
    final ProfileTooltip profileTooltip = Get.put(ProfileTooltip());
    return Obx(() {
      if (firestoreController.usersList.isEmpty) {
        return const Center(child: CircularProgressIndicator());
      }
      // Sắp xếp danh sách usersList theo totalCoins giảm dần
      var sortedUsersList = firestoreController.usersList.toList();
      sortedUsersList.sort((a, b) {
        int totalCoinsA = int.tryParse(a.totalCoins ?? '0') ?? 0;
        int totalCoinsB = int.tryParse(b.totalCoins ?? '0') ?? 0;
        return totalCoinsB.compareTo(totalCoinsA);
      });
      return Scrollbar(
        child: ListView.builder(
          physics: const BouncingScrollPhysics(),
          itemCount: sortedUsersList.length,
          itemBuilder: (context, index) {
            final GlobalKey itemKey = GlobalKey();
            var users = sortedUsersList[index];
            return Column(
              children: [
                Container(
                  margin: const EdgeInsets.only(bottom: 20),
                  decoration: BoxDecoration(
                    border: Border.all(color: Colors.white, width: 3),
                    boxShadow: const [
                      BoxShadow(
                        blurRadius: 3.0,
                        spreadRadius: 5.0,
                        color: Colors.white,
                      ),
                    ],
                  ),
                  child: ExpansionTile(
                    onExpansionChanged: (bool expanded) {
                      if (expanded) {
                        expandedIndex.value = index;
                      } else if (expandedIndex.value == index) {
                        expandedIndex.value = -1;
                      }
                    },
                    iconColor: Colors.white,
                    collapsedIconColor: Colors.pink,
                    collapsedBackgroundColor: users.name == userModel.name
                        ? Colors.purpleAccent.withOpacity(0.5)
                        : Colors.lightBlueAccent,
                    backgroundColor: users.name == userModel.name
                        ? Colors.purpleAccent.withOpacity(0.5)
                        : Colors.lightBlueAccent,
                    leading: Badge(
                      label: Text("${++index}"),
                      textColor: index == 1
                          ? Colors.red
                          : index == 2
                              ? Colors.yellow
                              : index == 3
                                  ? Colors.greenAccent
                                  : Colors.white,
                      backgroundColor: Colors.black,
                      child: Column(
                        children: [
                          Image.asset(
                            index == 1
                                ? TrimRanking.challTrim
                                : index == 2
                                    ? TrimRanking.masterTrim
                                    : index == 3
                                        ? TrimRanking.diamondTrim
                                        : TrimRanking.goldTrim,
                            width: 45,
                          ),
                        ],
                      ),
                    ),
                    trailing: Column(
                      children: [
                        users.status == "online"
                            ? const Text(
                                "Online",
                                style: TextStyle(
                                  color: Colors.lightGreenAccent,
                                  fontSize: 15,
                                ),
                              )
                            : const Text(
                                "Offline",
                                style: TextStyle(
                                  color: Colors.blueGrey,
                                  fontSize: 15,
                                ),
                              ),
                        Obx(
                          () => Icon(
                            expandedIndex.value == index
                                ? Icons.keyboard_arrow_up
                                : Icons.keyboard_arrow_down,
                          ),
                        ),
                      ],
                    ),
                    title: Row(
                      mainAxisAlignment: MainAxisAlignment.spaceBetween,
                      children: [
                        Row(
                          children: [
                            users.image != null && users.image!.isNotEmpty
                                ? GestureDetector(
                                    key: itemKey,
                                    onTap: () {
                                      profileTooltip.showProfileTooltip(
                                        context,
                                        itemKey,
                                        users,
                                        PopupPosition.right,
                                        null,
                                        null,
                                        null,
                                    
                                      );
                                    },
                                    child: CircleAvatar(
                                      backgroundImage:
                                          CachedNetworkImageProvider(
                                              users.image!),
                                      radius: 25,
                                    ),
                                  )
                                : const Icon(Icons.person_2_outlined),
                            const SizedBox(
                              width: 5,
                            ),
                            Column(
                              crossAxisAlignment: CrossAxisAlignment.start,
                              children: [
                                Text(
                                  users.name!,
                                  style: const TextStyle(
                                    fontWeight: FontWeight.bold,
                                    color: Colors.deepPurple,
                                    fontSize: 15,
                                  ),
                                  overflow: TextOverflow.clip,
                                  maxLines: 1,
                                ),
                                Row(
                                  children: [
                                    Text(
                                      users.totalCoins ?? "0",
                                      style: const TextStyle(
                                        fontWeight: FontWeight.bold,
                                        color: Colors.yellowAccent,
                                        fontSize: 20,
                                      ),
                                    ),
                                    const SizedBox(
                                      width: 5,
                                    ),
                                    SvgPicture.asset(
                                      IconsPath.coinIcon,
                                      width: 20,
                                      color: Colors.yellowAccent,
                                    ),
                                  ],
                                ),
                              ],
                            ),
                          ],
                        ),
                      ],
                    ),
                    children: [
                      Text(
                        "Email: ${users.email ?? "${users.name}@gmail.com"}",
                        maxLines: 2,
                        style: const TextStyle(
                          fontSize: 12,
                          color: Colors.white,
                        ),
                      ),
                      users.name != userModel.name
                          ? Row(
                              mainAxisAlignment: MainAxisAlignment.end,
                              children: [
                                Expanded(
                                  child: Container(
                                    alignment: Alignment.center,
                                    height: 30,
                                    decoration: BoxDecoration(
                                      color: Colors.white,
                                      borderRadius: BorderRadius.circular(20),
                                      border: Border.all(
                                        color: Colors.blue,
                                        width: 3,
                                      ),
                                    ),
                                    child: Text(
                                      "Chat with ${users.name!}",
                                      style: const TextStyle(
                                        color: Colors.grey,
                                        fontSize: 13,
                                      ),
                                    ),
                                  ),
                                ),
                                IconButton(
                                  onPressed: () {},
                                  icon: const Icon(Icons.favorite_border),
                                ),
                                Obx(() {
                                  bool isFriend = firestoreController
                                      .isFriend(users.id!)
                                      .value;
                                  return isFriend
                                      ? IconButton(
                                          onPressed: () async {
                                            await firestoreController
                                                .removeFriend(users.id!);
                                            errorMessage(
                                                'You removed ${users.name!} from the list of friends');
                                          },
                                          icon: const Icon(
                                              Icons.person_add_disabled_sharp),
                                        )
                                      : IconButton(
                                          onPressed: () async {
                                            // await firestoreController
                                            //     .addFriend(users.id!);
                                            notifyInMainController
                                                .sendFriendRequest(
                                                    users.id!, userModel);
                                            successMessage(
                                                'You added ${users.name!} to the list of friends');
                                          },
                                          icon: const Icon(
                                              Icons.person_add_alt_sharp),
                                        );
                                }),
                                IconButton(
                                  onPressed: () {},
                                  icon:
                                      const Icon(Icons.messenger_outline_sharp),
                                ),
                              ],
                            )
                          : const SizedBox(
                              height: 10,
                            ),
                    ],
                  ),
                ),
              ],
            );
          },
        ),
      );
    });
  }
}

```

---


### Pages\HomePage\Widgets\expansion_side_left.dart

```dart
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:tictactoe_gameapp/Components/fortune_wheel/fortune_wheel_page.dart';
import 'package:tictactoe_gameapp/Configs/assets_path.dart';
import 'package:tictactoe_gameapp/Components/daily_gift/daily_gift_page.dart';

class ExpansionSideWidgetLeft extends StatelessWidget {
  const ExpansionSideWidgetLeft({super.key});

  @override
  Widget build(BuildContext context) {
    RxBool isExpanded = false.obs;
    return Obx(
      () => Align(
        alignment: Alignment.centerLeft,
        child: Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            AnimatedOpacity(
              opacity: isExpanded.value ? 1.0 : 0.0, // Thay đổi độ mờ dần
              duration: const Duration(milliseconds: 500),
              child: AnimatedContainer(
                duration: const Duration(milliseconds: 500),
                width: isExpanded.value ? 80 : 0, // Mở rộng/thu gọn
                height: double.maxFinite,
                decoration: BoxDecoration(
                  color: Colors.blue[100],
                  borderRadius: const BorderRadius.only(
                      topRight: Radius.circular(50),
                      bottomRight: Radius.circular(50)),
                ),
                child: isExpanded.value
                    ? Column(
                        mainAxisAlignment: MainAxisAlignment.center,
                        children: [
                          Column(
                            children: [
                              InkWell(
                                onTap: () {
                                  Get.dialog(
                                    const Dialog(
                                        backgroundColor: Colors.transparent,
                                        child: DailyRewardPage()),
                                    barrierDismissible: true,
                                  );
                                },
                                child: Image.asset(
                                  Jajas.banner,
                                  width: 50,
                                  fit: BoxFit.cover,
                                ),
                              ),
                              const Text(
                                "Daily",
                                style: TextStyle(
                                  color: Colors.purple,
                                ),
                              ),
                            ],
                          ),
                          const SizedBox(
                            height: 20,
                          ),
                          Column(
                            children: [
                              Image.asset(
                                Jajas.event,
                                width: 50,
                                fit: BoxFit.cover,
                              ),
                              const Text(
                                "Event",
                                style: TextStyle(
                                  color: Colors.purple,
                                ),
                              ),
                            ],
                          ),
                          const SizedBox(
                            height: 20,
                          ),
                          Column(
                            children: [
                              InkWell(
                                onTap: () {
                                  Get.dialog(
                                    const Dialog(
                                      backgroundColor: Colors.transparent,
                                      child: FortuneWheelMain(),
                                    ),
                                    barrierDismissible: false,
                                  );
                                },
                                child: Image.asset(
                                  Jajas.spinner,
                                  width: 50,
                                  fit: BoxFit.cover,
                                ),
                              ),
                              const Text(
                                "Spinner",
                                style: TextStyle(
                                  color: Colors.purple,
                                ),
                              ),
                            ],
                          ),
                          const SizedBox(
                            height: 20,
                          ),
                          Column(
                            children: [
                              Image.asset(
                                Jajas.worldNews,
                                width: 50,
                                fit: BoxFit.cover,
                              ),
                              const Text(
                                "Explore",
                                style: TextStyle(
                                  color: Colors.purple,
                                ),
                              ),
                            ],
                          ),
                          const SizedBox(
                            height: 20,
                          ),
                          Column(
                            children: [
                              Image.asset(
                                Jajas.clans,
                                width: 50,
                                fit: BoxFit.cover,
                              ),
                              const Text(
                                "Clans",
                                style: TextStyle(
                                  color: Colors.purple,
                                ),
                              ),
                            ],
                          ),
                          const SizedBox(
                            height: 20,
                          ),
                          Column(
                            children: [
                              Image.asset(
                                Jajas.mission,
                                width: 50,
                                fit: BoxFit.cover,
                              ),
                              const Text(
                                "Pass",
                                style: TextStyle(
                                  color: Colors.purple,
                                ),
                              ),
                            ],
                          ),
                        ],
                      )
                    : const SizedBox(),
              ),
            ),
            GestureDetector(
              onTap: () {
                isExpanded.value = !isExpanded.value;
              },
              child: Stack(
                children: [
                  CustomPaint(
                    size: const Size(20, 100),
                    painter: TrapezoidPainterLeft(),
                  ),
                  Positioned(
                    left: isExpanded.value ? 0 : -3,
                    right: 0,
                    top: 0,
                    bottom: 0,
                    child: Icon(
                      !isExpanded.value
                          ? Icons.arrow_forward_ios
                          : Icons.arrow_back_ios,
                      color: Colors.white,
                      size: 30,
                    ),
                  ),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }
}

class TrapezoidPainterLeft extends CustomPainter {
  @override
  void paint(Canvas canvas, Size size) {
    final paint = Paint()..color = Colors.redAccent;

    var path = Path();
    path.moveTo(0, 0); // Góc trên bên trái
    path.lineTo(size.width, 20); // Góc trên bên phải
    path.lineTo(size.width, size.height - 20); // Góc dưới bên phải
    path.lineTo(0, size.height); // Góc dưới bên trái
    path.close(); // Đóng path lại

    canvas.drawPath(path, paint); // Vẽ hình thang
  }

  @override
  bool shouldRepaint(CustomPainter oldDelegate) => false;
}

```

---


### Pages\HomePage\Widgets\expansion_side_right.dart

```dart
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:tictactoe_gameapp/Components/fortune_wheel/fortune_wheel_page.dart';
import 'package:tictactoe_gameapp/Configs/assets_path.dart';
import 'package:tictactoe_gameapp/Components/daily_gift/daily_gift_page.dart';

class ExpansionSideWidgetRight extends StatelessWidget {
  const ExpansionSideWidgetRight({super.key});

  @override
  Widget build(BuildContext context) {
    RxBool isExpanded = false.obs;
    return Obx(
      () => Align(
        alignment: Alignment.centerRight,
        child: Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            GestureDetector(
              onTap: () {
                isExpanded.value = !isExpanded.value;
              },
              child: Stack(
                children: [
                  CustomPaint(
                      size: const Size(20, 100),
                      painter: TrapezoidPainterRight()),
                  Positioned(
                    left: isExpanded.value ? -3 : 3,
                    right: 0,
                    top: 0,
                    bottom: 0,
                    child: Icon(
                      isExpanded.value
                          ? Icons.arrow_forward_ios
                          : Icons.arrow_back_ios,
                      color: Colors.white,
                      size: 30,
                    ),
                  ),
                ],
              ),
            ),
            AnimatedOpacity(
              opacity: isExpanded.value ? 1.0 : 0.0, // Thay đổi độ mờ dần
              duration: const Duration(milliseconds: 500),
              child: AnimatedContainer(
                duration: const Duration(milliseconds: 500),
                width: isExpanded.value ? 80 : 0, // Mở rộng/thu gọn
                height: double.maxFinite,
                decoration: BoxDecoration(
                  color: Colors.blue[100],
                  borderRadius: const BorderRadius.only(
                      topLeft: Radius.circular(50),
                      bottomLeft: Radius.circular(50)),
                ),
                child: isExpanded.value
                    ? Column(
                        mainAxisAlignment: MainAxisAlignment.center,
                        children: [
                          Column(
                            children: [
                              InkWell(
                                onTap: () {
                                  Get.dialog(
                                    const Dialog(
                                        backgroundColor: Colors.transparent,
                                        child: DailyRewardPage()),
                                    barrierDismissible: true,
                                  );
                                },
                                child: Image.asset(
                                  Jajas.banner,
                                  width: 50,
                                  fit: BoxFit.cover,
                                ),
                              ),
                              const Text(
                                "Daily",
                                style: TextStyle(
                                  color: Colors.purple,
                                ),
                              ),
                            ],
                          ),
                          const SizedBox(
                            height: 20,
                          ),
                          Column(
                            children: [
                              Image.asset(
                                Jajas.event,
                                width: 50,
                                fit: BoxFit.cover,
                              ),
                              const Text(
                                "Event",
                                style: TextStyle(
                                  color: Colors.purple,
                                ),
                              ),
                            ],
                          ),
                          const SizedBox(
                            height: 20,
                          ),
                          Column(
                            children: [
                              InkWell(
                                onTap: () {
                                  Get.dialog(
                                    const Dialog(
                                      backgroundColor: Colors.transparent,
                                      child: FortuneWheelMain(),
                                    ),
                                    barrierDismissible: false,
                                  );
                                },
                                child: Image.asset(
                                  Jajas.spinner,
                                  width: 50,
                                  fit: BoxFit.cover,
                                ),
                              ),
                              const Text(
                                "Spinner",
                                style: TextStyle(
                                  color: Colors.purple,
                                ),
                              ),
                            ],
                          ),
                          const SizedBox(
                            height: 20,
                          ),
                          Column(
                            children: [
                              Image.asset(
                                Jajas.worldNews,
                                width: 50,
                                fit: BoxFit.cover,
                              ),
                              const Text(
                                "Explore",
                                style: TextStyle(
                                  color: Colors.purple,
                                ),
                              ),
                            ],
                          ),
                          const SizedBox(
                            height: 20,
                          ),
                          Column(
                            children: [
                              Image.asset(
                                Jajas.clans,
                                width: 50,
                                fit: BoxFit.cover,
                              ),
                              const Text(
                                "Clans",
                                style: TextStyle(
                                  color: Colors.purple,
                                ),
                              ),
                            ],
                          ),
                          const SizedBox(
                            height: 20,
                          ),
                          Column(
                            children: [
                              Image.asset(
                                Jajas.mission,
                                width: 50,
                                fit: BoxFit.cover,
                              ),
                              const Text(
                                "Pass",
                                style: TextStyle(
                                  color: Colors.purple,
                                ),
                              ),
                            ],
                          ),
                        ],
                      )
                    : const SizedBox(),
              ),
            ),
          ],
        ),
      ),
    );
  }
}

class TrapezoidPainterRight extends CustomPainter {
  @override
  void paint(Canvas canvas, Size size) {
    final paint = Paint()..color = Colors.redAccent;

    var path = Path();
    path.moveTo(size.width, 0); // Góc trên bên trái
    path.lineTo(0, 20); // Góc trên bên phải
    path.lineTo(0, size.height - 20); // Góc dưới bên phải
    path.lineTo(size.width, size.height); // Góc dưới bên trái
    path.close(); // Đóng path lại

    canvas.drawPath(path, paint); // Vẽ hình thang
  }

  @override
  bool shouldRepaint(CustomPainter oldDelegate) => false;
}

```

---


### Pages\HomePage\Widgets\jajas_top_icon_widget.dart

```dart
import 'package:flutter/material.dart';

class JajasTopIconWidget extends StatelessWidget {
  final String icon;
  final String name;
  final Function() onTap;
  const JajasTopIconWidget({
    super.key,
    required this.onTap,
    required this.icon,
    required this.name,
  });

  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        InkWell(
          onTap: onTap,
          child: Image.asset(
            icon,
            width: 50,
            fit: BoxFit.cover,
          ),
        ),
        Text(
          name,
          style: const TextStyle(
            color: Colors.purple,
          ),
        ),
      ],
    );
  }
}

```

---


### Pages\HomePage\Widgets\looping_carousel_widget.dart

```dart
import 'dart:async';
import 'package:flutter/material.dart';
import 'package:tictactoe_gameapp/Configs/constants.dart';

class LoopingCarousel extends StatefulWidget {
  const LoopingCarousel({super.key});

  @override
  State<LoopingCarousel> createState() => _LoopingCarouselState();
}

class _LoopingCarouselState extends State<LoopingCarousel> {
  final PageController _pageController = PageController(initialPage: 0);
  Timer? _timer;
  int _currentPage = 0;

  @override
  void initState() {
    super.initState();
    _startAutoScroll();
  }

  @override
  void dispose() {
    _timer?.cancel();
    _pageController.dispose();
    super.dispose();
  }

  void _startAutoScroll() {
    _timer = Timer.periodic(const Duration(seconds: 5), (timer) {
      if (_currentPage < imagePaths.length) {
        _currentPage++;
        _pageController.animateToPage(
          _currentPage,
          duration: const Duration(milliseconds: 500),
          curve: Curves.easeInOut,
        );
      } else {
        // Reset vị trí ngầm về trang đầu khi đạt đến trang cuối cùng
        _currentPage = 0;
        _pageController.jumpToPage(_currentPage);
        _pageController.animateToPage(
          _currentPage + 1,
          duration: const Duration(milliseconds: 500),
          curve: Curves.easeInOut,
        );
      }
    });
  }

  @override
  Widget build(BuildContext context) {
    return SizedBox(
      height: MediaQuery.sizeOf(context).height * 0.5,
      width: MediaQuery.sizeOf(context).width,
      child: PageView.builder(
        controller: _pageController,
        itemCount:
            imagePaths.length + 1, // Thêm một trang để tạo hiệu ứng vòng lặp
        onPageChanged: (index) {
          // Kiểm tra nếu đến trang sao chép ở cuối
          if (index == imagePaths.length) {
            Future.delayed(const Duration(milliseconds: 300), () {
              // Nhảy về trang đầu (trang thực sự) mà không có hiệu ứng
              _pageController.jumpToPage(0);
              _currentPage = 0;
            });
          } else {
            _currentPage = index;
          }
        },
        itemBuilder: (context, index) {
          final imageIndex =
              index % imagePaths.length; // Lấy ảnh theo index thực
          return Image.asset(imagePaths[imageIndex], fit: BoxFit.cover);
        },
      ),
    );
  }
}

```

---


### Pages\HomePage\Widgets\middle_custom_widget.dart

```dart
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:tictactoe_gameapp/Configs/constants.dart';
import 'dart:math';

class MiddleCustomWidget extends StatelessWidget {
  MiddleCustomWidget({
    super.key,
  });
  final CarouselController carouselController =
      Get.put(CarouselController(), permanent: true);
  @override
  Widget build(BuildContext context) {
    carouselController.reinitializePageController();
    return PageView.builder(
      controller: carouselController.pageController,
      itemCount: carouselController.virtualItemCount,
      physics: const BouncingScrollPhysics(),
      itemBuilder: (context, index) {
        int realIndex = carouselController.getRealIndex(index);
        return GestureDetector(
          onTap: () => Get.to(
            () => images[realIndex].page,
            transition: Transition.zoom,
            duration: duration750,
          ),
          child: Obx(() {
            return Transform(
              alignment: Alignment.center,
              transform: carouselController.build3DTransform(index),
              child: Stack(
                children: [
                  Container(
                    margin: const EdgeInsets.symmetric(
                      horizontal: 20,
                    ),
                    decoration: BoxDecoration(
                      borderRadius: BorderRadius.circular(20),
                      border: Border.all(
                        color: Colors.blueAccent,
                        width: 5,
                      ),
                      boxShadow: const [
                        BoxShadow(
                          color: Colors.black26,
                          offset: Offset(0, 4),
                          blurRadius: 10,
                        ),
                      ],
                    ),
                    child: ClipRRect(
                      borderRadius: BorderRadius.circular(15),
                      child: Image.asset(
                        images[realIndex].image,
                        fit: BoxFit.cover,
                      ),
                    ),
                  ),
                  Positioned(
                    top: 10,
                    child: RotatedBox(
                      quarterTurns: 1,
                      child: Container(
                        padding: const EdgeInsets.symmetric(horizontal: 10),
                        decoration: const BoxDecoration(
                          color: Colors.deepPurple,
                          borderRadius: BorderRadius.only(
                            bottomLeft: Radius.circular(50),
                            bottomRight: Radius.circular(50),
                          ),
                        ),
                        child: Text(
                          images[realIndex].title,
                          style: const TextStyle(
                            color: Colors.white,
                            fontWeight: FontWeight.bold,
                            fontSize: 15,
                          ),
                        ),
                      ),
                    ),
                  ),
                  Positioned(
                    top: 20,
                    left: 30,
                    child: Text(
                      images[realIndex].title,
                      style: const TextStyle(
                        color: Colors.white,
                        fontWeight: FontWeight.bold,
                        fontSize: 12,
                      ),
                    ),
                  )
                ],
              ),
            );
          }),
        );
      },
    );
  }
}

class CarouselController extends GetxController {
  final int realItemCount = images.length;
  late final int virtualItemCount;
  late PageController pageController;
  late var currentPage = (realItemCount * 500).toDouble().obs;

  @override
  void onInit() {
    super.onInit();
    virtualItemCount = realItemCount * 1000;
    _initializePageController();
  }

  void _initializePageController() {
    pageController =
        PageController(viewportFraction: 0.4, initialPage: realItemCount * 500);
    pageController.addListener(_pageListener);
  }

  void reinitializePageController() {
    pageController.removeListener(_pageListener);
    _initializePageController();
  }

  void _pageListener() {
    if (pageController.positions.length == 1) {
      currentPage.value = pageController.page!;
    }
  }

  int getRealIndex(int virtualIndex) {
    return virtualIndex % realItemCount;
  }

  Matrix4 build3DTransform(int index) {
    double offsetFromCenter = index - currentPage.value;
    double angle = offsetFromCenter * pi / 5;
    double scale = 1 - (offsetFromCenter.abs() * 0.3);
    double depth = -300 * cos(angle);

    return Matrix4.identity()
      ..rotateY(angle)
      ..translate(200 * sin(angle), 0.0, depth)
      ..scale(scale);
  }

  Color itemColor(int index) {
    double offsetFromCenter = (index - currentPage.value).abs();
    double opacity = 1 - offsetFromCenter * 0.5;
    opacity = opacity.clamp(0.0, 1.0);

    return Colors.red.withOpacity(opacity);
  }

  @override
  void onClose() {
    pageController.removeListener(_pageListener);
    pageController.dispose();
    super.onClose();
  }
}

```

---


### Pages\LobbyPage\lobby_page.dart

```dart
import 'dart:ui';

import 'package:flutter/material.dart';
import 'package:flutter_animate/flutter_animate.dart';
import 'package:flutter_svg/svg.dart';
import 'package:get/get.dart';
import 'package:tictactoe_gameapp/Components/user_card.dart';
import 'package:tictactoe_gameapp/Configs/constants.dart';
import 'package:tictactoe_gameapp/Configs/messages.dart';
import 'package:tictactoe_gameapp/Controller/Music/background_music_controller.dart';
import 'package:tictactoe_gameapp/Controller/profile_controller.dart';
import 'package:tictactoe_gameapp/Pages/GamePage/PlayerGame/multi_player.dart';
import 'package:tictactoe_gameapp/Pages/LobbyPage/Widget/end_drawer_lobby.dart';
import 'package:tictactoe_gameapp/Pages/LobbyPage/Widget/game_info.dart';
import 'package:tictactoe_gameapp/Pages/LobbyPage/Widget/room_info.dart';
import 'package:tictactoe_gameapp/Controller/matching_controller.dart';
import 'package:tictactoe_gameapp/Controller/Console/play_with_player_controller.dart';
import '../../Components/primary_button.dart';
import '../../Configs/assets_path.dart';
import '../../Controller/room_controller.dart';

class LobbyPage extends StatelessWidget {
  final String roomId;
  const LobbyPage({
    super.key,
    required this.roomId,
  });

  @override
  Widget build(BuildContext context) {
    final w = MediaQuery.of(context).size.width;
    final RoomController roomController = Get.find();
    roomController.listenRoomChanges(roomId);
    final MatchingController matchController = Get.find();
    final PlayWithPlayerController playWithPlayerController =
        Get.put(PlayWithPlayerController());
    final ProfileController profileController = Get.find<ProfileController>();
    final user = profileController.user!;
    final GlobalKey<ScaffoldState> scaffoldKey = GlobalKey<ScaffoldState>();
    // final musicController = Get.find<MusicController>();
    // WidgetsBinding.instance.addPostFrameCallback((_) {
    // musicController.playMusicOnScreen7();
    // Get.find<NotificationController>().showNotification(
    //   'Your Great!',
    //   'You have joined room: $roomId',
    //   {'screen': 'SplacePage'},
    // );
    // });
    return Scaffold(
      key: scaffoldKey,
      endDrawer: EndDrawerLobby(
        roomId: roomId,
        user: user,
      ),
      body: SafeArea(
        child: Padding(
          padding: const EdgeInsets.all(20),
          child: SingleChildScrollView(
            child: Column(
              children: [
                Row(
                  children: [
                    InkWell(
                      onTap: () async {
                        // musicController.stopMusicOnScreen7();
                        await matchController.deleteRoom(roomId);
                        Get.offAllNamed("/mainHome");
                      },
                      child: SvgPicture.asset(IconsPath.backIcon),
                    ),
                    const SizedBox(width: 15),
                    Text(
                      "Play With Private Room",
                      style: Theme.of(context).textTheme.bodyMedium,
                    ),
                  ],
                ),
                const SizedBox(height: 20),
                RoomInfo(roomCode: roomId),
                const SizedBox(height: 30),
                Obx(() {
                  if (roomController.roomData.value == null) {
                    return const Center(
                      child: CircularProgressIndicator(),
                    );
                  }

                  final room = roomController.roomData.value;

                  if (room == null) {
                    return const Text("Room does not exist.");
                  }

                  var player1 = room.player1;
                  var player2 = room.player2;

                  if (player2 != null) {
                    WidgetsBinding.instance.addPostFrameCallback((_) async {
                      await Future.delayed(const Duration(seconds: 2));
                      matchController.cancelFindingPlayer2();
                    });
                  } else {}

                  if (room.player1Status == "ready" &&
                      room.player2Status == "ready") {
                    WidgetsBinding.instance.addPostFrameCallback((_) async {
                      await Future.delayed(const Duration(seconds: 2));
                      // musicController.stopMusicOnScreen7();
                      Get.to(
                        MultiPlayer(
                          roomId: roomId,
                        ),
                        transition: Transition.zoom,
                      );
                    });
                  } else {}

                  return Stack(
                    children: [
                      Column(
                        children: [
                          GameInfo(
                            roomData: room,
                          ),
                          const SizedBox(height: 80),
                          Row(
                            mainAxisAlignment: MainAxisAlignment.spaceBetween,
                            children: [
                              player1 != null
                                  ? UserCard(
                                      user: player1,
                                      status: room.player1Status ?? "",
                                    )
                                  : SizedBox(
                                      width: w / 2.6,
                                      child: const Text(
                                        "Waiting for Player 1...",
                                        style: TextStyle(color: Colors.blue),
                                      ),
                                    ),
                              player2 != null
                                  ? UserCard(
                                      user: player2,
                                      status: room.player2Status ?? "",
                                    )
                                  : SizedBox(
                                      width: w / 2.6,
                                      child: Obx(
                                        () => Column(
                                          children: [
                                            matchController
                                                    .isFindingPlayer2.value
                                                ? const Text(
                                                    "Finding for Player 2...",
                                                    style: TextStyle(
                                                        color:
                                                            Colors.redAccent),
                                                  )
                                                : const Text(
                                                    "Waiting for Player 2...",
                                                    style: TextStyle(
                                                        color: Colors.blue),
                                                  ),
                                            const SizedBox(
                                              height: 5,
                                            ),
                                            matchController
                                                    .isFindingPlayer2.value
                                                ? Column(
                                                    children: [
                                                      ClipRRect(
                                                        borderRadius:
                                                            BorderRadius
                                                                .circular(100),
                                                        child: Image.asset(
                                                          GifsPath.loadingGif,
                                                          width: 100,
                                                          height: 100,
                                                        ),
                                                      ),
                                                      const SizedBox(
                                                        height: 5,
                                                      ),
                                                    ],
                                                  )
                                                : const SizedBox(),
                                            matchController
                                                    .isFindingPlayer2.value
                                                ? ElevatedButton.icon(
                                                    onPressed: () {
                                                      matchController
                                                          .cancelFindingPlayer2();
                                                    },
                                                    label: const Text("Cancel"),
                                                    icon: const Icon(
                                                        Icons.search_off),
                                                    style: ElevatedButton
                                                        .styleFrom(
                                                      padding: const EdgeInsets
                                                          .symmetric(
                                                          horizontal: 20,
                                                          vertical: 12),
                                                      backgroundColor:
                                                          Colors.white,
                                                      shape:
                                                          RoundedRectangleBorder(
                                                        borderRadius:
                                                            BorderRadius
                                                                .circular(50),
                                                      ),
                                                    ),
                                                  )
                                                : Column(
                                                    children: [
                                                      GestureDetector(
                                                        onTap: () {
                                                          scaffoldKey
                                                              .currentState!
                                                              .openEndDrawer();
                                                        },
                                                        child: Container(
                                                          padding:
                                                              const EdgeInsets
                                                                  .all(15),
                                                          decoration:
                                                              BoxDecoration(
                                                            color: Colors.white,
                                                            borderRadius:
                                                                BorderRadius
                                                                    .circular(
                                                                        100),
                                                            border: Border.all(
                                                              color:
                                                                  Colors.grey,
                                                              width: 5,
                                                            ),
                                                          ),
                                                          child: const Icon(
                                                            Icons.add,
                                                            color:
                                                                Colors.black87,
                                                            size: 40,
                                                          ),
                                                        ),
                                                      ),
                                                      const SizedBox(
                                                        height: 5,
                                                      ),
                                                      ElevatedButton.icon(
                                                        onPressed: () {
                                                          matchController
                                                              .findingPlayer2();
                                                        },
                                                        label: const Text(
                                                            "Finding"),
                                                        icon: const Icon(
                                                          Icons.search,
                                                        ),
                                                        style: ElevatedButton
                                                            .styleFrom(
                                                          foregroundColor:
                                                              Colors.blue,
                                                          padding:
                                                              const EdgeInsets
                                                                  .symmetric(
                                                                  horizontal:
                                                                      20,
                                                                  vertical: 12),
                                                          backgroundColor:
                                                              Colors.white,
                                                          shape:
                                                              RoundedRectangleBorder(
                                                            borderRadius:
                                                                BorderRadius
                                                                    .circular(
                                                                        50),
                                                          ),
                                                        ),
                                                      ),
                                                    ],
                                                  ),
                                          ],
                                        ),
                                      ),
                                    ),
                            ],
                          ),
                          const SizedBox(height: 20),
                          room.player1 != null &&
                                  room.player1!.email == user.email
                              ? PrimaryButton(
                                  buttonText: room.player1Status! == "ready"
                                      ? " Waiting for start"
                                      : "Start Game",
                                  onTap: () {
                                    if (room.player1Status! != "ready") {
                                      playWithPlayerController
                                          .showPickerMultiPlayer(
                                              roomId: roomId);
                                    } else {
                                      errorMessage("Waiting for game start");
                                    }
                                  },
                                )
                              : room.player2Status == "waiting"
                                  ? PrimaryButton(
                                      buttonText: "Ready",
                                      onTap: () async {
                                        await roomController
                                            .updatePlayer2Status(
                                                roomId, "ready");
                                      },
                                    )
                                  : PrimaryButton(
                                      buttonText: "Waiting for start",
                                      onTap: () async {
                                        await roomController
                                            .updatePlayer2Status(
                                                roomId, "waiting");
                                      },
                                    ),
                        ],
                      ),
                      room.player1Status == "ready" &&
                              room.player2Status == "ready"
                          ? Positioned.fill(
                              child: BackdropFilter(
                                filter:
                                    ImageFilter.blur(sigmaX: 5.0, sigmaY: 5.0),
                                child: const SizedBox(),
                              ),
                            ).animate().fadeIn(duration: duration750)
                          : const SizedBox(),
                      room.player1Status == "ready" &&
                              room.player2Status == "ready"
                          ? Positioned(
                              top: 10,
                              left: 0,
                              right: 0,
                              child: Center(
                                child: ClipRRect(
                                  borderRadius: BorderRadius.circular(100),
                                  child: Image.asset(
                                    GifsPath.loadingGif,
                                    width: 200,
                                    height: 200,
                                  ),
                                ),
                              ),
                            ).animate().slide(duration: duration750)
                          : const SizedBox(),
                    ],
                  );
                }),
              ],
            ),
          ),
        ),
      ),
    );
  }
}

```

---


### Pages\LobbyPage\Widget\end_drawer_lobby.dart

```dart
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:tictactoe_gameapp/Components/belong_to_users/avatar_user_widget.dart';
import 'package:tictactoe_gameapp/Controller/MainHome/notify_in_main_controller.dart';
import 'package:tictactoe_gameapp/Data/fetch_firestore_database.dart';
import 'package:tictactoe_gameapp/Models/user_model.dart';

class EndDrawerLobby extends StatelessWidget {
  final String roomId;
  final UserModel user;
  const EndDrawerLobby({super.key, required this.roomId, required this.user});

  @override
  Widget build(BuildContext context) {
    final FirestoreController firestoreController =
        Get.put(FirestoreController());
    final NotifyInMainController notifyInMainController = Get.find();
    return Drawer(
      width: 250,
      child: Obx(
        () {
          if (firestoreController.friendsList.isEmpty) {
            return const Center(child: CircularProgressIndicator());
          }
          var friends = firestoreController.friendsList.toList();
          return Padding(
            padding: const EdgeInsets.symmetric(
              vertical: 30,
            ),
            child: Column(
              children: [
                const Text(
                  'Friends',
                  style: TextStyle(
                    fontSize: 25,
                    fontWeight: FontWeight.bold,
                    color: Colors.lightBlue,
                  ),
                ),
                const Divider(),
                Expanded(
                  child: ListView.builder(
                    scrollDirection: Axis.vertical,
                    physics: const BouncingScrollPhysics(),
                    itemCount: friends.length,
                    itemBuilder: (context, index) {
                      var friend = friends[index];
                      return Padding(
                        padding: const EdgeInsets.all(8.0),
                        child: Row(
                          mainAxisAlignment: MainAxisAlignment.spaceBetween,
                          children: [
                            Stack(
                              children: [
                                AvatarUserWidget(
                                  radius: 35,
                                  imagePath: friend.image!,
                                  gradientColors: friend.avatarFrame,
                                ),
                                Positioned(
                                  bottom: 0,
                                  right: 0,
                                  child: Container(
                                    width: 20,
                                    height: 20,
                                    decoration: BoxDecoration(
                                      color: Colors.green,
                                      borderRadius: BorderRadius.circular(100),
                                      border: Border.all(
                                        color: Colors.white,
                                        width: 3,
                                      ),
                                    ),
                                  ),
                                ),
                              ],
                            ),
                            Expanded(
                              child: Column(
                                children: [
                                  Text(
                                    friend.name!,
                                    style: const TextStyle(
                                      fontSize: 18,
                                      color: Colors.redAccent,
                                      fontWeight: FontWeight.bold,
                                    ),
                                  ),
                                  Text(
                                    "${friend.totalWins ?? "0"} wins",
                                    style: const TextStyle(
                                      fontSize: 13,
                                      color: Colors.grey,
                                    ),
                                  ),
                                ],
                              ),
                            ),
                            Obx(
                              () => notifyInMainController.isWaitingForOk.value
                                  ? const SizedBox(
                                      height: 30,
                                      width: 30,
                                      child: CircularProgressIndicator(
                                        color: Colors.blue,
                                      ),
                                    )
                                  : IconButton(
                                      icon: const Icon(
                                        Icons.add,
                                        color: Colors.deepPurple,
                                        size: 30,
                                      ),
                                      onPressed: () {
                                        notifyInMainController.sendGameInvite(
                                          friend.id!,
                                          roomId,
                                          user,
                                        );
                                      },
                                    ),
                            ),
                          ],
                        ),
                      );
                    },
                  ),
                ),
              ],
            ),
          );
        },
      ),
    );
  }
}

```

---


### Pages\LobbyPage\Widget\game_info.dart

```dart
import 'package:flutter/material.dart';
import 'package:flutter_animate/flutter_animate.dart';
import 'package:tictactoe_gameapp/Configs/constants.dart';
import 'package:tictactoe_gameapp/Models/room_model.dart';

class GameInfo extends StatelessWidget {
  final RoomModel roomData;
  const GameInfo({super.key, required this.roomData});

  @override
  Widget build(BuildContext context) {
    final w = MediaQuery.of(context).size.width;
    final ThemeData theme = Theme.of(context);
    return Container(
      height: w * 0.4,
      padding: const EdgeInsets.all(20),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(20),
      ),
      child: SingleChildScrollView(
        scrollDirection: Axis.horizontal,
        child: Row(
          mainAxisAlignment: MainAxisAlignment.spaceBetween,
          children: [
            Column(
              children: [
                Text(
                  "Map",
                  style: theme.textTheme.bodyLarge,
                ),
                const SizedBox(
                  height: 5,
                ),
                Container(
                  height: w * 0.2,
                  width: w * 0.2,
                  decoration: const BoxDecoration(color: Colors.grey),
                  child: roomData.pickedMap != null
                      ? Image.asset(
                          roomData.pickedMap!,
                        ).animate().scale(duration: duration750)
                      : Icon(
                          Icons.question_mark,
                          color: Colors.white,
                          size: w * 0.15,
                        ),
                ),
              ],
            ),
            const SizedBox(
              width: 10,
            ),
            Column(
              children: [
                Text(
                  "Mode",
                  style: theme.textTheme.bodyLarge,
                ),
                const SizedBox(
                  height: 5,
                ),
                Container(
                  height: w * 0.2,
                  width: w * 0.2,
                  decoration: const BoxDecoration(color: Colors.grey),
                  child: roomData.imageMode != null
                      ? Image.asset(
                          roomData.imageMode!,
                        ).animate().scale(duration: duration750)
                      : Icon(
                          Icons.question_mark,
                          color: Colors.white,
                          size: w * 0.15,
                        ),
                ),
              ],
            ),
            const SizedBox(
              width: 10,
            ),
            Column(
              children: [
                Text(
                  "Hero X",
                  style: theme.textTheme.bodyLarge,
                ),
                const SizedBox(
                  height: 5,
                ),
                Container(
                  height: w * 0.2,
                  width: w * 0.2,
                  decoration: const BoxDecoration(color: Colors.grey),
                  child: roomData.pickedMap != null
                      ? Image.asset(
                          roomData.champX!,
                        ).animate().scale(duration: duration750)
                      : Icon(
                          Icons.question_mark,
                          color: Colors.white,
                          size: w * 0.15,
                        ),
                ),
              ],
            ),
            const SizedBox(
              width: 10,
            ),
            Column(
              children: [
                Text(
                  "Hero O",
                  style: theme.textTheme.bodyLarge,
                ),
                const SizedBox(
                  height: 5,
                ),
                Container(
                  height: w * 0.2,
                  width: w * 0.2,
                  decoration: const BoxDecoration(color: Colors.grey),
                  child: roomData.pickedMap != null
                      ? Image.asset(roomData.champO!)
                          .animate()
                          .scale(duration: duration750)
                      : Icon(
                          Icons.question_mark,
                          color: Colors.white,
                          size: w * 0.15,
                        ),
                ),
              ],
            ),
            const SizedBox(
              width: 10,
            ),
            Column(
              children: [
                Text(
                  "Coin",
                  style: theme.textTheme.bodyLarge,
                ),
                const SizedBox(
                  height: 5,
                ),
                Container(
                  height: w * 0.2,
                  width: w * 0.2,
                  decoration: roomData.pickedMap != null
                      ? BoxDecoration(
                          color: Colors.blue,
                          border: Border.all(
                            color: Colors.yellow,
                            width: 3,
                          ),
                          borderRadius: BorderRadius.circular(100))
                      : const BoxDecoration(color: Colors.grey),
                  child: roomData.pickedMap != null
                      ? Center(
                          child: Text(
                            roomData.winningPrize!,
                            style: theme.textTheme.headlineLarge!
                                .copyWith(color: Colors.yellowAccent),
                          ),
                        ).animate().scale(duration: duration750)
                      : Icon(
                          Icons.question_mark,
                          color: Colors.white,
                          size: w * 0.15,
                        ),
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }
}

```

---


### Pages\LobbyPage\Widget\pricing_area.dart

```dart
import 'package:flutter/material.dart';
import 'package:flutter_svg/svg.dart';

import '../../../Configs/assets_path.dart';

class PriceArea extends StatelessWidget {
  final String entryPrice;
  final String winningPrice;
  const PriceArea({super.key, required this.entryPrice, required this.winningPrice});

  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        Row(
          mainAxisAlignment: MainAxisAlignment.spaceBetween,
          children: [
            Container(
              padding: const EdgeInsets.symmetric(horizontal: 20,vertical: 15),
              decoration: BoxDecoration(
                  color: Theme.of(context).colorScheme.secondary,
                  borderRadius: BorderRadius.circular(10)
              ),
              child: const Row(
                children: [
                  Text("Entry Price")
                ],
              ),
            ),
            Column(
              children: [
                Container(
                  height: 10,
                  width: 10,
                  decoration: BoxDecoration(
                      borderRadius: BorderRadius.circular(100),
                      color: Theme.of(context).colorScheme.primaryContainer
                  ),
                ),
                const SizedBox(height: 10,),
                Container(
                  height: 10,
                  width: 10,
                  decoration: BoxDecoration(
                      borderRadius: BorderRadius.circular(100),
                      color: Theme.of(context).colorScheme.primary
                  ),
                )
              ],
            ),
            Container(
              padding: const EdgeInsets.symmetric(horizontal: 20,vertical: 15),
              decoration: BoxDecoration(
                  color: Theme.of(context).colorScheme.primaryContainer,
                  borderRadius: BorderRadius.circular(10)
              ),
              child: Row(
                children: [
                  SvgPicture.asset(IconsPath.coinIcon),
                  const SizedBox(width: 10,),
                  Text(entryPrice.toString())
                ],
              ),
            )
          ],
        ),
        const SizedBox(height: 10,),
        Row(
          mainAxisAlignment: MainAxisAlignment.spaceBetween,
          children: [
            Container(
              padding: const EdgeInsets.symmetric(horizontal: 20,vertical: 15),
              decoration: BoxDecoration(
                  color: Theme.of(context).colorScheme.secondary,
                  borderRadius: BorderRadius.circular(10)
              ),
              child: const Row(
                children: [
                  Text("Winning Price")
                ],
              ),
            ),
            Column(
              children: [
                Container(
                  height: 10,
                  width: 10,
                  decoration: BoxDecoration(
                      borderRadius: BorderRadius.circular(100),
                      color: Theme.of(context).colorScheme.primaryContainer
                  ),
                ),
                const SizedBox(height: 10,),
                Container(
                  height: 10,
                  width: 10,
                  decoration: BoxDecoration(
                      borderRadius: BorderRadius.circular(100),
                      color: Theme.of(context).colorScheme.primary
                  ),
                )
              ],
            ),
            Container(
              padding: const EdgeInsets.symmetric(horizontal: 20,vertical: 15),
              decoration: BoxDecoration(
                  color: Theme.of(context).colorScheme.primaryContainer,
                  borderRadius: BorderRadius.circular(10)
              ),
              child: Row(
                children: [
                  SvgPicture.asset(IconsPath.coinIcon),
                  const SizedBox(width: 10,),
                  Text(winningPrice.toString())
                ],
              ),
            )
          ],
        )
      ],
    );
  }
}

```

---


### Pages\LobbyPage\Widget\room_info.dart

```dart
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:share_plus/share_plus.dart';
import 'package:tictactoe_gameapp/Configs/messages.dart';
import 'package:tictactoe_gameapp/Controller/auth_controller.dart';

class RoomInfo extends StatelessWidget {
  final String roomCode;
  const RoomInfo({super.key, required this.roomCode});

  @override
  Widget build(BuildContext context) {
    final w = MediaQuery.of(context).size.width;
    final AuthController auth = Get.find<AuthController>();
    return Container(
      padding: const EdgeInsets.all(20),
      decoration: BoxDecoration(
        color: Theme.of(context).colorScheme.primaryContainer,
        borderRadius: BorderRadius.circular(20),
      ),
      child: Row(
        children: [
          Expanded(
            child: Column(
              children: [
                // const Row(
                //   children: [
                //     Text("Generated Room Code"),
                //   ],
                // ),
                // const SizedBox(height: 20),
                Row(
                  children: [
                    Expanded(
                        child: Container(
                      height: 70,
                      padding: const EdgeInsets.all(10),
                      decoration: BoxDecoration(
                        color: Theme.of(context).colorScheme.surface,
                        borderRadius: BorderRadius.circular(10),
                      ),
                      child: Row(
                        mainAxisAlignment: MainAxisAlignment.center,
                        children: [
                          Text(
                            roomCode,
                            style: TextStyle(
                              color: Colors.deepPurpleAccent,
                              fontSize: w / 14,
                              letterSpacing: 2.4,
                              fontFamily: "Poppins",
                              fontWeight: FontWeight.w600,
                            ),
                          ),
                        ],
                      ),
                    )),
                    const SizedBox(width: 10),
                    InkWell(
                      onTap: () async {
                        
                        final result = await Share.share(
                            "${auth.getCurrentUserEmail()} invited you play roomCode: $roomCode");
                        if (result.status == ShareResultStatus.success) {
                          successMessage("Your enemy has recieved roomCode");
                        } else {
                          errorMessage("Your enemy has not recieved roomCode");
                        }
                      },
                      child: Ink(
                        padding: const EdgeInsets.all(13),
                        height: 70,
                        width: 70,
                        decoration: BoxDecoration(
                          borderRadius: BorderRadius.circular(10),
                          color: Theme.of(context).colorScheme.primary,
                        ),
                        child: const Icon(
                          Icons.ios_share_outlined,
                          color: Colors.white,
                          size: 40,
                        ),
                      ),
                    ),
                  ],
                ),
                const SizedBox(height: 20),
                Text(
                  "Share This Private code with your Friends & Ask Theme To Join The Game",
                  style: Theme.of(context)
                      .textTheme
                      .bodyMedium
                      ?.copyWith(color: Theme.of(context).colorScheme.primary),
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }
}

```

---


### Pages\Login\change_password_dialog.dart

```dart
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:tictactoe_gameapp/Configs/constants.dart';
import 'package:tictactoe_gameapp/Configs/messages.dart';
import 'package:tictactoe_gameapp/Controller/auth_controller.dart';
import 'package:tictactoe_gameapp/Enums/firebase_exception.dart';

class PasswordChangeDialog {
  static Future<void> showPasswordChangeDialogWhenNotUser() async {
    final TextEditingController oldPasswordController = TextEditingController();
    final TextEditingController newPasswordController = TextEditingController();
    final TextEditingController emailController = TextEditingController();
    final AuthController auth = Get.find<AuthController>();
    final GlobalKey<FormState> formKey = GlobalKey<FormState>();

    await Get.dialog(
      AlertDialog(
        title: const Text('Change Password'),
        content: SingleChildScrollView(
          child: Form(
            key: formKey,
            child: Column(
              children: <Widget>[
                TextFormField(
                  controller: emailController,
                  validator: emaildValidator.call,
                  textInputAction: TextInputAction.next,
                  keyboardType: TextInputType.emailAddress,
                  decoration: const InputDecoration(
                    hintText: "Email",
                    hintStyle: TextStyle(color: Colors.white),
                    prefixIcon: Icon(
                      Icons.email,
                      color: Colors.white,
                    ),
                    fillColor: Colors.blueGrey,
                  ),
                ),
                const SizedBox(height: 10),
                Obx(() => TextFormField(
                      controller: oldPasswordController,
                      validator: passwordValidator.call,
                      textInputAction: TextInputAction.next,
                      obscureText: auth.obscure.value,
                      decoration: InputDecoration(
                        hintText: "Old Password",
                        hintStyle: const TextStyle(color: Colors.white),
                        prefixIcon: const Icon(
                          Icons.lock_outline,
                          color: Colors.white,
                        ),
                        suffixIcon: IconButton(
                          icon: Icon(
                            !auth.obscure.value
                                ? Icons.visibility
                                : Icons.visibility_off_outlined,
                          ),
                          onPressed: auth.togglePasswordVisibility,
                        ),
                        fillColor: Colors.blueGrey,
                      ),
                    )),
                const SizedBox(height: 10),
                Obx(() => TextFormField(
                      controller: newPasswordController,
                      validator: passwordValidator.call,
                      textInputAction: TextInputAction.done,
                      obscureText: auth.obscure.value,
                      decoration: InputDecoration(
                        hintText: "New Password",
                        hintStyle: const TextStyle(color: Colors.white),
                        prefixIcon: const Icon(
                          Icons.lock,
                          color: Colors.white,
                        ),
                        suffixIcon: IconButton(
                          icon: Icon(
                            !auth.obscure.value
                                ? Icons.visibility
                                : Icons.visibility_off_outlined,
                          ),
                          onPressed: auth.togglePasswordVisibility,
                        ),
                        fillColor: Colors.blueGrey,
                      ),
                    )),
                const SizedBox(
                  height: 10,
                ),
                Row(
                  mainAxisAlignment: MainAxisAlignment.spaceAround,
                  children: [
                    OutlinedButton(
                      onPressed: () => Get.back(),
                      child: const Text('Cancel'),
                    ),
                    const SizedBox(
                      width: 5,
                    ),
                    OutlinedButton(
                      onPressed: () async {
                        if (formKey.currentState!.validate()) {
                          AuthStatus status =
                              await auth.changePasswordWhenNotUser(
                            oldPasswordController.text.trim(),
                            newPasswordController.text.trim(),
                            emailController.text.trim(),
                          );
                          if (status == AuthStatus.successful) {
                            successMessage(
                                "Changed Password ${auth.getCurrentUserEmail()} successfully !");
                            Get.offAllNamed("/auth");
                          } else {
                            String error =
                                AuthExceptionHandler.generateErrorMessage(
                                    status);
                            errorMessage(error);
                          }
                        }
                      },
                      child: const Text('  OK  '),
                    ),
                  ],
                )
              ],
            ),
          ),
        ),
      ),
    );
  }

  static Future<void> showPasswordChangeDialogWhenUser() async {
    final TextEditingController oldPasswordController = TextEditingController();
    final TextEditingController newPasswordController = TextEditingController();
    final TextEditingController emailController = TextEditingController();
    final AuthController auth = Get.find<AuthController>();
    final GlobalKey<FormState> formKey = GlobalKey<FormState>();

    await Get.dialog(
      AlertDialog(
        title: const Text('Change Password'),
        content: SingleChildScrollView(
          child: Form(
            key: formKey,
            child: Column(
              children: <Widget>[
                TextFormField(
                  controller: emailController,
                  validator: emaildValidator.call,
                  textInputAction: TextInputAction.next,
                  keyboardType: TextInputType.emailAddress,
                  decoration: const InputDecoration(
                    hintText: "Email",
                    hintStyle: TextStyle(color: Colors.white),
                    prefixIcon: Icon(
                      Icons.email,
                      color: Colors.white,
                    ),
                    fillColor: Colors.blueGrey,
                  ),
                ),
                const SizedBox(height: 10),
                Obx(() => TextFormField(
                      controller: oldPasswordController,
                      validator: passwordValidator.call,
                      textInputAction: TextInputAction.next,
                      obscureText: auth.obscure.value,
                      decoration: InputDecoration(
                        hintText: "Old Password",
                        hintStyle: const TextStyle(color: Colors.white),
                        prefixIcon: const Icon(
                          Icons.lock_outline,
                          color: Colors.white,
                        ),
                        suffixIcon: IconButton(
                          icon: Icon(
                            !auth.obscure.value
                                ? Icons.visibility
                                : Icons.visibility_off,
                          ),
                          onPressed: auth.togglePasswordVisibility,
                        ),
                        fillColor: Colors.blueGrey,
                      ),
                    )),
                const SizedBox(height: 10),
                Obx(() => TextFormField(
                      controller: newPasswordController,
                      validator: passwordValidator.call,
                      textInputAction: TextInputAction.done,
                      obscureText: auth.obscure.value,
                      decoration: InputDecoration(
                        hintText: "New Password",
                        hintStyle: const TextStyle(color: Colors.white),
                        prefixIcon: const Icon(
                          Icons.lock,
                          color: Colors.white,
                        ),
                        suffixIcon: IconButton(
                          icon: Icon(
                            !auth.obscure.value
                                ? Icons.visibility
                                : Icons.visibility_off,
                          ),
                          onPressed: auth.togglePasswordVisibility,
                        ),
                        fillColor: Colors.blueGrey,
                      ),
                    )),
                const SizedBox(
                  height: 10,
                ),
                Row(
                  mainAxisAlignment: MainAxisAlignment.spaceAround,
                  children: [
                    OutlinedButton(
                      onPressed: () => Get.back(),
                      child: const Text('Cancel'),
                    ),
                    const SizedBox(
                      width: 5,
                    ),
                    OutlinedButton(
                      onPressed: () async {
                        if (formKey.currentState!.validate()) {
                          AuthStatus status = await auth.changePasswordWhenUser(
                            oldPasswordController.text.trim(),
                            newPasswordController.text.trim(),
                            emailController.text.trim(),
                          );
                          if (status == AuthStatus.successful) {
                            successMessage(
                                "Changed Password ${auth.getCurrentUserEmail()} successfully !");
                            Get.offAllNamed("/mainHome");
                          } else {
                            String error =
                                AuthExceptionHandler.generateErrorMessage(
                                    status);
                            errorMessage(error);
                          }
                        }
                      },
                      child: const Text('  OK  '),
                    ),
                  ],
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }
}

```

---


### Pages\Login\login_sheet.dart

```dart
import 'package:bottom_sheet/bottom_sheet.dart';
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:tictactoe_gameapp/Configs/assets_path.dart';
import 'package:tictactoe_gameapp/Configs/constants.dart';
import 'package:tictactoe_gameapp/Configs/messages.dart';
import 'package:tictactoe_gameapp/Controller/auth_controller.dart';
import 'package:tictactoe_gameapp/Enums/firebase_exception.dart';
import 'package:tictactoe_gameapp/Pages/Login/change_password_dialog.dart';

Future<void> loginBottomSheet(BuildContext context) async {
  await showFlexibleBottomSheet(
    minHeight: 0,
    initHeight: 0.7,
    maxHeight: 1,
    context: context,
    builder: _buildLoginBottomSheet,
    duration: const Duration(milliseconds: 1000),
    decoration: BoxDecoration(
      color: Theme.of(context).colorScheme.primary.withOpacity(0.4),
      border: Border.all(color: Colors.white, width: 4),
    ),
    // anchors: [0, 0.5, 1],
    isSafeArea: true,
  );
}

final GlobalKey<FormState> formKey = GlobalKey<FormState>();
final GlobalKey<FormState> formKeyReset = GlobalKey<FormState>();
final TextEditingController emailController = TextEditingController();
final TextEditingController passwordController = TextEditingController();
final TextEditingController emailResetController = TextEditingController();
final AuthController auth = Get.find<AuthController>();

Widget _buildLoginBottomSheet(
  BuildContext context,
  ScrollController scrollController,
  double bottomSheetOffset,
) {
  return Padding(
    padding: const EdgeInsets.all(20),
    child: SingleChildScrollView(
      controller: scrollController,
      child: Column(
        children: [
          const Icon(
            Icons.login_outlined,
            color: Colors.white,
            size: 100,
          ),
          const SizedBox(
            height: 10,
          ),
          Text(
            "L O G I N",
            style: Theme.of(context)
                .textTheme
                .titleLarge!
                .copyWith(color: Colors.white, fontWeight: FontWeight.bold),
          ),
          const SizedBox(
            height: 10,
          ),
          Form(
            key: formKey,
            child: Column(
              children: [
                TextFormField(
                  controller: emailController,
                  validator: emaildValidator.call,
                  autovalidateMode: AutovalidateMode.always,
                  textInputAction: TextInputAction.next,
                  keyboardType: TextInputType.emailAddress,
                  decoration: const InputDecoration(
                    hintText: "Email address",
                    prefixIcon: Icon(Icons.email_outlined),
                  ),
                ),
                const SizedBox(height: 10),
                Obx(
                  () => TextFormField(
                    controller: passwordController,
                    validator: passwordValidator.call,
                    autovalidateMode: AutovalidateMode.always,
                    textInputAction: TextInputAction.done,
                    obscureText: auth.obscure.value,
                    decoration: InputDecoration(
                      hintText: "Password",
                      prefixIcon: const Icon(Icons.key_outlined),
                      suffixIcon: IconButton(
                        icon: Icon(
                          !auth.obscure.value
                              ? Icons.visibility
                              : Icons.visibility_off,
                        ),
                        onPressed: auth.togglePasswordVisibility,
                      ),
                    ),
                  ),
                ),
                const SizedBox(
                  height: 5,
                ),
                Row(
                  mainAxisAlignment: MainAxisAlignment.spaceBetween,
                  children: [
                    TextButton(
                      onPressed: () async {
                        await PasswordChangeDialog
                            .showPasswordChangeDialogWhenNotUser();
                      },
                      child: const Text(
                        "Change your password?",
                        style: TextStyle(color: Colors.blueAccent),
                      ),
                    ),
                    TextButton(
                      onPressed: () async {
                        Get.defaultDialog(
                          content: Form(
                            key: formKeyReset,
                            child: Column(
                              children: [
                                TextFormField(
                                  controller: emailResetController,
                                  validator: emaildValidator.call,
                                  keyboardType: TextInputType.emailAddress,
                                  textInputAction: TextInputAction.done,
                                  autovalidateMode: AutovalidateMode.always,
                                  decoration: InputDecoration(
                                    hintText: "email",
                                    prefixIcon: const Icon(Icons.email),
                                    filled: true,
                                    enabledBorder: OutlineInputBorder(
                                      borderRadius: BorderRadius.circular(20.0),
                                      borderSide: BorderSide(
                                        color: Colors.grey.shade300,
                                        width: 2.0,
                                      ),
                                    ),
                                    focusedBorder: OutlineInputBorder(
                                      borderRadius: BorderRadius.circular(20.0),
                                      borderSide: BorderSide(
                                        color: Colors.blue.shade300,
                                        width: 2.0,
                                      ),
                                    ),
                                    errorBorder: OutlineInputBorder(
                                      borderRadius: BorderRadius.circular(20.0),
                                      borderSide: BorderSide(
                                        color: Colors.red.shade300,
                                        width: 2.0,
                                      ),
                                    ),
                                    focusedErrorBorder: OutlineInputBorder(
                                      borderRadius: BorderRadius.circular(20.0),
                                      borderSide: BorderSide(
                                        color: Colors.red.shade500,
                                        width: 2.0,
                                      ),
                                    ),
                                  ),
                                ),
                                const SizedBox(
                                  height: 10,
                                ),
                                MaterialButton(
                                  color: Colors.greenAccent,
                                  disabledColor: Colors.redAccent,
                                  splashColor: Colors.greenAccent,
                                  onPressed: () async {
                                    if (formKeyReset.currentState!.validate()) {
                                      AuthStatus status =
                                          await auth.resetPassword(
                                              email: emailResetController.text
                                                  .trim());
                                      if (status == AuthStatus.successful) {
                                        successMessage(
                                            "Resetting ${auth.getCurrentUserEmail()} successfully !");
                                        Get.offAllNamed("/auth");
                                      } else {
                                        String error = AuthExceptionHandler
                                            .generateErrorMessage(status);
                                        errorMessage(error);
                                      }
                                    }
                                  },
                                  child: const Text("Reset"),
                                ),
                              ],
                            ),
                          ),
                          title: "Reset Password",
                        );
                      },
                      child: const Text(
                        "Reset your password?",
                        style: TextStyle(color: Colors.redAccent),
                      ),
                    ),
                  ],
                ),
                OutlinedButton(
                  style: OutlinedButton.styleFrom(
                    backgroundColor: Colors.blue,
                    foregroundColor: Colors.white,
                  ),
                  onPressed: () async {
                    if (formKey.currentState!.validate()) {
                      AuthStatus status = await auth.signInWithEmailPassword(
                        emailController.text.trim(),
                        passwordController.text.trim(),
                      );
                      if (status == AuthStatus.successful) {
                        successMessage(
                            "Welcome ${auth.getCurrentUserEmail()} !");
                      } else {
                        String error =
                            AuthExceptionHandler.generateErrorMessage(status);
                        errorMessage(error);
                      }
                    }
                  },
                  child: const Text("Login"),
                ),
              ],
            ),
          ),
          const SizedBox(height: 20),
          ClipRRect(
            borderRadius: BorderRadius.circular(20),
            child: Image.asset(
              GifsPath.tictactoeGif,
            ),
          ),
        ],
      ),
    ),
  );
}

```

---


### Pages\MainHome\main_home.dart

```dart
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:tictactoe_gameapp/Controller/MainHome/main_home_controller.dart';
import 'package:tictactoe_gameapp/Controller/Music/background_music_controller.dart';
import 'package:tictactoe_gameapp/Controller/check_network_controller.dart';
import 'package:tictactoe_gameapp/Pages/HomePage/Bottom/button_nav_bar_curve.dart';

class MainHomePage extends StatelessWidget {
  const MainHomePage({super.key});

  @override
  Widget build(BuildContext context) {
    final MainHomeController controller = Get.put(MainHomeController());
    final BackgroundMusicController effectiveMusicController = Get.find();

    //todo check network
    // WidgetsBinding.instance.addPostFrameCallback((_) {
    //   Get.put(CheckNetworkController(), permanent: true);
    // });
    return Scaffold(
      body: Obx(() {
        final currentPage = controller.pages[controller.currentIndex.value];

        return AnimatedSwitcher(
          duration: const Duration(milliseconds: 750),
          transitionBuilder: (Widget child, Animation<double> animation) {
            // Apply different transition effects based on currentIndex
            if (controller.currentIndex.value < 2) {
              // For the first two pages, use Left to Right transition
              return SlideTransition(
                position: Tween<Offset>(
                  begin: const Offset(-1.0, 0.0), // From Left to Right
                  end: Offset.zero,
                ).animate(animation),
                child: child,
              );
            } else if (controller.currentIndex.value > 2) {
              // For the last two pages, use Right to Left transition
              return SlideTransition(
                position: Tween<Offset>(
                  begin: const Offset(1.0, 0.0), // From Right to Left
                  end: Offset.zero,
                ).animate(animation),
                child: child,
              );
            } else {
              // For the middle page, use Down to Up transition
              // return SlideTransition(
              //   position: Tween<Offset>(
              //     begin: const Offset(0.0, 1.0), // From Bottom to Top
              //     end: Offset.zero,
              //   ).animate(animation),
              //   child: child,
              // );
              return ScaleTransition(
                scale: Tween<double>(
                  begin: 0.0, // Bắt đầu nhỏ hơn một chút
                  end: 1.0, // Kết thúc với kích thước bình thường
                ).animate(CurvedAnimation(
                  parent: animation,
                  curve: Curves.easeIn,
                )),
                child: child,
              );
            }
          },
          child: currentPage,
        );
      }),
      bottomNavigationBar: CurvedBottomNavBar(
        currentIndex: controller.currentIndex.value,
        onTabChanged: (value) async {
          // await effectiveMusicController.buttonSoundEffect();
          controller.currentIndex.value = value;
        },
      ),
    );
  }
}

```

---


### Pages\Registration\register_sheet.dart

```dart
import 'package:bottom_sheet/bottom_sheet.dart';
import 'package:flutter/material.dart';
import 'package:form_field_validator/form_field_validator.dart';
import 'package:get/get.dart';
import 'package:tictactoe_gameapp/Configs/assets_path.dart';
import 'package:tictactoe_gameapp/Configs/constants.dart';
import 'package:tictactoe_gameapp/Configs/messages.dart';
import 'package:tictactoe_gameapp/Controller/auth_controller.dart';
import 'package:tictactoe_gameapp/Enums/firebase_exception.dart';

Future<void> registerBottomSheet(BuildContext context) async {
  await showFlexibleBottomSheet(
    minHeight: 0,
    initHeight: 0.73,
    maxHeight: 1,
    context: context,
    builder: _buildSignupBottomSheet,
    duration: const Duration(milliseconds: 1000),
    decoration: BoxDecoration(
      color: Theme.of(context).colorScheme.primary.withOpacity(0.4),
      border: Border.all(color: Colors.white, width: 4),
    ),
    // anchors: [0, 0.5, 1],
    isSafeArea: true,
  );
}

final GlobalKey<FormState> formKey = GlobalKey<FormState>();
final TextEditingController emailController = TextEditingController();
final TextEditingController passwordController = TextEditingController();
final TextEditingController confirmPasswordController = TextEditingController();
final AuthController auth = Get.find<AuthController>();
String password = '';

Widget _buildSignupBottomSheet(
  BuildContext context,
  ScrollController scrollController,
  double bottomSheetOffset,
) {
  return Padding(
    padding: const EdgeInsets.all(20),
    child: SingleChildScrollView(
      controller: scrollController,
      child: Column(
        children: [
          const Icon(
            Icons.app_registration_outlined,
            color: Colors.white,
            size: 100,
          ),
          const SizedBox(height: 10),
          Text(
            "S I G N  U P",
            style: Theme.of(context)
                .textTheme
                .titleLarge!
                .copyWith(color: Colors.white, fontWeight: FontWeight.bold),
          ),
          const SizedBox(height: 10),
          Form(
            key: formKey,
            child: Column(
              children: [
                TextFormField(
                  controller: emailController,
                  validator: emaildValidator.call,
                  autovalidateMode: AutovalidateMode.always,
                  textInputAction: TextInputAction.next,
                  keyboardType: TextInputType.emailAddress,
                  decoration: const InputDecoration(
                    hintText: "Email address",
                    prefixIcon: Icon(Icons.email_outlined),
                  ),
                ),
                const SizedBox(height: 10),
                Obx(() => TextFormField(
                      controller: passwordController,
                      validator: passwordValidator.call,
                      autovalidateMode: AutovalidateMode.always,
                      textInputAction: TextInputAction.next,
                      obscureText: auth.obscure.value,
                      decoration: InputDecoration(
                        hintText: "Password",
                        prefixIcon: const Icon(Icons.key_outlined),
                        suffixIcon: IconButton(
                          icon: Icon(
                            !auth.obscure.value
                                ? Icons.visibility
                                : Icons.visibility_off,
                          ),
                          onPressed: auth.togglePasswordVisibility,
                        ),
                      ),
                      onChanged: (val) => password = val,
                    )),
                const SizedBox(height: 10),
                Obx(() => TextFormField(
                      controller: confirmPasswordController,
                      // validator: (value) {
                      //   if (value != passwordController.text) {
                      //     return "Passwords do not match";
                      //   }
                      //   return null;
                      // },
                      validator: (val) =>
                          MatchValidator(errorText: 'passwords do not match')
                              .validateMatch(val!, password),
                      autovalidateMode: AutovalidateMode.always,
                      textInputAction: TextInputAction.done,
                      obscureText: auth.obscure.value,
                      decoration: InputDecoration(
                        hintText: "Confirm Password",
                        prefixIcon: const Icon(Icons.key_outlined),
                        suffixIcon: IconButton(
                          icon: Icon(
                            !auth.obscure.value
                                ? Icons.visibility
                                : Icons.visibility_off,
                          ),
                          onPressed: auth.togglePasswordVisibility,
                        ),
                      ),
                    )),
                const SizedBox(height: 20),
                OutlinedButton(
                  style: OutlinedButton.styleFrom(
                    backgroundColor: Colors.blue,
                    foregroundColor: Colors.white,
                  ),
                  onPressed: () async {
                    if (formKey.currentState!.validate()) {
                      AuthStatus status = await auth.registerWithEmailPassword(
                        emailController.text.trim(),
                        passwordController.text.trim(),
                      );
                      if (status == AuthStatus.successful) {
                        successMessage(
                            "Welcome ${auth.getCurrentUserEmail()} !");
                        Get.offAllNamed("/updateProfile");
                      } else {
                        String error =
                            AuthExceptionHandler.generateErrorMessage(status);
                        errorMessage(error);
                      }
                    }
                  },
                  child: const Text("Sign Up"),
                ),
                const SizedBox(height: 20),
                ClipRRect(
                  borderRadius: BorderRadius.circular(20),
                  child: Image.asset(
                    GifsPath.tictactoeGif,
                  ),
                ),
              ],
            ),
          ),
        ],
      ),
    ),
  );
}

```

---


### Pages\RoomPage\room_page.dart

```dart
import 'package:flutter/material.dart';
import 'package:flutter_svg/svg.dart';
import 'package:get/get.dart';
import 'package:tictactoe_gameapp/Components/primary_button.dart';
import 'package:tictactoe_gameapp/Configs/assets_path.dart';
import 'package:tictactoe_gameapp/Configs/constants.dart';
import 'package:tictactoe_gameapp/Configs/messages.dart';
import 'package:tictactoe_gameapp/Controller/Animations/dot_matching_animation_controller.dart';
import 'package:tictactoe_gameapp/Controller/Music/background_music_controller.dart';
import 'package:tictactoe_gameapp/Controller/room_controller.dart';
import 'package:tictactoe_gameapp/Controller/matching_controller.dart';

class RoomPage extends StatelessWidget {
  const RoomPage({super.key});

  @override
  Widget build(BuildContext context) {
    RoomController roomController = Get.put(RoomController());
    final MatchingController matchingController = Get.put(MatchingController());
    final MatchingAnimationController matchingAnimationController =
        Get.put(MatchingAnimationController());
    TextEditingController roomId = TextEditingController();
    final formKey = GlobalKey<FormState>();
    final BackgroundMusicController musicController = Get.find();
    return Scaffold(
      resizeToAvoidBottomInset: false,
      body: SafeArea(
        child: Padding(
          padding: const EdgeInsets.all(20),
          child: Form(
            key: formKey,
            child: Column(
              children: [
                Row(
                  children: [
                    InkWell(
                        onTap: () {
                          matchingController.cancelMatching();
                          musicController.stopMusicOnScreen8(1.0);
                          Get.back();
                        },
                        child: SvgPicture.asset(IconsPath.backIcon)),
                    const SizedBox(
                      width: 15,
                    ),
                    Text(
                      "Play With Private Room",
                      style: Theme.of(context).textTheme.bodyMedium,
                    )
                  ],
                ),
                const Spacer(
                  flex: 1,
                ),
                Text(
                  "Enter Private And Join With your Friends",
                  style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                        color: Theme.of(context).colorScheme.primary,
                      ),
                ),
                const SizedBox(
                  height: 20,
                ),
                TextFormField(
                  controller: roomId,
                  textAlign: TextAlign.center,
                  validator: roomCodeValidator.call,
                  autovalidateMode: AutovalidateMode.onUserInteraction,
                  decoration: InputDecoration(
                      fillColor: Theme.of(context).colorScheme.primaryContainer,
                      filled: true,
                      hintText: "Enter Room Code",
                      border: OutlineInputBorder(
                          borderSide: BorderSide.none,
                          borderRadius: BorderRadius.circular(20))),
                ),
                const SizedBox(
                  height: 20,
                ),
                Obx(
                  () => roomController.isLoading.value
                      ? const CircularProgressIndicator()
                      : PrimaryButton(
                          buttonText: "Join Now",
                          onTap: () {
                            // notificationController.registerDeviceToken();
                            if (formKey.currentState!.validate()) {
                              if (roomId.text.isNotEmpty) {
                                roomController.joinRoom(roomId.text);
                              }
                            } else {
                              errorMessage("Bro, enter room code clearly!");
                            }
                          }),
                ),
                const Spacer(
                  flex: 5,
                ),
                Obx(() {
                  if (roomController.isLoading.value) {
                    return const CircularProgressIndicator(
                      color: Colors.red,
                    );
                  } else if (matchingController.isSearching.value) {
                    return Column(
                      children: [
                        ClipRRect(
                          borderRadius: BorderRadius.circular(100),
                          child: Image.asset(
                            GifsPath.loadingGif,
                            height: 200,
                            width: 200,
                          ),
                        ),
                        const SizedBox(
                          height: 10,
                        ),
                        Row(
                          mainAxisAlignment: MainAxisAlignment.center,
                          children: [
                            Text(
                              "Matching",
                              style: Theme.of(context)
                                  .textTheme
                                  .headlineLarge!
                                  .copyWith(color: Colors.lightBlueAccent),
                            ),
                            const SizedBox(width: 5),
                            Obx(
                              () {
                                return Row(
                                  mainAxisSize: MainAxisSize.min,
                                  children: [
                                    Transform.translate(
                                      offset: Offset(
                                          0,
                                          matchingAnimationController
                                              .dotsOffset1.value),
                                      child: const Icon(
                                        Icons.square_outlined,
                                        color: Colors.lightBlueAccent,
                                        size: 20,
                                      ),
                                    ),
                                    const SizedBox(width: 5),
                                    Transform.translate(
                                      offset: Offset(
                                          0,
                                          matchingAnimationController
                                              .dotsOffset2.value),
                                      child: const Icon(
                                        Icons.square_outlined,
                                        color: Colors.lightBlueAccent,
                                        size: 20,
                                      ),
                                    ),
                                    const SizedBox(width: 5),
                                    Transform.translate(
                                      offset: Offset(
                                          0,
                                          matchingAnimationController
                                              .dotsOffset3.value),
                                      child: const Icon(
                                        Icons.square_outlined,
                                        color: Colors.lightBlueAccent,
                                        size: 20,
                                      ),
                                    ),
                                  ],
                                );
                              },
                            ),
                          ],
                        ),
                      ],
                    );
                  } else if (matchingController.isLoading.value) {
                    return const CircularProgressIndicator(
                      color: Colors.blue,
                    );
                  } else {
                    return Text(
                      "Create Private Room",
                      style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                            color: Theme.of(context).colorScheme.primary,
                          ),
                    );
                  }
                }),
                const Spacer(
                  flex: 4,
                ),
                Obx(
                  () => matchingController.isSearching.value
                      ? PrimaryButton(
                          buttonText: "Cancel",
                          onTap: () {
                            musicController.stopMusicOnScreen8(1.0);
                            matchingController.cancelMatching();
                          },
                        )
                      : PrimaryButton(
                          buttonText: "Matching",
                          onTap: () {
                            musicController.playMusicOnScreen8();
                            matchingController.startMatching();
                          },
                        ),
                ),
                const Spacer(
                  flex: 1,
                ),
                PrimaryButton(
                  buttonText: "Create Room",
                  onTap: () {
                    roomController.createRoom();
                  },
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }
}

```

---


### Pages\Setting\setting_screen_main.dart

```dart
import 'package:flutter/material.dart';
import 'package:flutter_settings_ui/flutter_settings_ui.dart';
import 'package:get/get.dart';
import 'package:get_storage/get_storage.dart';
import 'package:lite_rolling_switch/lite_rolling_switch.dart';
import 'package:tictactoe_gameapp/Configs/assets_path.dart';
import 'package:tictactoe_gameapp/Configs/messages.dart';
import 'package:tictactoe_gameapp/Controller/language_controller.dart';
import 'package:tictactoe_gameapp/Controller/Music/background_music_controller.dart';
import 'package:tictactoe_gameapp/Controller/online_status_controller.dart';
import 'package:tictactoe_gameapp/Controller/theme_controller.dart';
import 'package:tictactoe_gameapp/Pages/Login/change_password_dialog.dart';
import 'package:tictactoe_gameapp/Pages/Setting/Widgets/locale_button.dart';

class SettingScreen extends StatelessWidget {
  const SettingScreen({super.key});

  @override
  Widget build(BuildContext context) {
    final BackgroundMusicController musicController =
        Get.find<BackgroundMusicController>();
    final storage = GetStorage();
    if (!storage.hasData('isDarkMode')) {
      storage.write('isDarkMode', false);
    }
    final ThemeController themeController = Get.find<ThemeController>();

    final LanguageController languageController =
        Get.find<LanguageController>();

    final theme = Theme.of(context);
    return Scaffold(
      appBar: AppBar(
        centerTitle: true,
        title: Row(
          mainAxisAlignment: MainAxisAlignment.spaceBetween,
          children: [
            Container(
              padding: const EdgeInsets.all(5),
              decoration: BoxDecoration(
                color: theme.colorScheme.surface,
                borderRadius: BorderRadius.circular(10),
                border: Border.all(color: Colors.greenAccent, width: 4),
              ),
              child: const Icon(
                Icons.settings_accessibility_outlined,
                size: 30,
              ),
            ),
            Container(
              padding: const EdgeInsets.all(5),
              decoration: BoxDecoration(
                color: theme.colorScheme.surface,
                borderRadius: BorderRadius.circular(10),
                border: Border.all(color: Colors.greenAccent, width: 4),
              ),
              child: Text(
                "app_bar_sett".tr,
                style: Theme.of(context).textTheme.headlineMedium,
              ),
            ),
            Container(
              padding: const EdgeInsets.all(5),
              decoration: BoxDecoration(
                color: theme.colorScheme.surface,
                borderRadius: BorderRadius.circular(10),
                border: Border.all(color: Colors.greenAccent, width: 4),
              ),
              child: const Icon(Icons.search_off_outlined, size: 30),
            ),
          ],
        ),
        backgroundColor: Theme.of(context).colorScheme.primary,
      ),
      body: SettingsList(
        shrinkWrap: true,
        sections: [
          SettingsSection(
            title: Text("common_sett".tr),
            tiles: [
              SettingsTile(
                title: Text("languages_sett".tr),
                onPressed: (BuildContext context) {
                  musicController.buttonSoundEffect();
                },
                leading: const Icon(
                  Icons.language_outlined,
                ),
                description: Obx(
                    () => Text(languageController.getCurrentLanguageName())),
                trailing: ChangeLang(
                  musicController: musicController,
                ),
              ),
              SettingsTile(
                title: Text("dark_theme_sett".tr),
                onPressed: (BuildContext context) {
                  musicController.buttonSoundEffect();
                },
                leading: const Icon(Icons.contrast_outlined),
                description: Row(
                  children: [
                    const Icon(Icons.dark_mode),
                    const SizedBox(width: 5),
                    Expanded(
                      child: Text(
                        "description_dark_theme_sett".tr,
                        overflow: TextOverflow.ellipsis,
                      ),
                    ),
                  ],
                ),
                trailing: Obx(() {
                  return Switch(
                    value: themeController.isDarkMode.value,
                    onChanged: (value) {
                      themeController.toggleTheme();
                    },
                    activeTrackColor: Colors.lightBlueAccent,
                    activeColor: Colors.blue,
                  );
                }),
              ),
            ],
          ),
          SettingsSection(
            title: Text("account_tile_sett".tr),
            tiles: [
              SettingsTile(
                title: Text("profile_tile_sett".tr),
                onPressed: (BuildContext context) {
                  musicController.digitalSoundEffect();
                  Get.toNamed("/updateProfile");
                },
                leading: const Icon(Icons.account_circle_rounded),
                description: Text("edit_profile_file_sett".tr),
                trailing: const Icon(
                  Icons.edit,
                  color: Colors.lightBlueAccent,
                ),
              ),
              SettingsTile(
                title: Text("change_password_sett".tr),
                onPressed: (BuildContext context) async {
                  musicController.digitalSoundEffect();
                  await PasswordChangeDialog.showPasswordChangeDialogWhenUser();
                },
                leading: const Icon(Icons.change_circle_outlined),
                description: Text("everything_is_ok_sett".tr),
                trailing: const Icon(
                  Icons.password,
                  color: Colors.lightBlueAccent,
                ),
              ),
              SettingsTile(
                title: Text("logout_sett".tr),
                onPressed: (BuildContext context) {
                  if (Get.isRegistered<OnlineStatusController>()) {
                    final OnlineStatusController onlineStatusController =
                        Get.find<OnlineStatusController>();
                    musicController.digitalSoundEffect();
                    logoutMessage(context, onlineStatusController);
                  } else {
                    errorMessage("you haven't singed in?");
                  }
                },
                leading: const Icon(Icons.logout),
                description: Text("logout_from_app_sett".tr),
                trailing: const Icon(
                  Icons.subdirectory_arrow_right,
                  color: Colors.lightBlueAccent,
                ),
              ),
            ],
          ),
          SettingsSection(
            title: Text("sound_sett".tr),
            tiles: [
              SettingsTile(
                title: Text("play_music_sett".tr),
                onPressed: (BuildContext context) {},
                leading: const Icon(Icons.vibration_outlined),
                description: Text("turn _on_off_sett".tr),
                trailing: Obx(() {
                  bool isDarkMode = themeController.isDarkMode.value;
                  bool isPlaying = musicController.isPlaying.value;
                  return LiteRollingSwitch(
                    width: 110,
                    value: isPlaying,
                    textOn: 'stop_sett'.tr,
                    textOff: 'play_sett'.tr,
                    animationDuration: const Duration(milliseconds: 300),
                    colorOn: Colors.redAccent,
                    colorOff: Colors.greenAccent,
                    iconOn: Icons.stop,
                    iconOff: Icons.play_arrow,
                    onChanged: (bool value) {
                      if (value) {
                        if (isDarkMode) {
                          musicController
                              .playMusic([AudioSPath.infinityCastle]);
                        } else {
                          musicController.playMusic([AudioSPath.matchingSound]);
                        }
                      } else {
                        musicController.stopMusic();
                      }
                    },
                    onTap: () {
                      musicController.digitalSoundEffect();
                    },
                    onDoubleTap: () {},
                    onSwipe: () {},
                  );
                }),
              ),
              SettingsTile(
                title: Text("volume_sett".tr),
                onPressed: (BuildContext context) {},
                leading: const Icon(Icons.volume_up),
                description: Obx(() => Slider(
                      value: musicController.volume.value,
                      onChanged: (newVolume) {
                        musicController.setVolume(newVolume);
                      },
                      min: 0.0,
                      max: 1.0,
                      divisions: 100,
                      label: '${(musicController.volume.value * 100).toInt()}',
                    )),
              ),
              SettingsTile(
                title: Text("background_music_sett".tr),
                onPressed: (BuildContext context) {},
                leading: const Icon(Icons.music_note_outlined),
                description: Text("turn_off_background_music_sett".tr),
              ),
            ],
          ),
        ],
      ),
    );
  }
}

```

---


### Pages\Setting\Widgets\locale_button.dart

```dart
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:tictactoe_gameapp/Configs/theme/colors.dart';
import 'package:tictactoe_gameapp/Controller/Music/background_music_controller.dart';
import 'package:tictactoe_gameapp/Controller/language_controller.dart';

class ChangeLang extends StatelessWidget {
  final Color color;
  final Widget icon;
  final BackgroundMusicController musicController;
  const ChangeLang(
      {this.color = bgColor,
      this.icon = const Icon(
        Icons.more_vert,
        color: Colors.lightBlueAccent,
      ),
      super.key,
      required this.musicController});

  @override
  Widget build(BuildContext context) {
    final LanguageController languageController = Get.find();
    return PopupMenuButton(
      color: color,
      shadowColor: primaryColor,
      elevation: 2.0,
      offset: const Offset(5, 5),
      icon: icon,
      onSelected: (value) {
        musicController.digitalSoundEffect();
        languageController.changeLanguage(value);
      },
      itemBuilder: (BuildContext context) => <PopupMenuEntry>[
        const PopupMenuItem(
            value: 'en',
            child: Text(
              'English',
              style: TextStyle(color: Colors.black),
            )),
        const PopupMenuDivider(),
        const PopupMenuItem(
            value: 'vi',
            child: Text(
              'Tiếng Việt',
              style: TextStyle(color: Colors.black),
            )),
      ],
    );
  }
}

```

---


### Pages\Society\social_media_page.dart

```dart
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:tictactoe_gameapp/Controller/profile_controller.dart';
import 'package:tictactoe_gameapp/Pages/Society/Widgets/create_post_page.dart';
import 'package:tictactoe_gameapp/Pages/Society/Widgets/social_posts_widget.dart';
import 'package:tictactoe_gameapp/Pages/Society/Widgets/post_notification_page.dart';
import 'package:tictactoe_gameapp/Pages/Society/Widgets/social_livestreams_widget.dart';
import 'package:tictactoe_gameapp/Pages/Society/agora_livestreaming/create_livestream_room_page.dart';
import 'package:tictactoe_gameapp/Pages/Society/social_post_controller.dart';
import 'package:tictactoe_gameapp/Pages/Society/Reels/create_reel_page.dart';
import 'package:tictactoe_gameapp/Pages/Society/Reels/reel_page.dart';

class SocialMediaPage extends StatelessWidget {
  const SocialMediaPage({super.key});

  @override
  Widget build(BuildContext context) {
    final ThemeData theme = Theme.of(context);
    final GlobalKey<RefreshIndicatorState> refreshIndicatorState =
        GlobalKey<RefreshIndicatorState>();
    final ProfileController profileController = Get.find<ProfileController>();
    final PostController postController = Get.put(PostController());
    final user = profileController.user!;
    WidgetsBinding.instance.addPostFrameCallback((_) async {
      postController.listenToUnreadNotifications(userId: user.id!);
    });
    return Scaffold(
      body: DefaultTabController(
          length: 2,
          child: Column(
            children: [
              Row(
                children: [
                  const SizedBox(
                    width: 10,
                  ),
                  InkWell(
                    onTap: () {
                      postController.scrollToTop();
                      refreshIndicatorState.currentState?.show();
                    },
                    highlightColor: Colors.deepPurpleAccent,
                    borderRadius: BorderRadius.circular(10),
                    child: Ink(
                      padding: const EdgeInsets.symmetric(horizontal: 10),
                      decoration: BoxDecoration(
                        color: Colors.transparent,
                        borderRadius: BorderRadius.circular(10),
                        border: Border.all(color: Colors.white, width: 5),
                      ),
                      child: const Text(
                        "SOCIETY",
                        style: TextStyle(
                          fontSize: 25,
                          color: Colors.black,
                          fontWeight: FontWeight.bold,
                        ),
                      ),
                    ),
                  ),
                  Expanded(
                    child: Row(
                      mainAxisAlignment: MainAxisAlignment.end,
                      children: [
                        Stack(
                          clipBehavior: Clip.none,
                          children: [
                            IconButton(
                              onPressed: () {
                                Get.to(
                                  () => PostNotificationPage(
                                    user: user,
                                  ),
                                  transition: Transition.upToDown,
                                );
                              },
                              icon: const Icon(
                                Icons.notifications,
                                size: 35,
                                color: Colors.deepPurpleAccent,
                              ),
                            ),
                            Obx(() => postController.unreadCount.value == 0
                                ? const SizedBox()
                                : Positioned(
                                    top: 0,
                                    right: 0,
                                    child: Container(
                                      height: 25,
                                      width: 25,
                                      alignment: Alignment.center,
                                      decoration: BoxDecoration(
                                          color: Colors.pinkAccent,
                                          border: Border.all(
                                              color: Colors.white, width: 2),
                                          shape: BoxShape.circle),
                                      child: Text(
                                        postController.unreadCount.value > 99
                                            ? "99+"
                                            : postController.unreadCount.value
                                                .toString(),
                                        style: const TextStyle(
                                          fontSize: 10,
                                          color: Colors.white,
                                          fontWeight: FontWeight.bold,
                                        ),
                                      ),
                                    ),
                                  ))
                          ],
                        ),
                        IconButton(
                          onPressed: () {
                            Get.to(const ReelPage(
                              isBackable: true,
                            ));
                          },
                          icon: const Icon(
                            Icons.video_collection_rounded,
                            size: 35,
                            color: Colors.deepPurpleAccent,
                          ),
                        ),
                        MenuAnchor(
                          builder: (BuildContext context,
                              MenuController controller, Widget? child) {
                            return IconButton(
                              onPressed: () {
                                if (controller.isOpen) {
                                  controller.close();
                                } else {
                                  controller.open();
                                }
                              },
                              icon: const Icon(
                                Icons.add_circle_rounded,
                                size: 35,
                                color: Colors.deepPurpleAccent,
                              ),
                            );
                          },
                          menuChildren: [
                            MenuItemButton(
                              onPressed: () => Get.to(
                                CreatePostPage(
                                  userModel: user,
                                  postController: postController,
                                ),
                                transition: Transition.upToDown,
                              ),
                              child: const Text(
                                'Post',
                              ),
                            ),
                            MenuItemButton(
                              onPressed: () => Get.to(
                                CreateReelPage(user: user),
                                transition: Transition.upToDown,
                              ),
                              child: const Text('Reel'),
                            ),
                            MenuItemButton(
                              onPressed: () => Get.to(
                                CreateLivestreamRoomPage(currentUser: user),
                                transition: Transition.upToDown,
                              ),
                              child: const Text('Stream'),
                            ),
                          ],
                        ),
                        IconButton(
                          onPressed: () {
                            postController.scrollToTop();
                            refreshIndicatorState.currentState?.show();
                          },
                          icon: const Icon(
                            Icons.refresh,
                            size: 35,
                            color: Colors.deepPurpleAccent,
                          ),
                        ),
                      ],
                    ),
                  ),
                ],
              ),
              TabBar(
                labelColor: Colors.blueAccent,
                unselectedLabelColor: Colors.black,
                indicatorSize: TabBarIndicatorSize.tab,
                splashBorderRadius: const BorderRadius.only(
                  topLeft: Radius.circular(20),
                  topRight: Radius.circular(20),
                ),
                indicatorWeight: 5,
                indicatorColor: Colors.white,
                tabs: [
                  Container(
                    width: double.maxFinite,
                    padding: const EdgeInsets.all(5),
                    decoration: const BoxDecoration(
                      color: Colors.lightBlueAccent,
                      borderRadius: BorderRadius.only(
                        topLeft: Radius.circular(20),
                        topRight: Radius.circular(20),
                      ),
                    ),
                    child: const Row(
                      mainAxisAlignment: MainAxisAlignment.center,
                      children: [
                        Icon(
                          Icons.people,
                          color: Colors.white,
                        ),
                        SizedBox(
                          width: 10,
                        ),
                        Text(
                          "Posts",
                          style: TextStyle(
                            color: Colors.white,
                            fontSize: 20,
                            fontWeight: FontWeight.bold,
                          ),
                        ),
                      ],
                    ),
                  ),
                  Container(
                    width: double.maxFinite,
                    padding: const EdgeInsets.all(5),
                    decoration: const BoxDecoration(
                      color: Colors.lightBlueAccent,
                      borderRadius: BorderRadius.only(
                        topLeft: Radius.circular(20),
                        topRight: Radius.circular(20),
                      ),
                    ),
                    child: const Row(
                      mainAxisAlignment: MainAxisAlignment.center,
                      children: [
                        Icon(
                          Icons.public,
                          color: Colors.white,
                        ),
                        SizedBox(width: 10),
                        Text(
                          "Lives",
                          style: TextStyle(
                            color: Colors.white,
                            fontSize: 20,
                            fontWeight: FontWeight.bold,
                          ),
                        ),
                      ],
                    ),
                  ),
                ],
              ),
              Expanded(
                child: TabBarView(children: [
                  SocialPostsWidget(
                    postController: postController,
                    user: user,
                    theme: theme,
                    refreshIndicatorState: refreshIndicatorState,
                  ),
                  SocialLivestreamsWidget(
                    user: user,
                    theme: theme,
                  ),
                ]),
              )
            ],
          )),
    );
  }
}

```

---


### Pages\Society\social_post_controller.dart

```dart
import 'dart:async';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:flutter/material.dart';
import 'package:flutter_polls/flutter_polls.dart';
import 'package:get/get.dart';
import 'package:image_picker/image_picker.dart';
import 'package:tictactoe_gameapp/Configs/messages.dart';
import 'package:tictactoe_gameapp/Models/Functions/compress_image_function.dart';
import 'package:tictactoe_gameapp/Models/Functions/notification_add_functions.dart';
import 'package:tictactoe_gameapp/Models/user_model.dart';
import 'package:tictactoe_gameapp/Pages/Society/social_post_model.dart';
import 'package:tictactoe_gameapp/Pages/Society/Widgets/post_polls/post_polls_model.dart';
import 'package:uuid/uuid.dart';

class PostController extends GetxController {
  final FirebaseFirestore _firestore = FirebaseFirestore.instance;
  late StreamSubscription subscriptionListenPosts;
  late final ScrollController scrollController;
  final ImagePicker picker = ImagePicker();
  DocumentSnapshot? lastDocument;
  late final NotificationAddFunctions _notificationAddFunctions;

  final List<String> options = ["Favoritest", "Newest", "Oldest"];
  var selectedOption = 'Newest'.obs;
  var postsList = <PostModel>[].obs;
  RxBool isLiked = false.obs;

  RxBool isFetching = false.obs;
  int pageSize = 2;

  @override
  void onInit() {
    super.onInit();
    _notificationAddFunctions = NotificationAddFunctions(firestore: _firestore);
    scrollController = ScrollController();
    fetchInitialPosts();
    listenToPostChanges();
    ever(selectedOption, (_) => fetchFilteredPosts());
  }

  // Hàm tải dữ liệu trang đầu tiên
  Future<void> fetchInitialPosts() async {
    postsList.clear();
    if (isFetching.value) return; // Nếu đang tải, bỏ qua
    isFetching.value = true;
    try {
      QuerySnapshot snapshot = await _firestore
          .collection('posts')
          .orderBy('createdAt', descending: true)
          .limit(pageSize)
          .get();

      // Cập nhật danh sách posts và lastDocument
      if (snapshot.docs.isNotEmpty) {
        postsList.value = snapshot.docs.map((doc) {
          return PostModel.fromJson(doc.data() as Map<String, dynamic>);
        }).toList();
        lastDocument = snapshot.docs.last;
      }
    } catch (e) {
      errorMessage("Error fetching posts: $e");
    } finally {
      isFetching.value = false;
    }
  }

  Future<void> fetchFilteredPosts() async {
    postsList.clear();
    if (isFetching.value) return;
    isFetching.value = true;
    try {
      Query query = _firestore.collection('posts').limit(pageSize);

      switch (selectedOption.value) {
        case 'Favoritest':
          query = query.orderBy('likedList', descending: true);
          break;
        case 'Newest':
          query = query.orderBy('createdAt', descending: true);
          break;
        case 'Oldest':
          query = query.orderBy('createdAt', descending: false);
          break;
      }

      QuerySnapshot snapshot = await query.get();
      if (snapshot.docs.isNotEmpty) {
        postsList.value = snapshot.docs.map((doc) {
          return PostModel.fromJson(doc.data() as Map<String, dynamic>);
        }).toList();
        lastDocument = snapshot.docs.last;
      }
    } catch (e) {
      errorMessage("Error fetching posts: $e");
    } finally {
      isFetching.value = false;
    }
  }

  // Hàm tải thêm bình luận
  Future<void> fetchMoreFilteredPosts() async {
    if (isFetching.value || lastDocument == null) return;
    isFetching.value = true;

    try {
      // Khởi tạo query và sắp xếp trước
      Query query = _firestore.collection('posts');

      switch (selectedOption.value) {
        case 'Favoritest':
          query = query.orderBy('likedList', descending: true);
          break;
        case 'Newest':
          query = query.orderBy('createdAt', descending: true);
          break;
        case 'Oldest':
          query = query.orderBy('createdAt', descending: false);
          break;
      }

      // Thêm startAfterDocument sau khi orderBy
      query = query.startAfterDocument(lastDocument!).limit(pageSize);

      QuerySnapshot snapshot = await query.get();
      if (snapshot.docs.isNotEmpty) {
        var newPosts = snapshot.docs.map((doc) {
          return PostModel.fromJson(doc.data() as Map<String, dynamic>);
        }).toList();
        var uniqueNewPosts = newPosts.where((newPost) =>
            !postsList.any((post) => post.postId == newPost.postId));
        postsList.addAll(uniqueNewPosts);
        lastDocument = snapshot.docs.last;
      } else {
        lastDocument = null;
      }
    } catch (e) {
      errorMessage("Error fetching more posts: $e");
    } finally {
      isFetching.value = false;
    }
  }

  // Lắng nghe các thay đổi của bài viết theo thời gian thực
  void listenToPostChanges() {
    subscriptionListenPosts = _firestore
        .collection('posts')
        .orderBy('createdAt', descending: true)
        .snapshots()
        .listen((snapshot) {
      // if (isFetching.value) return;
      for (var change in snapshot.docChanges) {
        var newPost =
            PostModel.fromJson(change.doc.data() as Map<String, dynamic>);
        if (change.type == DocumentChangeType.added) {
          if (!postsList.any((post) => post.postId == newPost.postId)) {
            postsList.insert(0, newPost);
          }
        } else if (change.type == DocumentChangeType.modified) {
          int index =
              postsList.indexWhere((post) => post.postId == change.doc.id);
          if (index != -1) {
            postsList[index] = newPost;
          }
        } else if (change.type == DocumentChangeType.removed) {
          postsList.removeWhere((post) => post.postId == change.doc.id);
        }
      }
    });
  }

  Future<void> createPost({
    required String content,
    required UserModel user,
    List<String>? backgroundPost,
    List<XFile>? imageFiles,
    List<String>? taggedUserIds,
    required String privacy,
    String? gifUrl,
    PostPollsModel? postPollsModel,
  }) async {
    var uuid = const Uuid();
    String postId = uuid.v4();

    List<String> base64ImageList =
        await CompressImageFunction.processImages(imageFiles);

    if (base64ImageList.isEmpty && imageFiles != null) {
      return;
    }

    // Tạo post mới với thông tin đã chuẩn bị
    PostModel newPost = PostModel(
      postId: postId,
      postUser: user,
      content: content,
      backgroundPost: backgroundPost,
      imageUrls: base64ImageList.isEmpty ? null : base64ImageList,
      shareCount: 0,
      commentCount: 0,
      createdAt: DateTime.now(),
      taggedUserIds: taggedUserIds,
      privacy: privacy,
      isNotified: true,
      gif: gifUrl,
      postPolls: postPollsModel,
    );

    // Cập nhật vào Firestore
    try {
      await _firestore
          .collection('posts')
          .doc(postId)
          .set(newPost.toJson())
          .catchError((e) => errorMessage(e));
      successMessage("Post created with ID: $postId");
    } catch (e) {
      errorMessage("Failed to create post: ${e.toString()}");
    }
  }

  // Hàm cập nhật post
  Future<void> updatePost(
    String postId, {
    String? content,
    List<Color>? backgroundPost,
    List<XFile>? imageFiles,
    List<String>? taggedUserIds,
    String? privacy,
  }) async {
    Map<String, dynamic> updatedFields = {};

    if (content != null) {
      updatedFields['content'] = content;
    }
    if (backgroundPost != null) {
      updatedFields['backgroundPost'] = backgroundPost;
    }
    if (taggedUserIds != null) {
      updatedFields['taggedUserIds'] = taggedUserIds;
    }
    if (privacy != null) {
      updatedFields['privacy'] = privacy;
    }

    List<String> base64ImageList =
        await CompressImageFunction.processImages(imageFiles);

    if (base64ImageList.isEmpty && imageFiles != null) {
      return;
    }

    if (updatedFields.isNotEmpty) {
      try {
        await _firestore
            .collection('posts')
            .doc(postId)
            .update(updatedFields)
            .catchError((e) => errorMessage(e));
        successMessage("Post updated with ID: $postId");
      } catch (e) {
        errorMessage("Failed to update post: ${e.toString()}");
      }
    } else {
      errorMessage("No fields to update");
    }
  }

  Future<bool> onVoteFunction({
    required PollOption pollOption,
    required int newTotalVotes,
    required PostPollsModel postPolls,
    required String postId,
    required String userId,
  }) async {
    // Kiểm tra nếu user đã vote
    if (postPolls.voterList?.contains(userId) ?? false) {
      return false;
    }

    // Tìm option mà user đã vote
    OptionalPolls? option = postPolls.options?.firstWhere(
        (opt) => opt.id.toString() == pollOption.id,
        orElse: () => OptionalPolls());

    if (option == null) return false;

    // Cập nhật số lượng votes và danh sách user đã vote
    option.votes = (option.votes ?? 0) + 1;
    option.votedUserIds ??= [];
    option.votedUserIds!.add(userId);

    // Thêm user vào danh sách voterList của poll
    postPolls.voterList ??= [];
    postPolls.voterList!.add(userId);

    // Cập nhật dữ liệu trên Firestore
    try {
      await FirebaseFirestore.instance
          .collection('posts')
          .doc(postId)
          .update({'postPolls': postPolls.toJson()});
      return true;
    } catch (e) {
      errorMessage('Error updating vote: $e');
      return false;
    }
  }

  Future<void> undoVoteFunction({
    required PostPollsModel postPolls,
    required String postId,
    required String userId,
  }) async {
    // postPolls.voterList ??= [];
    // postPolls.options?.forEach((option) {
    //   option.votedUserIds ??= [];
    // });

    // Kiểm tra nếu userId nằm trong voterList
    if (!(postPolls.voterList?.contains(userId) ?? false)) return;

    // Tìm tùy chọn mà user đã vote
    OptionalPolls? votedOption = postPolls.options?.firstWhere(
      (option) => option.votedUserIds?.contains(userId) ?? false,
      orElse: () => OptionalPolls(),
    );

    if (votedOption == null) return;

    // Loại bỏ userId khỏi voterList và votedUserIds
    postPolls.voterList?.remove(userId);
    votedOption.votedUserIds?.remove(userId);
    votedOption.votes =
        (votedOption.votes ?? 1) > 0 ? votedOption.votes! - 1 : 0;

    // Cập nhật trên Firestore
    try {
      await FirebaseFirestore.instance
          .collection('posts')
          .doc(postId)
          .update({'postPolls': postPolls.toJson()});
    } catch (e) {
      debugPrint("Undo vote failed: $e");
    }
  }

  // Hàm xoá post
  Future<void> deletePost(
      {required PostModel post, required UserModel user}) async {
    if (post.postUser!.id == user.id) {
      await _firestore
          .collection('posts')
          .doc(post.postId)
          .delete()
          .catchError((e) => errorMessage(e));
      successMessage("Post deleted with ID: ${post.postId}");
    } else {
      errorMessage("You don't have permission to delete this post.");
    }
  }

  Future<void> likePost(PostModel postModel, UserModel userModel) async {
    DocumentReference postRef =
        _firestore.collection('posts').doc(postModel.postId);

    await postRef.update({
      'likedList':
          FieldValue.arrayUnion([userModel.id]) // Thêm userId vào likedList
    }).catchError((e) => errorMessage(e));

    if (postModel.isNotified != null && postModel.isNotified == true) {
      await _notificationAddFunctions.createLikeNotification(
        senderId: userModel.id!,
        senderModel: userModel,
        receiverId: postModel.postUser!.id!,
        postId: postModel.postId!,
      );
    }
  }

  // Hàm xóa userId khỏi likedList khi unlike
  Future<void> unlikePost(String postId, String userId) async {
    DocumentReference postRef = _firestore.collection('posts').doc(postId);

    await postRef.update({
      'likedList': FieldValue.arrayRemove([userId]) // Xóa userId khỏi likedList
    }).catchError((e) => errorMessage(e));
  }

  RxBool isLikedPost(String userId, String postId) {
    // Tìm bài viết theo postId
    final post = postsList.firstWhereOrNull((post) => post.postId == postId);

    // Nếu không tìm thấy post hoặc likedList là null, trả về false
    if (post == null || post.likedList == null) {
      return false.obs;
    }

    // Kiểm tra xem userId có nằm trong likedList của post không
    final isLiked = post.likedList!.contains(userId);

    return isLiked.obs; // Trả về RxBool phản ánh trạng thái "liked"
  }

  Future<void> incrementSharedCount(
      PostModel postModel, UserModel userModel) async {
    DocumentReference postRef =
        _firestore.collection('posts').doc(postModel.postId);

    await _firestore.runTransaction((transaction) async {
      DocumentSnapshot postSnapshot = await transaction.get(postRef);
      if (postSnapshot.exists) {
        int currentShareCount = postSnapshot['shareCount'] ?? 0;
        transaction.update(postRef, {'shareCount': currentShareCount + 1});
      }
    });

    if (postModel.isNotified != null && postModel.isNotified == true) {
      await _notificationAddFunctions.createShareNotification(
        senderId: userModel.id!,
        senderModel: userModel,
        receiverId: postModel.postUser!.id!,
        postId: postModel.postId!,
      );
    }
  }

  Future<List<XFile>?> pickMultiImages() async {
    final List<XFile> images = await picker.pickMultiImage(
      maxHeight: 240,
      maxWidth: 320,
      limit: 5,
    );
    return images;
  }

  Future<XFile?> pickImageCamera() async {
    final XFile? image = await picker.pickImage(
      source: ImageSource.camera,
      maxHeight: 240,
      maxWidth: 320,
    );
    return image;
  }

  Future<void> scrollToTop() async {
    await scrollController.animateTo(
      0,
      duration: const Duration(seconds: 1),
      curve: Curves.easeInOut,
    );
    await fetchFilteredPosts();
  }

  void updateSelectedOption(String value) {
    selectedOption.value = value;
  }

  var unreadCount = 0.obs;
  // Hàm để lắng nghe số lượng thông báo chưa đọc
  void listenToUnreadNotifications({required String userId}) {
    FirebaseFirestore.instance
        .collection("notifications")
        .where("receiverId", isEqualTo: userId)
        .where("isReaded", isEqualTo: false)
        .snapshots()
        .listen((snapshot) {
      unreadCount.value =
          snapshot.docs.length; // Cập nhật số lượng thông báo chưa đọc
    });
  }

  @override
  void onClose() {
    subscriptionListenPosts.cancel();
    scrollController.dispose();
    super.onClose();
  }
}

```

---


### Pages\Society\social_post_model.dart

```dart
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:tictactoe_gameapp/Models/user_model.dart';
import 'package:tictactoe_gameapp/Pages/Society/Widgets/post_polls/post_polls_model.dart';

class PostModel {
  String? postId;
  UserModel? postUser;
  String? content; // Nội dung bài viết
  PostPollsModel? postPolls;
  List<String>? backgroundPost;
  List<String>? imageUrls; // Danh sách URL ảnh đính kèm
  String? gif;
  List<String>? likedList;
  int? commentCount;
  int? shareCount;
  DateTime? createdAt; // Thời gian đăng bài
  List<String>? taggedUserIds; // Danh sách ID người dùng được gắn thẻ
  String? privacy; // Quyền riêng tư (public, friends, private)
  bool? isNotified;

  PostModel({
    this.postId,
    this.postUser,
    this.content,
    this.postPolls,
    this.backgroundPost,
    this.imageUrls,
    this.gif,
    this.likedList,
    this.shareCount,
    this.commentCount,
    this.createdAt,
    this.taggedUserIds,
    this.privacy,
    this.isNotified,
  });

  // Constructor để chuyển từ JSON sang PostModel
  PostModel.fromJson(Map<String, dynamic> json) {
    postId = json['postId'] as String?;
    if (json["postUser"] is Map) {
      postUser = json["postUser"] == null
          ? null
          : UserModel.fromJson(json["postUser"]);
    }
    content = json['content'] as String?;
    if (json['postPolls'] is Map) {
      postPolls = PostPollsModel.fromJson(json['postPolls']);
    }
    if (json["backgroundPost"] is List) {
      backgroundPost = List<String>.from(json["backgroundPost"]);
    }
    if (json['imageUrls'] is List) {
      imageUrls = List<String>.from(json['imageUrls']);
    }
    gif = json['gif'] as String?;
    if (json['likedList'] is List) {
      likedList = List<String>.from(json['likedList']);
    }
    shareCount = json['shareCount'] as int? ?? 0;
    if (json['commentCount'] is int) {
      commentCount = json['commentCount'];
    }
    if (json['createdAt'] is Timestamp) {
      createdAt = (json['createdAt'] as Timestamp).toDate();
    }
    if (json['taggedUserIds'] is List) {
      taggedUserIds = List<String>.from(json['taggedUserIds']);
    }
    privacy = json['privacy'] as String?;
    if (json["isNotified"] is bool) {
      isNotified = json["isNotified"];
    }
  }

  // Phương thức để chuyển PostModel thành JSON
  Map<String, dynamic> toJson() {
    final Map<String, dynamic> data = <String, dynamic>{};
    data['postId'] = postId;
    if (postUser != null) {
      data["postUser"] = postUser?.toJson();
    }
    data['content'] = content;
    if (postPolls != null) {
      data['postPolls'] = postPolls?.toJson();
    }
    data['backgroundPost'] = backgroundPost;
    data['imageUrls'] = imageUrls;
    data['gif'] = gif;
    data['likedList'] = likedList;
    data['shareCount'] = shareCount;
    data['commentCount'] = commentCount;
    if (createdAt != null) {
      data['createdAt'] = createdAt?.toUtc();
    }
    data['taggedUserIds'] = taggedUserIds;
    data['privacy'] = privacy;
    data["isNotified"] = isNotified;
    return data;
  }
}

```

---


### Pages\Society\About\user_about_controller.dart

```dart
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:get/get.dart';
import 'package:tictactoe_gameapp/Configs/messages.dart';
import 'package:tictactoe_gameapp/Models/user_model.dart';
import 'package:tictactoe_gameapp/Pages/Society/social_post_model.dart';

class UserAboutController extends GetxController {
  final FirebaseFirestore _firestore = FirebaseFirestore.instance;

  var friendsList = <UserModel>[].obs;
  var postsList = <PostModel>[].obs;
  RxBool isLoadingFriends = false.obs;
  RxBool isLoadingPosts = false.obs;
  final String userId;
  UserAboutController({required this.userId});

  @override
  void onInit() async {
    super.onInit();
    fetchFriendsList();
    fetchPostsList();
  }

  // Tải danh sách bạn bè từ Firestore khi khởi tạo
  Future<void> fetchFriendsList() async {
    if (isLoadingFriends.value) return;
    isLoadingFriends.value = true;
    try {
      friendsList.clear();

      // Lấy thông tin của người dùng hiện tại
      DocumentSnapshot userSnapshot =
          await _firestore.collection('users').doc(userId).get();

      if (userSnapshot.exists) {
        List<dynamic> friendsIds = userSnapshot['friendsList'] ?? [];

        // Tạo danh sách các futures để tải dữ liệu của từng friend ID
        List<Future<DocumentSnapshot>> friendSnapshotsFutures = friendsIds
            .map(
              (friendId) => _firestore.collection('users').doc(friendId).get(),
            )
            .toList();

        // Chờ tất cả futures hoàn thành
        List<DocumentSnapshot> friendSnapshots =
            await Future.wait(friendSnapshotsFutures);

        // Lọc ra các bạn bè đã tồn tại và chuyển thành UserModel
        friendsList.addAll(friendSnapshots
            .where((snapshot) => snapshot.exists)
            .map((snapshot) =>
                UserModel.fromJson(snapshot.data() as Map<String, dynamic>))
            .toList());
      }
    } catch (e) {
      print(e.toString());
    } finally {
      isLoadingFriends.value = false;
    }
  }

  // Hàm lấy danh sách bài đăng của người dùng hiện tại từ Firestore
  Future<void> fetchPostsList() async {
    if (isLoadingPosts.value) return;
    isLoadingPosts.value = true;
    try {
      // Query các tài liệu trong collection 'posts' với điều kiện postUserId == currentUserId
      QuerySnapshot querySnapshot = await _firestore
          .collection('posts')
          .where('postUser.id', isEqualTo: userId)
          .get();

      // Chuyển đổi danh sách tài liệu thành danh sách PostModel
      List<PostModel> posts = querySnapshot.docs.map((doc) {
        return PostModel.fromJson(doc.data() as Map<String, dynamic>);
      }).toList();
      postsList.value = posts;
    } catch (e) {
      errorMessage("Error fetching posts by current user: $e");
    } finally {
      isLoadingPosts.value = false;
    }
  }
}

```

---


### Pages\Society\About\user_about_page.dart

```dart
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:tictactoe_gameapp/Components/belong_to_users/avatar_user_widget.dart';
import 'package:tictactoe_gameapp/Components/shimmers/friendavatar_placeholder_widget.dart';
import 'package:tictactoe_gameapp/Components/shimmers/posts_placeholder_widget.dart';
import 'package:tictactoe_gameapp/Configs/assets_path.dart';
import 'package:tictactoe_gameapp/Configs/messages.dart';
import 'package:tictactoe_gameapp/Controller/MainHome/notify_in_main_controller.dart';
import 'package:tictactoe_gameapp/Controller/profile_controller.dart';
import 'package:tictactoe_gameapp/Data/fetch_firestore_database.dart';
import 'package:tictactoe_gameapp/Models/user_model.dart';
import 'package:tictactoe_gameapp/Pages/Friends/chat_with_friend_page.dart';
import 'package:tictactoe_gameapp/Pages/Society/About/user_about_controller.dart';
import 'package:tictactoe_gameapp/Pages/Society/Widgets/create_post_page.dart';
import 'package:tictactoe_gameapp/Pages/Society/Widgets/post_edit_model.dart';
import 'package:tictactoe_gameapp/Pages/Society/Widgets/post_list_card.dart';
import 'package:tictactoe_gameapp/Pages/Society/social_post_controller.dart';

class UserAboutPage extends StatelessWidget {
  final UserModel unknownableUser;
  final bool isCardTinder;

  const UserAboutPage({
    super.key,
    required this.unknownableUser,
    this.isCardTinder = false,
  });

  @override
  Widget build(BuildContext context) {
    final ProfileController profileController = Get.find();
    final UserModel currentUser = profileController.user!;
    final ThemeData theme = Theme.of(context);
    final ScrollController scrollController = ScrollController();
    final UserAboutController userAboutController = Get.put(
        UserAboutController(userId: unknownableUser.id!),
        tag: unknownableUser.id!);
    final FirestoreController firestoreController =
        Get.find<FirestoreController>();
    final List<String> options = ["Favoritest", "Newest", "Oldest"];
    var selectedOption = 'Newest'.obs;

    final double screenHeight = MediaQuery.of(context).size.height;
    final double expandedHeight = screenHeight * 0.3;

    return Scaffold(
      backgroundColor: isCardTinder ? Colors.transparent : null,
      body: CustomScrollView(
        controller: scrollController,
        slivers: [
          SliverPersistentHeader(
            pinned: true,
            delegate: MySliverHeader(
              expandedHeight: expandedHeight,
              user: unknownableUser,
              onBackPressed: () => Get.back(),
              onRefreshPressed: () {
                scrollController.animateTo(
                  0,
                  duration: const Duration(seconds: 1),
                  curve: Curves.easeInOutCirc,
                );
              },
            ),
          ),
          SliverToBoxAdapter(
            child: Padding(
              padding: EdgeInsets.only(
                top: expandedHeight *
                    0.5, // Khoảng cách để tránh overlap với avatar
                left: 10,
                right: 10,
                bottom: 30,
              ),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                mainAxisSize: MainAxisSize.min,
                children: [
                  Text(
                    unknownableUser.name!,
                    style: theme.textTheme.headlineLarge,
                  ),
                  Text(
                    unknownableUser.email!,
                    style: theme.textTheme.titleLarge,
                  ),
                  const SizedBox(height: 5),
                  Row(
                    children: [
                      Row(
                        children: [
                          Text(
                            userAboutController.friendsList.length.toString(),
                            style: theme.textTheme.bodyMedium,
                          ),
                          const Text(
                            " friends",
                            style:
                                TextStyle(color: Colors.blueGrey, fontSize: 14),
                          ),
                        ],
                      ),
                      const SizedBox(width: 10),
                      Row(
                        children: [
                          Text(
                            "0",
                            style: theme.textTheme.bodyMedium,
                          ),
                          const Text(
                            " mutual friends",
                            style:
                                TextStyle(color: Colors.blueGrey, fontSize: 14),
                          ),
                        ],
                      ),
                    ],
                  ),
                  Row(
                    children: [
                      Expanded(
                        child: Obx(() {
                          bool isFriend = firestoreController
                              .isFriend(unknownableUser.id!)
                              .value;
                          return isFriend
                              ? ElevatedButton(
                                  onPressed: () {},
                                  style: ElevatedButton.styleFrom(
                                    backgroundColor: Colors.white,
                                    foregroundColor: Colors.black,
                                    shadowColor: Colors.redAccent,
                                    elevation: 5,
                                  ),
                                  child: const Text("Friend"),
                                )
                              : ElevatedButton(
                                  onPressed: () {
                                    successMessage(
                                        'You added ${unknownableUser.name!} to the list of friends');
                                  },
                                  style: ElevatedButton.styleFrom(
                                    backgroundColor: Colors.blue,
                                    foregroundColor: Colors.white,
                                    shadowColor: Colors.redAccent,
                                    elevation: 5,
                                  ),
                                  child: const Text(
                                    "Add Friend",
                                    overflow: TextOverflow.ellipsis,
                                  ),
                                );
                        }),
                      ),
                      const SizedBox(width: 10),
                      Expanded(
                        child: ElevatedButton(
                          onPressed: () {
                            final NotifyInMainController
                                notifyInMainController =
                                Get.put(NotifyInMainController());
                            Get.to(() => ChatWithFriendPage(
                                  userFriend: unknownableUser,
                                  notifyInMainController:
                                      notifyInMainController,
                                ));
                          },
                          style: ElevatedButton.styleFrom(
                            backgroundColor: Colors.blue,
                            foregroundColor: Colors.white,
                            shadowColor: Colors.redAccent,
                            elevation: 5,
                          ),
                          child: const Text(
                            "Message",
                            overflow: TextOverflow.ellipsis,
                          ),
                        ),
                      ),
                      const SizedBox(width: 10),
                      Expanded(
                        child: ElevatedButton(
                          onPressed: () {},
                          style: ElevatedButton.styleFrom(
                            backgroundColor: Colors.blue,
                            foregroundColor: Colors.white,
                            shadowColor: Colors.redAccent,
                            elevation: 5,
                          ),
                          child: const Row(
                            children: [
                              Icon(Icons.menu_open_rounded),
                              SizedBox(width: 10),
                              Flexible(
                                  child: Text(
                                "Menu",
                                overflow: TextOverflow.ellipsis,
                              )),
                            ],
                          ),
                        ),
                      ),
                    ],
                  ),
                  const SizedBox(height: 10),
                  const Divider(thickness: 10, color: Colors.blueGrey),
                  const SizedBox(height: 10),
                  Text("Details", style: theme.textTheme.bodyLarge),
                  ListView.builder(
                    itemCount: PostEditModel.listPostEditModels.length,
                    shrinkWrap: true,
                    physics: const NeverScrollableScrollPhysics(),
                    itemBuilder: (context, index) {
                      var option = PostEditModel.listPostEditModels[index];
                      return Material(
                        color: Colors.transparent,
                        child: InkWell(
                          onTap: () {},
                          child: Padding(
                            padding: const EdgeInsets.all(10),
                            child: Row(
                              children: [
                                Icon(option.icon,
                                    size: 25, color: Colors.blueGrey),
                                const SizedBox(width: 10),
                                Expanded(
                                  child: Text(
                                    option.description,
                                    style: const TextStyle(
                                      fontSize: 15,
                                      color: Colors.black,
                                      fontStyle: FontStyle.italic,
                                    ),
                                  ),
                                ),
                              ],
                            ),
                          ),
                        ),
                      );
                    },
                  ),
                  const SizedBox(height: 10),
                  Text("Friends", style: theme.textTheme.bodyLarge),
                  Obx(() {
                    if (userAboutController.isLoadingFriends.value) {
                      return SizedBox(
                        height: 120,
                        width: double.infinity,
                        child: ListView.builder(
                          scrollDirection: Axis.horizontal,
                          itemCount: 5,
                          itemBuilder: (context, index) {
                            return const FriendavatarPlaceholderWidget();
                          },
                        ),
                      );
                    } else {
                      if (userAboutController.friendsList.isEmpty) {
                        return const SizedBox();
                      } else {
                        var friends = userAboutController.friendsList.toList();
                        return SizedBox(
                          height: 120,
                          width: double.infinity,
                          child: ListView.builder(
                            scrollDirection: Axis.horizontal,
                            physics: const BouncingScrollPhysics(),
                            itemCount: friends.length,
                            itemBuilder: (context, index) {
                              var friend = friends[index];
                              return Padding(
                                padding: const EdgeInsets.all(8.0),
                                child: Column(
                                  children: [
                                    Stack(
                                      children: [
                                        GestureDetector(
                                          onTap: friend.id != unknownableUser.id
                                              ? () {
                                                  Get.isRegistered<
                                                              UserAboutController>(
                                                          tag: friend.id!)
                                                      ? Get.find<
                                                              UserAboutController>(
                                                          tag: friend.id!)
                                                      : Get.put(
                                                          UserAboutController(
                                                              userId:
                                                                  friend.id!),
                                                          tag: friend.id!);
                                                  Navigator.of(context).push(
                                                    MaterialPageRoute(
                                                      builder: (context) =>
                                                          UserAboutPage(
                                                              unknownableUser:
                                                                  friend),
                                                    ),
                                                  );
                                                }
                                              : null,
                                          child: AvatarUserWidget(
                                            radius: 35,
                                            imagePath: friend.image!,
                                            gradientColors: friend.avatarFrame,
                                          ),
                                        ),
                                        Positioned(
                                          bottom: 0,
                                          right: 0,
                                          child: Container(
                                            width: 20,
                                            height: 20,
                                            decoration: BoxDecoration(
                                              color: Colors.green,
                                              borderRadius:
                                                  BorderRadius.circular(100),
                                              border: Border.all(
                                                color: Colors.white,
                                                width: 3,
                                              ),
                                            ),
                                          ),
                                        ),
                                      ],
                                    ),
                                    Text(
                                      friend.name!,
                                      style: theme.textTheme.bodyLarge!
                                          .copyWith(color: Colors.blueAccent),
                                    ),
                                  ],
                                ),
                              );
                            },
                          ),
                        );
                      }
                    }
                  }),
                  Obx(() => DropdownButton<String>(
                        value: selectedOption.value,
                        icon: const Icon(Icons.radio_button_checked_rounded),
                        iconSize: 24,
                        iconEnabledColor: Colors.blue,
                        focusColor: Colors.blue,
                        elevation: 16,
                        borderRadius:
                            const BorderRadius.all(Radius.circular(10)),
                        style:
                            const TextStyle(color: Colors.black, fontSize: 20),
                        underline: const SizedBox(),
                        onChanged: (String? newValue) {
                          if (newValue != null) {
                            selectedOption.value = newValue;
                          }
                        },
                        items: options
                            .map<DropdownMenuItem<String>>((String value) {
                          return DropdownMenuItem<String>(
                            value: value,
                            child: Text(value),
                          );
                        }).toList(),
                      )),
                  const SizedBox(height: 10),
                ],
              ),
            ),
          ),
          SliverPadding(
            padding: const EdgeInsets.symmetric(horizontal: 10),
            sliver: Obx(() {
              if (userAboutController.isLoadingPosts.value) {
                return const SliverToBoxAdapter(
                  child: PostsPlaceholderWidget(itemCount: 1),
                );
              } else if (userAboutController.postsList.isEmpty) {
                return SliverToBoxAdapter(
                  child: Center(
                    child: Column(
                      mainAxisAlignment: MainAxisAlignment.center,
                      children: [
                        Text(
                          "You haven't yet push any post?",
                          style: theme.textTheme.bodyLarge,
                        ),
                        Text(
                          "Post now",
                          style: theme.textTheme.bodySmall,
                        ),
                        IconButton(
                          onPressed: () {
                            final PostController postController =
                                Get.put(PostController());
                            Get.to(
                              CreatePostPage(
                                userModel: currentUser,
                                postController: postController,
                              ),
                              transition: Transition.downToUp,
                            );
                          },
                          icon: const Icon(Icons.arrow_circle_right_outlined),
                          iconSize: 40,
                          color: Colors.blueAccent,
                        ),
                      ],
                    ),
                  ),
                );
              } else {
                var posts = userAboutController.postsList.toList();
                return SliverList(
                  delegate: SliverChildBuilderDelegate(
                    (context, index) {
                      var post = posts[index];
                      var postUser = post.postUser!;
                      final PostController postController =
                          Get.put(PostController());
                      return PostListCard(
                        theme: theme,
                        post: post,
                        postUser: postUser,
                        currentUser: currentUser,
                        postController: postController,
                      );
                    },
                    childCount: posts.length,
                  ),
                );
              }
            }),
          ),
        ],
      ),
    );
  }
}

class MySliverHeader extends SliverPersistentHeaderDelegate {
  final double expandedHeight;
  final UserModel user;
  final VoidCallback onBackPressed;
  final VoidCallback onRefreshPressed;

  MySliverHeader({
    required this.expandedHeight,
    required this.user,
    required this.onBackPressed,
    required this.onRefreshPressed,
  });

  @override
  Widget build(
      BuildContext context, double shrinkOffset, bool overlapsContent) {
    final double opacity = (1 - shrinkOffset / expandedHeight).clamp(0.0, 1.0);
    final double topPadding = MediaQuery.of(context).padding.top;

    return Stack(
      clipBehavior: Clip.none, // Cho phép avatar vượt ra ngoài giới hạn header
      fit: StackFit.expand,
      children: [
        // Background gradient
        Container(
          decoration: const BoxDecoration(
            borderRadius: BorderRadius.only(
              bottomRight: Radius.circular(20),
              bottomLeft: Radius.circular(20),
            ),
            image: DecorationImage(
              image: AssetImage(GifsPath.cyberpunk),
              fit: BoxFit.cover,
            ),
            gradient: LinearGradient(
              begin: Alignment.topCenter,
              end: Alignment.bottomCenter,
              colors: [
                Color(0xff8360c3),
                Color(0xff2ebf91),
              ],
            ),
          ),
        ),
        // Nút back
        Positioned(
          top: topPadding + 8,
          left: 8,
          child: Opacity(
            opacity: 1 - shrinkOffset / expandedHeight,
            child: IconButton(
              onPressed: onBackPressed,
              icon: const Icon(
                Icons.arrow_back_rounded,
                size: 40,
                color: Colors.white,
              ),
            ),
          ),
        ),
        // Nút refresh
        Positioned(
          top: topPadding + 8,
          right: 8,
          child: Opacity(
            opacity: 1 - shrinkOffset / expandedHeight,
            child: IconButton(
              onPressed: onRefreshPressed,
              icon: const Icon(
                Icons.refresh,
                size: 35,
                color: Colors.white,
              ),
            ),
          ),
        ),
        // Tiêu đề xuất hiện khi thu nhỏ
        Opacity(
          opacity: shrinkOffset / expandedHeight,
          child: Row(
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            children: [
              IconButton(
                onPressed: onBackPressed,
                icon: const Icon(
                  Icons.arrow_back_rounded,
                  size: 40,
                  color: Colors.white,
                ),
              ),
              IconButton(
                onPressed: onRefreshPressed,
                icon: const Icon(
                  Icons.refresh,
                  size: 35,
                  color: Colors.white,
                ),
              ),
            ],
          ),
        ),
        // Avatar nằm giữa body và header
        Positioned(
          bottom: -100, // Đặt avatar vượt ra ngoài header
          left: 20,
          child: Opacity(
            opacity: opacity,
            child: AvatarUserWidget(
              radius: 100,
              imagePath: user.image!,
              gradientColors: user.avatarFrame ?? ["#FFE0E0E0", "#FFB0BEC5"],
              borderThickness: 5.0,
            ),
          ),
        ),
      ],
    );
  }

  @override
  double get maxExtent => expandedHeight;

  @override
  double get minExtent =>
      kToolbarHeight + MediaQuery.of(Get.context!).padding.top;

  @override
  bool shouldRebuild(covariant SliverPersistentHeaderDelegate oldDelegate) =>
      true;
}

```

---


### Pages\Society\agora_livestreaming\agora_livestreaming_controller.dart

```dart
import 'dart:async';
import 'dart:ui';

import 'package:agora_rtc_engine/agora_rtc_engine.dart';
import 'package:agora_token_service/agora_token_service.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:tictactoe_gameapp/Configs/constants.dart';
import 'package:tictactoe_gameapp/Configs/messages.dart';
import 'package:tictactoe_gameapp/Models/live_sream_model.dart';
import 'package:tictactoe_gameapp/Pages/Society/agora_livestreaming/livestream_doc_service.dart';

class AgoraLivestreamController extends GetxController {
  late final RtcEngine agoraEngine;
  LiveStreamService liveStreamService = LiveStreamService();
  final FirebaseFirestore _firestore = FirebaseFirestore.instance;
  StreamSubscription? liveStreamSubscription;
  final ScrollController _scrollController = ScrollController();
  ScrollController get scrollController => _scrollController;

  final RxBool isMicEnabled = true.obs;
  final RxBool isVideoEnabled = true.obs;
  final RxBool isSharingScreen = false.obs;

  final String channelId;
  final String userId;
  final String url;
  final bool isStreamer;
  final String streamId;

  AgoraLivestreamController({
    required this.channelId,
    required this.userId,
    required this.url,
    required this.isStreamer,
    required this.streamId,
  });

  @override
  void onInit() {
    super.onInit();
    _initialize();
  }

  @override
  void onClose() {
    if (isStreamer) {
      stopScreenSharing();
    }
    _disposeAgora();
    liveStreamSubscription?.cancel();
    super.onClose();
  }

  Future<void> _initialize() async {
    await _initializeAgora();
    await _joinChannel();
    WidgetsBinding.instance.addPostFrameCallback((_) {
      _listenToForestoreLiveStreamEvent();
    });
  }

  // 2.1. Khởi tạo Agora Engine
  Future<void> _initializeAgora() async {
    agoraEngine = createAgoraRtcEngine();
    await agoraEngine.initialize(
       RtcEngineContext(appId: apiAgoraAppId),
    );
    await agoraEngine.setChannelProfile(
      ChannelProfileType.channelProfileLiveBroadcasting,
    );
    if (isStreamer) {
      await agoraEngine.setClientRole(
          role: ClientRoleType.clientRoleBroadcaster);
      await agoraEngine.enableAudio();
      await agoraEngine.enableVideo();
    } else {
      await agoraEngine.setClientRole(role: ClientRoleType.clientRoleAudience);
    }
  }

  // 2.2. Tham gia phòng livestream
  Future<void> _joinChannel() async {
    final int intUserId = int.parse(_extractNumbers(userId));
    final expireTimestamp =
        DateTime.now().millisecondsSinceEpoch ~/ 1000 + 3600;
    final token = RtcTokenBuilder.build(
      appId: apiAgoraAppId,
      appCertificate: apiAgoraAppCertificate,
      channelName: channelId,
      uid: intUserId.toString(),
      role: isStreamer ? RtcRole.publisher : RtcRole.subscriber,
      expireTimestamp: expireTimestamp,
    );

    await agoraEngine.joinChannel(
      token: token,
      channelId: channelId,
      uid: intUserId,
      options: ChannelMediaOptions(
        clientRoleType: isStreamer
            ? ClientRoleType.clientRoleBroadcaster
            : ClientRoleType.clientRoleAudience,
      ),
    );
  }

  // 2.3. Bật chia sẻ màn hình (Host)
  Future<void> enableScreenSharing({required BuildContext context}) async {
    try {
      if (!isSharingScreen.value) {
        toggleVideo();
        await agoraEngine
            .setScreenCaptureScenario(ScreenScenarioType.screenScenarioGaming);
        const ScreenAudioParameters parametersAudioParams =
            ScreenAudioParameters(
          sampleRate: 100,
        );
        //todo: reposive screen sharing
        final FlutterView view = View.of(context);
        // final screenWidth = view.physicalSize.width.toInt();
        // final screenHeight = view.physicalSize.height.toInt();
        final int logicalWidth =
            (view.physicalSize.width / view.devicePixelRatio).toInt();
        final int logicalHeight =
            (view.physicalSize.height / view.devicePixelRatio).toInt();
        final VideoDimensions videoParamsDimensions = VideoDimensions(
          // width: 1280,
          // height: 720,
          width: logicalWidth,
          height: logicalHeight,
        );
        final ScreenVideoParameters parametersVideoParams =
            ScreenVideoParameters(
          dimensions: videoParamsDimensions,
          frameRate: 30,
          bitrate: 1000,
          contentHint: VideoContentHint.contentHintMotion,
        );
        final ScreenCaptureParameters2 parameters = ScreenCaptureParameters2(
          captureAudio: true,
          audioParams: parametersAudioParams,
          captureVideo: true,
          videoParams: parametersVideoParams,
        );

        await agoraEngine.startScreenCapture(parameters);

        isSharingScreen.value = true;
      } else {
        stopScreenSharing();
        toggleVideo();
      }
    } catch (e) {
      errorMessage("Failed to enable screen sharing: $e");
      isSharingScreen.value = false;
    }
  }

  // 2.4. Tắt chia sẻ màn hình
  Future<void> stopScreenSharing() async {
    if (isSharingScreen.value) {
      await agoraEngine.stopScreenCapture();
      isSharingScreen.value = false;
    }
  }

  // 2.6. Tắt mic
  void toggleMic() {
    isMicEnabled.toggle();
    agoraEngine.muteLocalAudioStream(!isMicEnabled.value);
  }

  void toggleVideo() {
    isVideoEnabled.toggle();
    agoraEngine.muteLocalVideoStream(!isVideoEnabled.value);
  }

  RxInt viewerCount = 1.obs;
  RxInt likeCount = 0.obs;
  RxList<Map<String, String>> comments = <Map<String, String>>[].obs;
  RxList<String> emojies = <String>[].obs;
  void _listenToForestoreLiveStreamEvent() {
    liveStreamSubscription = _firestore
        .collection('liveStreams')
        .doc(streamId)
        .snapshots()
        .listen((event) {
      if (event.exists) {
        LiveStreamModel liveStreamModel =
            LiveStreamModel.fromJson(event.data()!);

        viewerCount.value = liveStreamModel.viewerCount ?? 1;

        likeCount.value = liveStreamModel.likeCount ?? 0;

        emojies.value = liveStreamModel.emotes ?? [];

        if (event.data()?['comments'] is Map) {
          comments.value = (event.data()?['comments'] as Map<String, dynamic>)
              .entries
              .map((entry) => {
                    "name": entry.value['name']?.toString() ?? '',
                    "photoUrl": entry.value['photoUrl']?.toString() ?? '',
                    "content": entry.value['content']?.toString() ?? '',
                    "gif": entry.value['gif']?.toString() ?? '',
                    "createdAt": entry.value['createdAt']?.toString() ?? '',
                  })
              .toList();

          comments.sort((a, b) {
            final timeA = DateTime.parse(a['createdAt']!);
            final timeB = DateTime.parse(b['createdAt']!);
            return timeA.compareTo(timeB);
          });
          _scrollToBottom();
        } else {
          comments.clear();
        }
      } else {
        errorMessage("Room is not existing");
      }
    });
  }

  void _scrollToBottom() {
    WidgetsBinding.instance.addPostFrameCallback((_) {
      if (_scrollController.hasClients) {
        _scrollController.animateTo(
          _scrollController.position.maxScrollExtent,
          duration: const Duration(milliseconds: 750),
          curve: Curves.easeOut,
        );
        // _scrollController.jumpTo(
        //   _scrollController.position.maxScrollExtent,
        // );
      }
    });
  }

  // 2.8. Giải phóng Agora Engine
  Future<void> _disposeAgora() async {
    await agoraEngine.leaveChannel();
    await agoraEngine.release();
  }

  String _extractNumbers(String userId) {
    return userId.replaceAll(RegExp(r'[^0-9]'), '');
  }
}

```

---


### Pages\Society\agora_livestreaming\agora_livestreaming_page.dart

```dart
import 'package:agora_rtc_engine/agora_rtc_engine.dart';
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:giphy_picker/giphy_picker.dart';
import 'package:tictactoe_gameapp/Components/belong_to_users/avatar_user_widget.dart';
import 'package:tictactoe_gameapp/Components/gifphy/preview_gif_widget.dart';
import 'package:tictactoe_gameapp/Configs/assets_path.dart';
import 'package:tictactoe_gameapp/Configs/constants.dart';
import 'package:tictactoe_gameapp/Models/Functions/general_bottomsheet_show_function.dart';
import 'package:tictactoe_gameapp/Models/live_sream_model.dart';
import 'package:tictactoe_gameapp/Models/user_model.dart';
import 'package:tictactoe_gameapp/Pages/Friends/Widgets/Agoras_widget/agora_background_sheet.dart';
import 'package:tictactoe_gameapp/Pages/Society/agora_livestreaming/Widgets/bubbles_effect_widget.dart';
import 'package:tictactoe_gameapp/Pages/Society/agora_livestreaming/Widgets/livestream_comment_list_widget.dart';

import 'package:tictactoe_gameapp/Pages/Society/agora_livestreaming/agora_livestreaming_controller.dart';
import 'package:tictactoe_gameapp/Pages/Society/agora_livestreaming/livestream_doc_service.dart';
import 'package:tictactoe_gameapp/Components/emotes_picker_widget.dart';

class AgoraLivestreamingPage extends StatelessWidget {
  final UserModel currentUser;
  final LiveStreamModel liveStreamModel;
  final String channelId;
  final bool isStreamer;

  const AgoraLivestreamingPage({
    super.key,
    required this.currentUser,
    required this.channelId,
    required this.isStreamer,
    required this.liveStreamModel,
  });

  @override
  Widget build(BuildContext context) {
    final AgoraLivestreamController livestreamController =
        Get.put(AgoraLivestreamController(
      isStreamer: isStreamer,
      channelId: channelId,
      userId: currentUser.id!,
      url: currentUser.image!,
      streamId: liveStreamModel.streamId!,
    ));
    // final int hostUid =
    //     int.parse(_extractNumbers(liveStreamModel.streamer!.id!));
    final UserModel streamUser = liveStreamModel.streamer!;
    final ThemeData theme = Theme.of(context);
    final TextEditingController textController = TextEditingController();
    RxBool isSeeComment = true.obs;
    RxString comment = "".obs;
    RxBool isEmoteOpen = false.obs;
    RxBool isEmojiPickerVisible = false.obs;
    var selectedGif = Rx<GiphyGif?>(null);

    LiveStreamService liveStreamService = LiveStreamService();
    return Scaffold(
      resizeToAvoidBottomInset: true,
      body: Stack(
        children: [
          isStreamer
              ? AgoraVideoView(
                  controller: VideoViewController(
                    rtcEngine: livestreamController.agoraEngine,
                    canvas: const VideoCanvas(uid: 0),
                  ),
                )
              : AgoraVideoView(
                  controller: VideoViewController.remote(
                    rtcEngine: livestreamController.agoraEngine,
                    canvas: VideoCanvas(
                        uid: int.parse(
                            _extractNumbers(liveStreamModel.streamer!.id!))),
                    connection: RtcConnection(
                      channelId: liveStreamModel.channelId,
                    ),
                  ),
                ),
          Padding(
            padding: const EdgeInsets.only(top: 30, right: 10, left: 10),
            child: Column(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                SingleChildScrollView(
                  scrollDirection: Axis.horizontal,
                  child: Row(
                    mainAxisAlignment: MainAxisAlignment.spaceBetween,
                    children: [
                      Row(
                        children: [
                          AvatarUserWidget(
                            radius: 25,
                            imagePath: streamUser.image!,
                            borderThickness: 2,
                            gradientColors: streamUser.avatarFrame,
                          ),
                          const SizedBox(
                            width: 5,
                          ),
                          Column(
                            crossAxisAlignment: CrossAxisAlignment.start,
                            children: [
                              Text(streamUser.name!,
                                  style: theme.textTheme.bodyLarge!
                                      .copyWith(color: Colors.white)),
                              Text(liveStreamModel.category!,
                                  style: theme.textTheme.bodyMedium!
                                      .copyWith(color: Colors.grey)),
                            ],
                          ),
                          const SizedBox(
                            width: 5,
                          ),
                          !isStreamer
                              ? ElevatedButton(
                                  onPressed: () {},
                                  style: ElevatedButton.styleFrom(
                                    backgroundColor: Colors.blue,
                                    foregroundColor: Colors.white,
                                    shadowColor: Colors.redAccent,
                                    padding: const EdgeInsets.all(5),
                                    elevation: 5,
                                  ),
                                  child: const Row(
                                    children: [
                                      Icon(Icons.add),
                                      Text("Add"),
                                    ],
                                  ))
                              : const SizedBox(),
                          const SizedBox(
                            width: 10,
                          ),
                          Column(
                            children: [
                              Row(
                                children: [
                                  const Icon(
                                    Icons.favorite,
                                    color: Colors.redAccent,
                                  ),
                                  const SizedBox(
                                    width: 6,
                                  ),
                                  Obx(() => Text(
                                        livestreamController.likeCount
                                            .toString(),
                                        style: const TextStyle(
                                            color: Colors.white),
                                      ))
                                ],
                              ),
                              Row(
                                children: [
                                  const Icon(
                                    Icons.visibility,
                                    color: Colors.white,
                                  ),
                                  const SizedBox(
                                    width: 5,
                                  ),
                                  Obx(() => Text(
                                        livestreamController.viewerCount.value
                                            .toString(),
                                        style: const TextStyle(
                                            color: Colors.white),
                                      ))
                                ],
                              )
                            ],
                          )
                        ],
                      ),
                      Row(
                        children: [
                          IconButton(
                              onPressed: () async {
                                await GeneralBottomsheetShowFunction
                                    .showScrollableGeneralBottomsheet(
                                  widgetBuilder: (context, controller) =>
                                      AgoraBackgroundSheet(
                                    scrollController: controller,
                                    imageAvatar: currentUser.image!,
                                  ),
                                  context: context,
                                  initHeight: 0.9,
                                );
                              },
                              icon: const Icon(Icons.menu_open_rounded,
                                  size: 35, color: Colors.white)),
                          IconButton(
                              onPressed: () async {
                                if (isStreamer) {
                                  LiveStreamService liveStreamService =
                                      LiveStreamService();
                                  await liveStreamService.deleteLiveStream(
                                      liveStreamModel.streamId!);
                                  Get.toNamed("mainHome");
                                } else {
                                  await liveStreamService.decrementViewerCount(
                                      liveStreamModel.streamId!);
                                  Get.back();
                                }
                              },
                              icon: const Icon(
                                Icons.cancel_rounded,
                                color: Colors.white,
                                size: 30,
                              ))
                        ],
                      ),
                    ],
                  ),
                ),
                Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Stack(
                      clipBehavior: Clip.none,
                      children: [
                        Obx(
                          () => isSeeComment.value
                              ? LiveStreamCommentListWidget(
                                  theme: theme,
                                  livestreamController: livestreamController)
                              : const SizedBox(),
                        ),
                        Positioned.fill(
                          child: SizedBox(
                            height: double.infinity,
                            width: double.infinity,
                            child: EmojiDisplay(
                              emojies: livestreamController.emojies,
                            ),
                          ),
                        ),
                      ],
                    ),
                    PreviewGifWidget(selectedGif: selectedGif),
                    CustomEmojiPicker(
                      height: 200,
                      isSearchEmo: false,
                      onEmojiSelected: (emoji) {
                        textController.text += emoji;
                        comment.value = textController.text;
                        textController.selection = TextSelection.fromPosition(
                          TextPosition(offset: textController.text.length),
                        );
                      },
                      onBackspacePressed: () {
                        final text = textController.text;
                        if (text.isNotEmpty) {
                          // Xóa ký tự cuối (bao gồm cả emoji)
                          textController.text =
                              text.characters.skipLast(1).toString();
                          comment.value = textController.text;
                          textController.selection = TextSelection.fromPosition(
                            TextPosition(offset: textController.text.length),
                          );
                        }
                      },
                      isEmojiPickerVisible: isEmojiPickerVisible,
                      backgroundColor: const [
                        Colors.blueGrey,
                        Colors.blueGrey,
                      ],
                    ),
                    Row(
                      children: [
                        Obx(
                          () => IconButton(
                            onPressed: () {
                              isSeeComment.toggle();
                            },
                            icon: isSeeComment.value
                                ? const Icon(
                                    Icons.comment_rounded,
                                    size: 30,
                                    color: Colors.blue,
                                  )
                                : const Icon(
                                    Icons.comments_disabled_rounded,
                                    size: 30,
                                    color: Colors.blue,
                                  ),
                          ),
                        ),
                        Expanded(
                          child: TextField(
                            onChanged: (commentContent) {
                              if (commentContent.isNotEmpty) {
                                comment.value = commentContent;
                              } else {
                                comment.value = '';
                              }
                            },
                            controller: textController,
                            textInputAction: TextInputAction.done,
                            decoration: InputDecoration(
                              fillColor: Colors.transparent,
                              contentPadding: const EdgeInsets.symmetric(
                                  vertical: 10.0, horizontal: 10.0),
                              border: OutlineInputBorder(
                                borderRadius: BorderRadius.circular(25),
                                borderSide:
                                    const BorderSide(color: Colors.blueAccent),
                              ),
                              labelText: 'Send a comment',
                              labelStyle: theme.textTheme.bodyLarge!
                                  .copyWith(color: Colors.grey),
                              prefixIcon: IconButton(
                                icon: const Icon(
                                  Icons.gif_box_outlined,
                                  color: Colors.blueAccent,
                                  size: 30,
                                ),
                                onPressed: () async {
                                  final gif = await GiphyPicker.pickGif(
                                    context: context,
                                    apiKey: apiGifphy,
                                    showPreviewPage: false,
                                    showGiphyAttribution: false,
                                    loadingBuilder: (context) {
                                      return Center(
                                        child: ClipRRect(
                                          borderRadius:
                                              BorderRadius.circular(100),
                                          child: Image.asset(
                                            GifsPath.loadingGif,
                                            height: 200,
                                            width: 200,
                                          ),
                                        ),
                                      );
                                    },
                                  );

                                  if (gif != null) {
                                    selectedGif.value = gif;
                                  }
                                },
                              ),
                              suffixIcon: Obx(() => IconButton(
                                  onPressed: () {
                                    isEmojiPickerVisible.toggle();
                                  },
                                  icon: isEmojiPickerVisible.value
                                      ? const Icon(
                                          Icons.emoji_emotions,
                                          color: Colors.blue,
                                          size: 30,
                                        )
                                      : const Icon(
                                          Icons.emoji_emotions_outlined,
                                          color: Colors.blue,
                                          size: 30,
                                        ))),
                            ),
                          ),
                        ),
                        Obx(() => IconButton(
                            onPressed: () {
                              isEmoteOpen.toggle();
                            },
                            icon: isEmoteOpen.value
                                ? const Icon(
                                    Icons.card_giftcard_rounded,
                                    color: Colors.blue,
                                    size: 30,
                                  )
                                : const Icon(
                                    Icons.card_giftcard_outlined,
                                    color: Colors.blue,
                                    size: 30,
                                  ))),
                        Obx(
                          () => IconButton(
                            onPressed: () async {
                              if (comment.value.isNotEmpty) {
                                FocusScope.of(context).unfocus();
                                await liveStreamService.addComment(
                                  liveStreamModel.streamId!,
                                  comment.value,
                                  currentUser.image!,
                                  currentUser.name!,
                                  selectedGif.value?.images.original!.url!,
                                );
                                textController.clear();
                              }
                            },
                            icon: comment.value.isNotEmpty
                                ? const Icon(
                                    Icons.send_rounded,
                                    size: 30,
                                    color: Colors.blue,
                                  )
                                : const Icon(
                                    Icons.send_rounded,
                                    size: 30,
                                    color: Colors.grey,
                                  ),
                          ),
                        ),
                      ],
                    ),
                    Obx(
                      () => isEmoteOpen.value
                          ? SizedBox(
                              height: 100,
                              child: GridView.builder(
                                scrollDirection: Axis.horizontal,
                                physics: const BouncingScrollPhysics(),
                                gridDelegate:
                                    const SliverGridDelegateWithFixedCrossAxisCount(
                                  crossAxisCount: 2,
                                  mainAxisSpacing: 10,
                                  crossAxisSpacing: 10,
                                ),
                                itemCount: emotes.length,
                                itemBuilder: (context, index) {
                                  return Material(
                                    color: Colors.transparent,
                                    child: InkWell(
                                      borderRadius: BorderRadius.circular(50),
                                      splashColor: Colors.blueAccent,
                                      onTap: () async {
                                        await liveStreamService.addEmotes(
                                            liveStreamModel.streamId!,
                                            emotes[index]);
                                      },
                                      child: Image.asset(
                                        emotes[index],
                                        fit: BoxFit.cover,
                                        width: 50,
                                        height: 50,
                                      ),
                                    ),
                                  );
                                },
                              ),
                            )
                          : const SizedBox(),
                    )
                  ],
                )
              ],
            ),
          ),
          Positioned(
            top: 0,
            left: 0,
            child: Container(
              width: 60,
              height: 30,
              alignment: Alignment.center,
              decoration: BoxDecoration(
                color: Colors.red,
                borderRadius: BorderRadius.circular(10),
              ),
              child: const Text(
                "Live",
                style: TextStyle(
                  color: Colors.white,
                  fontWeight: FontWeight.bold,
                ),
              ),
            ),
          ),
          isStreamer
              ? Positioned(
                  top: 100,
                  right: 0,
                  child: Column(
                    children: [
                      Obx(
                        () => IconButton(
                          onPressed: () async {
                            livestreamController.enableScreenSharing(
                                context: context);
                          },
                          icon: !livestreamController.isSharingScreen.value
                              ? const Icon(
                                  Icons.mobile_screen_share_rounded,
                                  color: Colors.white,
                                  size: 35,
                                )
                              : const Icon(
                                  Icons.mobile_off_rounded,
                                  color: Colors.white,
                                  size: 35,
                                ),
                        ),
                      ),
                      Obx(() => !livestreamController.isMicEnabled.value
                          ? IconButton(
                              icon: const Icon(
                                Icons.mic_off_rounded,
                                color: Colors.white,
                                size: 35,
                              ),
                              onPressed: () {
                                livestreamController.toggleMic();
                              },
                            )
                          : IconButton(
                              icon: const Icon(
                                Icons.mic,
                                color: Colors.white,
                                size: 35,
                              ),
                              onPressed: () {
                                livestreamController.toggleMic();
                              },
                            )),
                      IconButton(
                        icon: const Icon(
                          Icons.switch_camera_rounded,
                          color: Colors.white,
                          size: 35,
                        ),
                        onPressed: () {
                          livestreamController.agoraEngine.switchCamera();
                        },
                      ),
                    ],
                  ))
              : const SizedBox(),
        ],
      ),
    );
  }

  String _extractNumbers(String userId) {
    return userId.replaceAll(RegExp(r'[^0-9]'), '');
  }
}

```

---


### Pages\Society\agora_livestreaming\create_livestream_room_page.dart

```dart
import 'dart:convert';
import 'dart:io';

import 'package:cached_network_image/cached_network_image.dart';
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:image_picker/image_picker.dart';
import 'package:tictactoe_gameapp/Configs/assets_path.dart';
import 'package:tictactoe_gameapp/Controller/profile_controller.dart';
import 'package:tictactoe_gameapp/Models/live_sream_model.dart';
import 'package:tictactoe_gameapp/Models/user_model.dart';
import 'package:tictactoe_gameapp/Pages/Society/Widgets/optional_tile_custom.dart';
import 'package:tictactoe_gameapp/Pages/Society/agora_livestreaming/agora_livestreaming_page.dart';
import 'package:tictactoe_gameapp/Pages/Society/agora_livestreaming/livestream_doc_service.dart';
import 'package:uuid/uuid.dart';

class CreateLivestreamRoomPage extends StatelessWidget {
  final UserModel currentUser;
  const CreateLivestreamRoomPage({super.key, required this.currentUser});

  @override
  Widget build(BuildContext context) {
    final ThemeData theme = Theme.of(context);
    RxString titleContent = "".obs;
    RxString descriptionContent = "".obs;
    RxString audienceMode = "Public".obs;
    RxString imagePath = "".obs;
    XFile? image;
    return Scaffold(
        appBar: AppBar(
          leading: IconButton(
            onPressed: () => Get.back(),
            icon: const Icon(
              Icons.arrow_back,
              size: 40,
              color: Colors.deepPurple,
            ),
          ),
          centerTitle: false,
          title: Text(
            "Create a new live room",
            style: theme.textTheme.headlineSmall!
                .copyWith(fontWeight: FontWeight.bold),
          ),
          actions: [
            Obx(
              () => titleContent.value.isEmpty ||
                      descriptionContent.value.isEmpty ||
                      imagePath.value.isEmpty
                  ? Container(
                      height: 50,
                      width: 100,
                      alignment: Alignment.center,
                      decoration: BoxDecoration(
                        color: Colors.grey,
                        borderRadius: BorderRadius.circular(10),
                      ),
                      child: Text(
                        "LIVE",
                        style: theme.textTheme.bodyLarge!
                            .copyWith(color: Colors.black45),
                      ),
                    )
                  : InkWell(
                      onTap: () async {
                        await Get.showOverlay(
                            asyncFunction: () async {
                              var uuid = const Uuid();
                              final String channelId =
                                  uuid.v4().substring(0, 12);
                              final String streamId = uuid.v4().substring(0, 8);
                              List<int> imageBytes = await image!.readAsBytes();
                              String? base64String = base64Encode(imageBytes);
                              LiveStreamService liveStreamService =
                                  LiveStreamService();
                              LiveStreamModel liveStreamModel = LiveStreamModel(
                                streamId: streamId,
                                channelId: channelId,
                                streamer: currentUser,
                                title: titleContent.value,
                                description: descriptionContent.value,
                                thumbnailUrl: base64String,
                                category: audienceMode.value,
                                viewerCount: 1,
                                likeCount: 0,
                                emotes: [],
                                createdAt: DateTime.now(),
                              );
                              await liveStreamService
                                  .createLiveStream(liveStreamModel);
                              Get.to(() => AgoraLivestreamingPage(
                                    currentUser: currentUser,
                                    liveStreamModel: liveStreamModel,
                                    channelId: channelId,
                                    isStreamer: true,
                                  ));
                            },
                            loadingWidget: Center(
                              child: ClipRRect(
                                borderRadius: BorderRadius.circular(100),
                                child: Image.asset(
                                  GifsPath.loadingGif,
                                  width: 200,
                                  height: 200,
                                ),
                              ),
                            ));
                      },
                      child: Ink(
                        height: 50,
                        width: 100,
                        decoration: BoxDecoration(
                          color: Colors.blueAccent,
                          borderRadius: BorderRadius.circular(10),
                        ),
                        child: Center(
                          child: Text(
                            "LIVE",
                            style: theme.textTheme.bodyLarge!
                                .copyWith(color: Colors.white),
                          ),
                        ),
                      ),
                    ),
            ),
            const SizedBox(
              width: 10,
            ),
          ],
        ),
        body: Padding(
          padding: const EdgeInsets.all(10.0),
          child: SingleChildScrollView(
            child: Column(
              children: [
                Row(
                  children: [
                    CircleAvatar(
                      backgroundImage:
                          CachedNetworkImageProvider(currentUser.image!),
                      radius: 35,
                    ),
                    const SizedBox(width: 10),
                    Expanded(
                      child: Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          Text(
                            currentUser.name!,
                            style: theme.textTheme.headlineMedium,
                          ),
                          const SizedBox(
                            height: 10,
                          ),
                          SingleChildScrollView(
                            scrollDirection: Axis.horizontal,
                            child: Row(
                              children: [
                                GestureDetector(
                                    onTap: () {
                                      audienceMode.value = "Private";
                                    },
                                    child: Obx(
                                      () => Container(
                                        height: 40,
                                        width: 100,
                                        margin:
                                            const EdgeInsets.only(right: 10),
                                        alignment: Alignment.center,
                                        decoration: BoxDecoration(
                                          color: audienceMode.value == "Private"
                                              ? Colors.blueAccent
                                              : Colors.grey.shade400,
                                          borderRadius:
                                              BorderRadius.circular(10),
                                        ),
                                        child: Row(
                                          mainAxisAlignment:
                                              MainAxisAlignment.center,
                                          children: [
                                            Icon(
                                              Icons.person,
                                              color: audienceMode.value ==
                                                      "Private"
                                                  ? Colors.white
                                                  : Colors.black,
                                            ),
                                            const SizedBox(width: 5),
                                            Text(
                                              "Private",
                                              style: theme.textTheme.bodyMedium!
                                                  .copyWith(
                                                color: audienceMode.value ==
                                                        "Private"
                                                    ? Colors.white
                                                    : Colors.black,
                                              ),
                                            ),
                                          ],
                                        ),
                                      ),
                                    )),
                                GestureDetector(
                                  onTap: () {
                                    audienceMode.value = "Friends";
                                  },
                                  child: Obx(() => Container(
                                        height: 40,
                                        width: 100,
                                        margin:
                                            const EdgeInsets.only(right: 10),
                                        alignment: Alignment.center,
                                        decoration: BoxDecoration(
                                          color: audienceMode.value == "Friends"
                                              ? Colors.blueAccent
                                              : Colors.grey.shade400,
                                          borderRadius:
                                              BorderRadius.circular(10),
                                        ),
                                        child: Row(
                                          mainAxisAlignment:
                                              MainAxisAlignment.center,
                                          children: [
                                            Icon(
                                              Icons.people_alt_rounded,
                                              color: audienceMode.value ==
                                                      "Friends"
                                                  ? Colors.white
                                                  : Colors.black,
                                            ),
                                            const SizedBox(width: 5),
                                            Text(
                                              "Friends",
                                              style: theme.textTheme.bodyMedium!
                                                  .copyWith(
                                                color: audienceMode.value ==
                                                        "Friends"
                                                    ? Colors.white
                                                    : Colors.black,
                                              ),
                                            ),
                                          ],
                                        ),
                                      )),
                                ),
                                GestureDetector(
                                  onTap: () {
                                    audienceMode.value = "Public";
                                  },
                                  child: Obx(() => Container(
                                        height: 40,
                                        width: 100,
                                        margin:
                                            const EdgeInsets.only(right: 10),
                                        alignment: Alignment.center,
                                        decoration: BoxDecoration(
                                          color: audienceMode.value == "Public"
                                              ? Colors.blueAccent
                                              : Colors.grey.shade400,
                                          borderRadius:
                                              BorderRadius.circular(10),
                                        ),
                                        child: Row(
                                          mainAxisAlignment:
                                              MainAxisAlignment.center,
                                          children: [
                                            Icon(
                                              Icons.public,
                                              color:
                                                  audienceMode.value == "Public"
                                                      ? Colors.white
                                                      : Colors.black,
                                            ),
                                            const SizedBox(width: 5),
                                            Text(
                                              "Public",
                                              style: theme.textTheme.bodyMedium!
                                                  .copyWith(
                                                color: audienceMode.value ==
                                                        "Public"
                                                    ? Colors.white
                                                    : Colors.black,
                                              ),
                                            ),
                                          ],
                                        ),
                                      )),
                                ),
                              ],
                            ),
                          ),
                        ],
                      ),
                    ),
                  ],
                ),
                const SizedBox(
                  height: 20,
                ),
                SizedBox(
                  height: 100,
                  child: TextField(
                    onChanged: (text) {
                      if (text.isNotEmpty) {
                        titleContent.value = text;
                      } else {
                        titleContent.value = "";
                      }
                    },
                    minLines: null,
                    maxLines: null,
                    expands: true,
                    textAlign: TextAlign.left,
                    textAlignVertical: TextAlignVertical.top,
                    decoration: InputDecoration(
                      fillColor: Colors.transparent,
                      labelText: 'Title for live',
                      alignLabelWithHint: true,
                      labelStyle: theme.textTheme.bodyLarge!
                          .copyWith(color: Colors.grey),
                      border: OutlineInputBorder(
                        borderRadius: BorderRadius.circular(20),
                        borderSide: const BorderSide(
                          color: Colors.blueAccent,
                        ),
                      ),
                    ),
                  ),
                ),
                const SizedBox(
                  height: 10,
                ),
                SizedBox(
                  height: 150,
                  child: TextField(
                    onChanged: (text) {
                      if (text.isNotEmpty) {
                        descriptionContent.value = text;
                      } else {
                        descriptionContent.value = "";
                      }
                    },
                    minLines: null,
                    maxLines: null,
                    expands: true,
                    textAlign: TextAlign.left,
                    textAlignVertical: TextAlignVertical.top,
                    decoration: InputDecoration(
                      fillColor: Colors.transparent,
                      labelText: 'Description for live',
                      alignLabelWithHint: true,
                      labelStyle: theme.textTheme.bodyLarge!
                          .copyWith(color: Colors.grey),
                      border: OutlineInputBorder(
                        borderRadius: BorderRadius.circular(20),
                        borderSide: const BorderSide(
                          color: Colors.blueAccent,
                        ),
                      ),
                    ),
                  ),
                ),
                const SizedBox(
                  height: 20,
                ),
                Column(
                  children: [
                    const Text(
                      "Thumbnail",
                      style: TextStyle(
                          color: Colors.blueGrey,
                          fontSize: 20,
                          fontWeight: FontWeight.bold),
                    ),
                    Row(
                      mainAxisAlignment: MainAxisAlignment.center,
                      children: [
                        IconButton(
                          onPressed: () async {
                            final ProfileController profileController =
                                Get.find();

                            image = await profileController
                                .pickFileX(ImageSource.camera);
                            if (image != null) {
                              imagePath.value = image!.path;
                            } else {
                              imagePath.value = "";
                            }
                          },
                          icon: const Icon(
                            Icons.camera_alt_rounded,
                            size: 30,
                          ),
                        ),
                        IconButton(
                          onPressed: () async {
                            final ProfileController profileController =
                                Get.find();

                            image = await profileController
                                .pickFileX(ImageSource.gallery);
                            if (image != null) {
                              imagePath.value = image!.path;
                            } else {
                              imagePath.value = "";
                            }
                          },
                          icon: const Icon(
                            Icons.image_rounded,
                            size: 30,
                          ),
                        ),
                        IconButton(
                          onPressed: () {
                            imagePath.value = "";
                          },
                          icon: const Icon(
                            Icons.refresh_rounded,
                            size: 30,
                          ),
                        ),
                      ],
                    ),
                    Obx(() => Container(
                          height: 250,
                          width: 200,
                          alignment: Alignment.center,
                          decoration: imagePath.value.isNotEmpty
                              ? BoxDecoration(
                                  borderRadius: BorderRadius.circular(10),
                                  image: DecorationImage(
                                    image: FileImage(
                                      File(
                                        imagePath.value,
                                      ),
                                    ),
                                    fit: BoxFit.cover,
                                  ))
                              : BoxDecoration(
                                  borderRadius: BorderRadius.circular(10),
                                  color: Colors.blueGrey.shade300,
                                ),
                        )),
                    OptionalTileWidget(
                      onTap: () {},
                      title: "Tag people",
                      icon: Icons.person_add_alt_1_sharp,
                      color: Colors.blue,
                    ),
                    Container(
                      height: 50,
                      width: double.maxFinite,
                      alignment: Alignment.center,
                      decoration: BoxDecoration(
                        color: Colors.grey,
                        borderRadius: BorderRadius.circular(10),
                      ),
                      child: Text(
                        "LIVE",
                        style: theme.textTheme.bodyLarge!
                            .copyWith(color: Colors.black45),
                      ),
                    ),
                  ],
                )
              ],
            ),
          ),
        ));
  }
}

```

---


### Pages\Society\agora_livestreaming\livestream_controller.dart

```dart
import 'dart:async';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:tictactoe_gameapp/Models/live_sream_model.dart';

class LiveStreamController extends GetxController {
  final FirebaseFirestore _firestore = FirebaseFirestore.instance;

  // ScrollController để hỗ trợ lazy load
  late final ScrollController scrollController;

  // Danh sách live streams
  var liveStreamsList = <LiveStreamModel>[].obs;

  // Biến để theo dõi trạng thái tải
  bool isFetching = false;
  DocumentSnapshot? lastDocument;
  final int pageSize = 6;

  late StreamSubscription subscriptionListenStreams;

  @override
  void onInit() {
    super.onInit();
    scrollController = ScrollController();
    fetchInitialLiveStreams();
    listenToLiveStreamChanges();

    // Lắng nghe sự kiện scroll để tải thêm dữ liệu
    // scrollController.addListener(() {
    //   if (scrollController.position.pixels >=
    //           scrollController.position.maxScrollExtent &&
    //       !isFetching) {
    //     fetchMoreLiveStreams();
    //   }
    // });
  }

  // Hàm tải dữ liệu trang đầu tiên
  Future<void> fetchInitialLiveStreams() async {
    if (isFetching) return;
    isFetching = true;

    try {
      QuerySnapshot snapshot = await _firestore
          .collection('liveStreams')
          .orderBy('createdAt', descending: true)
          .limit(pageSize)
          .get();

      if (snapshot.docs.isNotEmpty) {
        liveStreamsList.value = snapshot.docs.map((doc) {
          return LiveStreamModel.fromJson(doc.data() as Map<String, dynamic>);
        }).toList();
        lastDocument = snapshot.docs.last;
      }
    } catch (e) {
      print("Error fetching live streams: $e");
    } finally {
      isFetching = false;
    }
  }

  // Hàm tải thêm dữ liệu (lazy load)
  Future<void> fetchMoreLiveStreams() async {
    if (isFetching || lastDocument == null) return;
    isFetching = true;

    try {
      Query query = _firestore
          .collection('liveStreams')
          .orderBy('createdAt', descending: true)
          .startAfterDocument(lastDocument!)
          .limit(pageSize);

      QuerySnapshot snapshot = await query.get();

      if (snapshot.docs.isNotEmpty) {
        liveStreamsList.value = snapshot.docs.map((doc) {
          return LiveStreamModel.fromJson(doc.data() as Map<String, dynamic>);
        }).toList();
        lastDocument = snapshot.docs.last;
      } else {
        lastDocument = null; // Không còn dữ liệu để tải
      }
    } catch (e) {
      print("Error fetching more live streams: $e");
    } finally {
      isFetching = false;
    }
  }

  // Lắng nghe các thay đổi của collection liveStreams
  void listenToLiveStreamChanges() {
    subscriptionListenStreams = _firestore
        .collection('liveStreams')
        .orderBy('createdAt', descending: true)
        .snapshots()
        .listen((snapshot) {
      for (var change in snapshot.docChanges) {
        if (change.type == DocumentChangeType.added) {
          liveStreamsList.insert(
              0,
              LiveStreamModel.fromJson(
                  change.doc.data() as Map<String, dynamic>));
        } else if (change.type == DocumentChangeType.modified) {
          int index = liveStreamsList
              .indexWhere((live) => live.streamId == change.doc.id);
          if (index != -1) {
            liveStreamsList[index] = LiveStreamModel.fromJson(
                change.doc.data() as Map<String, dynamic>);
          }
        } else if (change.type == DocumentChangeType.removed) {
          liveStreamsList.removeWhere((live) => live.streamId == change.doc.id);
        }
      }
    });
  }

  @override
  void onClose() {
    subscriptionListenStreams.cancel();
    scrollController.dispose();
    super.onClose();
  }
}

```

---


### Pages\Society\agora_livestreaming\livestream_doc_service.dart

```dart
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:tictactoe_gameapp/Configs/messages.dart';
import 'package:tictactoe_gameapp/Models/live_sream_model.dart';
import 'package:uuid/uuid.dart';

class LiveStreamService {
  final FirebaseFirestore _firestore = FirebaseFirestore.instance;

  /// **Collection Reference**
  /// Đây là tham chiếu đến collection trong Firestore nơi lưu trữ các livestream.
  CollectionReference get _liveStreamCollection =>
      _firestore.collection('liveStreams');

  /// **Tạo mới một livestream**
  Future<void> createLiveStream(LiveStreamModel liveStream) async {
    try {
      // Tạo ID tự động nếu không có
      final String newStreamId =
          liveStream.streamId ?? _liveStreamCollection.doc().id;

      liveStream.streamId = newStreamId;

      await _liveStreamCollection.doc(newStreamId).set(liveStream.toJson());
    } catch (e) {
      errorMessage("Error creating live stream: $e");
      rethrow;
    }
  }

  /// **Lấy danh sách tất cả các livestream**
  Future<List<LiveStreamModel>> getAllLiveStreams() async {
    try {
      final QuerySnapshot snapshot = await _liveStreamCollection.get();
      return snapshot.docs
          .map((doc) =>
              LiveStreamModel.fromJson(doc.data() as Map<String, dynamic>))
          .toList();
    } catch (e) {
      errorMessage("Error fetching live streams: $e");
      rethrow;
    }
  }

  /// **Lấy thông tin một livestream theo streamId**
  Future<LiveStreamModel?> getLiveStreamById(String streamId) async {
    try {
      final DocumentSnapshot doc =
          await _liveStreamCollection.doc(streamId).get();

      if (doc.exists) {
        return LiveStreamModel.fromJson(doc.data() as Map<String, dynamic>);
      }
      return null;
    } catch (e) {
      errorMessage("Error fetching live stream by ID: $e");
      rethrow;
    }
  }

  /// **Cập nhật thông tin livestream**
  Future<void> updateLiveStream(
      String streamId, LiveStreamModel liveStream) async {
    try {
      await _liveStreamCollection.doc(streamId).update(liveStream.toJson());
      print("Live stream updated successfully");
    } catch (e) {
      errorMessage("Error updating live stream: $e");
      rethrow;
    }
  }

  /// **Cập nhật một số trường của livestream**
  Future<void> updateLiveStreamFields(
      String streamId, String field, dynamic value) async {
    try {
      // Chỉ cập nhật các trường được truyền trong fieldsToUpdate
      await _liveStreamCollection.doc(streamId).update({field: value});
    } on FirebaseException catch (e) {
      // Bắt lỗi cụ thể từ Firebase
      errorMessage("Firebase error: ${e.message}");
      rethrow;
    } catch (e) {
      // Bắt các lỗi khác (nếu có)
      errorMessage("Unexpected error: $e");
      rethrow;
    }
  }

  /// **Xóa livestream**
  Future<void> deleteLiveStream(String streamId) async {
    try {
      await _liveStreamCollection.doc(streamId).delete();
    } catch (e) {
      errorMessage("Error deleting live stream: $e");
      rethrow;
    }
  }

  /// **Tăng số lượt xem**
  Future<void> incrementViewerCount(String streamId) async {
    try {
      await _liveStreamCollection.doc(streamId).update({
        'viewerCount': FieldValue.increment(1),
      });
    } catch (e) {
      errorMessage("Error incrementing viewer count: $e");
      rethrow;
    }
  }

  Future<void> decrementViewerCount(String streamId) async {
    try {
      await _liveStreamCollection.doc(streamId).update({
        'viewerCount': FieldValue.increment(-1),
      });
    } catch (e) {
      errorMessage("Error decrementing viewer count: $e");
    }
  }

  /// **Thêm bình luận vào livestream**
  Future<void> addComment(
    String streamId,
    String content,
    String avtCommentUser,
    String nameCommentUser,
    String? gifUrl,
  ) async {
    try {
      var uuid = const Uuid();
      final String commentId = uuid.v4().substring(0, 12);
      final Map<String, String> comment = {
        "name": nameCommentUser,
        "photoUrl": avtCommentUser,
        "content": content,
        "createdAt": DateTime.now().toIso8601String(),
        "gif":gifUrl??"",
      };
      await _liveStreamCollection
          .doc(streamId)
          .update({'comments.$commentId': comment});
    } catch (e) {
      errorMessage("Error adding comment: $e");
      rethrow;
    }
  }

  // Future<void> addComment(
  //   String streamId,
  //   String content,
  //   String avtCommentUser,
  //   String nameCommentUser,
  // ) async {
  //   try {
  //     var uuid = const Uuid();
  //     final String commentId = uuid.v4().substring(0, 12);
  //     final Map<String, dynamic> newComment = {
  //       "name": nameCommentUser,
  //       "photoUrl": avtCommentUser,
  //       "content": content,
  //       "createdAt": DateTime.now().toIso8601String(),
  //     };

  //     final docRef = _liveStreamCollection.doc(streamId);

  //     await FirebaseFirestore.instance.runTransaction((transaction) async {
  //       // Lấy dữ liệu hiện tại
  //       DocumentSnapshot snapshot = await transaction.get(docRef);

  //       if (!snapshot.exists) {
  //         throw Exception("Stream with ID $streamId does not exist.");
  //       }

  //       // Lấy danh sách comments hiện tại (Map)
  //       Map<String, dynamic> comments = snapshot.get("comments") ?? {};

  //       // Chuyển Map thành List để dễ xử lý
  //       List<MapEntry<String, dynamic>> commentList = comments.entries.toList();

  //       // Nếu đã đạt đến giới hạn, xóa comment cũ nhất
  //       if (commentList.length >= 100) {
  //         commentList.removeAt(0);
  //       }

  //       // Thêm comment mới vào danh sách
  //       commentList.add(MapEntry(commentId, newComment));

  //       // Chuyển danh sách trở lại Map và cập nhật Firestore
  //       Map<String, dynamic> updatedComments = Map.fromEntries(commentList);
  //       transaction.update(docRef, {"comments": updatedComments});
  //     });
  //   } catch (e) {
  //     errorMessage("Error adding comment: $e");
  //     rethrow;
  //   }
  // }

  Future<void> addEmotes(String streamId, String emote) async {
    final docRef = _liveStreamCollection.doc(streamId);

    await FirebaseFirestore.instance.runTransaction((transaction) async {
      // Lấy document hiện tại
      DocumentSnapshot snapshot = await transaction.get(docRef);

      // Lấy danh sách messages hiện tại
      List<dynamic> messages = snapshot.get('emotes') ?? [];

      // Thêm message mới
      if (messages.length >= 30) {
        messages.removeAt(0); // Xóa message cũ nhất
      }
      messages.add(emote); // Thêm message mới

      // Cập nhật lại danh sách
      transaction.update(docRef, {'emotes': messages});
    }).catchError((e) {
      errorMessage("Failed to add emote: $e");
    });
  }

  /// **Nghe cập nhật realtime cho một livestream**
  Stream<LiveStreamModel?> streamLiveStreamUpdates(String streamId) {
    return _liveStreamCollection.doc(streamId).snapshots().map((snapshot) {
      if (snapshot.exists) {
        return LiveStreamModel.fromJson(
            snapshot.data() as Map<String, dynamic>);
      }
      return null;
    });
  }
}

```

---


### Pages\Society\agora_livestreaming\Widgets\bubbles_effect_widget.dart

```dart
import 'dart:math';

import 'package:flutter/material.dart';
import 'package:flutter_animate/flutter_animate.dart';
import 'package:get/get.dart';
import 'package:tictactoe_gameapp/Models/Functions/gradient_generator_functions.dart';

class EmojiDisplay extends StatelessWidget {
  final RxList<String> emojies;
  const EmojiDisplay({super.key, required this.emojies});

  @override
  Widget build(BuildContext context) {
    return Obx(() {
      return Stack(
        children: emojies.map((imagePath) {
          final random = Random();
          return Positioned.fill(
            child: RepaintBoundary(
              child: AnimatedEmoji(
                imagePath: imagePath,
                startX: random.nextDouble(),
                startY: 0.5,
                controlX: random.nextDouble(),
                controlY: random.nextDouble(),
                endX: random.nextDouble(),
                endY: -1.0,
              ),
            ),
          );
        }).toList(),
      );
    });
  }
}

class AnimatedEmoji extends StatefulWidget {
  final String imagePath;
  final double startX;
  final double startY;
  final double controlX;
  final double controlY;
  final double endX;
  final double endY;

  const AnimatedEmoji({
    super.key,
    required this.imagePath,
    required this.startX,
    required this.startY,
    required this.controlX,
    required this.controlY,
    required this.endX,
    required this.endY,
  });

  @override
  State<AnimatedEmoji> createState() => _AnimatedEmojiState();
}

class _AnimatedEmojiState extends State<AnimatedEmoji>
    with SingleTickerProviderStateMixin {
  late AnimationController _controller;
  late Animation<double> _opacityAnimation;
  late Animation<double> _sizeAnimation;
  late Animation<Offset> _positionAnimation;
  late Animation<Color?> _colorAnimation;

  @override
  void initState() {
    super.initState();

    _controller = AnimationController(
      vsync: this,
      duration: const Duration(seconds: 5),
    );

    // Opacity giảm dần
    _opacityAnimation = Tween<double>(begin: 1.0, end: 0.4).animate(
      CurvedAnimation(
          parent: _controller, curve: Curves.easeOut), //easeOut , easeInOut
    );

    // Kích thước emoji nhỏ dần
    _sizeAnimation = Tween<double>(begin: 50.0, end: 0.0).animate(
      CurvedAnimation(parent: _controller, curve: Curves.easeOut),
    );

    // Hiệu ứng thay đổi vị trí (Bezier Curve)
    _positionAnimation = TweenSequence<Offset>([
      TweenSequenceItem(
        tween: Tween<Offset>(
          begin: Offset(widget.startX, widget.startY),
          end: Offset(widget.controlX, widget.controlY),
        ).chain(CurveTween(curve: Curves.easeInOut)),
        weight: 50,
      ),
      TweenSequenceItem(
        tween: Tween<Offset>(
          begin: Offset(widget.controlX, widget.controlY),
          end: Offset(widget.endX, widget.endY),
        ).chain(CurveTween(curve: Curves.easeInOut)),
        weight: 50,
      ),
    ]).animate(_controller);

    _colorAnimation = ColorTween(
      begin: Colors.white,
      end: GradientGeneratorFunctions.generateRandomColor(),
    ).animate(CurvedAnimation(parent: _controller, curve: Curves.easeOut));

    _controller.forward();
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return AnimatedBuilder(
      animation: _controller,
      builder: (context, child) {
        return FractionalTranslation(
          translation: _positionAnimation.value,
          child: Opacity(
            opacity: _opacityAnimation.value,
            child: Transform.scale(
              scale: _sizeAnimation.value / 50,
              child: Container(
                decoration: BoxDecoration(
                  shape: BoxShape.circle,
                  boxShadow: [
                    BoxShadow(
                      color: _colorAnimation.value ?? Colors.white,
                      blurRadius: 10,
                      spreadRadius: 5,
                    ),
                  ],
                ),
                child: Image.asset(
                  widget.imagePath,
                  width: _sizeAnimation.value,
                  height: _sizeAnimation.value,
                ),
              ),
            ),
          ),
        );
      },
    );
  }
}

```

---


### Pages\Society\agora_livestreaming\Widgets\livestream_comment_list_widget.dart

```dart
import 'package:flutter/material.dart';
import 'package:get/get_state_manager/src/rx_flutter/rx_obx_widget.dart';
import 'package:tictactoe_gameapp/Components/belong_to_users/avatar_user_widget.dart';
import 'package:tictactoe_gameapp/Components/gifphy/display_gif_widget.dart';
import 'package:tictactoe_gameapp/Models/Functions/time_functions.dart';
import 'package:tictactoe_gameapp/Pages/Society/agora_livestreaming/agora_livestreaming_controller.dart';

class LiveStreamCommentListWidget extends StatelessWidget {
  final ThemeData theme;
  final AgoraLivestreamController livestreamController;
  const LiveStreamCommentListWidget(
      {super.key, required this.theme, required this.livestreamController});

  @override
  Widget build(BuildContext context) {
    return SizedBox(
        height: 300,
        width: 300,
        child: Obx(() => livestreamController.comments.isNotEmpty
            ? ListView.builder(
                clipBehavior: Clip.none,
                controller: livestreamController.scrollController,
                itemCount: livestreamController.comments.toList().length,
                itemBuilder: (context, index) {
                  final comment = livestreamController.comments[index];
                  return Padding(
                    padding: const EdgeInsets.only(bottom: 10.0),
                    child: Row(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        AvatarUserWidget(
                          radius: 25,
                          imagePath: comment['photoUrl']!,
                          borderThickness: 2,
                          
                        ),
                        const SizedBox(
                          width: 5,
                        ),
                        Expanded(
                          child: Column(
                            crossAxisAlignment: CrossAxisAlignment.start,
                            children: [
                              Text(comment['name']!,
                                  style: theme.textTheme.bodyLarge!),
                              Text(
                                comment["content"]!,
                                softWrap: true,
                                overflow: TextOverflow.visible,
                                style: const TextStyle(color: Colors.white),
                              ),
                              comment["gif"] != null || comment["gif"] ==""
                                  ? DisplayGifWidget(gifUrl: comment["gif"]!)
                                  : const SizedBox(),
                              SingleChildScrollView(
                                scrollDirection: Axis.horizontal,
                                child: Row(
                                  mainAxisAlignment: MainAxisAlignment.end,
                                  children: [
                                    Text(
                                        TimeFunctions.timeAgo(
                                            now: DateTime.now(),
                                            createdAt: DateTime.parse(
                                                comment['createdAt']!)),
                                        style: theme.textTheme.bodySmall!
                                            .copyWith(color: Colors.blueGrey)),
                                    IconButton(
                                        onPressed: () {},
                                        icon: const Icon(
                                          Icons.thumb_up_alt_rounded,
                                          size: 20,
                                          color: Colors.blueAccent,
                                        )),
                                    IconButton(
                                        onPressed: () {},
                                        icon: const Icon(
                                          Icons.thumb_down_alt_rounded,
                                          size: 20,
                                          color: Colors.blueAccent,
                                        )),
                                    IconButton(
                                        onPressed: () {},
                                        icon: const Icon(
                                          Icons.reply_all_rounded,
                                          size: 25,
                                          color: Colors.white,
                                        )),
                                  ],
                                ),
                              )
                            ],
                          ),
                        )
                      ],
                    ),
                  );
                })
            : const SizedBox()));
  }
}

```

---


### Pages\Society\Comment\comment_post_model.dart

```dart
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:tictactoe_gameapp/Models/user_model.dart';

class CommentModel {
  String? id;
  UserModel? commentUser; // Người bình luận
  String? content; // Nội dung bình luận
  String? gif;
  List<String>? likedList;
  DateTime? createdAt; // Thời gian bình luận
  String? postId; // Bài viết mà bình luận thuộc về
  int? countReplies;
  List<String>? taggedUserIds;

  CommentModel({
    this.id,
    this.commentUser,
    this.content,
    this.gif,
    this.likedList,
    this.createdAt,
    this.postId,
    this.countReplies,
    this.taggedUserIds,
  });

  // Constructor để chuyển từ JSON sang CommentModel
  CommentModel.fromJson(Map<String, dynamic> json) {
    id = json['commentId'] as String?;

    // Parse user data
    if (json['commentUser'] is Map) {
      commentUser = json['commentUser'] == null
          ? null
          : UserModel.fromJson(json['commentUser']);
    }

    content = json['content'] as String?;
    if (json['likedList'] is List) {
      likedList = List<String>.from(json['likedList']);
    }

    // Parse timestamp to DateTime
    if (json['createdAt'] is Timestamp) {
      createdAt = (json['createdAt'] as Timestamp).toDate();
    }

    gif = json['gif'] as String?;

    postId = json['postId'] as String?;
    countReplies = json['countReplies'] as int? ?? 0;

    // Parse tagged user IDs
    if (json['taggedUserIds'] is List) {
      taggedUserIds = List<String>.from(json['taggedUserIds']);
    }
  }

  // Phương thức để chuyển CommentModel thành JSON
  Map<String, dynamic> toJson() {
    final Map<String, dynamic> data = <String, dynamic>{};

    data['commentId'] = id;

    if (commentUser != null) {
      data['commentUser'] =
          commentUser?.toJson(); // Convert commentUser to JSON
    }

    data['content'] = content;
    if (likedList != null) {
      data['likedList'] = likedList;
    }

    data['gif'] = gif; // Gif

    // Convert createdAt to UTC
    if (createdAt != null) {
      data['createdAt'] = createdAt?.toUtc();
    }

    data['postId'] = postId;
    data['countReplies'] = countReplies;

    if (taggedUserIds != null) {
      data['taggedUserIds'] = taggedUserIds;
    }

    return data;
  }
}

```

---


### Pages\Society\Comment\post_comment_controller.dart

```dart
import 'dart:async';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:get/get.dart';
import 'package:tictactoe_gameapp/Configs/messages.dart';
import 'package:tictactoe_gameapp/Models/Functions/notification_add_functions.dart';
import 'package:tictactoe_gameapp/Models/user_model.dart';
import 'package:tictactoe_gameapp/Pages/Society/Comment/comment_post_model.dart';
import 'package:uuid/uuid.dart';

class PostCommentController extends GetxController {
  final FirebaseFirestore _firestore = FirebaseFirestore.instance;

  late StreamSubscription subscriptionListenComment;
  late final NotificationAddFunctions _notificationAddFunctions;
  DocumentSnapshot? lastDocument; // Tài liệu cuối cùng để phục vụ phân trang

  final List<String> options = ["Favoritest", "Newest", "Oldest"];
  var selectedOption = 'Newest'.obs;
  var commentsList = <CommentModel>[].obs;
  var isLoading = false.obs;
  int pageSize = 2;

  final String postId; // ID của bài viết mà controller này quản lý comments
  PostCommentController(this.postId);

  @override
  void onInit() {
    super.onInit();
    _notificationAddFunctions = NotificationAddFunctions(firestore: _firestore);
    fetchInitialComments();
    listenToCommentChanges();
    ever(selectedOption, (_) => fetchFilteredComments());
  }

  // Hàm tải các bình luận đầu tiên cho bài viết
  Future<void> fetchInitialComments() async {
    if (isLoading.value) return;
    isLoading.value = true;

    try {
      QuerySnapshot snapshot = await _firestore
          .collection('posts')
          .doc(postId)
          .collection('comments')
          .orderBy('createdAt', descending: true)
          .limit(pageSize)
          .get();

      if (snapshot.docs.isNotEmpty) {
        commentsList.value = snapshot.docs.map((doc) {
          return CommentModel.fromJson(doc.data() as Map<String, dynamic>);
        }).toList();
        lastDocument = snapshot.docs.last;
      }
    } catch (e) {
      errorMessage("Error fetching comments: $e");
    } finally {
      isLoading.value = false;
    }
  }

  // Hàm lọc bình luận dựa trên lựa chọn
  Future<void> fetchFilteredComments() async {
    if (isLoading.value) return;
    isLoading.value = true;

    try {
      Query query = _firestore
          .collection('posts')
          .doc(postId)
          .collection('comments')
          .limit(pageSize);

      switch (selectedOption.value) {
        case 'Favoritest':
          query = query.orderBy('likedList', descending: true);
          break;
        case 'Newest':
          query = query.orderBy('createdAt', descending: true);
          break;
        case 'Oldest':
          query = query.orderBy('createdAt', descending: false);
          break;
      }

      QuerySnapshot snapshot = await query.get();
      if (snapshot.docs.isNotEmpty) {
        commentsList.value = snapshot.docs.map((doc) {
          return CommentModel.fromJson(doc.data() as Map<String, dynamic>);
        }).toList();
        lastDocument = snapshot.docs.last;
      }
    } catch (e) {
      errorMessage("Error fetching comments: $e");
    } finally {
      isLoading.value = false;
    }
  }

  // Hàm tải thêm bình luận
  Future<void> fetchMoreFilteredComments() async {
    if (isLoading.value || lastDocument == null) return;
    isLoading.value = true;

    try {
      // Khởi tạo query và sắp xếp trước
      Query query =
          _firestore.collection('posts').doc(postId).collection('comments');

      switch (selectedOption.value) {
        case 'Favoritest':
          query = query.orderBy('likedList', descending: true);
          break;
        case 'Newest':
          query = query.orderBy('createdAt', descending: true);
          break;
        case 'Oldest':
          query = query.orderBy('createdAt', descending: false);
          break;
      }

      // Thêm startAfterDocument sau khi orderBy
      query = query.startAfterDocument(lastDocument!).limit(pageSize);

      QuerySnapshot snapshot = await query.get();
      if (snapshot.docs.isNotEmpty) {
        var newComments = snapshot.docs.map((doc) {
          return CommentModel.fromJson(doc.data() as Map<String, dynamic>);
        }).toList();
        commentsList.addAll(newComments);
        lastDocument = snapshot.docs.last;
      } else {
        lastDocument = null;
      }
    } catch (e) {
      errorMessage("Error fetching more comments: $e");
    } finally {
      isLoading.value = false;
    }
  }

  // Lắng nghe thay đổi real-time cho comments
  void listenToCommentChanges() {
    subscriptionListenComment = _firestore
        .collection('posts')
        .doc(postId)
        .collection('comments')
        .orderBy('createdAt', descending: true)
        .snapshots()
        .listen((snapshot) {
      for (var change in snapshot.docChanges) {
        if (change.type == DocumentChangeType.added) {
          // Thêm bình luận mới vào đầu danh sách
          commentsList.insert(0,
              CommentModel.fromJson(change.doc.data() as Map<String, dynamic>));
        } else if (change.type == DocumentChangeType.modified) {
          // Cập nhật bình luận nếu có thay đổi
          int index =
              commentsList.indexWhere((comment) => comment.id == change.doc.id);
          if (index != -1) {
            commentsList[index] = CommentModel.fromJson(
                change.doc.data() as Map<String, dynamic>);
          }
        } else if (change.type == DocumentChangeType.removed) {
          // Xóa bình luận nếu bị xóa khỏi Firestore
          commentsList.removeWhere((comment) => comment.id == change.doc.id);
        }
      }
    });
  }

  // Hàm thêm bình luận mới
  Future<void> addComment(
      {required String content,
      List<String>? taggedUserIds,
      String? gifUrl,
      required String receiverId,
      required UserModel currentUser}) async {
    try {
      var uuid = const Uuid();
      String commentId = uuid.v4();
      CommentModel newComment = CommentModel(
        id: commentId,
        postId: postId,
        content: content,
        gif: gifUrl,
        commentUser: currentUser,
        createdAt: DateTime.now(),
        taggedUserIds: taggedUserIds,
      );
      DocumentReference commentRef = _firestore
          .collection('posts')
          .doc(postId)
          .collection('comments')
          .doc(commentId);

      await commentRef
          .set(newComment.toJson())
          .catchError((e) => errorMessage(e));

      await _firestore.collection('posts').doc(postId).update({
        'commentCount': FieldValue.increment(1),
      }).catchError((e) => errorMessage(e));

      await _notificationAddFunctions.createCommentNotification(
        senderId: currentUser.id!,
        senderModel: currentUser,
        receiverId: receiverId,
        postId: postId,
        commentId: commentId,
        comment: content,
      );
    } catch (e) {
      errorMessage("Error adding comment: $e");
    }
  }

  // Hàm cập nhật bình luận
  Future<void> updateComment(String commentId, String newContent) async {
    try {
      await _firestore
          .collection('posts')
          .doc(postId)
          .collection('comments')
          .doc(commentId)
          .update({
        'content': newContent,
        'createdAt': FieldValue.serverTimestamp(),
      }).catchError((e) => errorMessage(e));
    } catch (e) {
      errorMessage("Error updating comment: $e");
    }
  }

  Future<void> likeComment(String commentId, String userId) async {
    DocumentReference commentRef = _firestore
        .collection('posts')
        .doc(postId)
        .collection("comments")
        .doc(commentId);

    await commentRef.update({
      'likedList': FieldValue.arrayUnion([userId]) // Thêm userId vào likedList
    }).catchError((e) => errorMessage(e));
  }

  // Hàm xóa userId khỏi likedList khi unlike
  Future<void> unlikeComment(String commentId, String userId) async {
    DocumentReference commentRef = _firestore
        .collection('posts')
        .doc(postId)
        .collection("comments")
        .doc(commentId);

    await commentRef.update({
      'likedList': FieldValue.arrayRemove([userId]) // Xóa userId khỏi likedList
    }).catchError((e) => errorMessage(e));
  }

  RxBool isLikedComment(String userId, String commentId) {
    // Tìm bài viết theo postId
    final comment =
        commentsList.firstWhereOrNull((comment) => comment.id == commentId);

    // Nếu không tìm thấy post hoặc likedList là null, trả về false
    if (comment == null || comment.likedList == null) {
      return false.obs;
    }

    // Kiểm tra xem userId có nằm trong likedList của post không
    final isLiked = comment.likedList!.contains(userId);

    return isLiked.obs; // Trả về RxBool phản ánh trạng thái "liked"
  }

  // Hàm xóa bình luận
  Future<void> deleteComment(String commentId) async {
    try {
      await _firestore
          .collection('posts')
          .doc(postId)
          .collection('comments')
          .doc(commentId)
          .delete()
          .catchError((e) => errorMessage(e));

      await _firestore.collection('posts').doc(postId).update({
        'commentCount': FieldValue.increment(-1),
      }).catchError((e) => errorMessage(e));
    } catch (e) {
      errorMessage("Error deleting comment: $e");
    }
  }

  // Hàm để cập nhật lựa chọn
  void updateSelectedOption(String value) {
    selectedOption.value = value;
  }

  // Hủy stream khi không cần thiết
  @override
  void onClose() {
    subscriptionListenComment.cancel();
    super.onClose();
  }
}

```

---


### Pages\Society\Comment\post_comment_list_sheet.dart

```dart
import 'package:bottom_sheet/bottom_sheet.dart';
import 'package:flutter/material.dart';
import 'package:flutter_animate/flutter_animate.dart';
import 'package:get/get.dart';
import 'package:giphy_picker/giphy_picker.dart';
import 'package:tictactoe_gameapp/Components/belong_to_users/avatar_user_widget.dart';
import 'package:tictactoe_gameapp/Components/gifphy/display_gif_widget.dart';
import 'package:tictactoe_gameapp/Components/gifphy/preview_gif_widget.dart';
import 'package:tictactoe_gameapp/Configs/assets_path.dart';
import 'package:tictactoe_gameapp/Configs/constants.dart';
import 'package:tictactoe_gameapp/Models/Functions/time_functions.dart';
import 'package:tictactoe_gameapp/Models/user_model.dart';
import 'package:tictactoe_gameapp/Pages/Society/Comment/post_comment_controller.dart';
import 'package:tictactoe_gameapp/Pages/Society/Comment/post_reply_comment_controller.dart';
import 'package:tictactoe_gameapp/Pages/Society/Widgets/expandable_text_custom.dart';
import 'package:tictactoe_gameapp/Pages/Society/Comment/post_reply_comment_list_sheet.dart';
import 'package:tictactoe_gameapp/Pages/Society/social_post_model.dart';
import 'package:tictactoe_gameapp/Components/emotes_picker_widget.dart';

class PostCommentListSheet extends StatelessWidget {
  final ScrollController scrollController;
  final UserModel currentUser;
  final PostModel post;
  const PostCommentListSheet(
      {super.key,
      required this.scrollController,
      required this.currentUser,
      required this.post});

  @override
  Widget build(BuildContext context) {
    final PostCommentController commentController =
        Get.put(PostCommentController(post.postId!));
    final TextEditingController textController = TextEditingController();
    final FocusNode focusNode = FocusNode();
    RxString commentContent = "".obs;
    RxString commentId = "".obs;
    RxBool isEmojiPickerVisible = false.obs;
    var selectedGif = Rx<GiphyGif?>(null);
    return Column(
      children: [
        Row(
          mainAxisAlignment: MainAxisAlignment.spaceBetween,
          children: [
            IconButton(
              onPressed: () {
                Get.back();
              },
              icon: const Icon(
                Icons.arrow_back_ios_new_rounded,
                size: 30,
              ),
            ),
            Expanded(
              child: Column(
                children: [
                  Container(
                    height: 5,
                    width: 50,
                    margin: const EdgeInsets.only(top: 10),
                    decoration: const BoxDecoration(
                      color: Colors.blueGrey,
                      borderRadius: BorderRadius.all(Radius.circular(20)),
                    ),
                  ),
                  const Text(
                    "Comments",
                    overflow: TextOverflow.clip,
                    style: TextStyle(fontSize: 20),
                  ),
                  Obx(() => DropdownButton<String>(
                        value: commentController.selectedOption.value,
                        icon: const Icon(Icons.radio_button_checked_rounded),
                        iconSize: 24,
                        iconEnabledColor: Colors.blue,
                        elevation: 16,
                        borderRadius:
                            const BorderRadius.all(Radius.circular(10)),
                        style:
                            const TextStyle(color: Colors.black, fontSize: 16),
                        underline: const SizedBox(),
                        onChanged: (String? newValue) {
                          if (newValue != null) {
                            commentController.updateSelectedOption(newValue);
                          }
                        },
                        items: commentController.options
                            .map<DropdownMenuItem<String>>((String value) {
                          return DropdownMenuItem<String>(
                            value: value,
                            child: Text(value),
                          );
                        }).toList(),
                      )),
                ],
              ),
            ),
            IconButton(
              onPressed: () {
                commentController.fetchInitialComments();
              },
              icon: const Icon(
                Icons.refresh_outlined,
                size: 35,
                color: Colors.blue,
              ),
            ),
          ],
        ),
        Expanded(
          child: Obx(() {
            if (commentController.commentsList.isEmpty) {
              return const Center(
                child: Column(
                  mainAxisAlignment: MainAxisAlignment.center,
                  children: [
                    Text("No comments yet", style: TextStyle(fontSize: 25)),
                    Text("Start the conversation...",
                        style: TextStyle(fontSize: 15, color: Colors.grey)),
                  ],
                ),
              );
            } else {
              var comments = commentController.commentsList.toList();
              return NotificationListener<ScrollNotification>(
                onNotification: (ScrollNotification scrollInfo) {
                  if (scrollInfo.metrics.pixels >=
                      scrollInfo.metrics.maxScrollExtent - 200) {
                    commentController.fetchMoreFilteredComments();
                  }
                  return true;
                },
                child: ListView.builder(
                    controller: scrollController,
                    itemCount: comments.length,
                    itemBuilder: (context, index) {
                      var comment = comments[index];
                      var commentUser = comment.commentUser!;
                      return Padding(
                        padding: const EdgeInsets.all(15.0),
                        child: Column(
                          children: [
                            Row(
                              crossAxisAlignment: CrossAxisAlignment.start,
                              children: [
                                AvatarUserWidget(
                                  radius: 20,
                                  imagePath: commentUser.image!,
                                  gradientColors: commentUser.avatarFrame,
                                ),
                                const SizedBox(
                                  width: 10,
                                ),
                                Expanded(
                                  child: Column(
                                    crossAxisAlignment:
                                        CrossAxisAlignment.start,
                                    children: [
                                      Row(
                                        children: [
                                          Text(
                                            commentUser.name!,
                                            style: const TextStyle(
                                              fontSize: 18,
                                              fontWeight: FontWeight.bold,
                                              color: Colors.purpleAccent,
                                            ),
                                          ),
                                          const SizedBox(
                                            width: 10,
                                          ),
                                          Text(
                                            TimeFunctions.timeAgo(
                                                now: DateTime.now(),
                                                createdAt: comment.createdAt!),
                                            style: const TextStyle(
                                              color: Colors.blueGrey,
                                              fontSize: 12,
                                            ),
                                          )
                                        ],
                                      ),
                                      ExpandableContent(
                                        content: comment.content!,
                                        style: const TextStyle(
                                          color: Colors.black,
                                          fontSize: 17,
                                        ),
                                        maxLines: 5,
                                      ),
                                      comment.gif != null
                                          ? DisplayGifWidget(
                                              gifUrl: comment.gif!,
                                            )
                                          : const SizedBox(),
                                      GestureDetector(
                                        onTap: () {
                                          commentId.value = comment.id!;
                                          textController.text =
                                              "@${commentUser.name!} ";
                                          textController.selection =
                                              TextSelection.fromPosition(
                                            TextPosition(
                                                offset:
                                                    textController.text.length),
                                          );
                                          focusNode.requestFocus();
                                        },
                                        child: const Text(
                                          "Reply",
                                          style: TextStyle(
                                            color: Colors.blueGrey,
                                            fontSize: 14,
                                          ),
                                        ),
                                      )
                                    ],
                                  ),
                                ),
                                Column(
                                  children: [
                                    comment.likedList != null
                                        ? Obx(() {
                                            RxBool isLiked = commentController
                                                .isLikedComment(currentUser.id!,
                                                    comment.id!);
                                            return !isLiked.value
                                                ? IconButton(
                                                    icon: const Icon(
                                                      Icons.favorite_border,
                                                      size: 25,
                                                      color: Colors.black,
                                                    ),
                                                    onPressed: () async {
                                                      commentController
                                                          .likeComment(
                                                              comment.id!,
                                                              currentUser.id!);
                                                    },
                                                  )
                                                : IconButton(
                                                    icon: const Icon(
                                                      Icons.favorite,
                                                      size: 25,
                                                      color: Colors.red,
                                                    ),
                                                    onPressed: () async {
                                                      commentController
                                                          .unlikeComment(
                                                              comment.id!,
                                                              currentUser.id!);
                                                    },
                                                  );
                                          })
                                        : IconButton(
                                            icon: const Icon(
                                              Icons.favorite_border,
                                              size: 25,
                                              color: Colors.black,
                                            ),
                                            onPressed: () async {
                                              commentController.likeComment(
                                                  comment.id!, currentUser.id!);
                                            },
                                          ),
                                    comment.likedList == null ||
                                            comment.likedList!.isEmpty
                                        ? const Text(
                                            "0",
                                            style: TextStyle(
                                              color: Colors.blueGrey,
                                              fontSize: 15,
                                            ),
                                          )
                                        : Text(
                                            "${comment.likedList!.length}",
                                            style: const TextStyle(
                                              color: Colors.blueGrey,
                                              fontSize: 15,
                                            ),
                                          ),
                                  ],
                                )
                              ],
                            ),
                            comment.countReplies == null ||
                                    comment.countReplies == 0
                                ? const SizedBox()
                                : Row(
                                    children: [
                                      const SizedBox(
                                        width: 40,
                                      ),
                                      Container(
                                        height: 2,
                                        width: 50,
                                        decoration: const BoxDecoration(
                                          color: Colors.blueGrey,
                                          borderRadius: BorderRadius.all(
                                              Radius.circular(20)),
                                        ),
                                      ),
                                      GestureDetector(
                                        onTap: () async {
                                          Get.delete<
                                              PostReplyCommentController>();
                                          await showFlexibleBottomSheet(
                                            minHeight: 0,
                                            initHeight: 0.8,
                                            maxHeight: 1,
                                            context: context,
                                            builder: (context, scrollController,
                                                bottomSheet) {
                                              return PostReplyCommentListSheet(
                                                scrollController:
                                                    scrollController,
                                                currentUser: currentUser,
                                                postId: post.postId!,
                                                commentModel: comment,
                                                commentController:
                                                    commentController,
                                              );
                                            },
                                            duration: const Duration(
                                                milliseconds: 500),
                                            bottomSheetColor: Colors.white,
                                            bottomSheetBorderRadius:
                                                const BorderRadius.only(
                                              topLeft: Radius.circular(20),
                                              topRight: Radius.circular(20),
                                            ),
                                            isSafeArea: true,
                                          );
                                        },
                                        child: Text(
                                          "View ${comment.countReplies} more replies",
                                          style: const TextStyle(
                                            fontStyle: FontStyle.italic,
                                            fontSize: 14,
                                            color: Colors.blueGrey,
                                          ),
                                        ),
                                      )
                                    ],
                                  ),
                          ],
                        ),
                      )
                          .animate()
                          .scale(duration: duration750)
                          .fadeIn(duration: duration750);
                    }),
              );
            }
          }),
        ),
        Padding(
          padding: const EdgeInsets.all(10.0),
          child: Column(
            children: [
              Obx(() => commentId.value.isNotEmpty
                  ? Container(
                      padding: const EdgeInsets.symmetric(
                          vertical: 10, horizontal: 10),
                      margin: const EdgeInsets.only(bottom: 10),
                      width: double.infinity,
                      height: 50,
                      color: Colors.grey.shade400,
                      child: Row(
                        mainAxisAlignment: MainAxisAlignment.start,
                        children: [
                          Expanded(
                            child: Text(
                              "Replying to ${textController.text} ",
                              style: const TextStyle(
                                color: Colors.black,
                                fontSize: 15,
                              ),
                            ),
                          ),
                          GestureDetector(
                              onTap: () {
                                commentId.value = "";
                                textController.clear();
                              },
                              child: const Text(
                                "X",
                                style: TextStyle(
                                  color: Colors.redAccent,
                                  fontSize: 25,
                                ),
                              ))
                        ],
                      ),
                    )
                  : const SizedBox()),
              PreviewGifWidget(
                selectedGif: selectedGif,
              ),
              CustomEmojiPicker(
                onEmojiSelected: (emoji) {
                  textController.text += emoji;
                  commentContent.value = textController.text;
                  textController.selection = TextSelection.fromPosition(
                    TextPosition(offset: textController.text.length),
                  );
                },
                onBackspacePressed: () {
                  final text = textController.text;
                  if (text.isNotEmpty) {
                    // Xóa ký tự cuối (bao gồm cả emoji)
                    textController.text =
                        text.characters.skipLast(1).toString();
                    commentContent.value = textController.text;
                    textController.selection = TextSelection.fromPosition(
                      TextPosition(offset: textController.text.length),
                    );
                  }
                },
                isEmojiPickerVisible: isEmojiPickerVisible,
                backgroundColor: const [
                  Colors.blueGrey,
                  Colors.blueGrey,
                ],
              ),
              Row(
                children: [
                  AvatarUserWidget(
                    radius: 25,
                    imagePath: currentUser.image!,
                    gradientColors: currentUser.avatarFrame,
                  ),
                  const SizedBox(
                    width: 10,
                  ),
                  Expanded(
                      child: TextField(
                    focusNode: focusNode,
                    controller: textController,
                    textInputAction: TextInputAction.done,
                    onChanged: (value) {
                      if (value.isNotEmpty) {
                        commentContent.value = value;
                      } else {
                        commentContent.value = "";
                      }
                    },
                    decoration: InputDecoration(
                      fillColor: Colors.grey.shade400,
                      hintStyle: const TextStyle(color: Colors.black54),
                      hintText: "Write a comment...",
                      prefixIcon: IconButton(
                        icon: const Icon(
                          Icons.gif_box_outlined,
                          color: Colors.blueAccent,
                          size: 30,
                        ),
                        onPressed: () async {
                          final gif = await GiphyPicker.pickGif(
                            context: context,
                            apiKey: apiGifphy,
                            showPreviewPage: false,
                            showGiphyAttribution: false,
                            loadingBuilder: (context) {
                              return Center(
                                child: ClipRRect(
                                  borderRadius: BorderRadius.circular(100),
                                  child: Image.asset(
                                    GifsPath.loadingGif,
                                    height: 200,
                                    width: 200,
                                  ),
                                ),
                              );
                            },
                          );

                          if (gif != null) {
                            selectedGif.value = gif;
                          }
                        },
                      ),
                      suffixIcon: Obx(() => IconButton(
                          onPressed: () {
                            isEmojiPickerVisible.toggle();
                          },
                          icon: isEmojiPickerVisible.value
                              ? const Icon(
                                  Icons.emoji_emotions,
                                  color: Colors.blue,
                                  size: 30,
                                )
                              : const Icon(
                                  Icons.emoji_emotions_outlined,
                                  color: Colors.blue,
                                  size: 30,
                                ))),
                    ),
                  )),
                  Obx(() => commentContent.value.isEmpty ||
                          commentContent.value == ""
                      ? const SizedBox()
                      : Obx(
                          () => commentId.value.isNotEmpty
                              ? IconButton(
                                  onPressed: () async {
                                    focusNode.unfocus();
                                    Get.delete<PostReplyCommentController>();
                                    PostReplyCommentController
                                        subCommentController =
                                        Get.put(PostReplyCommentController(
                                      post.postId!,
                                      commentId.value,
                                    ));
                                    await subCommentController.addSubComment(
                                        content: commentContent.value,
                                        gifUrl: selectedGif
                                            .value?.images.original!.url!,
                                        currentUser: currentUser);
                                    textController.clear();
                                    commentContent.value = "";
                                    selectedGif.value = null;
                                    commentId.value = "";
                                  },
                                  icon: const Icon(
                                    Icons.reply_all_rounded,
                                    size: 35,
                                    color: Colors.blue,
                                  ),
                                )
                              : IconButton(
                                  onPressed: () async {
                                    focusNode.unfocus();
                                    await commentController.addComment(
                                      content: commentContent.value,
                                      currentUser: currentUser,
                                      receiverId: post.postUser!.id!,
                                      gifUrl: selectedGif
                                          .value?.images.original!.url!,
                                    );
                                    textController.clear();
                                    selectedGif.value = null;
                                    commentContent.value = "";
                                  },
                                  icon: const Icon(
                                    Icons.send_rounded,
                                    size: 35,
                                    color: Colors.blue,
                                  ),
                                ),
                        )),
                ],
              ),
            ],
          ),
        ),
      ],
    );
  }
}

```

---


### Pages\Society\Comment\post_reply_comment_controller.dart

```dart
import 'dart:async';

import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:get/get.dart';
import 'package:tictactoe_gameapp/Configs/messages.dart';
import 'package:tictactoe_gameapp/Models/user_model.dart';
import 'package:tictactoe_gameapp/Pages/Society/Comment/comment_post_model.dart';
import 'package:uuid/uuid.dart';

class PostReplyCommentController extends GetxController {
  final FirebaseFirestore _firestore = FirebaseFirestore.instance;
  late StreamSubscription subscriptionListenComment;

  RxList<CommentModel> subCommentsList = <CommentModel>[].obs;
  final int commentsPerPage = 1; // Số sub-comments tải mỗi lần cho pagination
  DocumentSnapshot? lastDocument; // Để theo dõi pagination
  bool isFetching = false;

  final String postId; // ID của bài viết
  final String commentId; // ID của comment chính
  PostReplyCommentController(this.postId, this.commentId);

  @override
  void onInit() {
    super.onInit();
    fetchSubComments(); // Lắng nghe sub-comments ngay từ khi init
    listenToSubComments();
  }

  // Lấy danh sách sub-comments theo pagination
  Future<void> fetchSubComments({bool isPagination = false}) async {
    if (isFetching) return;
    isFetching = true;

    try {
      Query query = _firestore
          .collection('posts')
          .doc(postId)
          .collection('comments')
          .doc(commentId)
          .collection('subComments')
          .orderBy('createdAt', descending: true)
          .limit(commentsPerPage);

      // Nếu đang pagination, bắt đầu từ document cuối cùng đã lấy
      if (isPagination && lastDocument != null) {
        query = query.startAfterDocument(lastDocument!);
      }

      QuerySnapshot snapshot = await query.get();

      // Cập nhật document cuối để tiếp tục pagination
      if (snapshot.docs.isNotEmpty) {
        lastDocument = snapshot.docs.last;
      }

      // Nếu không phải là pagination, clear danh sách trước khi thêm mới
      if (!isPagination) {
        subCommentsList.clear();
      }

      // Thêm vào danh sách subCommentsList
      subCommentsList.addAll(
        snapshot.docs.map((doc) {
          return CommentModel.fromJson(doc.data() as Map<String, dynamic>);
        }).toList(),
      );
    } catch (e) {
      throw Exception("Error fetching sub-comments: $e");
    } finally {
      isFetching = false;
    }
  }

  // Lắng nghe sub-comments theo thời gian thực
  void listenToSubComments() {
    subscriptionListenComment = _firestore
        .collection('posts')
        .doc(postId)
        .collection('comments')
        .doc(commentId)
        .collection('subComments')
        .orderBy('createdAt', descending: true)
        .snapshots()
        .listen((snapshot) {
      for (var change in snapshot.docChanges) {
        if (change.type == DocumentChangeType.added) {
          // Thêm bình luận mới vào đầu danh sách
          subCommentsList.insert(0,
              CommentModel.fromJson(change.doc.data() as Map<String, dynamic>));
        } else if (change.type == DocumentChangeType.modified) {
          // Cập nhật bình luận nếu có thay đổi
          int index = subCommentsList
              .indexWhere((comment) => comment.id == change.doc.id);
          if (index != -1) {
            subCommentsList[index] = CommentModel.fromJson(
                change.doc.data() as Map<String, dynamic>);
          }
        } else if (change.type == DocumentChangeType.removed) {
          // Xóa bình luận nếu bị xóa khỏi Firestore
          subCommentsList.removeWhere((comment) => comment.id == change.doc.id);
        }
      }
    });
  }

  // Thêm sub-comment
  Future<void> addSubComment(
      {required String content,
      String? gifUrl,
      List<String>? taggedUserIds,
      required UserModel currentUser}) async {
    try {
      var uuid = const Uuid();
      String subCommentId = uuid.v4();
      CommentModel newSubComment = CommentModel(
        id: commentId,
        postId: commentId,
        gif: gifUrl,
        content: content,
        commentUser: currentUser,
        createdAt: DateTime.now(),
        taggedUserIds: taggedUserIds,
      );
      DocumentReference subCommentRef = _firestore
          .collection('posts')
          .doc(postId)
          .collection('comments')
          .doc(commentId)
          .collection('subComments')
          .doc(subCommentId);

      await subCommentRef
          .set(newSubComment.toJson())
          .catchError((e) => errorMessage(e));

      await _firestore.collection('posts').doc(postId).update({
        'commentCount': FieldValue.increment(1),
      }).catchError((e) => errorMessage(e));
      await _firestore
          .collection('posts')
          .doc(postId)
          .collection('comments')
          .doc(commentId)
          .update({
        'countReplies': FieldValue.increment(1),
      }).catchError((e) => errorMessage(e));
    } catch (e) {
      throw Exception("Error adding sub-comment: $e");
    }
  }

  Future<void> likeSubComment(String subCommentId, String userId) async {
    DocumentReference commentRef = _firestore
        .collection('posts')
        .doc(postId)
        .collection('comments')
        .doc(commentId)
        .collection('subComments')
        .doc(subCommentId);

    await commentRef.update({
      'likedList': FieldValue.arrayUnion([userId]) // Thêm userId vào likedList
    }).catchError((e) => errorMessage(e));
  }

  // Hàm xóa userId khỏi likedList khi unlike
  Future<void> unlikeSubComment(String subCommentId, String userId) async {
    DocumentReference commentRef = _firestore
        .collection('posts')
        .doc(postId)
        .collection('comments')
        .doc(commentId)
        .collection('subComments')
        .doc(subCommentId);

    await commentRef.update({
      'likedList': FieldValue.arrayRemove([userId]) // Xóa userId khỏi likedList
    }).catchError((e) => errorMessage(e));
  }

  RxBool isLikedSubComment(String userId, String subCommentId) {
    // Tìm bài viết theo postId
    final comment = subCommentsList
        .firstWhereOrNull((subComment) => subComment.id == subCommentId);

    // Nếu không tìm thấy post hoặc likedList là null, trả về false
    if (comment == null || comment.likedList == null) {
      return false.obs;
    }

    // Kiểm tra xem userId có nằm trong likedList của post không
    final isLiked = comment.likedList!.contains(userId);

    return isLiked.obs; // Trả về RxBool phản ánh trạng thái "liked"
  }

  // Hàm xóa bình luận
  Future<void> deleteComment(String subCommentId) async {
    try {
      await _firestore
          .collection('posts')
          .doc(postId)
          .collection('comments')
          .doc(commentId)
          .collection('subComments')
          .doc(subCommentId)
          .delete()
          .catchError((e) => errorMessage(e));
      await _firestore.collection('posts').doc(postId).update({
        'commentCount': FieldValue.increment(-1),
      }).catchError((e) => errorMessage(e));
      await _firestore
          .collection('posts')
          .doc(postId)
          .collection('comments')
          .doc(commentId)
          .update({
        'countReplies': FieldValue.increment(-1),
      }).catchError((e) => errorMessage(e));
    } catch (e) {
      errorMessage("Error deleting comment: $e");
    }
  }

  // Hàm để tải thêm sub-comments cho pagination
  Future<void> loadMoreSubComments() async {
    await fetchSubComments(isPagination: true);
  }

  @override
  void onClose() {
    subscriptionListenComment.cancel();
    super.onClose();
  }
}

```

---


### Pages\Society\Comment\post_reply_comment_list_sheet.dart

```dart
import 'package:flutter/material.dart';
import 'package:flutter_animate/flutter_animate.dart';
import 'package:get/get.dart';
import 'package:giphy_picker/giphy_picker.dart';
import 'package:tictactoe_gameapp/Components/belong_to_users/avatar_user_widget.dart';
import 'package:tictactoe_gameapp/Components/gifphy/display_gif_widget.dart';
import 'package:tictactoe_gameapp/Components/gifphy/preview_gif_widget.dart';
import 'package:tictactoe_gameapp/Configs/assets_path.dart';
import 'package:tictactoe_gameapp/Configs/constants.dart';
import 'package:tictactoe_gameapp/Models/Functions/time_functions.dart';
import 'package:tictactoe_gameapp/Models/user_model.dart';
import 'package:tictactoe_gameapp/Pages/Society/Comment/post_comment_controller.dart';
import 'package:tictactoe_gameapp/Pages/Society/Comment/comment_post_model.dart';
import 'package:tictactoe_gameapp/Pages/Society/Comment/post_reply_comment_controller.dart';
import 'package:tictactoe_gameapp/Pages/Society/Widgets/expandable_text_custom.dart';
import 'package:tictactoe_gameapp/Components/emotes_picker_widget.dart';

class PostReplyCommentListSheet extends StatelessWidget {
  final PostCommentController commentController;
  final ScrollController scrollController;
  final UserModel currentUser;
  final String postId;
  final CommentModel commentModel;
  const PostReplyCommentListSheet(
      {super.key,
      required this.scrollController,
      required this.currentUser,
      required this.postId,
      required this.commentModel,
      required this.commentController});

  @override
  Widget build(BuildContext context) {
    final PostReplyCommentController subCommentController =
        Get.put(PostReplyCommentController(postId, commentModel.id!));
    final UserModel commentUser = commentModel.commentUser!;
    final TextEditingController textController = TextEditingController();
    final FocusNode focusNode = FocusNode();
    RxString commentContent = "".obs;
    RxString replyCommentId = "".obs;
    RxBool isEmojiPickerVisible = false.obs;
    var selectedGif = Rx<GiphyGif?>(null);
    return Column(
      children: [
        Row(
          mainAxisAlignment: MainAxisAlignment.spaceBetween,
          children: [
            IconButton(
              onPressed: () {
                Get.back();
              },
              icon: const Icon(
                Icons.arrow_back_ios_new_rounded,
                size: 30,
              ),
            ),
            Expanded(
              child: Column(
                children: [
                  Container(
                    height: 5,
                    width: 50,
                    margin: const EdgeInsets.only(top: 10),
                    decoration: const BoxDecoration(
                      color: Colors.blueGrey,
                      borderRadius: BorderRadius.all(Radius.circular(20)),
                    ),
                  ),
                  const Text(
                    "Replies",
                    overflow: TextOverflow.clip,
                    style: TextStyle(fontSize: 20),
                  ),
                  Padding(
                    padding: const EdgeInsets.symmetric(
                        horizontal: 20, vertical: 10),
                    child: Row(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        AvatarUserWidget(
                          radius: 30,
                          imagePath: commentUser.image!,
                          gradientColors: commentUser.avatarFrame,
                        ),
                        const SizedBox(
                          width: 10,
                        ),
                        Expanded(
                          child: Column(
                            crossAxisAlignment: CrossAxisAlignment.start,
                            children: [
                              Text(
                                commentUser.name!,
                                style: const TextStyle(
                                  fontSize: 20,
                                  fontWeight: FontWeight.bold,
                                  color: Colors.purpleAccent,
                                ),
                              ),
                              ExpandableContent(
                                content: commentModel.content!,
                                style: const TextStyle(
                                  color: Colors.black,
                                  fontSize: 19,
                                ),
                                maxLines: 5,
                              ),
                              Text(
                                TimeFunctions.timeAgo(
                                    now: DateTime.now(),
                                    createdAt: commentModel.createdAt!),
                                style: const TextStyle(
                                  color: Colors.blueGrey,
                                  fontSize: 13,
                                ),
                              )
                            ],
                          ),
                        ),
                        Column(
                          children: [
                            commentModel.likedList != null
                                ? Obx(() {
                                    RxBool isLiked =
                                        commentController.isLikedComment(
                                            currentUser.id!, commentModel.id!);
                                    return !isLiked.value
                                        ? IconButton(
                                            icon: const Icon(
                                              Icons.favorite_border,
                                              size: 30,
                                              color: Colors.black,
                                            ),
                                            onPressed: () async {
                                              commentController.likeComment(
                                                  commentModel.id!,
                                                  currentUser.id!);
                                            },
                                          )
                                        : IconButton(
                                            icon: const Icon(
                                              Icons.favorite,
                                              size: 30,
                                              color: Colors.red,
                                            ),
                                            onPressed: () async {
                                              commentController.unlikeComment(
                                                  commentModel.id!,
                                                  currentUser.id!);
                                            },
                                          );
                                  })
                                : IconButton(
                                    icon: const Icon(
                                      Icons.favorite_border,
                                      size: 30,
                                      color: Colors.black,
                                    ),
                                    onPressed: () async {
                                      commentController.likeComment(
                                          commentModel.id!, currentUser.id!);
                                    },
                                  ),
                            commentModel.likedList == null ||
                                    commentModel.likedList!.isEmpty
                                ? const Text(
                                    "0",
                                    style: TextStyle(
                                      color: Colors.blueGrey,
                                      fontSize: 17,
                                    ),
                                  )
                                : Text(
                                    "${commentModel.likedList!.length}",
                                    style: const TextStyle(
                                      color: Colors.blueGrey,
                                      fontSize: 17,
                                    ),
                                  ),
                          ],
                        )
                      ],
                    ),
                  ),
                ],
              ),
            ),
            IconButton(
              onPressed: () {},
              icon: const Icon(
                Icons.info_outline,
                size: 35,
              ),
            ),
          ],
        ),
        Expanded(
          child: Obx(() {
            if (subCommentController.subCommentsList.isEmpty) {
              return const Center(
                child: Column(
                  mainAxisAlignment: MainAxisAlignment.center,
                  children: [
                    Text("No replies yet", style: TextStyle(fontSize: 25)),
                    Text("Start the conversation...",
                        style: TextStyle(fontSize: 15, color: Colors.grey)),
                  ],
                ),
              );
            } else {
              var comments = subCommentController.subCommentsList.toList();
              return NotificationListener<ScrollNotification>(
                onNotification: (ScrollNotification scrollInfo) {
                  if (scrollInfo.metrics.pixels >=
                      scrollInfo.metrics.maxScrollExtent - 200) {
                    subCommentController.loadMoreSubComments();
                  }
                  return true;
                },
                child: ListView.builder(
                    controller: scrollController,
                    itemCount: comments.length,
                    itemBuilder: (context, index) {
                      var comment = comments[index];
                      var commentUser = comment.commentUser!;
                      return Padding(
                        padding: const EdgeInsets.all(15.0),
                        child: Column(
                          children: [
                            Row(
                              crossAxisAlignment: CrossAxisAlignment.start,
                              children: [
                                AvatarUserWidget(
                                  radius: 20,
                                  imagePath: commentUser.image!,
                                  gradientColors: commentUser.avatarFrame,
                                ),
                                const SizedBox(
                                  width: 10,
                                ),
                                Expanded(
                                  child: Column(
                                    crossAxisAlignment:
                                        CrossAxisAlignment.start,
                                    children: [
                                      Row(
                                        children: [
                                          Text(
                                            commentUser.name!,
                                            style: const TextStyle(
                                              fontSize: 18,
                                              fontWeight: FontWeight.bold,
                                              color: Colors.blueAccent,
                                            ),
                                          ),
                                          const SizedBox(
                                            width: 10,
                                          ),
                                          Text(
                                            TimeFunctions.timeAgo(
                                                now: DateTime.now(),
                                                createdAt: comment.createdAt!),
                                            style: const TextStyle(
                                              color: Colors.blueGrey,
                                              fontSize: 12,
                                            ),
                                          )
                                        ],
                                      ),
                                      ExpandableContent(
                                        content: comment.content!,
                                        style: const TextStyle(
                                          color: Colors.black,
                                          fontSize: 17,
                                        ),
                                        maxLines: 5,
                                      ),
                                      comment.gif != null
                                          ? DisplayGifWidget(
                                              gifUrl: comment.gif!)
                                          : const SizedBox(),
                                      GestureDetector(
                                        onTap: () {
                                          replyCommentId.value = comment.id!;
                                          textController.text =
                                              "@${commentUser.name!} ";
                                          textController.selection =
                                              TextSelection.fromPosition(
                                            TextPosition(
                                                offset:
                                                    textController.text.length),
                                          );
                                          focusNode.requestFocus();
                                        },
                                        child: const Text(
                                          "Reply",
                                          style: TextStyle(
                                            color: Colors.blueGrey,
                                            fontSize: 14,
                                          ),
                                        ),
                                      )
                                    ],
                                  ),
                                ),
                                Column(
                                  children: [
                                    IconButton(
                                      icon: const Icon(
                                        Icons.favorite_border,
                                        size: 25,
                                        color: Colors.black,
                                      ),
                                      onPressed: () {},
                                    ),
                                    comment.likedList == null ||
                                            comment.likedList!.isEmpty
                                        ? const Text(
                                            "0",
                                            style: TextStyle(
                                              color: Colors.blueGrey,
                                              fontSize: 15,
                                            ),
                                          )
                                        : Text(
                                            "${comment.likedList!.length}",
                                            style: const TextStyle(
                                              color: Colors.blueGrey,
                                              fontSize: 15,
                                            ),
                                          ),
                                  ],
                                )
                              ],
                            ),
                          ],
                        ),
                      )
                          .animate()
                          .scale(duration: duration750)
                          .fadeIn(duration: duration750);
                    }),
              );
            }
          }),
        ),
        Padding(
          padding: const EdgeInsets.all(10.0),
          child: Column(
            children: [
              Obx(() => replyCommentId.value.isNotEmpty
                  ? Container(
                      padding: const EdgeInsets.symmetric(
                          vertical: 10, horizontal: 10),
                      margin: const EdgeInsets.only(bottom: 10),
                      width: double.infinity,
                      height: 50,
                      color: Colors.grey.shade400,
                      child: Row(
                        mainAxisAlignment: MainAxisAlignment.start,
                        children: [
                          Expanded(
                            child: Text(
                              "Replying to ${textController.text} ",
                              style: const TextStyle(
                                color: Colors.black,
                                fontSize: 15,
                              ),
                            ),
                          ),
                          GestureDetector(
                              onTap: () {
                                replyCommentId.value = "";
                                textController.clear();
                              },
                              child: const Text(
                                "X",
                                style: TextStyle(
                                  color: Colors.redAccent,
                                  fontSize: 25,
                                ),
                              ))
                        ],
                      ),
                    )
                  : const SizedBox()),
              PreviewGifWidget(selectedGif: selectedGif),
              CustomEmojiPicker(
                onEmojiSelected: (emoji) {
                  textController.text += emoji;
                  commentContent.value = textController.text;
                  textController.selection = TextSelection.fromPosition(
                    TextPosition(offset: textController.text.length),
                  );
                },
                onBackspacePressed: () {
                  final text = textController.text;
                  if (text.isNotEmpty) {
                    // Xóa ký tự cuối (bao gồm cả emoji)
                    textController.text =
                        text.characters.skipLast(1).toString();
                    commentContent.value = textController.text;
                    textController.selection = TextSelection.fromPosition(
                      TextPosition(offset: textController.text.length),
                    );
                  }
                },
                isEmojiPickerVisible: isEmojiPickerVisible,
                backgroundColor: const [
                  Colors.blueGrey,
                  Colors.blueGrey,
                ],
              ),
              Row(
                children: [
                  AvatarUserWidget(
                    radius: 25,
                    imagePath: currentUser.image!,
                    gradientColors: currentUser.avatarFrame,
                  ),
                  const SizedBox(
                    width: 10,
                  ),
                  Expanded(
                      child: TextField(
                    focusNode: focusNode,
                    controller: textController,
                    textInputAction: TextInputAction.done,
                    onChanged: (value) {
                      if (value.isNotEmpty) {
                        commentContent.value = value;
                      } else {
                        commentContent.value = "";
                      }
                    },
                    decoration: InputDecoration(
                      fillColor: Colors.grey.shade400,
                      hintStyle: const TextStyle(color: Colors.black54),
                      hintText:
                          "Reply a comment of @${commentModel.commentUser!.name!}",
                      prefixIcon: IconButton(
                        icon: const Icon(
                          Icons.gif_box_outlined,
                          color: Colors.blueAccent,
                          size: 30,
                        ),
                        onPressed: () async {
                          final gif = await GiphyPicker.pickGif(
                            context: context,
                            apiKey: apiGifphy,
                            showPreviewPage: false,
                            showGiphyAttribution: false,
                            loadingBuilder: (context) {
                              return Center(
                                child: ClipRRect(
                                  borderRadius: BorderRadius.circular(100),
                                  child: Image.asset(
                                    GifsPath.loadingGif,
                                    height: 200,
                                    width: 200,
                                  ),
                                ),
                              );
                            },
                          );

                          if (gif != null) {
                            selectedGif.value = gif;
                          }
                        },
                      ),
                      suffixIcon: Obx(() => IconButton(
                          onPressed: () {
                            isEmojiPickerVisible.toggle();
                          },
                          icon: isEmojiPickerVisible.value
                              ? const Icon(
                                  Icons.emoji_emotions,
                                  color: Colors.blue,
                                  size: 30,
                                )
                              : const Icon(
                                  Icons.emoji_emotions_outlined,
                                  color: Colors.blue,
                                  size: 30,
                                ))),
                    ),
                  )),
                  Obx(
                    () => commentContent.value.isEmpty ||
                            commentContent.value == ""
                        ? const SizedBox()
                        : IconButton(
                            onPressed: () async {
                              focusNode.unfocus();
                              await subCommentController.addSubComment(
                                  content: commentContent.value,
                                  currentUser: currentUser);
                              textController.clear();
                              commentContent.value = "";
                            },
                            icon: const Icon(
                              Icons.arrow_outward_rounded,
                              size: 35,
                              color: Colors.blue,
                              weight: 10.0,
                            ),
                          ),
                  ),
                ],
              ),
            ],
          ),
        ),
      ],
    );
  }
}

```

---


### Pages\Society\Reels\create_reel_page.dart

```dart
import 'dart:io';
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:image_picker/image_picker.dart';
import 'package:tictactoe_gameapp/Components/belong_to_users/avatar_user_widget.dart';
import 'package:tictactoe_gameapp/Configs/assets_path.dart';
import 'package:tictactoe_gameapp/Controller/profile_controller.dart';
import 'package:tictactoe_gameapp/Models/user_model.dart';
import 'package:tictactoe_gameapp/Pages/Society/Widgets/optional_tile_custom.dart';
import 'package:tictactoe_gameapp/Pages/Society/Reels/api/fetch_url_link_api_page.dart';
import 'package:tictactoe_gameapp/Pages/Society/Reels/whitecodel/whitecodel_reels_page.dart';
import 'package:tictactoe_gameapp/Pages/Society/Reels/reel_controller.dart';
import 'package:video_player/video_player.dart';

import 'package:http/http.dart' as http;

class CreateReelPage extends StatelessWidget {
  final UserModel user;
  const CreateReelPage({super.key, required this.user});

  @override
  Widget build(BuildContext context) {
    final ThemeData theme = Theme.of(context);
    final TextEditingController videoUrlTextEditingController =
        TextEditingController();
    RxString videoUrl = "".obs;
    RxBool isVideoValid = false.obs;
    RxString description = "".obs;
    RxString imagePath = "".obs;
    XFile? image;
    return Scaffold(
      appBar: AppBar(
        leading: IconButton(
          onPressed: () {
            if (videoUrl.value.isNotEmpty) {
              videoUrl.value = "";
            }
            Get.offNamed("mainHome");
          },
          icon: const Icon(
            Icons.arrow_back,
            size: 40,
            color: Colors.deepPurple,
          ),
        ),
        centerTitle: false,
        title: Text(
          "Create a new reel",
          style: theme.textTheme.headlineMedium,
        ),
        actions: [
          Obx(
            () => isVideoValid.value && description.value.isNotEmpty
                ? InkWell(
                    onTap: () async {
                      await Get.showOverlay(
                        asyncFunction: () async {
                          final ReelController reelController =
                              Get.put(ReelController());
                          await reelController.createReel(
                            videoUrl: videoUrl.value,
                            user: user,
                            description: description.value,
                            imagePath: image,
                          );
                        },
                        loadingWidget: Center(
                          child: ClipRRect(
                            borderRadius: BorderRadius.circular(100),
                            child: Image.asset(
                              GifsPath.loadingGif,
                              width: 200,
                              height: 200,
                            ),
                          ),
                        ),
                      ).then((_) {
                        Get.toNamed("mainHome");
                      });
                    },
                    child: Ink(
                      height: 50,
                      width: 100,
                      decoration: BoxDecoration(
                        color: Colors.blueAccent,
                        borderRadius: BorderRadius.circular(10),
                      ),
                      child: Center(
                        child: Text(
                          "Reel",
                          style: theme.textTheme.bodyLarge!
                              .copyWith(color: Colors.white),
                        ),
                      ),
                    ),
                  )
                : Container(
                    height: 50,
                    width: 100,
                    alignment: Alignment.center,
                    decoration: BoxDecoration(
                      color: Colors.grey,
                      borderRadius: BorderRadius.circular(10),
                    ),
                    child: Text(
                      "Reel",
                      style: theme.textTheme.bodyLarge!
                          .copyWith(color: Colors.black45),
                    ),
                  ),
          ),
          const SizedBox(
            width: 10,
          ),
        ],
      ),
      body: Padding(
        padding: const EdgeInsets.all(10.0),
        child: SingleChildScrollView(
          child: Column(
            children: [
              Row(
                children: [
                  AvatarUserWidget(
                    radius: 35,
                    imagePath: user.image!,
                    gradientColors: user.avatarFrame,
                  ),
                  const SizedBox(width: 10),
                  Expanded(
                    child: Text(
                      user.name!,
                      style: theme.textTheme.headlineMedium,
                    ),
                  ),
                ],
              ),
              const SizedBox(
                height: 20,
              ),
              SizedBox(
                height: 100,
                child: TextField(
                  controller: videoUrlTextEditingController,
                  onChanged: (text) async {
                    if (text.isNotEmpty) {
                      videoUrl.value = text.trim();
                      await validateVideo(text, isVideoValid);
                    } else {
                      videoUrl.value = "";
                    }
                  },
                  minLines: null,
                  maxLines: null,
                  expands: true,
                  textAlign: TextAlign.left,
                  textAlignVertical: TextAlignVertical.top,
                  decoration: InputDecoration(
                    fillColor: Colors.transparent,
                    labelText: 'Video Link ...',
                    alignLabelWithHint: true,
                    labelStyle: theme.textTheme.bodyLarge,
                    border: OutlineInputBorder(
                      borderRadius: BorderRadius.circular(20),
                      borderSide: const BorderSide(
                        color: Colors.blueAccent,
                      ),
                    ),
                  ),
                ),
              ),
              const SizedBox(
                height: 20,
              ),
              Obx(() => isVideoValid.value
                  ? Column(
                      children: [
                        SizedBox(
                          height: 300,
                          width: MediaQuery.sizeOf(context).width * 0.5,
                          child: ClipRRect(
                            borderRadius: BorderRadius.circular(15),
                            child: WhiteCodelReelsPage(
                              singleVideoUrl: videoUrl.value,
                              isCaching: false,
                            ),
                          ),
                        ),
                        // FutureBuilder<String?>(
                        //   future: CompressImageFunction.generateThumbnailBase64(
                        //       videoUrl.value),
                        //   builder: (context, snapshot) {
                        //     if (snapshot.connectionState ==
                        //         ConnectionState.waiting) {
                        //       return Container(
                        //         width: double.infinity,
                        //         height: 200,
                        //         alignment: Alignment.center,
                        //         child: const CircularProgressIndicator(),
                        //       );
                        //     }
                        //     if (snapshot.hasError ||
                        //         !snapshot.hasData ||
                        //         snapshot.data == null) {
                        //       return Container(
                        //         width: double.infinity,
                        //         height: 200,
                        //         decoration: const BoxDecoration(
                        //           image: DecorationImage(
                        //             image: AssetImage(GifsPath.loadingGif2),
                        //             fit: BoxFit.cover,
                        //           ),
                        //         ),
                        //       );
                        //     }
                        //     return Image.memory(
                        //       base64Decode(snapshot.data!),
                        //       fit: BoxFit.cover,
                        //       width: 270,
                        //       height: 480,
                        //       errorBuilder: (context, error, stackTrace) {
                        //         return Container(
                        //           width: double.infinity,
                        //           height: double.infinity,
                        //           decoration: const BoxDecoration(
                        //             image: DecorationImage(
                        //               image: AssetImage(GifsPath.loadingGif2),
                        //               fit: BoxFit.cover,
                        //             ),
                        //           ),
                        //         );
                        //       },
                        //     );
                        //   },
                        // ),
                      ],
                    )
                  : videoUrl.value.isNotEmpty
                      ? const Column(
                          children: [
                            Icon(Icons.error, color: Colors.red, size: 50),
                            Text("Video is not available or invalid!",
                                style: TextStyle(color: Colors.red)),
                          ],
                        )
                      : const SizedBox.shrink()),
              const SizedBox(
                height: 20,
              ),
              SizedBox(
                height: 150,
                child: TextField(
                  onChanged: (text) {
                    if (text.isNotEmpty) {
                      description.value = text;
                    } else {
                      description.value = "";
                    }
                  },
                  minLines: null,
                  maxLines: null,
                  expands: true,
                  textAlign: TextAlign.left,
                  textAlignVertical: TextAlignVertical.top,
                  decoration: InputDecoration(
                    fillColor: Colors.transparent,
                    labelText: 'Description...',
                    alignLabelWithHint: true,
                    labelStyle: theme.textTheme.bodyLarge,
                    border: OutlineInputBorder(
                      borderRadius: BorderRadius.circular(20),
                      borderSide: const BorderSide(
                        color: Colors.blueAccent,
                      ),
                    ),
                  ),
                ),
              ),
              const SizedBox(
                height: 10,
              ),
              Obx(() {
                if (imagePath.value.isNotEmpty) {
                  return Column(
                    children: [
                      IconButton(
                        onPressed: () {
                          imagePath.value = "";
                        },
                        icon: const Icon(
                          Icons.cancel,
                          color: Colors.deepPurpleAccent,
                          size: 30,
                        ),
                      ),
                      SizedBox(
                        width: 200,
                        height: 120,
                        child: Image.file(
                          File(
                            imagePath.value,
                          ),
                          fit: BoxFit.cover,
                        ),
                      ),
                      const SizedBox(
                        height: 5,
                      )
                    ],
                  );
                } else {
                  return const SizedBox();
                }
              }),
              const SizedBox(
                height: 10,
              ),
              Column(
                children: [
                  const Divider(
                    color: Colors.grey,
                  ),
                  OptionalTileWidget(
                    onTap: () async {
                      final ProfileController profileController = Get.find();
                      image = await profileController.pickImageGallery();
                      if (image != null) {
                        imagePath.value = image!.path;
                      } else {
                        imagePath.value = "";
                      }
                    },
                    title: "Gallery",
                    icon: Icons.image,
                    color: Colors.green,
                  ),
                  const Divider(
                    color: Colors.grey,
                  ),
                  OptionalTileWidget(
                    onTap: () async {
                      final ProfileController profileController = Get.find();
                      image = await profileController.pickImageCamera();
                      if (image != null) {
                        imagePath.value = image!.path;
                      } else {
                        imagePath.value = "";
                      }
                    },
                    title: "Camera",
                    icon: Icons.camera_alt,
                    color: Colors.deepPurple,
                  ),
                  const Divider(
                    color: Colors.grey,
                  ),
                  OptionalTileWidget(
                    onTap: () async {
                      final result =
                          await Get.to(() => const VideoSelectionScreen());
                      if (result != null && result is String) {
                        videoUrl.value = result;
                        isVideoValid.value = true;
                        videoUrlTextEditingController.text = result;
                      }
                    },
                    title: "Video",
                    icon: Icons.video_settings_rounded,
                    color: Colors.red,
                  ),
                ],
              ),
              const SizedBox(
                height: 20,
              ),
              Container(
                height: 50,
                width: double.maxFinite,
                alignment: Alignment.center,
                decoration: BoxDecoration(
                  color: Colors.grey,
                  borderRadius: BorderRadius.circular(10),
                ),
                child: Text(
                  "POST",
                  style: theme.textTheme.bodyLarge!
                      .copyWith(color: Colors.black45),
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }

  // ✅ Kiểm tra URL có hợp lệ không
  bool isValidVideoUrl(String url) {
    final Uri? uri = Uri.tryParse(url);
    if (uri == null ||
        uri.host.isEmpty ||
        (uri.scheme != 'http' && uri.scheme != 'https')) {
      return false;
    }

    final List<String> validExtensions = [
      '.mp4',
      '.mkv',
      '.mov',
      '.avi',
      '.flv',
      '.wmv',
      '.webm'
    ];

    return validExtensions.any((ext) {
      final uriWithoutQuery = uri.path.toLowerCase(); // Loại bỏ query params
      return uriWithoutQuery.endsWith(ext);
    });
  }

  // ✅ Kiểm tra video có thể phát được không

  Future<void> validateVideo(String url, RxBool isVideoValid) async {
    if (!isValidVideoUrl(url)) {
      isVideoValid.value = false;
      return;
    }

    // 1️⃣ Kiểm tra HEAD request trước khi tải video
    try {
      final response =
          await http.head(Uri.parse(url)).timeout(const Duration(seconds: 5));
      if (response.statusCode != 200) {
        isVideoValid.value = false;
        return;
      }
    } catch (e) {
      isVideoValid.value = false;
      return;
    }

    // 2️⃣ Kiểm tra xem video có thể phát không
    VideoPlayerController? controller;
    try {
      controller = VideoPlayerController.networkUrl(Uri.parse(url));
      await controller
          .initialize()
          .timeout(const Duration(seconds: 10)); // Timeout để tránh treo app

      if (controller.value.hasError) {
        isVideoValid.value = false;
      } else {
        isVideoValid.value = true;
      }
    } catch (e) {
      isVideoValid.value = false;
    } finally {
      controller?.dispose(); // Dọn dẹp tránh memory leak
    }
  }
}

```

---


### Pages\Society\Reels\like_animation_widget.dart

```dart
import 'package:flutter/material.dart';

class LikeAnimationWidget extends StatefulWidget {
  final bool isLiked;
  final VoidCallback onAnimationComplete;

  const LikeAnimationWidget({
    super.key,
    required this.isLiked,
    required this.onAnimationComplete,
  });

  @override
  State<LikeAnimationWidget> createState() => _LikeAnimationWidgetState();
}

class _LikeAnimationWidgetState extends State<LikeAnimationWidget>
    with SingleTickerProviderStateMixin {
  late AnimationController _controller;
  late Animation<double> _scaleAnimation;
  late Animation<double> _opacityAnimation;
  late Animation<double> _shakeAnimation;

  @override
  void initState() {
    super.initState();
    _controller = AnimationController(
      vsync: this,
      duration: const Duration(milliseconds: 750), // Thời gian animation
    );

    // Animation phóng to (scale)
    _scaleAnimation = Tween<double>(begin: 0.8, end: 1.8).animate(
      CurvedAnimation(
          parent: _controller,
          curve: const Interval(0.0, 0.5, curve: Curves.elasticOut)),
    );

    // Animation mờ dần (opacity)
    _opacityAnimation = Tween<double>(begin: 1.0, end: 0.0).animate(
      CurvedAnimation(
          parent: _controller,
          curve: const Interval(0.5, 1.0, curve: Curves.easeIn)),
    );

    // Animation rung nhẹ
    _shakeAnimation = TweenSequence<double>([
      TweenSequenceItem(
          tween: Tween<double>(begin: 0.0, end: 0.02), weight: 25),
      TweenSequenceItem(
          tween: Tween<double>(begin: 0.02, end: -0.02), weight: 25),
      TweenSequenceItem(
          tween: Tween<double>(begin: -0.02, end: 0.02), weight: 25),
      TweenSequenceItem(
          tween: Tween<double>(begin: 0.02, end: 0.0), weight: 25),
    ]).animate(
      CurvedAnimation(
          parent: _controller,
          curve: const Interval(0.2, 0.6, curve: Curves.easeInOut)),
    );

    // Bắt đầu animation và gọi callback khi hoàn thành
    _controller.forward().then((_) {
      widget.onAnimationComplete();
    });
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Center(
      child: AnimatedBuilder(
        animation: _controller,
        builder: (context, child) {
          return Opacity(
            opacity: _opacityAnimation.value,
            child: Transform(
              transform: Matrix4.identity()
                ..scale(_scaleAnimation.value)
                ..rotateZ(_shakeAnimation.value), // Hiệu ứng rung
              alignment: Alignment.center,
              child: Icon(
                widget.isLiked ? Icons.favorite : Icons.favorite_border,
                color: widget.isLiked ? Colors.pinkAccent : Colors.white,
                size: 120, // Kích thước lớn hơn để hoành tráng
              ),
            ),
          );
        },
      ),
    );
  }
}

```

---


### Pages\Society\Reels\reel_controller.dart

```dart
import 'dart:async';
import 'dart:convert';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:get/get.dart';
import 'package:image_picker/image_picker.dart';
import 'package:tictactoe_gameapp/Models/Functions/compress_image_function.dart';
import 'package:tictactoe_gameapp/Pages/Society/Reels/reel_model.dart';
import 'package:uuid/uuid.dart';
import '../../../Models/user_model.dart';
import '../../../Configs/messages.dart';

class ReelController extends GetxController {
  final FirebaseFirestore _firestore = FirebaseFirestore.instance;
  late StreamSubscription subscriptionListenReels;
  final ImagePicker picker = ImagePicker();
  DocumentSnapshot? lastDocument;

  var reelsList = <ReelModel>[].obs;
  RxBool isLiked = false.obs;
  RxBool isFetching = false.obs;
  int pageSize = 3;
  RxBool showLikeAnimation = false.obs;

  @override
  void onInit() {
    super.onInit();
    fetchInitialReels();
    listenToReelChanges();
  }

  Future<void> fetchInitialReels() async {
    reelsList.clear();
    if (isFetching.value) return;
    isFetching.value = true;
    try {
      QuerySnapshot snapshot = await _firestore
          .collection('reels')
          .orderBy('createdAt', descending: true)
          .limit(pageSize)
          .get();

      if (snapshot.docs.isNotEmpty) {
        reelsList.value = snapshot.docs.map((doc) {
          return ReelModel.fromJson(doc.data() as Map<String, dynamic>);
        }).toList();
        lastDocument = snapshot.docs.last;
      }
    } catch (e) {
      errorMessage("Error fetching reels: $e");
    } finally {
      isFetching.value = false;
    }
  }

  Future<void> fetchMoreReels() async {
    try {
      Query query = _firestore
          .collection('reels')
          .orderBy('createdAt', descending: true)
          .startAfterDocument(lastDocument!)
          .limit(pageSize);
      QuerySnapshot snapshot = await query.get();
      if (snapshot.docs.isNotEmpty) {
        var newReels = snapshot.docs.map((doc) {
          return ReelModel.fromJson(doc.data() as Map<String, dynamic>);
        }).toList();
        var uniqueNewReels = newReels.where((newReel) =>
            !reelsList.any((reel) => reel.reelId == newReel.reelId));
        reelsList.addAll(uniqueNewReels);
        lastDocument = snapshot.docs.last;
      } else {
        lastDocument = null;
      }
    } catch (e) {
      errorMessage("Error fetching more reels: $e");
    }
  }

  void listenToReelChanges() {
    subscriptionListenReels = _firestore
        .collection('reels')
        .orderBy('createdAt', descending: true)
        .snapshots()
        .listen((snapshot) {
      for (var change in snapshot.docChanges) {
        var newReel =
            ReelModel.fromJson(change.doc.data() as Map<String, dynamic>);
        if (change.type == DocumentChangeType.added) {
          if (!reelsList.any((reel) => reel.reelId == newReel.reelId)) {
            reelsList.insert(0, newReel);
          }
        } else if (change.type == DocumentChangeType.modified) {
          int index =
              reelsList.indexWhere((reel) => reel.reelId == change.doc.id);
          if (index != -1) {
            reelsList[index] = newReel;
          }
        } else if (change.type == DocumentChangeType.removed) {
          reelsList.removeWhere((reel) => reel.reelId == change.doc.id);
        }
      }
    });
  }

  Future<void> createReel({
    required String videoUrl,
    required UserModel user,
    required String description,
    List<String>? taggedUserIds,
    XFile? imagePath,
  }) async {
    var uuid = const Uuid();
    String reelId = uuid.v4();
    String? thumbnailUrl;
    if (imagePath == null) {
      thumbnailUrl =
          await CompressImageFunction.generateThumbnailBase64(videoUrl);
    } else {
      thumbnailUrl = await _getUrlVideo(imagePath);
    }
    ReelModel newReel = ReelModel(
      reelId: reelId,
      reelUser: user,
      videoUrl: videoUrl,
      description: description,
      thumbnailUrl: thumbnailUrl ?? "",
      taggedUserIds: taggedUserIds,
      createdAt: DateTime.now(),
      likedList: [],
      commentCount: 0,
      shareCount: 0,
      isNotified: true,
      privacy: "public",
    );

    try {
      await _firestore
          .collection('reels')
          .doc(reelId)
          .set(newReel.toJson())
          .catchError((e) => errorMessage(e));
      successMessage("Reel created with ID: $reelId");
    } catch (e) {
      errorMessage("Failed to create reel: ${e.toString()}");
    }
  }

  Future<String?> _getUrlVideo(XFile? thumbnailUrl) async {
    if (thumbnailUrl != null) {
      List<int> imageBytes = await thumbnailUrl.readAsBytes();
      String? base64String = base64Encode(imageBytes);

      // Kiểm tra kích thước của chuỗi Base64
      int base64Size = CompressImageFunction.calculateBase64Size(base64String);
      if (base64Size > 999999) {
        errorMessage("Please pick a image which is lighter than 1 mega byte");
        return null;
      }
      return base64String;
    } else {
      return null;
    }
  }

  Future<void> deleteReel(
      {required ReelModel reel, required UserModel user}) async {
    try {
      if (reel.reelUser!.id == user.id) {
        await _firestore
            .collection('reels')
            .doc(reel.reelId)
            .delete()
            .catchError((e) => errorMessage(e));
        successMessage("Reel deleted");
      } else {
        errorMessage("You don't have permission to delete this post.");
      }
    } catch (e) {
      errorMessage("Error deleting reel: $e");
    }
  }

  Future<void> likeReel(String reelId, String userId) async {
    DocumentReference reelRef = _firestore.collection('reels').doc(reelId);
    await reelRef.update({
      'likedList': FieldValue.arrayUnion([userId])
    }).catchError((e) => errorMessage(e));
  }

  Future<void> unlikeReel(String reelId, String userId) async {
    DocumentReference reelRef = _firestore.collection('reels').doc(reelId);
    await reelRef.update({
      'likedList': FieldValue.arrayRemove([userId])
    }).catchError((e) => errorMessage(e));
  }

  RxBool isLikedReel(String userId, String reelId) {
    final reel = reelsList.firstWhereOrNull((reel) => reel.reelId == reelId);
    if (reel == null || reel.likedList == null) {
      return false.obs;
    }
    return reel.likedList!.contains(userId).obs;
  }

  Future<void> incrementSharedCount(
      ReelModel reelModel, UserModel userModel) async {
    DocumentReference postRef =
        _firestore.collection('reels').doc(reelModel.reelId);

    await _firestore.runTransaction((transaction) async {
      DocumentSnapshot postSnapshot = await transaction.get(postRef);
      if (postSnapshot.exists) {
        int currentShareCount = postSnapshot['shareCount'] ?? 0;
        transaction.update(postRef, {'shareCount': currentShareCount + 1});
      }
    });

    // if (postModel.isNotified != null && postModel.isNotified == true) {
    //   await _notificationAddFunctions.createShareNotification(
    //     senderId: userModel.id!,
    //     senderModel: userModel,
    //     receiverId: postModel.postUser!.id!,
    //     postId: postModel.postId!,
    //   );
    // }
  }

  @override
  void onClose() {
    subscriptionListenReels.cancel();
    super.onClose();
  }
}

```

---


### Pages\Society\Reels\reel_model.dart

```dart
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:tictactoe_gameapp/Models/user_model.dart';

class ReelModel {
  String? reelId;
  UserModel? reelUser;
  String? videoUrl; // URL video
  String? thumbnailUrl; // Ảnh thumbnail
  String? description; // Mô tả video
  List<String>? likedList; // Danh sách người đã like
  int? commentCount; // Số lượng comment
  int? shareCount; // Số lần chia sẻ
  DateTime? createdAt; // Ngày đăng
  List<String>? taggedUserIds; // Người được gắn thẻ
  String? privacy; // Quyền riêng tư (public, friends, private)
  bool? isNotified; // Thông báo khi có tương tác

  ReelModel({
    this.reelId,
    this.reelUser,
    this.videoUrl,
    this.thumbnailUrl,
    this.description,
    this.likedList,
    this.commentCount,
    this.shareCount,
    this.createdAt,
    this.taggedUserIds,
    this.privacy,
    this.isNotified,
  });

  // Constructor chuyển từ JSON sang ReelModel
  ReelModel.fromJson(Map<String, dynamic> json) {
    reelId = json['reelId'] as String?;
    if (json["reelUser"] is Map) {
      reelUser = json["reelUser"] == null
          ? null
          : UserModel.fromJson(json["reelUser"]);
    }
    videoUrl = json['videoUrl'] as String?;
    thumbnailUrl = json['thumbnailUrl'] as String?;
    description = json['description'] as String?;
    if (json['likedList'] is List) {
      likedList = List<String>.from(json['likedList']);
    }
    commentCount = json['commentCount'] as int? ?? 0;
    shareCount = json['shareCount'] as int? ?? 0;
    if (json['createdAt'] is Timestamp) {
      createdAt = (json['createdAt'] as Timestamp).toDate();
    }
    if (json['taggedUserIds'] is List) {
      taggedUserIds = List<String>.from(json['taggedUserIds']);
    }
    privacy = json['privacy'] as String?;
    isNotified = json["isNotified"] as bool? ?? false;
  }

  // Chuyển ReelModel thành JSON
  Map<String, dynamic> toJson() {
    final Map<String, dynamic> data = <String, dynamic>{};
    data['reelId'] = reelId;
    if (reelUser != null) {
      data["reelUser"] = reelUser?.toJson();
    }
    data['videoUrl'] = videoUrl;
    data['thumbnailUrl'] = thumbnailUrl;
    data['description'] = description;
    data['likedList'] = likedList;
    data['commentCount'] = commentCount;
    data['shareCount'] = shareCount;
    if (createdAt != null) {
      data['createdAt'] = createdAt?.toUtc();
    }
    data['taggedUserIds'] = taggedUserIds;
    data['privacy'] = privacy;
    data["isNotified"] = isNotified;
    return data;
  }

  // Phương thức cập nhật các trường cần thiết từ JSON mới
  void updateFromJson(Map<String, dynamic> json) {
    if (json.containsKey('likedList') && json['likedList'] is List) {
      likedList = List<String>.from(json['likedList']);
    }
    if (json.containsKey('commentCount')) {
      commentCount = json['commentCount'] as int? ?? commentCount;
    }
    if (json.containsKey('shareCount')) {
      shareCount = json['shareCount'] as int? ?? shareCount;
    }
    // Nếu có các trường khác cần cập nhật, bạn có thể thêm ở đây
  }
}

```

---


### Pages\Society\Reels\reel_page.dart

```dart
import 'dart:async';
import 'package:bottom_sheet/bottom_sheet.dart';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:get/get.dart';
import 'package:tictactoe_gameapp/Components/belong_to_users/avatar_user_widget.dart';
import 'package:tictactoe_gameapp/Configs/assets_path.dart';
import 'package:tictactoe_gameapp/Configs/messages.dart';
import 'package:tictactoe_gameapp/Controller/profile_controller.dart';
import 'package:tictactoe_gameapp/Models/Functions/fetch_firestore_data_functions.dart';
import 'package:tictactoe_gameapp/Models/Functions/general_bottomsheet_show_function.dart';
import 'package:tictactoe_gameapp/Models/Functions/time_functions.dart';
import 'package:tictactoe_gameapp/Models/user_model.dart';
import 'package:tictactoe_gameapp/Pages/Society/Widgets/expandable_text_custom.dart';
import 'package:tictactoe_gameapp/Pages/Society/Widgets/like_user_list_sheet.dart';
import 'package:tictactoe_gameapp/Pages/Society/Widgets/post_edit_model.dart';
import 'package:tictactoe_gameapp/Pages/Society/Widgets/post_edit_sheet.dart';
import 'package:tictactoe_gameapp/Pages/Society/Widgets/share_sheet_custom.dart';
import 'package:tictactoe_gameapp/Pages/Society/Reels/comment/reel_comment_controller.dart';
import 'package:tictactoe_gameapp/Pages/Society/Reels/comment/reel_comment_list_sheet.dart';
import 'package:tictactoe_gameapp/Pages/Society/Reels/create_reel_page.dart';
import 'package:tictactoe_gameapp/Pages/Society/Reels/like_animation_widget.dart';
import 'package:tictactoe_gameapp/Pages/Society/Reels/whitecodel/whitecodel_reels_page.dart';
import 'package:tictactoe_gameapp/Pages/Society/Reels/reel_controller.dart';
import 'package:tictactoe_gameapp/Pages/Society/Reels/reel_model.dart';
import 'package:video_player/video_player.dart';

class ReelPage extends StatelessWidget {
  final bool isBackable;
  const ReelPage({super.key, this.isBackable = false});

  @override
  Widget build(BuildContext context) {
    final ThemeData theme = Theme.of(context);
    final ReelController reelController = Get.put(ReelController());
    final ProfileController profileController = Get.find<ProfileController>();
    final user = profileController.user!;
    return Scaffold(
      body: Obx(() {
        if (reelController.isFetching.value) {
          return Container(
            width: double.infinity,
            height: double.infinity,
            decoration: const BoxDecoration(
              image: DecorationImage(
                image: AssetImage(
                  GifsPath.transitionGif,
                ),
                fit: BoxFit.cover,
              ),
            ),
          );
        } else {
          var reels = reelController.reelsList.toList();
          return Stack(
            children: [
              WhiteCodelReelsPage(
                isCaching: true,
                reelController: reelController,
                reels: reels,
                builder: (context, index, child, videoPlayerController,
                    pageController, videoProgressController) {
                  if (index < 0 || index >= reels.length) {
                    return const Center(
                      child: Text(
                        "Error!",
                        style: TextStyle(color: Colors.white, fontSize: 18),
                      ),
                    );
                  }
                  var reel = reels[index];
                  return Stack(
                    children: [
                      Container(
                        color: Colors.transparent,
                        child: GestureDetector(
                            onDoubleTap: () async {
                              reelController.showLikeAnimation.value = true;
                              reelController
                                      .isLikedReel(user.id!, reel.reelId!)
                                      .value
                                  ? await reelController.unlikeReel(
                                      reel.reelId!, user.id!)
                                  : await reelController.likeReel(
                                      reel.reelId!, user.id!);
                            },
                            onLongPress: () => _showEditSheet(
                                  context,
                                  () async => await reelController.deleteReel(
                                      reel: reel, user: user),
                                  () async => await Clipboard.setData(
                                          ClipboardData(
                                              text:
                                                  reel.videoUrl ?? "https://"))
                                      .then(
                                    (value) =>
                                        successMessage('Copied to Clipboard'),
                                  ),
                                ),
                            child: child),
                      ),
                      Positioned(
                        bottom: 5,
                        left: 0,
                        right: 50,
                        child: Column(
                          mainAxisAlignment: MainAxisAlignment.start,
                          crossAxisAlignment: CrossAxisAlignment.start,
                          children: [
                            _buildVideoInfo(theme, reel),
                            _buildProcessingLine(context,
                                videoProgressController, videoPlayerController),
                          ],
                        ),
                      ),
                      Positioned(
                        bottom: 10,
                        right: 0,
                        child: _buildActionButtons(
                            context, reel, index, reelController, user),
                      ),
                      if (reelController.showLikeAnimation.value)
                        LikeAnimationWidget(
                          isLiked: reelController
                              .isLikedReel(user.id!, reel.reelId!)
                              .value,
                          onAnimationComplete: () {
                            reelController.showLikeAnimation.value = false;
                          },
                        ),
                    ],
                  );
                },
              ),
              isBackable
                  ? Positioned(
                      top: 10,
                      left: 10,
                      child: IconButton(
                        onPressed: () => Get.toNamed("mainHome"),
                        icon: const Icon(Icons.arrow_back_rounded,
                            color: Colors.white, size: 30),
                      ),
                    )
                  : const SizedBox.shrink(),
              Positioned(
                top: 10,
                right: 10,
                child: IconButton(
                  onPressed: () => Get.to(
                    CreateReelPage(user: user),
                    transition: Transition.upToDown,
                  ),
                  icon: const Icon(Icons.camera_enhance_outlined,
                      color: Colors.white, size: 30),
                ),
              ),
            ],
          );
        }
      }),
    );
  }

  Widget _buildVideoInfo(ThemeData theme, ReelModel reel) {
    return Padding(
      padding: const EdgeInsets.only(
        left: 10.0,
        right: 8.0,
        bottom: 5.0,
      ),
      child: Column(
        mainAxisAlignment: MainAxisAlignment.start,
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(
            "#${reel.privacy}",
            style: theme.textTheme.bodyLarge!.copyWith(color: Colors.blueGrey),
          ),
          const SizedBox(
            height: 5,
          ),
          ExpandableContent(
              content: reel.description ?? "",
              maxLines: 2,
              style: theme.textTheme.headlineSmall!.copyWith(
                overflow: TextOverflow.ellipsis,
                color: Colors.white,
                fontSize: 17,
              )),
          const SizedBox(
            height: 5,
          ),
          Text(
            TimeFunctions.timeAgo(
                now: DateTime.now(), createdAt: reel.createdAt!),
            style: const TextStyle(
              color: Colors.grey,
              fontSize: 15,
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildActionButtons(BuildContext context, ReelModel reel, int index,
      ReelController reelController, UserModel user) {
    return Column(
      children: [
        AvatarUserWidget(
          radius: 30,
          imagePath: reel.reelUser!.image!,
          gradientColors:
              reel.reelUser!.avatarFrame ?? ["#FFE0E0E0", "#FFB0BEC5"],
        ),
        GestureDetector(
            onTap: () async {},
            child: const Text("Follow",
                style: TextStyle(
                    color: Colors.white,
                    fontSize: 16,
                    fontWeight: FontWeight.bold))),
        Obx(() {
          bool isLiked =
              reelController.isLikedReel(user.id!, reel.reelId!).value;
          return GestureDetector(
            onLongPress: () async {
              if (reel.likedList != null) {
                final FetchFirestoreDataFunctions fetchFirestoreDataFunctions =
                    FetchFirestoreDataFunctions();
                var likeUsers = await fetchFirestoreDataFunctions
                    .fetchPostLikeUsers(reel.likedList!);
                await showFlexibleBottomSheet(
                  minHeight: 0,
                  initHeight: 0.8,
                  maxHeight: 1,
                  context: context,
                  builder: (context, scrollController, bottomSheet) {
                    return LikeUserListSheet(
                      likeUsers: likeUsers,
                      scrollController: scrollController,
                    );
                  },
                  duration: const Duration(milliseconds: 500),
                  bottomSheetColor: Colors.white,
                  bottomSheetBorderRadius: const BorderRadius.only(
                    topLeft: Radius.circular(20),
                    topRight: Radius.circular(20),
                  ),
                  isSafeArea: true,
                );
              }
            },
            child: Column(
              children: [
                IconButton(
                  onPressed: () async {
                    reelController.showLikeAnimation.value = true;
                    reelController.isLikedReel(user.id!, reel.reelId!).value
                        ? await reelController.unlikeReel(
                            reel.reelId!, user.id!)
                        : await reelController.likeReel(reel.reelId!, user.id!);
                  },
                  icon: Icon(
                    isLiked ? Icons.star_rounded : Icons.star_outline_rounded,
                    color: isLiked ? Colors.pinkAccent : Colors.white,
                    size: 35,
                  ),
                ),
                Text(
                  reel.likedList == null
                      ? "0"
                      : reel.likedList!.length.toString(),
                  style: const TextStyle(
                      color: Colors.white,
                      fontSize: 13,
                      fontWeight: FontWeight.bold),
                ),
              ],
            ),
          );
        }),
        const SizedBox(height: 10),
        _buildActionButton(Icons.comment, Icons.messenger_outline, false,
            () async {
          Get.delete<ReelCommentController>();
          await showFlexibleBottomSheet(
            minHeight: 0,
            initHeight: 0.9,
            maxHeight: 1,
            context: context,
            builder: (context, scrollController, bottomSheet) {
              return ReelCommentListSheet(
                scrollController: scrollController,
                currentUser: user,
                reel: reel,
              );
            },
            duration: const Duration(milliseconds: 500),
            bottomSheetColor: Colors.white,
            bottomSheetBorderRadius: const BorderRadius.only(
              topLeft: Radius.circular(20),
              topRight: Radius.circular(20),
            ),
            isSafeArea: true,
          );
        }, reel.commentCount.toString()),
        const SizedBox(height: 10),
        _buildActionButton(Icons.share, Icons.share_outlined, false, () async {
          await GeneralBottomsheetShowFunction.showScrollableGeneralBottomsheet(
            widgetBuilder: (context, controller) => ShareSheetCustom(
              scrollController: controller,
              currentUser: user,
              onPressed: () async {
                await reelController.incrementSharedCount(reel, user).then((_) {
                  Get.back();
                  successMessage("Reel shared successfully!");
                });
              },
            ),
            context: context,
            initHeight: 0.8,
            color: Colors.transparent,
          );
        }, "Share"),
        const SizedBox(height: 10),
        _buildActionButton(
            Icons.more_horiz,
            Icons.more_horiz_outlined,
            false,
            () => _showEditSheet(
                  context,
                  () async =>
                      await reelController.deleteReel(reel: reel, user: user),
                  () async => await Clipboard.setData(ClipboardData(
                          text: reel.videoUrl ?? "https://www.youtube.com/"))
                      .then(
                    (value) => successMessage('Copied to Clipboard'),
                  ),
                ),
            "More"),
      ],
    );
  }

  Widget _buildActionButton(
    IconData iconActive,
    IconData iconInactive,
    bool isActive,
    VoidCallback onPressed,
    String label,
  ) {
    return Column(
      children: [
        IconButton(
          onPressed: onPressed,
          icon: Icon(
            isActive ? iconActive : iconInactive,
            color: Colors.white,
            size: 25,
          ),
        ),
        Text(
          label,
          style: const TextStyle(
              color: Colors.white, fontSize: 13, fontWeight: FontWeight.bold),
        ),
      ],
    );
  }

  Widget _buildProcessingLine(
    BuildContext context,
    StreamController<double> videoProgressController,
    VideoPlayerController videoPlayerController,
  ) {
    return StreamBuilder(
      stream: videoProgressController.stream,
      builder: (context, snapshot) {
        return SliderTheme(
          data: SliderTheme.of(context).copyWith(
            thumbShape: SliderComponentShape.noThumb,
            overlayShape: SliderComponentShape.noOverlay,
            trackHeight: 2,
          ),
          child: Container(
            width: double.infinity,
            padding: const EdgeInsets.symmetric(horizontal: 10),
            child: SliderTheme(
              data: SliderTheme.of(context).copyWith(
                thumbShape: SliderComponentShape.noThumb,
                overlayShape: SliderComponentShape.noOverlay,
                trackHeight: 2,
              ),
              child: Slider(
                value: (snapshot.data ?? 0).clamp(0.0, 1.0),
                min: 0.0,
                max: 1.0,
                activeColor: Colors.pinkAccent,
                inactiveColor: Colors.white,

                onChanged: (value) {
                  final position =
                      videoPlayerController.value.duration.inMilliseconds *
                          value;
                  videoPlayerController
                      .seekTo(Duration(milliseconds: position.toInt()));
                },
                // onChangeEnd: (value) {
                //   videoPlayerController.play();
                // },
              ),
            ),
          ),
        );
      },
    );
  }

  void _showEditSheet(
      BuildContext context, VoidCallback onTapDelete, VoidCallback onTapSave) {
    showFlexibleBottomSheet(
      minHeight: 0,
      initHeight: 0.5,
      maxHeight: 1,
      context: context,
      builder: (context, scrollController, bottomSheetOffset) {
        return PostEditSheet(
          scrollController: scrollController,
          onDeletePost: onTapDelete,
          onSavePost: onTapSave,
          postType: PostType.reel,
        );
      },
      duration: const Duration(milliseconds: 500),
      bottomSheetColor: Theme.of(context).colorScheme.primary.withOpacity(0.4),
      bottomSheetBorderRadius: const BorderRadius.only(
        topLeft: Radius.circular(20),
        topRight: Radius.circular(20),
      ),
      decoration: const BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.only(
          topLeft: Radius.circular(20),
          topRight: Radius.circular(20),
        ),
      ),
      anchors: [0, 1],
      isSafeArea: true,
    );
  }
}

```

---


### Pages\Society\Reels\api\fetch_url_api_controller.dart

```dart
import 'dart:convert';
import 'dart:math';
import 'dart:async';
import 'package:get/get.dart';
import 'package:get_storage/get_storage.dart';
import 'package:http/http.dart' as http;
import 'package:tictactoe_gameapp/Configs/constants.dart';
import 'package:tictactoe_gameapp/Pages/Society/Reels/api/video_api_model.dart';

/// Ngưỡng làm mới dữ liệu mỗi ngày
const Duration randomizationThreshold = Duration(days: 1);
const String lastRandomizationKey = 'last_randomization_time';

class FetchUrlApiController extends GetxController {
  var videoList = <VideoApiModel>[].obs;
  var isLoading = false.obs;
  int page = 1; // Sử dụng cho chế độ pagination khi không refresh toàn bộ
  var searchQuery = ''.obs;

  final GetStorage storage = GetStorage();
  final Random random = Random();

  @override
  void onInit() {
    super.onInit();
    _checkAndRefreshData();
  }

  /// Kiểm tra xem đã đủ thời gian làm mới (1 ngày) chưa.
  bool get _shouldRandomize {
    int? lastRandomMillis = storage.read(lastRandomizationKey);
    if (lastRandomMillis == null) return true;
    final lastRandom = DateTime.fromMillisecondsSinceEpoch(lastRandomMillis);
    return DateTime.now().difference(lastRandom) >= randomizationThreshold;
  }

  /// Làm mới dữ liệu khi đủ thời gian
  Future<void> refreshData() async {
    if (_shouldRandomize) {
      clearData();
      await fetchVideos();
      await storage.write(
          lastRandomizationKey, DateTime.now().millisecondsSinceEpoch);
    } else {
      print("Dữ liệu vẫn mới, không cần refresh.");
    }
  }

  /// Kiểm tra khi khởi tạo: nếu chưa có dữ liệu hoặc đã đủ thời gian refresh, fetch mới.
  Future<void> _checkAndRefreshData() async {
    if (_shouldRandomize) {
      clearData();
      await fetchVideos();
      storage.write(
          lastRandomizationKey, DateTime.now().millisecondsSinceEpoch);
    } else if (videoList.isEmpty) {
      await fetchVideos();
    }
  }

  /// Xóa dữ liệu cũ và reset biến page
  void clearData() {
    videoList.clear();
    page = 1;
  }

  /// Fetch dữ liệu từ Pexels và Pixabay cùng lúc.
  /// Mỗi lần fetch, gọi 5 trang (pagesToFetch = 5).
  Future<void> fetchVideos() async {
    if (isLoading.value) return;
    isLoading.value = true;
    try {
      const int pagesToFetch = 5; // Số trang fetch mỗi lần gọi
      List<Future<List<VideoApiModel>>> pexelsFutures = List.generate(
          pagesToFetch,
          (i) => _shouldRandomize
              ? fetchPexelsVideos(_randomPage())
              : fetchPexelsVideos(page + i));
      List<Future<List<VideoApiModel>>> pixabayFutures = List.generate(
          pagesToFetch,
          (i) => _shouldRandomize
              ? fetchPixabayVideos(_randomPage())
              : fetchPixabayVideos(page + i));

      var results = await Future.wait([...pexelsFutures, ...pixabayFutures]);
      var newVideos = results.expand((list) => list).toList();
      newVideos.shuffle(random); // Trộn danh sách để đảm bảo ngẫu nhiên
      videoList.addAll(newVideos);
      // Nếu không làm mới toàn bộ, tăng page; nếu làm mới, ta không cần dựa vào page
      if (!_shouldRandomize) {
        page += pagesToFetch;
      }
    } catch (e) {
      print("Error fetching videos: $e");
    } finally {
      isLoading.value = false;
    }
  }

  /// Hàm sinh số trang ngẫu nhiên dựa trên giới hạn của API (ví dụ: 1 đến 50)
  int _randomPage() {
    return random.nextInt(50) + 1;
  }

  /// Fetch video từ Pexels theo trang
  Future<List<VideoApiModel>> fetchPexelsVideos(int page) async {
    final url = Uri.parse("https://api.pexels.com/videos/popular?page=$page");
    final response =
        await http.get(url, headers: {'Authorization': pexelsApiKey});
    if (response.statusCode == 200) {
      final data = json.decode(response.body);
      return List<VideoApiModel>.from(
        (data['videos'] as List).map((video) => VideoApiModel(
              title: video['user']['name'] ?? 'Pexels Video',
              description: video['url'] ?? '',
              thumbnail: video['image'] ?? '',
              url: video['video_files'][0]['link'] ?? '',
            )),
      );
    }
    return [];
  }

  /// Fetch video từ Pixabay theo trang
  Future<List<VideoApiModel>> fetchPixabayVideos(int page) async {
    final url = Uri.parse(
        "https://pixabay.com/api/videos/?key=$pixabayApiKey&page=$page");
    final response = await http.get(url);
    if (response.statusCode == 200) {
      final data = json.decode(response.body);
      return List<VideoApiModel>.from(
        (data['hits'] as List).map((video) => VideoApiModel(
              title: video['tags'] ?? 'Pixabay Video',
              description: "Pixabay Video",
              thumbnail: video['picture_id'] != null
                  ? "https://i.vimeocdn.com/video/${video['picture_id']}_295x166.jpg"
                  : videoPlaceholder,
              url: video['videos']['medium']['url'] ?? '',
            )),
      );
    }
    return [];
  }

  /// Cập nhật query tìm kiếm
  void updateSearchQuery(String query) {
    searchQuery.value = query;
  }

  /// Lọc danh sách video theo query nhập từ người dùng
  List<VideoApiModel> get filteredVideoList {
    if (searchQuery.value.trim().isEmpty) return videoList;
    return videoList.where((video) {
      return _matchOrdered(video.title, searchQuery.value) ||
          _matchOrdered(video.description, searchQuery.value);
    }).toList();
  }

  /// Hàm so khớp từ khóa theo thứ tự (ordered matching)
  bool _matchOrdered(String text, String query) {
    final words = query
        .toLowerCase()
        .split(' ')
        .where((word) => word.trim().isNotEmpty)
        .toList();
    int lastIndex = 0;
    for (final word in words) {
      final index = text.toLowerCase().indexOf(word, lastIndex);
      if (index == -1) return false;
      lastIndex = index + word.length;
    }
    return true;
  }
}

```

---


### Pages\Society\Reels\api\fetch_url_link_api_page.dart

```dart
import 'package:get/get.dart';
import 'package:flutter/material.dart';
import 'package:tictactoe_gameapp/Configs/constants.dart';
import 'package:tictactoe_gameapp/Configs/assets_path.dart';
import 'package:tictactoe_gameapp/Pages/Society/Reels/api/fetch_url_api_controller.dart';
import 'package:tictactoe_gameapp/Pages/Society/Reels/api/video_player_preview_page.dart';
import 'package:tictactoe_gameapp/Components/shimmers/urls_placeholder_widget.dart';

class VideoSelectionScreen extends StatelessWidget {
  const VideoSelectionScreen({super.key});

  @override
  Widget build(BuildContext context) {
    final FetchUrlApiController controller = Get.put(FetchUrlApiController());
    final ThemeData theme = Theme.of(context);
    return Scaffold(
      appBar: AppBar(
        title: Text("Pick a Video", style: theme.textTheme.headlineMedium),
      ),
      body: Column(
        children: [
          // Search TextField
          Padding(
            padding: const EdgeInsets.all(8.0),
            child: SizedBox(
              height: 50,
              child: TextField(
                decoration: InputDecoration(
                  hintText: "Search video by title or description",
                  border: OutlineInputBorder(
                    borderRadius: BorderRadius.circular(20),
                  ),
                  prefixIcon: const Icon(Icons.search),
                ),
                onChanged: (query) {
                  controller.updateSearchQuery(query);
                },
              ),
            ),
          ),
          // ListView hiển thị video kèm bottom loading indicator
          Expanded(
            child: Obx(() {
              if (controller.isLoading.value) {
                return const UrlsPlaceholderWidget();
              } else {
                if (controller.videoList.isEmpty) {
                  return Column(
                    mainAxisAlignment: MainAxisAlignment.center,
                    children: [
                      Text(
                        "Video is unavailable? Retry",
                        style: theme.textTheme.headlineSmall,
                      ),
                      IconButton(
                        onPressed: () => controller.fetchVideos(),
                        icon: const Icon(Icons.replay_circle_filled),
                        iconSize: 35,
                        color: Colors.blueAccent,
                      )
                    ],
                  );
                } else {
                  var videos = controller.filteredVideoList;
                  return NotificationListener<ScrollNotification>(
                    onNotification: (ScrollNotification scrollInfo) {
                      double remaining = scrollInfo.metrics.maxScrollExtent -
                          scrollInfo.metrics.pixels;
                      if (!controller.isLoading.value && remaining < 200) {
                        controller.fetchVideos();
                      }
                      return true;
                    },
                    child: RefreshIndicator(
                      onRefresh: () async {
                        await controller.refreshData();
                      },
                      backgroundColor: Colors.blue,
                      color: Colors.white,
                      child: ListView.builder(
                        itemCount: videos.length +
                            (controller.isLoading.value ? 1 : 0),
                        itemBuilder: (context, index) {
                          // Nếu index là cuối cùng, hiển thị bottom loading indicator
                          if (index == videos.length) {
                            return const Padding(
                              padding: EdgeInsets.all(16.0),
                              child: Center(
                                  child: CircularProgressIndicator(
                                backgroundColor: Colors.blue,
                                color: Colors.white,
                              )),
                            );
                          }
                          final video = videos[index];
                          return ListTile(
                            leading: ClipRRect(
                              borderRadius: BorderRadius.circular(10),
                              child: Image.network(
                                video.thumbnail.isNotEmpty
                                    ? video.thumbnail
                                    : videoPlaceholder,
                                width: 100,
                                height: 80,
                                fit: BoxFit.cover,
                                errorBuilder: (context, error, stackTrace) {
                                  return Image.asset(GifsPath.loadingGif,
                                      width: 100,
                                      height: 80,
                                      fit: BoxFit.cover);
                                },
                              ),
                            ),
                            title: Text(
                              video.title,
                              style: theme.textTheme.bodyLarge,
                              maxLines: 2,
                              overflow: TextOverflow.ellipsis,
                            ),
                            subtitle: Text(
                              video.description,
                              maxLines: 3,
                              overflow: TextOverflow.ellipsis,
                              style: theme.textTheme.bodySmall,
                            ),
                            onTap: () async {
                              final result = await Get.to(() =>
                                  VideoPlayerPreviewPage(videoUrl: video.url));
                              if (result != null && result is String) {
                                Get.back(result: result);
                              }
                            },
                          );
                        },
                      ),
                    ),
                  );
                }
              }
            }),
          ),
        ],
      ),
    );
  }
}

```

---


### Pages\Society\Reels\api\video_api_model.dart

```dart
class VideoApiModel {
  final String title;
  final String description;
  final String thumbnail;
  final String url;

  VideoApiModel(
      {required this.title,
      required this.description,
      required this.thumbnail,
      required this.url});
}

```

---


### Pages\Society\Reels\api\video_player_preview_page.dart

```dart
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:tictactoe_gameapp/Configs/messages.dart';
import 'package:video_player/video_player.dart';

class VideoPlayerPreviewController extends GetxController {
  late VideoPlayerController _controller;
  var isInitialized = false.obs;
  var isError = false.obs;
  var isPlaying = false.obs;

  void initializeVideo(String videoUrl) {
    if (videoUrl.isEmpty || !Uri.parse(videoUrl).isAbsolute) {
      isError.value = true;
      return;
    }

    try {
      _controller = VideoPlayerController.networkUrl(Uri.parse(videoUrl))
        ..initialize().then((_) {
          isInitialized.value = true;
          update();
        }).catchError((error) {
          isError.value = true;
          print("Error initializing video: $error");
        });
    } catch (e) {
      isError.value = true;
      errorMessage("Exception caught: $e");
    }
  }

  VideoPlayerController get controller => _controller;

  void togglePlayPause() {
    if (_controller.value.isPlaying) {
      _controller.pause();
      isPlaying.value = false;
    } else {
      _controller.play();
      isPlaying.value = true;
    }
  }

  @override
  void onClose() {
    _controller.dispose();
    super.onClose();
  }
}

class VideoPlayerPreviewPage extends StatelessWidget {
  final String videoUrl;
  VideoPlayerPreviewPage({super.key, required this.videoUrl});

  final VideoPlayerPreviewController videoController =
      Get.put(VideoPlayerPreviewController());

  @override
  Widget build(BuildContext context) {
    videoController.initializeVideo(videoUrl);

    return Scaffold(
      appBar: AppBar(
        leading: IconButton(
            onPressed: () {
              Get.back();
            },
            icon: const Icon(
              Icons.arrow_back_rounded,
              size: 30,
            )),
        title: const Text(
          "Preview Video",
          style: TextStyle(fontSize: 18),
        ),
        actions: [
          IconButton(
              onPressed: () {
                Get.back(result: videoUrl);
              },
              icon: const Icon(
                Icons.done_outline_rounded,
                size: 30,
              ))
        ],
      ),
      body: Center(
        child: Obx(() {
          if (videoController.isError.value) {
            return const Text(
              "Error loading video. Please try another video.",
              style: TextStyle(color: Colors.red, fontSize: 16),
            );
          }
          if (!videoController.isInitialized.value) {
            return const CircularProgressIndicator();
          }
          return ClipRRect(
            borderRadius: BorderRadius.circular(10),
            child: AspectRatio(
              aspectRatio: videoController.controller.value.aspectRatio,
              child: VideoPlayer(videoController.controller),
            ),
          );
        }),
      ),
      floatingActionButton: Obx(() {
        if (videoController.isError.value ||
            !videoController.isInitialized.value) {
          return const SizedBox.shrink(); // Ẩn nút nếu có lỗi
        }
        return FloatingActionButton(
          onPressed: videoController.togglePlayPause,
          child: Icon(
              videoController.isPlaying.value ? Icons.pause : Icons.play_arrow),
        );
      }),
    );
  }
}

```

---


### Pages\Society\Reels\api\video_thumbnail.dart

```dart
import 'dart:async';
import 'package:flutter/services.dart';

/// Enum định nghĩa các định dạng ảnh thumbnail hỗ trợ
enum ImageFormat { JPEG, PNG, WEBP }

/// Lớp xử lý tạo thumbnail từ video, thay thế package video_thumbnail
class VideoThumbnail {
  // Định nghĩa MethodChannel với một tên duy nhất cho dự án của bạn
  static const MethodChannel _channel =
      MethodChannel('com.example.tictactoe_gameapp/video_thumbnail');

  /// Tạo thumbnail dưới dạng tệp và lưu vào đường dẫn được chỉ định
  static Future<String?> thumbnailFile({
    required String video, // Đường dẫn video cục bộ hoặc URL
    Map<String, String>? headers, // Headers cho yêu cầu HTTP (nếu là URL)
    String? thumbnailPath, // Đường dẫn lưu thumbnail (nếu null, dùng mặc định)
    ImageFormat imageFormat = ImageFormat.JPEG, // Định dạng mặc định là JPEG để tối ưu dung lượng
    int maxHeight = 0, // 0 để giữ nguyên chiều cao gốc
    int maxWidth = 0,  // 0 để giữ nguyên chiều rộng gốc
    int timeMs = 0,    // Frame tại thời gian (ms), mặc định là frame đầu tiên
    int quality = 75,  // Chất lượng mặc định cao hơn (75) cho hình ảnh nét
  }) async {
    try {
      // Kiểm tra video không rỗng
      if (video.isEmpty) throw Exception('Video path or URL cannot be empty');

      final reqMap = <String, dynamic>{
        'video': video,
        'headers': headers,
        'path': thumbnailPath,
        'format': imageFormat.index,
        'maxh': maxHeight,
        'maxw': maxWidth,
        'timeMs': timeMs,
        'quality': quality.clamp(0, 100), // Giới hạn quality từ 0-100
      };

      final result = await _channel.invokeMethod<String>('file', reqMap);
      if (result == null) throw Exception('Failed to generate thumbnail file');
      return result;
    } catch (e) {
      print('Error generating thumbnail file: $e');
      return null;
    }
  }

  /// Tạo thumbnail dưới dạng dữ liệu Uint8List để dùng trực tiếp trong bộ nhớ
  static Future<Uint8List?> thumbnailData({
    required String video,
    Map<String, String>? headers,
    ImageFormat imageFormat = ImageFormat.JPEG,
    int maxHeight = 0,
    int maxWidth = 0,
    int timeMs = 0,
    int quality = 75,
  }) async {
    try {
      if (video.isEmpty) throw Exception('Video path or URL cannot be empty');

      final reqMap = <String, dynamic>{
        'video': video,
        'headers': headers,
        'format': imageFormat.index,
        'maxh': maxHeight,
        'maxw': maxWidth,
        'timeMs': timeMs,
        'quality': quality.clamp(0, 100),
      };

      final result = await _channel.invokeMethod<Uint8List>('data', reqMap);
      if (result == null) throw Exception('Failed to generate thumbnail data');
      return result;
    } catch (e) {
      print('Error generating thumbnail data: $e');
      return null;
    }
  }

  /// Tối ưu hóa: Tạo thumbnail với kích thước chuẩn cho reels (360x640)
  static Future<Uint8List?> generateReelThumbnail({
    required String videoUrl,
    Map<String, String>? headers,
    int timeMs = 0,
    int quality = 75,
  }) async {
    return await thumbnailData(
      video: videoUrl,
      headers: headers,
      imageFormat: ImageFormat.JPEG,
      maxHeight: 640, // Tỷ lệ 9:16 phổ biến cho reels
      maxWidth: 360,
      timeMs: timeMs,
      quality: quality,
    );
  }
}
```

---


### Pages\Society\Reels\comment\reel_comment_controller.dart

```dart
import 'dart:async';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:get/get.dart';
import 'package:tictactoe_gameapp/Configs/messages.dart';
import 'package:tictactoe_gameapp/Models/Functions/notification_add_functions.dart';
import 'package:tictactoe_gameapp/Models/user_model.dart';
import 'package:tictactoe_gameapp/Pages/Society/Comment/comment_post_model.dart';
import 'package:uuid/uuid.dart';

class ReelCommentController extends GetxController {
  final FirebaseFirestore _firestore = FirebaseFirestore.instance;

  late StreamSubscription subscriptionListenComment;
  late final NotificationAddFunctions _notificationAddFunctions;
  DocumentSnapshot? lastDocument;

  final List<String> options = ["Favoritest", "Newest", "Oldest"];
  var selectedOption = 'Newest'.obs;
  var commentsList = <CommentModel>[].obs;
  var isLoading = false.obs;
  int pageSize = 2;

  final String reelId; // ID của reel mà controller này quản lý comments
  ReelCommentController(this.reelId);

  @override
  void onInit() {
    super.onInit();
    _notificationAddFunctions = NotificationAddFunctions(firestore: _firestore);
    fetchInitialComments();
    listenToCommentChanges();
    ever(selectedOption, (_) => fetchFilteredComments());
  }

  Future<void> fetchInitialComments() async {
    if (isLoading.value) return;
    isLoading.value = true;

    try {
      QuerySnapshot snapshot = await _firestore
          .collection('reels')
          .doc(reelId)
          .collection('comments')
          .orderBy('createdAt', descending: true)
          .limit(pageSize)
          .get();

      if (snapshot.docs.isNotEmpty) {
        commentsList.value = snapshot.docs.map((doc) {
          return CommentModel.fromJson(doc.data() as Map<String, dynamic>);
        }).toList();
        lastDocument = snapshot.docs.last;
      }
    } catch (e) {
      errorMessage("Error fetching comments: $e");
    } finally {
      isLoading.value = false;
    }
  }

  Future<void> fetchFilteredComments() async {
    if (isLoading.value) return;
    isLoading.value = true;

    try {
      Query query = _firestore
          .collection('reels')
          .doc(reelId)
          .collection('comments')
          .limit(pageSize);

      switch (selectedOption.value) {
        case 'Favoritest':
          query = query.orderBy('likedList', descending: true);
          break;
        case 'Newest':
          query = query.orderBy('createdAt', descending: true);
          break;
        case 'Oldest':
          query = query.orderBy('createdAt', descending: false);
          break;
      }

      QuerySnapshot snapshot = await query.get();
      if (snapshot.docs.isNotEmpty) {
        commentsList.value = snapshot.docs.map((doc) {
          return CommentModel.fromJson(doc.data() as Map<String, dynamic>);
        }).toList();
        lastDocument = snapshot.docs.last;
      }
    } catch (e) {
      errorMessage("Error fetching comments: $e");
    } finally {
      isLoading.value = false;
    }
  }

  Future<void> fetchMoreFilteredComments() async {
    if (isLoading.value || lastDocument == null) return;
    isLoading.value = true;

    try {
      Query query =
          _firestore.collection('reels').doc(reelId).collection('comments');

      switch (selectedOption.value) {
        case 'Favoritest':
          query = query.orderBy('likedList', descending: true);
          break;
        case 'Newest':
          query = query.orderBy('createdAt', descending: true);
          break;
        case 'Oldest':
          query = query.orderBy('createdAt', descending: false);
          break;
      }

      query = query.startAfterDocument(lastDocument!).limit(pageSize);

      QuerySnapshot snapshot = await query.get();
      if (snapshot.docs.isNotEmpty) {
        var newComments = snapshot.docs.map((doc) {
          return CommentModel.fromJson(doc.data() as Map<String, dynamic>);
        }).toList();
        commentsList.addAll(newComments);
        lastDocument = snapshot.docs.last;
      } else {
        lastDocument = null;
      }
    } catch (e) {
      errorMessage("Error fetching more comments: $e");
    } finally {
      isLoading.value = false;
    }
  }

  void listenToCommentChanges() {
    subscriptionListenComment = _firestore
        .collection('reels')
        .doc(reelId)
        .collection('comments')
        .orderBy('createdAt', descending: true)
        .snapshots()
        .listen((snapshot) {
      for (var change in snapshot.docChanges) {
        if (change.type == DocumentChangeType.added) {
          commentsList.insert(0,
              CommentModel.fromJson(change.doc.data() as Map<String, dynamic>));
        } else if (change.type == DocumentChangeType.modified) {
          int index =
              commentsList.indexWhere((comment) => comment.id == change.doc.id);
          if (index != -1) {
            commentsList[index] = CommentModel.fromJson(
                change.doc.data() as Map<String, dynamic>);
          }
        } else if (change.type == DocumentChangeType.removed) {
          commentsList.removeWhere((comment) => comment.id == change.doc.id);
        }
      }
    });
  }

  Future<void> addComment({
    required String content,
    List<String>? taggedUserIds,
    String? gifUrl,
    required String receiverId,
    required UserModel currentUser,
  }) async {
    try {
      var uuid = const Uuid();
      String commentId = uuid.v4();
      CommentModel newComment = CommentModel(
        id: commentId,
        postId: reelId, // Sử dụng postId để lưu reelId
        content: content,
        gif: gifUrl,
        commentUser: currentUser,
        createdAt: DateTime.now(),
        taggedUserIds: taggedUserIds,
      );
      DocumentReference commentRef = _firestore
          .collection('reels')
          .doc(reelId)
          .collection('comments')
          .doc(commentId);

      await commentRef.set(newComment.toJson()).catchError((e) => errorMessage(e));

      await _firestore.collection('reels').doc(reelId).update({
        'commentCount': FieldValue.increment(1),
      }).catchError((e) => errorMessage(e));

      await _notificationAddFunctions.createReelCommentNotification(
        senderId: currentUser.id!,
        senderModel: currentUser,
        receiverId: receiverId,
        reelId: reelId,
        commentId: commentId,
        comment: content,
      );
    } catch (e) {
      errorMessage("Error adding comment: $e");
    }
  }

  Future<void> updateComment(String commentId, String newContent) async {
    try {
      await _firestore
          .collection('reels')
          .doc(reelId)
          .collection('comments')
          .doc(commentId)
          .update({
        'content': newContent,
        'createdAt': FieldValue.serverTimestamp(),
      }).catchError((e) => errorMessage(e));
    } catch (e) {
      errorMessage("Error updating comment: $e");
    }
  }

  Future<void> likeComment(String commentId, String userId) async {
    DocumentReference commentRef = _firestore
        .collection('reels')
        .doc(reelId)
        .collection("comments")
        .doc(commentId);

    await commentRef.update({
      'likedList': FieldValue.arrayUnion([userId])
    }).catchError((e) => errorMessage(e));
  }

  Future<void> unlikeComment(String commentId, String userId) async {
    DocumentReference commentRef = _firestore
        .collection('reels')
        .doc(reelId)
        .collection("comments")
        .doc(commentId);

    await commentRef.update({
      'likedList': FieldValue.arrayRemove([userId])
    }).catchError((e) => errorMessage(e));
  }

  RxBool isLikedComment(String userId, String commentId) {
    final comment =
        commentsList.firstWhereOrNull((comment) => comment.id == commentId);
    if (comment == null || comment.likedList == null) {
      return false.obs;
    }
    final isLiked = comment.likedList!.contains(userId);
    return isLiked.obs;
  }

  Future<void> deleteComment(String commentId) async {
    try {
      await _firestore
          .collection('reels')
          .doc(reelId)
          .collection('comments')
          .doc(commentId)
          .delete()
          .catchError((e) => errorMessage(e));

      await _firestore.collection('reels').doc(reelId).update({
        'commentCount': FieldValue.increment(-1),
      }).catchError((e) => errorMessage(e));
    } catch (e) {
      errorMessage("Error deleting comment: $e");
    }
  }

  void updateSelectedOption(String value) {
    selectedOption.value = value;
  }

  @override
  void onClose() {
    subscriptionListenComment.cancel();
    super.onClose();
  }
}
```

---


### Pages\Society\Reels\comment\reel_comment_list_sheet.dart

```dart
import 'package:bottom_sheet/bottom_sheet.dart';
import 'package:flutter/material.dart';
import 'package:flutter_animate/flutter_animate.dart';
import 'package:get/get.dart';
import 'package:giphy_picker/giphy_picker.dart';
import 'package:tictactoe_gameapp/Components/belong_to_users/avatar_user_widget.dart';
import 'package:tictactoe_gameapp/Components/gifphy/display_gif_widget.dart';
import 'package:tictactoe_gameapp/Components/gifphy/preview_gif_widget.dart';
import 'package:tictactoe_gameapp/Configs/assets_path.dart';
import 'package:tictactoe_gameapp/Configs/constants.dart';
import 'package:tictactoe_gameapp/Models/user_model.dart';
import 'package:tictactoe_gameapp/Models/Functions/time_functions.dart';
import 'package:tictactoe_gameapp/Pages/Society/Comment/post_reply_comment_controller.dart';
import 'package:tictactoe_gameapp/Pages/Society/Widgets/expandable_text_custom.dart';
import 'package:tictactoe_gameapp/Components/emotes_picker_widget.dart';
import 'package:tictactoe_gameapp/Pages/Society/Reels/comment/reel_comment_controller.dart';
import 'package:tictactoe_gameapp/Pages/Society/Reels/comment/reel_reply_comment_controller.dart';
import 'package:tictactoe_gameapp/Pages/Society/Reels/comment/reel_reply_comment_list_sheet.dart';
import 'package:tictactoe_gameapp/Pages/Society/Reels/reel_model.dart';

class ReelCommentListSheet extends StatelessWidget {
  final ScrollController scrollController;
  final UserModel currentUser;
  final ReelModel reel; // Giả sử bạn đã có ReelModel

  const ReelCommentListSheet({
    super.key,
    required this.scrollController,
    required this.currentUser,
    required this.reel,
  });

  @override
  Widget build(BuildContext context) {
    final ReelCommentController commentController = Get.put(
        ReelCommentController(reel.reelId!)); // Giả sử reelId là trường ID
    final TextEditingController textController = TextEditingController();
    final FocusNode focusNode = FocusNode();
    RxString commentContent = "".obs;
    RxString commentId = "".obs;
    RxBool isEmojiPickerVisible = false.obs;
    var selectedGif = Rx<GiphyGif?>(null);

    return Column(
      children: [
        Row(
          mainAxisAlignment: MainAxisAlignment.spaceBetween,
          children: [
            IconButton(
              onPressed: () => Get.back(),
              icon: const Icon(Icons.arrow_back_ios_new_rounded, size: 30),
            ),
            Expanded(
              child: Column(
                children: [
                  Container(
                    height: 5,
                    width: 50,
                    margin: const EdgeInsets.only(top: 10),
                    decoration: const BoxDecoration(
                      color: Colors.blueGrey,
                      borderRadius: BorderRadius.all(Radius.circular(20)),
                    ),
                  ),
                  const Text("Comments", style: TextStyle(fontSize: 20)),
                  Obx(() => DropdownButton<String>(
                        value: commentController.selectedOption.value,
                        icon: const Icon(Icons.radio_button_checked_rounded),
                        iconSize: 24,
                        iconEnabledColor: Colors.blue,
                        elevation: 16,
                        borderRadius:
                            const BorderRadius.all(Radius.circular(10)),
                        style:
                            const TextStyle(color: Colors.black, fontSize: 16),
                        underline: const SizedBox(),
                        onChanged: (String? newValue) {
                          if (newValue != null) {
                            commentController.updateSelectedOption(newValue);
                          }
                        },
                        items: commentController.options
                            .map<DropdownMenuItem<String>>((String value) {
                          return DropdownMenuItem<String>(
                            value: value,
                            child: Text(value),
                          );
                        }).toList(),
                      )),
                ],
              ),
            ),
            IconButton(
              onPressed: () => commentController.fetchInitialComments(),
              icon: const Icon(Icons.refresh_outlined,
                  size: 35, color: Colors.blue),
            ),
          ],
        ),
        Expanded(
          child: Obx(() {
            if (commentController.commentsList.isEmpty) {
              return const Center(
                child: Column(
                  mainAxisAlignment: MainAxisAlignment.center,
                  children: [
                    Text("No comments yet", style: TextStyle(fontSize: 25)),
                    Text("Start the conversation...",
                        style: TextStyle(fontSize: 15, color: Colors.grey)),
                  ],
                ),
              );
            } else {
              var comments = commentController.commentsList.toList();
              return NotificationListener<ScrollNotification>(
                onNotification: (ScrollNotification scrollInfo) {
                  if (scrollInfo.metrics.pixels >=
                      scrollInfo.metrics.maxScrollExtent - 200) {
                    commentController.fetchMoreFilteredComments();
                  }
                  return true;
                },
                child: ListView.builder(
                  controller: scrollController,
                  itemCount: comments.length,
                  itemBuilder: (context, index) {
                    var comment = comments[index];
                    var commentUser = comment.commentUser!;
                    return Padding(
                      padding: const EdgeInsets.all(15.0),
                      child: Column(
                        children: [
                          Row(
                            crossAxisAlignment: CrossAxisAlignment.start,
                            children: [
                              AvatarUserWidget(
                                radius: 20,
                                imagePath: commentUser.image!,
                                gradientColors: commentUser.avatarFrame,
                              ),
                              const SizedBox(width: 10),
                              Expanded(
                                child: Column(
                                  crossAxisAlignment: CrossAxisAlignment.start,
                                  children: [
                                    Row(
                                      children: [
                                        Text(
                                          commentUser.name!,
                                          style: const TextStyle(
                                            fontSize: 18,
                                            fontWeight: FontWeight.bold,
                                            color: Colors.purpleAccent,
                                          ),
                                        ),
                                        const SizedBox(width: 10),
                                        Text(
                                          TimeFunctions.timeAgo(
                                              now: DateTime.now(),
                                              createdAt: comment.createdAt!),
                                          style: const TextStyle(
                                            color: Colors.blueGrey,
                                            fontSize: 12,
                                          ),
                                        ),
                                      ],
                                    ),
                                    ExpandableContent(
                                      content: comment.content!,
                                      style: const TextStyle(
                                        color: Colors.black,
                                        fontSize: 17,
                                      ),
                                      maxLines: 5,
                                    ),
                                    comment.gif != null
                                        ? DisplayGifWidget(gifUrl: comment.gif!)
                                        : const SizedBox(),
                                    GestureDetector(
                                      onTap: () {
                                        commentId.value = comment.id!;
                                        textController.text =
                                            "@${commentUser.name!} ";
                                        textController.selection =
                                            TextSelection.fromPosition(
                                                TextPosition(
                                                    offset: textController
                                                        .text.length));
                                        focusNode.requestFocus();
                                      },
                                      child: const Text(
                                        "Reply",
                                        style: TextStyle(
                                          color: Colors.blueGrey,
                                          fontSize: 14,
                                        ),
                                      ),
                                    ),
                                  ],
                                ),
                              ),
                              Column(
                                children: [
                                  comment.likedList != null
                                      ? Obx(() {
                                          RxBool isLiked =
                                              commentController.isLikedComment(
                                                  currentUser.id!, comment.id!);
                                          return !isLiked.value
                                              ? IconButton(
                                                  icon: const Icon(
                                                    Icons.favorite_border,
                                                    size: 25,
                                                    color: Colors.black,
                                                  ),
                                                  onPressed: () async {
                                                    commentController
                                                        .likeComment(
                                                            comment.id!,
                                                            currentUser.id!);
                                                  },
                                                )
                                              : IconButton(
                                                  icon: const Icon(
                                                    Icons.favorite,
                                                    size: 25,
                                                    color: Colors.red,
                                                  ),
                                                  onPressed: () async {
                                                    commentController
                                                        .unlikeComment(
                                                            comment.id!,
                                                            currentUser.id!);
                                                  },
                                                );
                                        })
                                      : IconButton(
                                          icon: const Icon(
                                            Icons.favorite_border,
                                            size: 25,
                                            color: Colors.black,
                                          ),
                                          onPressed: () async {
                                            commentController.likeComment(
                                                comment.id!, currentUser.id!);
                                          },
                                        ),
                                  comment.likedList == null ||
                                          comment.likedList!.isEmpty
                                      ? const Text(
                                          "0",
                                          style: TextStyle(
                                            color: Colors.blueGrey,
                                            fontSize: 15,
                                          ),
                                        )
                                      : Text(
                                          "${comment.likedList!.length}",
                                          style: const TextStyle(
                                            color: Colors.blueGrey,
                                            fontSize: 15,
                                          ),
                                        ),
                                ],
                              ),
                            ],
                          ),
                          comment.countReplies == null ||
                                  comment.countReplies == 0
                              ? const SizedBox()
                              : Row(
                                  children: [
                                    const SizedBox(width: 40),
                                    Container(
                                      height: 2,
                                      width: 50,
                                      decoration: const BoxDecoration(
                                        color: Colors.blueGrey,
                                        borderRadius: BorderRadius.all(
                                            Radius.circular(20)),
                                      ),
                                    ),
                                    GestureDetector(
                                      onTap: () async {
                                        Get.delete<
                                            PostReplyCommentController>();
                                        await showFlexibleBottomSheet(
                                          minHeight: 0,
                                          initHeight: 0.8,
                                          maxHeight: 1,
                                          context: context,
                                          builder: (context, scrollController,
                                              bottomSheet) {
                                            return ReelReplyCommentListSheet(
                                              scrollController:
                                                  scrollController,
                                              currentUser: currentUser,
                                              reelId: reel.reelId!,
                                              commentModel: comment,
                                              commentController:
                                                  commentController,
                                            );
                                          },
                                          duration:
                                              const Duration(milliseconds: 500),
                                          bottomSheetColor: Colors.white,
                                          bottomSheetBorderRadius:
                                              const BorderRadius.only(
                                            topLeft: Radius.circular(20),
                                            topRight: Radius.circular(20),
                                          ),
                                          isSafeArea: true,
                                        );
                                      },
                                      child: Text(
                                        "View ${comment.countReplies} more replies",
                                        style: const TextStyle(
                                          fontStyle: FontStyle.italic,
                                          fontSize: 14,
                                          color: Colors.blueGrey,
                                        ),
                                      ),
                                    ),
                                  ],
                                ),
                        ],
                      ),
                    )
                        .animate()
                        .scale(duration: duration750)
                        .fadeIn(duration: duration750);
                  },
                ),
              );
            }
          }),
        ),
        Padding(
          padding: const EdgeInsets.all(10.0),
          child: Column(
            children: [
              Obx(() => commentId.value.isNotEmpty
                  ? Container(
                      padding: const EdgeInsets.symmetric(
                          vertical: 10, horizontal: 10),
                      margin: const EdgeInsets.only(bottom: 10),
                      width: double.infinity,
                      height: 50,
                      color: Colors.grey.shade400,
                      child: Row(
                        mainAxisAlignment: MainAxisAlignment.start,
                        children: [
                          Expanded(
                            child: Text(
                              "Replying to ${textController.text} ",
                              style: const TextStyle(
                                color: Colors.black,
                                fontSize: 15,
                              ),
                            ),
                          ),
                          GestureDetector(
                            onTap: () {
                              commentId.value = "";
                              textController.clear();
                            },
                            child: const Text(
                              "X",
                              style: TextStyle(
                                color: Colors.redAccent,
                                fontSize: 25,
                              ),
                            ),
                          ),
                        ],
                      ),
                    )
                  : const SizedBox()),
              PreviewGifWidget(selectedGif: selectedGif),
              CustomEmojiPicker(
                onEmojiSelected: (emoji) {
                  textController.text += emoji;
                  commentContent.value = textController.text;
                  textController.selection = TextSelection.fromPosition(
                      TextPosition(offset: textController.text.length));
                },
                onBackspacePressed: () {
                  final text = textController.text;
                  if (text.isNotEmpty) {
                    textController.text =
                        text.characters.skipLast(1).toString();
                    commentContent.value = textController.text;
                    textController.selection = TextSelection.fromPosition(
                        TextPosition(offset: textController.text.length));
                  }
                },
                isEmojiPickerVisible: isEmojiPickerVisible,
                backgroundColor: const [Colors.blueGrey, Colors.blueGrey],
              ),
              Row(
                children: [
                  AvatarUserWidget(
                    radius: 25,
                    imagePath: currentUser.image!,
                    gradientColors: currentUser.avatarFrame,
                  ),
                  const SizedBox(width: 10),
                  Expanded(
                    child: TextField(
                      focusNode: focusNode,
                      controller: textController,
                      textInputAction: TextInputAction.done,
                      onChanged: (value) {
                        if (value.isNotEmpty) {
                          commentContent.value = value;
                        } else {
                          commentContent.value = "";
                        }
                      },
                      decoration: InputDecoration(
                        fillColor: Colors.grey.shade400,
                        hintStyle: const TextStyle(color: Colors.black54),
                        hintText: "Write a comment...",
                        prefixIcon: IconButton(
                          icon: const Icon(
                            Icons.gif_box_outlined,
                            color: Colors.blueAccent,
                            size: 30,
                          ),
                          onPressed: () async {
                            final gif = await GiphyPicker.pickGif(
                              context: context,
                              apiKey: apiGifphy,
                              showPreviewPage: false,
                              showGiphyAttribution: false,
                              loadingBuilder: (context) {
                                return Center(
                                  child: ClipRRect(
                                    borderRadius: BorderRadius.circular(100),
                                    child: Image.asset(
                                      GifsPath.loadingGif,
                                      height: 200,
                                      width: 200,
                                    ),
                                  ),
                                );
                              },
                            );
                            if (gif != null) {
                              selectedGif.value = gif;
                            }
                          },
                        ),
                        suffixIcon: Obx(() => IconButton(
                            onPressed: () => isEmojiPickerVisible.toggle(),
                            icon: isEmojiPickerVisible.value
                                ? const Icon(Icons.emoji_emotions,
                                    color: Colors.blue, size: 30)
                                : const Icon(Icons.emoji_emotions_outlined,
                                    color: Colors.blue, size: 30))),
                      ),
                    ),
                  ),
                  Obx(() =>
                      commentContent.value.isEmpty || commentContent.value == ""
                          ? const SizedBox()
                          : Obx(() => commentId.value.isNotEmpty
                              ? IconButton(
                                  onPressed: () async {
                                    focusNode.unfocus();
                                    Get.delete<ReelReplyCommentController>();
                                    ReelReplyCommentController
                                        subCommentController =
                                        Get.put(ReelReplyCommentController(
                                      reel.reelId!, // Sử dụng reelId
                                      commentId.value,
                                    ));
                                    await subCommentController.addSubComment(
                                        content: commentContent.value,
                                        gifUrl: selectedGif
                                            .value?.images.original!.url!,
                                        currentUser: currentUser);
                                    textController.clear();
                                    commentContent.value = "";
                                    selectedGif.value = null;
                                    commentId.value = "";
                                  },
                                  icon: const Icon(
                                    Icons.reply_all_rounded,
                                    size: 35,
                                    color: Colors.blue,
                                  ),
                                )
                              : IconButton(
                                  onPressed: () async {
                                    focusNode.unfocus();
                                    await commentController.addComment(
                                      content: commentContent.value,
                                      currentUser: currentUser,
                                      receiverId: reel.reelUser!
                                          .id!, // Giả sử reelUser là trường
                                      gifUrl: selectedGif
                                          .value?.images.original!.url!,
                                    );
                                    textController.clear();
                                    selectedGif.value = null;
                                    commentContent.value = "";
                                  },
                                  icon: const Icon(
                                    Icons.send_rounded,
                                    size: 35,
                                    color: Colors.blue,
                                  ),
                                ))),
                ],
              ),
            ],
          ),
        ),
      ],
    );
  }
}

```

---


### Pages\Society\Reels\comment\reel_reply_comment_controller.dart

```dart
import 'dart:async';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:get/get.dart';
import 'package:tictactoe_gameapp/Configs/messages.dart';
import 'package:tictactoe_gameapp/Models/user_model.dart';
import 'package:tictactoe_gameapp/Pages/Society/Comment/comment_post_model.dart';
import 'package:uuid/uuid.dart';

class ReelReplyCommentController extends GetxController {
  final FirebaseFirestore _firestore = FirebaseFirestore.instance;
  late StreamSubscription subscriptionListenComment;

  RxList<CommentModel> subCommentsList = <CommentModel>[].obs;
  final int commentsPerPage = 1; // Số sub-comments tải mỗi lần cho pagination
  DocumentSnapshot? lastDocument; // Để theo dõi pagination
  bool isFetching = false;

  final String reelId; // ID của reel
  final String commentId; // ID của comment chính
  ReelReplyCommentController(this.reelId, this.commentId);

  @override
  void onInit() {
    super.onInit();
    fetchSubComments(); // Lấy danh sách sub-comments ngay từ khi init
    listenToSubComments(); // Lắng nghe thay đổi thời gian thực
  }

  // Lấy danh sách sub-comments theo pagination
  Future<void> fetchSubComments({bool isPagination = false}) async {
    if (isFetching) return;
    isFetching = true;

    try {
      Query query = _firestore
          .collection('reels')
          .doc(reelId)
          .collection('comments')
          .doc(commentId)
          .collection('subComments')
          .orderBy('createdAt', descending: true)
          .limit(commentsPerPage);

      if (isPagination && lastDocument != null) {
        query = query.startAfterDocument(lastDocument!);
      }

      QuerySnapshot snapshot = await query.get();

      if (snapshot.docs.isNotEmpty) {
        lastDocument = snapshot.docs.last;
      }

      if (!isPagination) {
        subCommentsList.clear();
      }

      subCommentsList.addAll(
        snapshot.docs.map((doc) => CommentModel.fromJson(doc.data() as Map<String, dynamic>)).toList(),
      );
    } catch (e) {
      throw Exception("Error fetching sub-comments: $e");
    } finally {
      isFetching = false;
    }
  }

  // Lắng nghe sub-comments theo thời gian thực
  void listenToSubComments() {
    subscriptionListenComment = _firestore
        .collection('reels')
        .doc(reelId)
        .collection('comments')
        .doc(commentId)
        .collection('subComments')
        .orderBy('createdAt', descending: true)
        .snapshots()
        .listen((snapshot) {
      for (var change in snapshot.docChanges) {
        if (change.type == DocumentChangeType.added) {
          subCommentsList.insert(0, CommentModel.fromJson(change.doc.data() as Map<String, dynamic>));
        } else if (change.type == DocumentChangeType.modified) {
          int index = subCommentsList.indexWhere((comment) => comment.id == change.doc.id);
          if (index != -1) {
            subCommentsList[index] = CommentModel.fromJson(change.doc.data() as Map<String, dynamic>);
          }
        } else if (change.type == DocumentChangeType.removed) {
          subCommentsList.removeWhere((comment) => comment.id == change.doc.id);
        }
      }
    });
  }

  // Thêm sub-comment
  Future<void> addSubComment({
    required String content,
    String? gifUrl,
    List<String>? taggedUserIds,
    required UserModel currentUser,
  }) async {
    try {
      var uuid = const Uuid();
      String subCommentId = uuid.v4();
      CommentModel newSubComment = CommentModel(
        id: subCommentId, // Sử dụng ID mới cho sub-comment
        postId: reelId, // Gán reelId vào postId để tái sử dụng CommentModel
        gif: gifUrl,
        content: content,
        commentUser: currentUser,
        createdAt: DateTime.now(),
        taggedUserIds: taggedUserIds,
      );

      DocumentReference subCommentRef = _firestore
          .collection('reels')
          .doc(reelId)
          .collection('comments')
          .doc(commentId)
          .collection('subComments')
          .doc(subCommentId);

      await subCommentRef.set(newSubComment.toJson()).catchError((e) => errorMessage(e));

      await _firestore.collection('reels').doc(reelId).update({
        'commentCount': FieldValue.increment(1),
      }).catchError((e) => errorMessage(e));

      await _firestore
          .collection('reels')
          .doc(reelId)
          .collection('comments')
          .doc(commentId)
          .update({
        'countReplies': FieldValue.increment(1),
      }).catchError((e) => errorMessage(e));
    } catch (e) {
      throw Exception("Error adding sub-comment: $e");
    }
  }

  // Like sub-comment
  Future<void> likeSubComment(String subCommentId, String userId) async {
    DocumentReference commentRef = _firestore
        .collection('reels')
        .doc(reelId)
        .collection('comments')
        .doc(commentId)
        .collection('subComments')
        .doc(subCommentId);

    await commentRef.update({
      'likedList': FieldValue.arrayUnion([userId]),
    }).catchError((e) => errorMessage(e));
  }

  // Unlike sub-comment
  Future<void> unlikeSubComment(String subCommentId, String userId) async {
    DocumentReference commentRef = _firestore
        .collection('reels')
        .doc(reelId)
        .collection('comments')
        .doc(commentId)
        .collection('subComments')
        .doc(subCommentId);

    await commentRef.update({
      'likedList': FieldValue.arrayRemove([userId]),
    }).catchError((e) => errorMessage(e));
  }

  // Kiểm tra trạng thái like của sub-comment
  RxBool isLikedSubComment(String userId, String subCommentId) {
    final comment = subCommentsList.firstWhereOrNull((subComment) => subComment.id == subCommentId);
    if (comment == null || comment.likedList == null) {
      return false.obs;
    }
    final isLiked = comment.likedList!.contains(userId);
    return isLiked.obs;
  }

  // Xóa sub-comment
  Future<void> deleteSubComment(String subCommentId) async {
    try {
      await _firestore
          .collection('reels')
          .doc(reelId)
          .collection('comments')
          .doc(commentId)
          .collection('subComments')
          .doc(subCommentId)
          .delete()
          .catchError((e) => errorMessage(e));

      await _firestore.collection('reels').doc(reelId).update({
        'commentCount': FieldValue.increment(-1),
      }).catchError((e) => errorMessage(e));

      await _firestore
          .collection('reels')
          .doc(reelId)
          .collection('comments')
          .doc(commentId)
          .update({
        'countReplies': FieldValue.increment(-1),
      }).catchError((e) => errorMessage(e));
    } catch (e) {
      errorMessage("Error deleting sub-comment: $e");
    }
  }

  // Tải thêm sub-comments (pagination)
  Future<void> loadMoreSubComments() async {
    await fetchSubComments(isPagination: true);
  }

  @override
  void onClose() {
    subscriptionListenComment.cancel();
    super.onClose();
  }
}
```

---


### Pages\Society\Reels\comment\reel_reply_comment_list_sheet.dart

```dart
import 'package:flutter/material.dart';
import 'package:flutter_animate/flutter_animate.dart';
import 'package:get/get.dart';
import 'package:giphy_picker/giphy_picker.dart';
import 'package:tictactoe_gameapp/Components/belong_to_users/avatar_user_widget.dart';
import 'package:tictactoe_gameapp/Components/gifphy/display_gif_widget.dart';
import 'package:tictactoe_gameapp/Components/gifphy/preview_gif_widget.dart';
import 'package:tictactoe_gameapp/Configs/assets_path.dart';
import 'package:tictactoe_gameapp/Configs/constants.dart';
import 'package:tictactoe_gameapp/Models/Functions/time_functions.dart';
import 'package:tictactoe_gameapp/Models/user_model.dart';
import 'package:tictactoe_gameapp/Pages/Society/Comment/comment_post_model.dart';
import 'package:tictactoe_gameapp/Pages/Society/Widgets/expandable_text_custom.dart';
import 'package:tictactoe_gameapp/Components/emotes_picker_widget.dart';
import 'package:tictactoe_gameapp/Pages/Society/Reels/comment/reel_comment_controller.dart';
import 'package:tictactoe_gameapp/Pages/Society/Reels/comment/reel_reply_comment_controller.dart';

class ReelReplyCommentListSheet extends StatelessWidget {
  final ReelCommentController commentController; // Controller cho comment cha
  final ScrollController scrollController;
  final UserModel currentUser;
  final String reelId;
  final CommentModel commentModel;
  const ReelReplyCommentListSheet({
    super.key,
    required this.scrollController,
    required this.currentUser,
    required this.reelId,
    required this.commentModel,
    required this.commentController,
  });

  @override
  Widget build(BuildContext context) {
    final ReelReplyCommentController subCommentController =
        Get.put(ReelReplyCommentController(reelId, commentModel.id!));
    final UserModel commentUser = commentModel.commentUser!;
    final TextEditingController textController = TextEditingController();
    final FocusNode focusNode = FocusNode();
    RxString commentContent = "".obs;
    RxString replyCommentId = "".obs;
    RxBool isEmojiPickerVisible = false.obs;
    var selectedGif = Rx<GiphyGif?>(null);

    return Column(
      children: [
        Row(
          mainAxisAlignment: MainAxisAlignment.spaceBetween,
          children: [
            IconButton(
              onPressed: () => Get.back(),
              icon: const Icon(Icons.arrow_back_ios_new_rounded, size: 30),
            ),
            Expanded(
              child: Column(
                children: [
                  Container(
                    height: 5,
                    width: 50,
                    margin: const EdgeInsets.only(top: 10),
                    decoration: const BoxDecoration(
                      color: Colors.blueGrey,
                      borderRadius: BorderRadius.all(Radius.circular(20)),
                    ),
                  ),
                  const Text("Replies", style: TextStyle(fontSize: 20)),
                  Padding(
                    padding: const EdgeInsets.symmetric(
                        horizontal: 20, vertical: 10),
                    child: Row(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        AvatarUserWidget(
                          radius: 30,
                          imagePath: commentUser.image!,
                          gradientColors: commentUser.avatarFrame,
                        ),
                        const SizedBox(width: 10),
                        Expanded(
                          child: Column(
                            crossAxisAlignment: CrossAxisAlignment.start,
                            children: [
                              Text(
                                commentUser.name!,
                                style: const TextStyle(
                                  fontSize: 20,
                                  fontWeight: FontWeight.bold,
                                  color: Colors.purpleAccent,
                                ),
                              ),
                              ExpandableContent(
                                content: commentModel.content!,
                                style: const TextStyle(
                                    color: Colors.black, fontSize: 19),
                                maxLines: 5,
                              ),
                              Text(
                                TimeFunctions.timeAgo(
                                    now: DateTime.now(),
                                    createdAt: commentModel.createdAt!),
                                style: const TextStyle(
                                    color: Colors.blueGrey, fontSize: 13),
                              ),
                            ],
                          ),
                        ),
                        Column(
                          children: [
                            commentModel.likedList != null
                                ? Obx(() {
                                    RxBool isLiked =
                                        commentController.isLikedComment(
                                            currentUser.id!, commentModel.id!);
                                    return !isLiked.value
                                        ? IconButton(
                                            icon: const Icon(
                                                Icons.favorite_border,
                                                size: 30,
                                                color: Colors.black),
                                            onPressed: () =>
                                                commentController.likeComment(
                                                    commentModel.id!,
                                                    currentUser.id!),
                                          )
                                        : IconButton(
                                            icon: const Icon(Icons.favorite,
                                                size: 30, color: Colors.red),
                                            onPressed: () =>
                                                commentController.unlikeComment(
                                                    commentModel.id!,
                                                    currentUser.id!),
                                          );
                                  })
                                : IconButton(
                                    icon: const Icon(Icons.favorite_border,
                                        size: 30, color: Colors.black),
                                    onPressed: () =>
                                        commentController.likeComment(
                                            commentModel.id!, currentUser.id!),
                                  ),
                            Text(
                              commentModel.likedList == null ||
                                      commentModel.likedList!.isEmpty
                                  ? "0"
                                  : "${commentModel.likedList!.length}",
                              style: const TextStyle(
                                  color: Colors.blueGrey, fontSize: 17),
                            ),
                          ],
                        ),
                      ],
                    ),
                  ),
                ],
              ),
            ),
            IconButton(
                onPressed: () {},
                icon: const Icon(Icons.info_outline, size: 35)),
          ],
        ),
        Expanded(
          child: Obx(() {
            if (subCommentController.subCommentsList.isEmpty) {
              return const Center(
                child: Column(
                  mainAxisAlignment: MainAxisAlignment.center,
                  children: [
                    Text("No replies yet", style: TextStyle(fontSize: 25)),
                    Text("Start the conversation...",
                        style: TextStyle(fontSize: 15, color: Colors.grey)),
                  ],
                ),
              );
            }
            var comments = subCommentController.subCommentsList.toList();
            return NotificationListener<ScrollNotification>(
              onNotification: (scrollInfo) {
                if (scrollInfo.metrics.pixels >=
                    scrollInfo.metrics.maxScrollExtent - 200) {
                  subCommentController.loadMoreSubComments();
                }
                return true;
              },
              child: ListView.builder(
                controller: scrollController,
                itemCount: comments.length,
                itemBuilder: (context, index) {
                  var comment = comments[index];
                  var commentUser = comment.commentUser!;
                  return Padding(
                    padding: const EdgeInsets.all(15.0),
                    child: Row(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        AvatarUserWidget(
                          radius: 20,
                          imagePath: commentUser.image!,
                          gradientColors: commentUser.avatarFrame,
                        ),
                        const SizedBox(width: 10),
                        Expanded(
                          child: Column(
                            crossAxisAlignment: CrossAxisAlignment.start,
                            children: [
                              Row(
                                children: [
                                  Text(
                                    commentUser.name!,
                                    style: const TextStyle(
                                        fontSize: 18,
                                        fontWeight: FontWeight.bold,
                                        color: Colors.blueAccent),
                                  ),
                                  const SizedBox(width: 10),
                                  Text(
                                    TimeFunctions.timeAgo(
                                        now: DateTime.now(),
                                        createdAt: comment.createdAt!),
                                    style: const TextStyle(
                                        color: Colors.blueGrey, fontSize: 12),
                                  ),
                                ],
                              ),
                              ExpandableContent(
                                content: comment.content!,
                                style: const TextStyle(
                                    color: Colors.black, fontSize: 17),
                                maxLines: 5,
                              ),
                              if (comment.gif != null)
                                DisplayGifWidget(gifUrl: comment.gif!),
                              GestureDetector(
                                onTap: () {
                                  replyCommentId.value = comment.id!;
                                  textController.text =
                                      "@${commentUser.name!} ";
                                  textController.selection =
                                      TextSelection.fromPosition(TextPosition(
                                          offset: textController.text.length));
                                  focusNode.requestFocus();
                                },
                                child: const Text("Reply",
                                    style: TextStyle(
                                        color: Colors.blueGrey, fontSize: 14)),
                              ),
                            ],
                          ),
                        ),
                        Column(
                          children: [
                            comment.likedList != null
                                ? Obx(() {
                                    RxBool isLiked =
                                        subCommentController.isLikedSubComment(
                                            currentUser.id!, comment.id!);
                                    return !isLiked.value
                                        ? IconButton(
                                            icon: const Icon(
                                                Icons.favorite_border,
                                                size: 25,
                                                color: Colors.black),
                                            onPressed: () =>
                                                subCommentController
                                                    .likeSubComment(comment.id!,
                                                        currentUser.id!),
                                          )
                                        : IconButton(
                                            icon: const Icon(Icons.favorite,
                                                size: 25, color: Colors.red),
                                            onPressed: () =>
                                                subCommentController
                                                    .unlikeSubComment(
                                                        comment.id!,
                                                        currentUser.id!),
                                          );
                                  })
                                : IconButton(
                                    icon: const Icon(Icons.favorite_border,
                                        size: 25, color: Colors.black),
                                    onPressed: () =>
                                        subCommentController.likeSubComment(
                                            comment.id!, currentUser.id!),
                                  ),
                            Text(
                              comment.likedList == null ||
                                      comment.likedList!.isEmpty
                                  ? "0"
                                  : "${comment.likedList!.length}",
                              style: const TextStyle(
                                  color: Colors.blueGrey, fontSize: 15),
                            ),
                          ],
                        ),
                      ],
                    ),
                  )
                      .animate()
                      .scale(duration: duration750)
                      .fadeIn(duration: duration750);
                },
              ),
            );
          }),
        ),
        Padding(
          padding: const EdgeInsets.all(10.0),
          child: Column(
            children: [
              Obx(() => replyCommentId.value.isNotEmpty
                  ? Container(
                      padding: const EdgeInsets.symmetric(
                          vertical: 10, horizontal: 10),
                      margin: const EdgeInsets.only(bottom: 10),
                      width: double.infinity,
                      height: 50,
                      color: Colors.grey.shade400,
                      child: Row(
                        mainAxisAlignment: MainAxisAlignment.start,
                        children: [
                          Expanded(
                            child: Text(
                              "Replying to ${textController.text} ",
                              style: const TextStyle(
                                  color: Colors.black, fontSize: 15),
                            ),
                          ),
                          GestureDetector(
                            onTap: () {
                              replyCommentId.value = "";
                              textController.clear();
                            },
                            child: const Text("X",
                                style: TextStyle(
                                    color: Colors.redAccent, fontSize: 25)),
                          ),
                        ],
                      ),
                    )
                  : const SizedBox()),
              PreviewGifWidget(selectedGif: selectedGif),
              CustomEmojiPicker(
                onEmojiSelected: (emoji) {
                  textController.text += emoji;
                  commentContent.value = textController.text;
                  textController.selection = TextSelection.fromPosition(
                      TextPosition(offset: textController.text.length));
                },
                onBackspacePressed: () {
                  final text = textController.text;
                  if (text.isNotEmpty) {
                    textController.text =
                        text.characters.skipLast(1).toString();
                    commentContent.value = textController.text;
                    textController.selection = TextSelection.fromPosition(
                        TextPosition(offset: textController.text.length));
                  }
                },
                isEmojiPickerVisible: isEmojiPickerVisible,
                backgroundColor: const [Colors.blueGrey, Colors.blueGrey],
              ),
              Row(
                children: [
                  AvatarUserWidget(
                    radius: 25,
                    imagePath: currentUser.image!,
                    gradientColors: currentUser.avatarFrame,
                  ),
                  const SizedBox(width: 10),
                  Expanded(
                    child: TextField(
                      focusNode: focusNode,
                      controller: textController,
                      textInputAction: TextInputAction.done,
                      onChanged: (value) => commentContent.value = value,
                      decoration: InputDecoration(
                        fillColor: Colors.grey.shade400,
                        hintStyle: const TextStyle(color: Colors.black54),
                        hintText:
                            "Reply a comment of @${commentModel.commentUser!.name!}",
                        prefixIcon: IconButton(
                          icon: const Icon(Icons.gif_box_outlined,
                              color: Colors.blueAccent, size: 30),
                          onPressed: () async {
                            final gif = await GiphyPicker.pickGif(
                              context: context,
                              apiKey: apiGifphy,
                              showPreviewPage: false,
                              showGiphyAttribution: false,
                              loadingBuilder: (context) => Center(
                                child: ClipRRect(
                                  borderRadius: BorderRadius.circular(100),
                                  child: Image.asset(GifsPath.loadingGif,
                                      height: 200, width: 200),
                                ),
                              ),
                            );
                            if (gif != null) selectedGif.value = gif;
                          },
                        ),
                        suffixIcon: Obx(() => IconButton(
                              onPressed: () => isEmojiPickerVisible.toggle(),
                              icon: isEmojiPickerVisible.value
                                  ? const Icon(Icons.emoji_emotions,
                                      color: Colors.blue, size: 30)
                                  : const Icon(Icons.emoji_emotions_outlined,
                                      color: Colors.blue, size: 30),
                            )),
                      ),
                    ),
                  ),
                  Obx(() => commentContent.value.isEmpty
                      ? const SizedBox()
                      : IconButton(
                          onPressed: () async {
                            focusNode.unfocus();
                            await subCommentController.addSubComment(
                              content: commentContent.value,
                              currentUser: currentUser,
                              gifUrl: selectedGif.value?.images.original!.url,
                            );
                            textController.clear();
                            commentContent.value = "";
                            selectedGif.value = null;
                          },
                          icon: const Icon(Icons.arrow_outward_rounded,
                              size: 35, color: Colors.blue),
                        )),
                ],
              ),
            ],
          ),
        ),
      ],
    );
  }
}

```

---


### Pages\Society\Reels\whitecodel\video_controller_service.dart

```dart
import 'dart:developer';
import 'package:flutter_cache_manager/flutter_cache_manager.dart';
import 'package:video_player/video_player.dart';
abstract class VideoControllerService {
  Future<VideoPlayerController?> getControllerForVideo(
      String url, bool isCaching);
}

class CachedVideoControllerService extends VideoControllerService {
  final BaseCacheManager _cacheManager;

  CachedVideoControllerService(this._cacheManager);

  @override
  Future<VideoPlayerController?> getControllerForVideo(
      String url, bool isCaching) async {
    if (isCaching) {
      try {
        FileInfo? fileInfo = await _cacheManager.getFileFromCache(url);
        if (fileInfo != null) return VideoPlayerController.file(fileInfo.file);
        fileInfo = await _cacheManager.downloadFile(url);
        return VideoPlayerController.file(fileInfo.file);
      } catch (e) {
        log('Error downloading video from $url: $e');
        return null; // Trả về null khi lỗi
      }
    } else {
      try {
        final controller = VideoPlayerController.networkUrl(Uri.parse(url));
        await controller.initialize();
        return controller;
      } catch (e) {
        log('Error creating network controller for $url: $e');
        return null; // Trả về null khi lỗi
      }
    }
  }
}

class CustomCacheManager {
  static const key = 'customCacheKey';
  static CacheManager instance = CacheManager(
    Config(
      key,
      stalePeriod: const Duration(minutes: 30), // Xóa cache sau 30 phút
      maxNrOfCacheObjects: 10, // Giới hạn tối đa 10 video trong cache
      repo: JsonCacheInfoRepository(databaseName: key),
      fileSystem: IOFileSystem(key),
      fileService: HttpFileService(),
    ),
  );
}

```

---


### Pages\Society\Reels\whitecodel\video_full_screen_widget.dart

```dart
import 'package:flutter/material.dart';
import 'package:get/get_state_manager/src/rx_flutter/rx_obx_widget.dart';
import 'package:tictactoe_gameapp/Pages/Society/Reels/whitecodel/whitecodel_reels_controller.dart';
import 'package:video_player/video_player.dart';

/// VideoFullScreenPage nhận controller từ cha để tránh lỗi Get.find()
class VideoFullScreenWidget extends StatelessWidget {
  final VideoPlayerController videoPlayerController;
  final WhiteCodelReelsController controller;

  const VideoFullScreenWidget({
    super.key,
    required this.videoPlayerController,
    required this.controller,
  });

  @override
  Widget build(BuildContext context) {
    return Stack(
      children: [
        // Hiển thị video với FittedBox để cover toàn màn hình
        SizedBox(
          height: MediaQuery.of(context).size.height,
          width: MediaQuery.of(context).size.width,
          child: FittedBox(
            fit: BoxFit.cover,
            child: SizedBox(
              width: MediaQuery.of(context).size.height *
                  videoPlayerController.value.aspectRatio,
              height: MediaQuery.of(context).size.height,
              child: VideoPlayer(videoPlayerController),
            ),
          ),
        ),
        // Nút Play/Pause với AnimatedOpacity dựa trên observable visible
        Positioned.fill(
          child: Center(
            child: Obx(
              () => AnimatedOpacity(
                opacity: controller.visible.value ? 1 : 0,
                duration: const Duration(milliseconds: 500),
                child: Container(
                  alignment: Alignment.center,
                  width: 70,
                  height: 70,
                  decoration: const BoxDecoration(
                    color: Colors.black38,
                    shape: BoxShape.circle,
                    border: Border.fromBorderSide(
                      BorderSide(color: Colors.white, width: 1),
                    ),
                  ),
                  child: !videoPlayerController.value.isPlaying
                      ? const Icon(Icons.play_arrow,
                          color: Colors.white, size: 40)
                      : const Icon(Icons.pause, color: Colors.white, size: 40),
                ),
              ),
            ),
          ),
        ),
      ],
    );
  }
}

```

---


### Pages\Society\Reels\whitecodel\whitecodel_reels_controller.dart

```dart
import 'dart:async';
import 'dart:developer';
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:tictactoe_gameapp/Pages/Society/Reels/reel_controller.dart';
import 'package:video_player/video_player.dart';
import 'video_controller_service.dart';

class WhiteCodelReelsController extends GetxController
    with GetTickerProviderStateMixin, WidgetsBindingObserver {
  final PageController pageController = PageController(viewportFraction: 1.0);
  RxList<VideoPlayerController> videoPlayerControllerList =
      <VideoPlayerController>[].obs;
  final CachedVideoControllerService videoControllerService =
      CachedVideoControllerService(CustomCacheManager.instance);

  RxBool loading = true.obs;
  RxBool visible = false.obs;
  RxBool isFetchingMore = false.obs;
  late AnimationController animationController;
  late Animation animation;

  final List<String> reelsVideoList;
  List<String> videoList = <String>[];
  int loadLimit = 1; // Giảm từ 3 xuống 1 để tối ưu hiệu suất
  List<int> alreadyListened = [];
  List<String> caching = [];
  RxInt pageCount = 0.obs;
  final int startIndex;
  bool isCaching;
  bool _isDisposed = false;
  final Map<int, int> _retryAttempts =
      {}; // Theo dõi số lần thử lại cho mỗi video

  WhiteCodelReelsController({
    required this.reelsVideoList,
    required this.isCaching,
    this.startIndex = 0,
  });

  @override
  void onInit() {
    super.onInit();
    videoList.addAll(reelsVideoList);
    pageCount.value = videoList.length;

    animationController =
        AnimationController(vsync: this, duration: const Duration(seconds: 5));
    animation =
        CurvedAnimation(parent: animationController, curve: Curves.easeIn);

    _initializeVideoControllers(startIndex);
    WidgetsBinding.instance.addObserver(this);
  }

  @override
  void onClose() {
    _isDisposed = true;
    final List<VideoPlayerController> controllersToDispose =
        List.from(videoPlayerControllerList);
    WidgetsBinding.instance.addPostFrameCallback((_) {
      videoPlayerControllerList.clear();
    });
    for (var controller in controllersToDispose) {
      if (controller.value.isInitialized) {
        controller.pause();
      }
      controller.dispose();
    }
    animationController.dispose();
    pageController.dispose();
    WidgetsBinding.instance.removeObserver(this);
    super.onClose();
  }

  @override
  void didChangeAppLifecycleState(AppLifecycleState state) {
    super.didChangeAppLifecycleState(state);
    if (state == AppLifecycleState.paused) {
      for (var controller in videoPlayerControllerList) {
        if (controller.value.isInitialized && controller.value.isPlaying) {
          controller.pause();
        }
      }
      safeAnimationStop();
    } else if (state == AppLifecycleState.resumed) {
      final currentIndex = pageController.page?.toInt() ?? startIndex;
      if (currentIndex >= 0 &&
          currentIndex < videoPlayerControllerList.length) {
        final controller = videoPlayerControllerList[currentIndex];
        if (controller.value.isInitialized && !controller.value.isPlaying) {
          controller.play();
        }
      }
    }
  }

  Future<void> _initializeVideoControllers(int startIndex) async {
    loading.value = true;
    List<String> validUrls = [];
    videoPlayerControllerList.clear();

    for (var url in videoList) {
      try {
        final controller =
            await videoControllerService.getControllerForVideo(url, isCaching);
        if (controller != null) {
          videoPlayerControllerList.add(controller);
          validUrls.add(url);
        } else {
          videoPlayerControllerList
              .add(VideoPlayerController.networkUrl(Uri.parse('')));
          validUrls.add(url);
        }
      } catch (e) {
        debugPrint('Skipping invalid URL: $url, error: $e');
      }
    }
    videoPlayerControllerList.refresh();
    videoList = validUrls;
    pageCount.value = videoPlayerControllerList.length;

    if (videoPlayerControllerList.isNotEmpty &&
        startIndex < videoPlayerControllerList.length) {
      final initialController = videoPlayerControllerList[startIndex];
      if (initialController.dataSource.isNotEmpty) {
        try {
          await initialController.initialize();
          await initialController.play();
        } catch (e) {
          debugPrint('Error initializing first video: $e');
        }
      }
    }
    loading.value = false;
  }

  Future<void> updateVideoList(List<String> newVideoList) async {
    final newUrls =
        newVideoList.where((url) => !videoList.contains(url)).toList();
    if (newUrls.isEmpty) return;

    List<String> validUrls = [];
    List<VideoPlayerController> newControllers = [];

    for (var url in newUrls) {
      try {
        final controller =
            await videoControllerService.getControllerForVideo(url, isCaching);
        if (controller != null) {
          newControllers.add(controller);
          validUrls.add(url);
        } else {
          newControllers.add(VideoPlayerController.networkUrl(Uri.parse('')));
          validUrls.add(url);
        }
      } catch (e) {
        log('Error adding video controller for $url: $e');
      }
    }

    videoList.addAll(validUrls);
    videoPlayerControllerList.addAll(newControllers);
    pageCount.value = videoPlayerControllerList.length;
    videoPlayerControllerList.refresh();
  }

  void checkAndFetchMoreReels(
      {required ReelController reelController,
      required int currentIndex}) async {
    if (currentIndex >= videoList.length - 1 && !isFetchingMore.value) {
      isFetchingMore.value = true;
      for (var controller in videoPlayerControllerList) {
        if (controller.value.isInitialized && controller.value.isPlaying) {
          await controller.pause();
        }
      }
      await reelController.fetchMoreReels();
      await updateVideoList(
          reelController.reelsList.map((e) => e.videoUrl!).toList());
      isFetchingMore.value = false;
    }
  }

  void listenEvents(int index, {bool force = false}) {
    if (alreadyListened.contains(index) && !force) return;
    alreadyListened.add(index);
    var vpController = videoPlayerControllerList[index];
    vpController.addListener(() {
      if (_isDisposed) return;
      if (vpController.value.isInitialized &&
          vpController.value.position >= vpController.value.duration &&
          vpController.value.duration != Duration.zero) {
        vpController.seekTo(Duration.zero);
        vpController.play();
      }
    });
  }

  Future<void> cacheVideo(int index) async {
    if (!isCaching || _isDisposed) return;
    String url = videoList[index];
    if (caching.contains(url)) return;
    caching.add(url);
    final cacheManager = CustomCacheManager.instance;
    try {
      final fileInfo = await cacheManager.getFileFromCache(url);
      if (fileInfo != null) return;
      await cacheManager.downloadFile(url);
    } catch (e) {
      caching.remove(url);
      log('Error caching video at index $index: $e');
    }
  }

  Future<void> initNearByVideos(int index) async {
    if (_isDisposed) return;
    try {
      if (videoList.asMap().containsKey(index) &&
          !videoPlayerControllerList[index].value.isInitialized) {
        await videoPlayerControllerList[index].initialize();
      }

      for (int i = 1; i <= loadLimit; i++) {
        if (_isDisposed) return;
        int nextIndex = index + i;
        int prevIndex = index - i;

        if (videoList.asMap().containsKey(nextIndex) &&
            !videoPlayerControllerList[nextIndex].value.isInitialized) {
          await Future.delayed(const Duration(milliseconds: 150));
          if (!_isDisposed) {
            await videoPlayerControllerList[nextIndex].initialize();
          }
        }
        if (videoList.asMap().containsKey(prevIndex) &&
            !videoPlayerControllerList[prevIndex].value.isInitialized) {
          await Future.delayed(const Duration(milliseconds: 150));
          if (!_isDisposed) {
            await videoPlayerControllerList[prevIndex].initialize();
          }
        }
      }
    } catch (e) {
      log('Error initializing nearby videos at index $index: $e');
    }
    loading.value = false;
  }

  Future<bool> retryInitializeVideo(int index) async {
    if (_isDisposed || index < 0 || index >= videoList.length) return false;

    // Tăng số lần thử lại
    _retryAttempts[index] = (_retryAttempts[index] ?? 0) + 1;

    try {
      final url = videoList[index];
      final newController =
          await videoControllerService.getControllerForVideo(url, isCaching);
      if (newController != null) {
        await videoPlayerControllerList[index].pause();
        videoPlayerControllerList[index].dispose();
        videoPlayerControllerList[index] = newController;
        await newController.initialize();
        await newController.play();
        _retryAttempts.remove(index); // Reset số lần thử khi thành công
        videoPlayerControllerList.refresh();
        return true;
      } else {
        if (_retryAttempts[index]! >= 2) {
          // Nếu thử lại 2 lần vẫn lỗi
          await removeInvalidVideo(index);
        }
        return false;
      }
    } catch (e) {
      log('Error retrying video at index $index: $e');
      if (_retryAttempts[index]! >= 2) {
        await removeInvalidVideo(index);
      }
      return false;
    }
  }

  Future<void> removeInvalidVideo(int index) async {
    if (index < 0 || index >= videoList.length) return;
    log('Removing invalid video at index $index: ${videoList[index]}');
    videoPlayerControllerList[index].dispose();
    videoPlayerControllerList.removeAt(index);
    videoList.removeAt(index);
    pageCount.value = videoList.length;
    videoPlayerControllerList.refresh();
  }

  void safeAnimationStop() {
    if (!_isDisposed) {
      try {
        animationController.stop();
      } catch (e) {
        log('Error stopping animationController: $e');
      }
    }
  }

  void safeAnimationRepeat() {
    if (!_isDisposed) {
      try {
        animationController.repeat();
      } catch (e) {
        log('Error repeating animationController: $e');
      }
    }
  }
}

```

---


### Pages\Society\Reels\whitecodel\whitecodel_reels_page.dart

```dart
import 'dart:async';
import 'dart:convert';
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:tictactoe_gameapp/Configs/assets_path.dart';
import 'package:tictactoe_gameapp/Configs/messages.dart';
import 'package:tictactoe_gameapp/Pages/Society/Reels/reel_controller.dart';
import 'package:tictactoe_gameapp/Pages/Society/Reels/reel_model.dart';
import 'package:tictactoe_gameapp/Pages/Society/Reels/whitecodel/video_full_screen_widget.dart';
import 'package:tictactoe_gameapp/Pages/Society/Reels/whitecodel/whitecodel_reels_controller.dart';
import 'package:video_player/video_player.dart';
import 'package:visibility_detector/visibility_detector.dart';

class WhiteCodelReelsPage extends StatefulWidget {
  final List<ReelModel>? reels;
  final String? singleVideoUrl;
  final String? reelThumbnail;
  final bool isCaching;
  final int startIndex;
  final ReelController? reelController;
  final Widget Function(
    BuildContext context,
    int index,
    Widget child,
    VideoPlayerController videoPlayerController,
    PageController pageController,
    StreamController<double> videoProgressController,
  )? builder;

  const WhiteCodelReelsPage({
    super.key,
    this.singleVideoUrl,
    this.isCaching = false,
    this.builder,
    this.startIndex = 0,
    this.reelController,
    this.reelThumbnail,
    this.reels,
  });

  @override
  State<WhiteCodelReelsPage> createState() => _WhiteCodelReelsPageState();
}

class _WhiteCodelReelsPageState extends State<WhiteCodelReelsPage> {
  late final WhiteCodelReelsController controller;
  bool _isMounted = true;
  final Map<int, StreamController<double>> _progressControllers = {};
  final Map<int, Function()> _progressListeners = {};

  @override
  void initState() {
    super.initState();
    final tag = widget.singleVideoUrl != null
        ? 'whitecodel_reels_controller_${widget.singleVideoUrl.hashCode}'
        : 'whitecodel_reels_controller';

    Get.delete<WhiteCodelReelsController>(tag: tag, force: true);
    if (Get.isRegistered<WhiteCodelReelsController>(tag: tag)) {
      controller = Get.find<WhiteCodelReelsController>(tag: tag);
    } else {
      controller = Get.put(
        WhiteCodelReelsController(
          reelsVideoList: widget.reels?.map((e) => e.videoUrl!).toList() ??
              (widget.singleVideoUrl != null ? [widget.singleVideoUrl!] : []),
          isCaching: widget.isCaching,
          startIndex: widget.startIndex,
        ),
        tag: tag,
      );
    }
  }

  @override
  void dispose() {
    _isMounted = false;
    _progressListeners.forEach((index, listener) {
      if (index < controller.videoPlayerControllerList.length) {
        controller.videoPlayerControllerList[index].removeListener(listener);
      }
    });
    _progressControllers.forEach((_, controller) => controller.close());
    final tag = widget.singleVideoUrl != null
        ? 'whitecodel_reels_controller_${widget.singleVideoUrl.hashCode}'
        : 'whitecodel_reels_controller';
    Get.delete<WhiteCodelReelsController>(tag: tag, force: true);
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: Colors.black,
      body: Obx(() {
        final itemCount = controller.isFetchingMore.value
            ? controller.videoPlayerControllerList.length + 1
            : controller.videoPlayerControllerList.length;
        return PageView.builder(
          controller: controller.pageController,
          itemCount: itemCount,
          scrollDirection: Axis.vertical,
          onPageChanged: (index) async {
            try {
              if (index < 0 ||
                  index >= controller.videoPlayerControllerList.length) return;
              for (var i = 0;
                  i < controller.videoPlayerControllerList.length;
                  i++) {
                if (i != index &&
                    controller
                        .videoPlayerControllerList[i].value.isInitialized) {
                  await controller.videoPlayerControllerList[i].pause();
                }
              }
              final currentController =
                  controller.videoPlayerControllerList[index];
              if (currentController.dataSource.isNotEmpty &&
                  !currentController.value.isInitialized) {
                await currentController.initialize();
              }
              if (currentController.value.isInitialized) {
                await currentController.play();
              }
              if (widget.reelController != null) {
                controller.checkAndFetchMoreReels(
                    reelController: widget.reelController!,
                    currentIndex: index);
              }
            } catch (e) {
              print("Error switching page: $e");
            }
          },
          itemBuilder: (context, index) {
            if (index < controller.videoPlayerControllerList.length) {
              return _buildTile(index);
            } else {
              return const Center(
                  child: CircularProgressIndicator(color: Colors.white));
            }
          },
        );
      }),
    );
  }

  Widget _buildTile(int index) {
    final reel = widget.reels != null && index < widget.reels!.length
        ? widget.reels![index]
        : null;
    final vpController = controller.videoPlayerControllerList[index];

    if (vpController.dataSource.isEmpty ||
        (!vpController.value.isInitialized && !controller.loading.value)) {
      return Center(
        child: Container(
          width: double.infinity,
          height: double.infinity,
          decoration: reel?.thumbnailUrl != null
              ? BoxDecoration(
                  image: DecorationImage(
                    image: MemoryImage(base64Decode(reel!.thumbnailUrl!)),
                    fit: BoxFit.cover,
                    colorFilter: ColorFilter.mode(
                        Colors.black.withOpacity(0.5), BlendMode.dstATop),
                  ),
                )
              : const BoxDecoration(color: Colors.black),
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              const Icon(Icons.error_outline, color: Colors.white, size: 50),
              const SizedBox(height: 10),
              const Text(
                "Failed to load video",
                style: TextStyle(color: Colors.white, fontSize: 16),
              ),
              const SizedBox(height: 10),
              ElevatedButton(
                onPressed: () async {
                  controller.loading.value = true;
                  final success = await controller.retryInitializeVideo(index);
                  controller.loading.value = false;
                  if (success) {
                    successMessage("Video loaded successfully");
                  } else {
                    errorMessage("Failed to reload video. It may be invalid.");
                  }
                },
                style: ElevatedButton.styleFrom(
                  foregroundColor: Colors.white,
                  backgroundColor: Colors.pinkAccent,
                ),
                child: const Text("Retry"),
              ),
            ],
          ),
        ),
      );
    }

    return VisibilityDetector(
      key: Key('reel_tile_$index'),
      onVisibilityChanged: (visibilityInfo) async {
        if (!_isMounted ||
            index < 0 ||
            index >= controller.videoPlayerControllerList.length) return;
        await Future.delayed(const Duration(milliseconds: 100));
        if (!_isMounted) return;

        final vpController = controller.videoPlayerControllerList[index];
        if (visibilityInfo.visibleFraction < 0.5) {
          if (vpController.value.isInitialized) {
            await vpController.seekTo(Duration.zero);
            await vpController.pause();
          }
          controller.safeAnimationStop();
        } else {
          if (vpController.value.isInitialized) {
            await vpController.play();
          }
          controller.listenEvents(index);
          await controller.initNearByVideos(index);
          if (!controller.caching.contains(controller.videoList[index])) {
            await controller.cacheVideo(index);
          }
          controller.safeAnimationRepeat();
        }
      },
      child: GestureDetector(
        onTap: () async {
          if (index < 0 || index >= controller.videoPlayerControllerList.length)
            return;
          if (vpController.value.isInitialized) {
            if (vpController.value.isPlaying) {
              await vpController.pause();
              controller.visible.value = true;
              controller.safeAnimationStop();
            } else {
              await vpController.play();
              controller.visible.value = false;
              controller.safeAnimationRepeat();
            }
          }
        },
        child: Obx(() {
          if (index < 0 ||
              index >= controller.videoPlayerControllerList.length) {
            return const Center(child: Text("Error: Invalid index"));
          }
          if (controller.loading.value) {
            return reel?.thumbnailUrl != null
                ? Image.memory(
                    base64Decode(reel!.thumbnailUrl!),
                    fit: BoxFit.cover,
                    width: double.infinity,
                    height: double.infinity,
                    errorBuilder: (context, error, stackTrace) {
                      return Container(
                        width: double.infinity,
                        height: double.infinity,
                        decoration: const BoxDecoration(
                          image: DecorationImage(
                            image: AssetImage(GifsPath.loadingGif2),
                            fit: BoxFit.cover,
                          ),
                        ),
                      );
                    },
                  )
                : Container(
                    width: double.infinity,
                    height: double.infinity,
                    decoration: const BoxDecoration(
                      image: DecorationImage(
                        image: AssetImage(GifsPath.loadingGif2),
                        fit: BoxFit.cover,
                      ),
                    ),
                  );
          }
          if (!_progressControllers.containsKey(index)) {
            _progressControllers[index] = StreamController<double>.broadcast();
            void listener() {
              if (vpController.value.isInitialized && _isMounted) {
                double videoProgress =
                    vpController.value.position.inMilliseconds /
                        (vpController.value.duration.inMilliseconds > 0
                            ? vpController.value.duration.inMilliseconds
                            : 1);
                _progressControllers[index]!.add(videoProgress.clamp(0.0, 1.0));
              }
            }

            _progressListeners[index] = listener;
            vpController.addListener(listener);
          }

          Widget videoWidget = VideoFullScreenWidget(
            videoPlayerController: vpController,
            controller: controller,
          );
          return widget.builder == null
              ? videoWidget
              : widget.builder!(
                  context,
                  index,
                  videoWidget,
                  vpController,
                  controller.pageController,
                  _progressControllers[index]!,
                );
        }),
      ),
    );
  }
}

```

---


### Pages\Society\Widgets\create_post_page.dart

```dart
import 'dart:io';
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:giphy_picker/giphy_picker.dart';
import 'package:image_picker/image_picker.dart';
import 'package:tictactoe_gameapp/Components/belong_to_users/avatar_user_widget.dart';
import 'package:tictactoe_gameapp/Components/gifphy/preview_gif_widget.dart';
import 'package:tictactoe_gameapp/Configs/assets_path.dart';
import 'package:tictactoe_gameapp/Configs/constants.dart';
import 'package:tictactoe_gameapp/Models/Functions/color_string_reverse_function.dart';
import 'package:tictactoe_gameapp/Models/user_model.dart';
import 'package:tictactoe_gameapp/Pages/Society/Widgets/optional_tile_custom.dart';
import 'package:tictactoe_gameapp/Pages/Society/social_post_controller.dart';
import 'package:tictactoe_gameapp/Pages/Society/Widgets/post_polls/create_polls_inpost_page.dart';
import 'package:tictactoe_gameapp/Pages/Society/Widgets/post_polls/post_polls_model.dart';
import 'package:tictactoe_gameapp/Pages/Society/Widgets/post_polls/post_polls_card.dart';

class CreatePostPage extends StatelessWidget {
  final PostController postController;
  final UserModel userModel;
  const CreatePostPage(
      {super.key, required this.userModel, required this.postController});

  @override
  Widget build(BuildContext context) {
    final ThemeData theme = Theme.of(context);
    RxString postContent = "".obs;
    RxString audienceMode = "Public".obs;
    RxList<Color> backgroundPost = <Color>[].obs;
    RxList<String>? imagePath = <String>[].obs;
    var selectedGif = Rx<GiphyGif?>(null); // Quản lý GIF đã chọn
    List<XFile>? images;
    XFile? image;
    var postPollsModel = Rx<PostPollsModel?>(null);
    return Scaffold(
      appBar: AppBar(
        leading: IconButton(
          onPressed: () => Get.back(),
          icon: const Icon(
            Icons.arrow_back,
            size: 40,
            color: Colors.deepPurple,
          ),
        ),
        centerTitle: false,
        title: Text(
          "Create a new post",
          style: theme.textTheme.headlineMedium,
        ),
        actions: [
          Obx(
            () => postContent.value.isEmpty || postContent.value == ""
                ? Container(
                    height: 50,
                    width: 100,
                    alignment: Alignment.center,
                    decoration: BoxDecoration(
                      color: Colors.grey,
                      borderRadius: BorderRadius.circular(10),
                    ),
                    child: Text(
                      "POST",
                      style: theme.textTheme.bodyLarge!
                          .copyWith(color: Colors.black45),
                    ),
                  )
                : InkWell(
                    onTap: () async {
                      await Get.showOverlay(
                          asyncFunction: () async {
                            await postController.createPost(
                              content: postContent.value,
                              user: userModel,
                              backgroundPost: backgroundPost
                                  .toList()
                                  .map((color) =>
                                      ColorStringReverseFunction.colorToHex(
                                          color))
                                  .toList(),
                              privacy: audienceMode.value,
                              imageFiles: images,
                              gifUrl: selectedGif.value?.images.original!.url,
                              postPollsModel: postPollsModel.value,
                            );
                          },
                          loadingWidget: Center(
                            child: ClipRRect(
                              borderRadius: BorderRadius.circular(100),
                              child: Image.asset(
                                GifsPath.loadingGif,
                                width: 200,
                                height: 200,
                              ),
                            ),
                          )).then((_) {
                        Get.toNamed("mainHome");
                      });
                    },
                    child: Ink(
                      height: 50,
                      width: 100,
                      decoration: BoxDecoration(
                        color: Colors.blueAccent,
                        borderRadius: BorderRadius.circular(10),
                      ),
                      child: Center(
                        child: Text(
                          "POST",
                          style: theme.textTheme.bodyLarge!
                              .copyWith(color: Colors.white),
                        ),
                      ),
                    ),
                  ),
          ),
          const SizedBox(
            width: 10,
          ),
        ],
      ),
      body: Padding(
        padding: const EdgeInsets.all(10.0),
        child: SingleChildScrollView(
          child: Column(
            children: [
              Row(
                children: [
                  AvatarUserWidget(
                    radius: 35,
                    imagePath: userModel.image!,
                    gradientColors: userModel.avatarFrame,
                  ),
                  const SizedBox(width: 10),
                  Expanded(
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Text(
                          userModel.name!,
                          style: theme.textTheme.headlineMedium,
                        ),
                        const SizedBox(
                          height: 10,
                        ),
                        SingleChildScrollView(
                          scrollDirection: Axis.horizontal,
                          child: Row(
                            children: [
                              GestureDetector(
                                  onTap: () {
                                    audienceMode.value = "Private";
                                  },
                                  child: Obx(
                                    () => Container(
                                      height: 40,
                                      width: 100,
                                      margin: const EdgeInsets.only(right: 10),
                                      alignment: Alignment.center,
                                      decoration: BoxDecoration(
                                        color: audienceMode.value == "Private"
                                            ? Colors.blueAccent
                                            : Colors.grey.shade400,
                                        borderRadius: BorderRadius.circular(10),
                                      ),
                                      child: Row(
                                        mainAxisAlignment:
                                            MainAxisAlignment.center,
                                        children: [
                                          Icon(
                                            Icons.person,
                                            color:
                                                audienceMode.value == "Private"
                                                    ? Colors.white
                                                    : Colors.black,
                                          ),
                                          const SizedBox(width: 5),
                                          Text(
                                            "Private",
                                            style: theme.textTheme.bodyMedium!
                                                .copyWith(
                                              color: audienceMode.value ==
                                                      "Private"
                                                  ? Colors.white
                                                  : Colors.black,
                                            ),
                                          ),
                                        ],
                                      ),
                                    ),
                                  )),
                              GestureDetector(
                                onTap: () {
                                  audienceMode.value = "Friends";
                                },
                                child: Obx(() => Container(
                                      height: 40,
                                      width: 100,
                                      margin: const EdgeInsets.only(right: 10),
                                      alignment: Alignment.center,
                                      decoration: BoxDecoration(
                                        color: audienceMode.value == "Friends"
                                            ? Colors.blueAccent
                                            : Colors.grey.shade400,
                                        borderRadius: BorderRadius.circular(10),
                                      ),
                                      child: Row(
                                        mainAxisAlignment:
                                            MainAxisAlignment.center,
                                        children: [
                                          Icon(
                                            Icons.people_alt_rounded,
                                            color:
                                                audienceMode.value == "Friends"
                                                    ? Colors.white
                                                    : Colors.black,
                                          ),
                                          const SizedBox(width: 5),
                                          Text(
                                            "Friends",
                                            style: theme.textTheme.bodyMedium!
                                                .copyWith(
                                              color: audienceMode.value ==
                                                      "Friends"
                                                  ? Colors.white
                                                  : Colors.black,
                                            ),
                                          ),
                                        ],
                                      ),
                                    )),
                              ),
                              GestureDetector(
                                onTap: () {
                                  audienceMode.value = "Public";
                                },
                                child: Obx(() => Container(
                                      height: 40,
                                      width: 100,
                                      margin: const EdgeInsets.only(right: 10),
                                      alignment: Alignment.center,
                                      decoration: BoxDecoration(
                                        color: audienceMode.value == "Public"
                                            ? Colors.blueAccent
                                            : Colors.grey.shade400,
                                        borderRadius: BorderRadius.circular(10),
                                      ),
                                      child: Row(
                                        mainAxisAlignment:
                                            MainAxisAlignment.center,
                                        children: [
                                          Icon(
                                            Icons.public,
                                            color:
                                                audienceMode.value == "Public"
                                                    ? Colors.white
                                                    : Colors.black,
                                          ),
                                          const SizedBox(width: 5),
                                          Text(
                                            "Public",
                                            style: theme.textTheme.bodyMedium!
                                                .copyWith(
                                              color:
                                                  audienceMode.value == "Public"
                                                      ? Colors.white
                                                      : Colors.black,
                                            ),
                                          ),
                                        ],
                                      ),
                                    )),
                              ),
                            ],
                          ),
                        ),
                      ],
                    ),
                  ),
                ],
              ),
              const SizedBox(
                height: 20,
              ),
              Obx(() => Container(
                    height: 300,
                    decoration: BoxDecoration(
                      gradient: LinearGradient(
                        colors: backgroundPost.isEmpty
                            ? [Colors.white, Colors.white]
                            // ignore: invalid_use_of_protected_member
                            : backgroundPost.value,
                        begin: Alignment.topLeft,
                        end: Alignment.bottomRight,
                      ),
                      borderRadius: BorderRadius.circular(20),
                    ),
                    child: TextField(
                      onChanged: (text) {
                        if (text.isNotEmpty) {
                          postContent.value = text;
                        } else {
                          postContent.value = "";
                        }
                      },
                      minLines: null,
                      maxLines: null,
                      expands: true,
                      textAlign: TextAlign.left,
                      textAlignVertical: TextAlignVertical.top,
                      decoration: InputDecoration(
                        fillColor: Colors.transparent,
                        labelText: '  What\'s on your mind?',
                        alignLabelWithHint: true,
                        labelStyle: theme.textTheme.bodyLarge!.copyWith(
                            color: backgroundPost.isEmpty
                                ? Colors.grey
                                : Colors.white),
                        border: OutlineInputBorder(
                          borderRadius: BorderRadius.circular(20),
                          borderSide: const BorderSide(
                            color: Colors.blueAccent,
                          ),
                        ),
                      ),
                    ),
                  )),
              const SizedBox(
                height: 10,
              ),
              SizedBox(
                height: 50,
                child: ListView.builder(
                    scrollDirection: Axis.horizontal,
                    itemCount: gradientColors.length,
                    itemBuilder: (context, index) {
                      return Row(
                        children: [
                          InkWell(
                            borderRadius: BorderRadius.circular(10),
                            onTap: () {
                              backgroundPost.value = gradientColors[index];
                            },
                            child: Ink(
                              width: 50,
                              decoration: BoxDecoration(
                                borderRadius: BorderRadius.circular(10),
                                gradient: LinearGradient(
                                  colors: gradientColors[index],
                                  begin: Alignment.topLeft,
                                  end: Alignment.bottomRight,
                                ),
                              ),
                            ),
                          ),
                          const SizedBox(
                            width: 10,
                          ),
                        ],
                      );
                    }),
              ),
              const SizedBox(
                height: 10,
              ),
              Obx(() {
                if (imagePath.isEmpty) {
                  return const SizedBox();
                }
                return Column(
                  mainAxisAlignment: MainAxisAlignment.center,
                  crossAxisAlignment: CrossAxisAlignment.center,
                  children: [
                    SizedBox(
                        height: 150,
                        child: ListView.builder(
                            scrollDirection: Axis.horizontal,
                            physics: const BouncingScrollPhysics(),
                            itemCount: imagePath.length,
                            itemBuilder: (context, index) {
                              return Padding(
                                padding:
                                    const EdgeInsets.symmetric(horizontal: 10),
                                child: Stack(
                                  clipBehavior: Clip.none,
                                  children: [
                                    ClipRRect(
                                      borderRadius: BorderRadius.circular(10),
                                      child: Image.file(
                                        File(
                                          imagePath[index],
                                        ),
                                        fit: BoxFit.cover,
                                      ),
                                    ),
                                    Positioned(
                                      top: -20,
                                      right: -20,
                                      child: IconButton(
                                        onPressed: () {
                                          imagePath.removeAt(index);
                                        },
                                        icon: const Icon(
                                          Icons.cancel,
                                          size: 28,
                                          color: Colors.red,
                                        ),
                                      ),
                                    ),
                                  ],
                                ),
                              );
                            })),
                    IconButton(
                      onPressed: () {
                        imagePath.clear();
                      },
                      icon:
                          const Icon(Icons.delete, size: 40, color: Colors.red),
                    ),
                  ],
                );
              }),
              GestureDetector(
                  onTap: () => selectedGif.value = null,
                  child: PreviewGifWidget(selectedGif: selectedGif)),
              const SizedBox(
                height: 10,
              ),
              Column(
                children: [
                  const Divider(
                    color: Colors.grey,
                  ),
                  OptionalTileWidget(
                    onTap: () async {
                      images = await postController.pickMultiImages();
                      if (images != null) {
                        imagePath.value =
                            images!.map((xFile) => xFile.path).toList();
                      } else {
                        imagePath.value = [];
                      }
                    },
                    title: "Image / Video",
                    icon: Icons.image,
                    color: Colors.green,
                  ),
                  const Divider(
                    color: Colors.grey,
                  ),
                  OptionalTileWidget(
                    onTap: () async {
                      image = await postController.pickImageCamera();
                      if (image != null) {
                        imagePath.add(image!.path);
                      } else {
                        imagePath.value = [];
                      }
                    },
                    title: "Catch up moments",
                    icon: Icons.camera_alt,
                    color: Colors.deepPurple,
                  ),
                  const Divider(
                    color: Colors.grey,
                  ),
                  Obx(() => postPollsModel.value != null
                      ? PostPollWidget(
                          postPollsModel: postPollsModel.value!,
                        )
                      : const SizedBox.shrink()),
                  OptionalTileWidget(
                    onTap: () async {
                      final PostPollsModel? result = await Get.to(
                        () => const CreatePollsInpostPage(),
                        transition: Transition.downToUp,
                      );
                      if (result != null) {
                        postPollsModel.value = result;
                      }
                    },
                    title: "Add Polls / Votes",
                    icon: Icons.person_add_alt_1_sharp,
                    color: Colors.blue,
                  ),
                  const Divider(
                    color: Colors.grey,
                  ),
                  OptionalTileWidget(
                    onTap: () async {
                      final gif = await GiphyPicker.pickGif(
                        context: context,
                        apiKey: apiGifphy,
                        showPreviewPage: false,
                        showGiphyAttribution: false,
                        loadingBuilder: (context) {
                          return Center(
                            child: ClipRRect(
                              borderRadius: BorderRadius.circular(100),
                              child: Image.asset(
                                GifsPath.loadingGif,
                                height: 200,
                                width: 200,
                              ),
                            ),
                          );
                        },
                      );

                      if (gif != null) {
                        selectedGif.value = gif;
                      }
                    },
                    title: "Feeling / Gifphy",
                    icon: Icons.emoji_emotions_outlined,
                    color: Colors.orange,
                  ),
                  const Divider(
                    color: Colors.grey,
                  ),
                  OptionalTileWidget(
                    onTap: () {},
                    title: "Check in",
                    icon: Icons.add_location_alt,
                    color: Colors.red,
                  ),
                ],
              ),
              const SizedBox(
                height: 20,
              ),
              Container(
                height: 50,
                width: double.maxFinite,
                alignment: Alignment.center,
                decoration: BoxDecoration(
                  color: Colors.grey,
                  borderRadius: BorderRadius.circular(10),
                ),
                child: Text(
                  "POST",
                  style: theme.textTheme.bodyLarge!
                      .copyWith(color: Colors.black45),
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }
}

```

---


### Pages\Society\Widgets\expandable_text_custom.dart

```dart
import 'package:flutter/gestures.dart';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_animate/flutter_animate.dart';
import 'package:get/get.dart';
import 'package:tictactoe_gameapp/Configs/messages.dart';
import 'package:tictactoe_gameapp/Models/Functions/hyperlink_text_function.dart';

class ExpandableContent extends StatelessWidget {
  final String content;
  final int maxLines;
  final TextStyle style;
  final bool isAligCenter;

  const ExpandableContent({
    super.key,
    required this.content,
    this.maxLines = 5,
    required this.style,
    this.isAligCenter = false,
  });
  @override
  Widget build(BuildContext context) {
    RxBool isExpanded = false.obs;

    return LayoutBuilder(
      builder: (context, constraints) {
        // Kiểm tra overflow dựa trên số dòng
        final TextPainter textPainter = TextPainter(
          text: TextSpan(text: content, style: style),
          maxLines: maxLines,
          textDirection: TextDirection.ltr,
        )..layout(maxWidth: constraints.maxWidth);

        final bool isOverflowing = textPainter.didExceedMaxLines;

        return Obx(() {
          if (!isOverflowing || isExpanded.value) {
            // Hiển thị toàn bộ nội dung khi mở rộng
            return GestureDetector(
              onTap: () {
                isExpanded.value = !isExpanded.value;
              },
              onLongPress: () async =>
                  await Clipboard.setData(ClipboardData(text: content)).then(
                (value) => successMessage('Copied to Clipboard'),
              ),
              child: Text.rich(
                TextSpan(children: [
                  HyperlinkTextFunction.parseContent(
                    content: content,
                    defaultStyle: style,
                    linkColor: Colors.deepPurpleAccent,
                    tagColor: Colors.black,
                  ),
                  isExpanded.value
                      ? TextSpan(
                          text: '\n Show less',
                          style: style.copyWith(color: Colors.blue),
                          recognizer: TapGestureRecognizer()
                            ..onTap = () {
                              isExpanded.value = !isExpanded.value;
                            },
                        )
                      : const TextSpan(),
                ]),
                textAlign: isAligCenter ? TextAlign.center : TextAlign.start,
                maxLines: isExpanded.value ? null : maxLines,
              ).animate().fadeIn(duration: const Duration(milliseconds: 750)),
            );
          } else {
            // Thu gọn nội dung
            final truncatedText = _getTruncatedTextByBinary(
              textPainter,
              content,
              constraints.maxWidth,
            );

            return GestureDetector(
              onTap: () {
                isExpanded.value = !isExpanded.value;
              },
              onLongPress: () async =>
                  await Clipboard.setData(ClipboardData(text: content)).then(
                (value) => successMessage('Copied to Clipboard'),
              ),
              child: Text.rich(
                TextSpan(
                  children: [
                    HyperlinkTextFunction.parseContent(
                      content: truncatedText,
                      defaultStyle: style,
                      linkColor: Colors.blue,
                      tagColor: Colors.green,
                    ),
                    TextSpan(
                      text: ' ...',
                      style: style.copyWith(
                        fontWeight: FontWeight.bold,
                        fontStyle: FontStyle.italic,
                      ),
                    ),
                    TextSpan(
                      text: ' Show more',
                      style: style.copyWith(
                        color: Colors.blueAccent,
                        fontWeight: FontWeight.w400,
                        fontStyle: FontStyle.italic,
                      ),
                      recognizer: TapGestureRecognizer()
                        ..onTap = () {
                          isExpanded.value = !isExpanded.value;
                        },
                    ),
                  ],
                ),
                textAlign: isAligCenter ? TextAlign.center : TextAlign.start,
              ),
            );
          }
        });
      },
    );
  }

  String _getTruncatedTextByBinary(
      TextPainter textPainter, String content, double maxWidth) {
    int start = 0;
    int end = content.length;
    String truncatedText = '';

    while (start <= end) {
      int mid = (start + end) ~/ 2;
      final testText = content.substring(0, mid);

      final testPainter = TextPainter(
        text: TextSpan(text: testText, style: style),
        maxLines: maxLines,
        textDirection: TextDirection.ltr,
      )..layout(maxWidth: maxWidth);

      if (testPainter.didExceedMaxLines) {
        end = mid - 1; // Cắt ngắn hơn
      } else {
        truncatedText = testText; // Lưu kết quả
        start = mid + 1; // Mở rộng văn bản
      }
    }

    return truncatedText.trim();
  }

  //   double _calculateFontSize() {
  //   if (text.length < 50) {
  //     return 25.0; // Văn bản ngắn, chữ lớn hơn
  //   } else if (text.length < 500) {
  //     return 20.0; // Văn bản trung bình, chữ vừa
  //   } else if (text.length < 2000) {
  //     return 17.0; // Văn bản trung bình, chữ vừa
  //   } else {
  //     return 16.0;
  //   }
  // }
}

```

---


### Pages\Society\Widgets\like_user_list_sheet.dart

```dart
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:tictactoe_gameapp/Components/belong_to_users/avatar_user_widget.dart';
import 'package:tictactoe_gameapp/Models/user_model.dart';
import 'package:tictactoe_gameapp/Pages/Society/About/user_about_page.dart';

class LikeUserListSheet extends StatelessWidget {
  final List<UserModel> likeUsers;
  final ScrollController scrollController;
  const LikeUserListSheet(
      {super.key, required this.likeUsers, required this.scrollController});

  @override
  Widget build(BuildContext context) {
    final ThemeData theme = Theme.of(context);
    return Padding(
      padding: const EdgeInsets.all(10.0),
      child: Column(
        children: [
          Row(
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            children: [
              IconButton(
                onPressed: () {
                  Get.back();
                },
                icon: const Icon(
                  Icons.arrow_back,
                  size: 35,
                ),
              ),
              Text(
                'People liked post',
                style: theme.textTheme.headlineMedium,
              ),
              IconButton(
                onPressed: () {
                  scrollController.animateTo(0,
                      duration: const Duration(seconds: 1),
                      curve: Curves.bounceInOut);
                },
                icon: const Icon(
                  Icons.refresh_outlined,
                  size: 35,
                  color: Colors.blue,
                ),
              ),
            ],
          ),
          const Divider(
            color: Colors.blueGrey,
          ),
          Expanded(
            child: ListView.builder(
                itemCount: likeUsers.length,
                physics: const BouncingScrollPhysics(),
                itemBuilder: (context, index) {
                  UserModel likeUser = likeUsers[index];
                  return Padding(
                    padding: const EdgeInsets.all(10.0),
                    child: Row(
                      children: [
                        Container(
                          decoration: BoxDecoration(
                            borderRadius: BorderRadius.circular(100),
                            border: Border.all(color: Colors.blue, width: 3),
                          ),
                          child: GestureDetector(
                            onTap: () {
                              Get.to(
                                  UserAboutPage(
                                    unknownableUser: likeUser,
                                  ),
                                  transition: Transition.leftToRightWithFade);
                            },
                            child: AvatarUserWidget(
                              radius: 30,
                              imagePath: likeUser.image!,
                              gradientColors: likeUser.avatarFrame,
                            ),
                          ),
                        ),
                        const SizedBox(
                          width: 10,
                        ),
                        Expanded(
                          child: Column(
                            crossAxisAlignment: CrossAxisAlignment.start,
                            children: [
                              Text(
                                likeUser.name!,
                                style: theme.textTheme.bodyLarge,
                              ),
                              Text(
                                likeUser.email!,
                                style: theme.textTheme.bodyMedium,
                              ),
                            ],
                          ),
                        ),
                        ElevatedButton(
                            onPressed: () {},
                            style: ElevatedButton.styleFrom(
                              backgroundColor: Colors.blue,
                              foregroundColor: Colors.white,
                              shadowColor: Colors.redAccent,
                              elevation: 5,
                            ),
                            child: const Row(
                              children: [
                                Icon(Icons.person_add),
                                SizedBox(
                                  width: 10,
                                ),
                                Text("Add Friend"),
                              ],
                            )),
                      ],
                    ),
                  );
                }),
          )
        ],
      ),
    );
  }
}

```

---


### Pages\Society\Widgets\notification_badge_custom.dart

```dart
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:flutter/material.dart';

class NotificationBadge extends StatelessWidget {
  final String userId;

  const NotificationBadge({super.key, required this.userId});

  @override
  Widget build(BuildContext context) {
    return StreamBuilder<int>(
      stream: _unreadNotificationCountStream(),
      builder: (context, snapshot) {
        if (!snapshot.hasData) {
          // Trường hợp chưa tải được dữ liệu từ Firestore
          return const Icon(Icons.notifications);
        }

        int unreadCount = snapshot.data!;
        return _buildNotificationIcon(unreadCount);
      },
    );
  }

  // Hàm để tạo Stream đếm số lượng thông báo chưa đọc
  Stream<int> _unreadNotificationCountStream() {
    return FirebaseFirestore.instance
        .collection("notifications")
        .where("receiverId", isEqualTo: userId)
        .where("isReaded", isEqualTo: false) // Chỉ lấy thông báo chưa đọc
        .snapshots()
        .map((snapshot) => snapshot.docs.length);
  }

  // Hàm dựng giao diện UI với badge cho số lượng thông báo chưa đọc
  Widget _buildNotificationIcon(int unreadCount) {
    return Stack(
      children: [
        const Icon(Icons.notifications),
        if (unreadCount > 0) // Chỉ hiển thị badge nếu có thông báo chưa đọc
          Positioned(
            right: 0,
            child: Container(
              padding: const EdgeInsets.all(4),
              decoration: const BoxDecoration(
                color: Colors.red,
                shape: BoxShape.circle,
              ),
              constraints: const BoxConstraints(
                minWidth: 18,
                minHeight: 18,
              ),
              child: Text(
                unreadCount > 9 ? "9+" : unreadCount.toString(),
                style: const TextStyle(
                  color: Colors.white,
                  fontSize: 12,
                ),
                textAlign: TextAlign.center,
              ),
            ),
          ),
      ],
    );
  }
}

```

---


### Pages\Society\Widgets\optional_tile_custom.dart

```dart
import 'package:flutter/material.dart';

class OptionalTileWidget extends StatelessWidget {
  final IconData icon;
  final Function() onTap;
  final String title;
  final Color color;
  const OptionalTileWidget(
      {super.key,
      required this.icon,
      required this.title,
      required this.onTap,
      required this.color});

  @override
  Widget build(BuildContext context) {
    return InkWell(
      borderRadius: BorderRadius.circular(10),
      onTap: onTap,
      child: SizedBox(
        height: 50,
        child: Row(
          children: [
            Icon(
              icon,
              size: 40,
              color: color,
            ),
            const SizedBox(
              width: 10,
            ),
            Expanded(
              child: Text(
                title,
                style: const TextStyle(
                  color: Colors.black,
                  fontSize: 18,
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }
}

```

---


### Pages\Society\Widgets\post_edit_model.dart

```dart
import 'package:flutter/material.dart';

/// Các loại hành động
enum PostEditActionType {
  interested,
  notInterested,
  savePost,
  editPost,
  deletePost,
  reportPost,
  addImageOrVideo,
  formatText,
  replyToComment,
}

/// Enum để xác định kiểu nội dung: post hoặc reel
enum PostType {
  post,
  reel,
}

class PostEditModel {
  final IconData icon;
  final String title;
  final String description;
  final PostEditActionType actionType;
  final VoidCallback? callback;

  PostEditModel({
    required this.icon,
    required this.title,
    required this.description,
    required this.actionType,
    this.callback,
  });

  /// Phương thức copyWith để gán callback mới khi cần.
  PostEditModel copyWith({VoidCallback? callback}) {
    return PostEditModel(
      icon: icon,
      title: title,
      description: description,
      actionType: actionType,
      callback: callback ?? this.callback,
    );
  }

  /// Danh sách model dành cho Post (mặc định)
  static final List<PostEditModel> listPostEditModels = [
    PostEditModel(
      icon: Icons.add_circle_rounded,
      title: 'Interested',
      description: 'More suggested posts in your Feed will be like this',
      actionType: PostEditActionType.interested,
    ),
    PostEditModel(
      icon: Icons.remove_circle,
      title: 'Not interested',
      description: 'Less suggested posts in your Feed will be like this',
      actionType: PostEditActionType.notInterested,
    ),
    PostEditModel(
      icon: Icons.save_alt,
      title: 'Save Post',
      description: 'Add this to your saved posts',
      actionType: PostEditActionType.savePost,
    ),
    PostEditModel(
      icon: Icons.edit,
      title: 'Edit Post',
      description: 'Update the details of your post',
      actionType: PostEditActionType.editPost,
    ),
    PostEditModel(
      icon: Icons.delete,
      title: 'Delete Post',
      description: 'Delete your post forever',
      actionType: PostEditActionType.deletePost,
    ),
    PostEditModel(
      icon: Icons.report_problem,
      title: 'Report Post',
      description: 'Submit a report about the post',
      actionType: PostEditActionType.reportPost,
    ),
    PostEditModel(
      icon: Icons.add_circle,
      title: 'Add Image/Video',
      description: 'Attach images or videos to your post',
      actionType: PostEditActionType.addImageOrVideo,
    ),
    PostEditModel(
      icon: Icons.text_format,
      title: 'Format Text',
      description: 'Format your text in different styles',
      actionType: PostEditActionType.formatText,
    ),
    PostEditModel(
      icon: Icons.reply,
      title: 'Reply to Comment',
      description: 'Reply to a comment on your post',
      actionType: PostEditActionType.replyToComment,
    ),
  ];

  /// Danh sách model dành cho Reel với các text được chuyển đổi (post -> reel)
  static final List<PostEditModel> listReelEditModels = [
    PostEditModel(
      icon: Icons.add_circle_rounded,
      title: 'Interested',
      description: 'More suggested reels in your Feed will be like this',
      actionType: PostEditActionType.interested,
    ),
    PostEditModel(
      icon: Icons.remove_circle,
      title: 'Not interested',
      description: 'Less suggested reels in your Feed will be like this',
      actionType: PostEditActionType.notInterested,
    ),
    PostEditModel(
      icon: Icons.save_alt,
      title: 'Save Reel',
      description: 'Add this to your saved reels',
      actionType: PostEditActionType.savePost,
    ),
    PostEditModel(
      icon: Icons.edit,
      title: 'Edit Reel',
      description: 'Update the details of your reel',
      actionType: PostEditActionType.editPost,
    ),
    PostEditModel(
      icon: Icons.delete,
      title: 'Delete Reel',
      description: 'Delete your reel forever',
      actionType: PostEditActionType.deletePost,
    ),
    PostEditModel(
      icon: Icons.report_problem,
      title: 'Report Reel',
      description: 'Submit a report about the reel',
      actionType: PostEditActionType.reportPost,
    ),
    PostEditModel(
      icon: Icons.add_circle,
      title: 'Add Image/Video',
      description: 'Attach images or videos to your reel',
      actionType: PostEditActionType.addImageOrVideo,
    ),
    PostEditModel(
      icon: Icons.text_format,
      title: 'Format Text',
      description: 'Format your text in different styles',
      actionType: PostEditActionType.formatText,
    ),
    PostEditModel(
      icon: Icons.reply,
      title: 'Reply to Comment',
      description: 'Reply to a comment on your reel',
      actionType: PostEditActionType.replyToComment,
    ),
  ];
}

```

---


### Pages\Society\Widgets\post_edit_sheet.dart

```dart
import 'package:flutter/material.dart';
import 'post_edit_model.dart';

class PostEditSheet extends StatelessWidget {
  final ScrollController scrollController;
  final PostType postType;

  // Các callback cho từng hành động (có thể null)
  final VoidCallback? onInterested;
  final VoidCallback? onNotInterested;
  final VoidCallback? onSavePost;
  final VoidCallback? onEditPost;
  final VoidCallback? onDeletePost;
  final VoidCallback? onReportPost;
  final VoidCallback? onAddImageOrVideo;
  final VoidCallback? onFormatText;
  final VoidCallback? onReplyToComment;

  const PostEditSheet({
    super.key,
    required this.scrollController,
    required this.postType,
    this.onInterested,
    this.onNotInterested,
    this.onSavePost,
    this.onEditPost,
    this.onDeletePost,
    this.onReportPost,
    this.onAddImageOrVideo,
    this.onFormatText,
    this.onReplyToComment,
  });

  /// Tùy chọn danh sách model theo kiểu post hoặc reel
  List<PostEditModel> get updatedModels {
    List<PostEditModel> baseList = postType == PostType.reel
        ? PostEditModel.listReelEditModels
        : PostEditModel.listPostEditModels;
    return baseList.map((model) {
      switch (model.actionType) {
        case PostEditActionType.interested:
          return model.copyWith(callback: onInterested);
        case PostEditActionType.notInterested:
          return model.copyWith(callback: onNotInterested);
        case PostEditActionType.savePost:
          return model.copyWith(callback: onSavePost);
        case PostEditActionType.editPost:
          return model.copyWith(callback: onEditPost);
        case PostEditActionType.deletePost:
          return model.copyWith(callback: onDeletePost);
        case PostEditActionType.reportPost:
          return model.copyWith(callback: onReportPost);
        case PostEditActionType.addImageOrVideo:
          return model.copyWith(callback: onAddImageOrVideo);
        case PostEditActionType.formatText:
          return model.copyWith(callback: onFormatText);
        case PostEditActionType.replyToComment:
          return model.copyWith(callback: onReplyToComment);
        default:
          // Nếu có trường hợp nào không được xử lý, trả về model ban đầu.
          return model;
      }
    }).toList();
  }

  @override
  Widget build(BuildContext context) {
    final models = updatedModels;
    return ListView.builder(
      controller: scrollController,
      itemCount: models.length,
      itemBuilder: (context, index) {
        final option = models[index];
        return Material(
          child: InkWell(
            onTap: option.callback,
            child: Padding(
              padding: const EdgeInsets.all(10),
              child: Row(
                children: [
                  Icon(
                    option.icon,
                    size: 35,
                  ),
                  const SizedBox(width: 10),
                  Expanded(
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Text(
                          option.title,
                          style: const TextStyle(
                            fontSize: 20,
                            fontWeight: FontWeight.bold,
                          ),
                        ),
                        const SizedBox(height: 10),
                        Text(
                          option.description,
                          style: const TextStyle(
                            fontSize: 15,
                            color: Colors.blueGrey,
                            fontStyle: FontStyle.italic,
                          ),
                        ),
                      ],
                    ),
                  )
                ],
              ),
            ),
          ),
        );
      },
    );
  }
}

```

---


### Pages\Society\Widgets\post_list_card.dart

```dart
import 'package:bottom_sheet/bottom_sheet.dart';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:get/get.dart';
import 'package:tictactoe_gameapp/Components/belong_to_users/avatar_user_widget.dart';
import 'package:tictactoe_gameapp/Components/gifphy/display_gif_widget.dart';
import 'package:tictactoe_gameapp/Configs/messages.dart';
import 'package:tictactoe_gameapp/Models/Functions/color_string_reverse_function.dart';
import 'package:tictactoe_gameapp/Models/Functions/fetch_firestore_data_functions.dart';
import 'package:tictactoe_gameapp/Models/Functions/general_bottomsheet_show_function.dart';
import 'package:tictactoe_gameapp/Models/Functions/time_functions.dart';
import 'package:tictactoe_gameapp/Models/user_model.dart';
import 'package:tictactoe_gameapp/Pages/Society/About/user_about_page.dart';
import 'package:tictactoe_gameapp/Pages/Society/Comment/post_comment_controller.dart';
import 'package:tictactoe_gameapp/Pages/Society/Comment/post_comment_list_sheet.dart';
import 'package:tictactoe_gameapp/Pages/Society/Widgets/expandable_text_custom.dart';
import 'package:tictactoe_gameapp/Pages/Society/Widgets/like_user_list_sheet.dart';
import 'package:tictactoe_gameapp/Pages/Society/Widgets/post_edit_model.dart';
import 'package:tictactoe_gameapp/Pages/Society/Widgets/post_edit_sheet.dart';
import 'package:tictactoe_gameapp/Pages/Society/Widgets/share_sheet_custom.dart';
import 'package:tictactoe_gameapp/Pages/Society/social_post_controller.dart';
import 'package:tictactoe_gameapp/Pages/Society/social_post_model.dart';
import 'package:tictactoe_gameapp/Pages/Society/Widgets/post_polls/post_polls_card.dart';
import 'package:tictactoe_gameapp/Components/gifphy/stack_image_widget.dart';

class PostListCard extends StatelessWidget {
  final PostModel post;
  final UserModel postUser;
  final UserModel currentUser;
  final ThemeData theme;
  final PostController postController;
  const PostListCard({
    super.key,
    required this.post,
    required this.postUser,
    required this.theme,
    required this.postController,
    required this.currentUser,
  });

  @override
  Widget build(BuildContext context) {
    return Obx(() {
      final isLiked =
          postController.isLikedPost(currentUser.id!, post.postId!).value;
      final likeCount = post.likedList?.length ?? 0;
      final commentCount = post.commentCount ?? 0;
      final shareCount = post.shareCount ?? 0;
      return Container(
        padding: const EdgeInsets.all(10),
        margin: const EdgeInsets.only(bottom: 10),
        decoration: BoxDecoration(
          color: Colors.white,
          borderRadius: BorderRadius.circular(10),
        ),
        child: Column(
          children: [
            GestureDetector(
              onTap: () {
                Get.to(
                    UserAboutPage(
                      unknownableUser: postUser,
                    ),
                    transition: Transition.leftToRightWithFade);
              },
              child: Row(
                children: [
                  AvatarUserWidget(
                    radius: 20,
                    imagePath: postUser.image!,
                    gradientColors: postUser.avatarFrame,
                  ),
                  const SizedBox(
                    width: 10,
                  ),
                  Expanded(
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      mainAxisAlignment: MainAxisAlignment.start,
                      children: [
                        Text(postUser.name!, style: theme.textTheme.bodyLarge!),
                        Row(
                          children: [
                            Text(
                              TimeFunctions.timeAgo(
                                  now: DateTime.now(),
                                  createdAt: post.createdAt!),
                              style: const TextStyle(
                                color: Colors.grey,
                                fontSize: 15,
                              ),
                            ),
                            const SizedBox(
                              width: 10,
                            ),
                            if (post.privacy == "Public")
                              const Icon(
                                Icons.public,
                                size: 23,
                                color: Colors.blueGrey,
                              ),
                            if (post.privacy == "Friends")
                              const Icon(
                                Icons.people_outline_outlined,
                                size: 23,
                                color: Colors.blueGrey,
                              ),
                            if (post.privacy == "Private")
                              const Icon(
                                Icons.lock,
                                size: 23,
                                color: Colors.blueGrey,
                              )
                          ],
                        )
                      ],
                    ),
                  ),
                  IconButton(
                    onPressed: () async {
                      await showFlexibleBottomSheet(
                        minHeight: 0,
                        initHeight: 0.8,
                        maxHeight: 1,
                        context: context,
                        builder:
                            (context, scrollController, bottomSheetOffset) {
                          return PostEditSheet(
                            scrollController: scrollController,
                            onDeletePost: () async => postController.deletePost(
                                post: post, user: currentUser),
                            onSavePost: () async => await Clipboard.setData(
                              ClipboardData(text: post.content ?? ""),
                            ).then(
                              (value) => successMessage('Copied to Clipboard'),
                            ),
                            postType: PostType.post,
                          );
                        },
                        duration: const Duration(milliseconds: 500),
                        bottomSheetColor:
                            theme.colorScheme.primary.withOpacity(0.4),
                        bottomSheetBorderRadius: const BorderRadius.only(
                          topLeft: Radius.circular(20),
                          topRight: Radius.circular(20),
                        ),
                        decoration: const BoxDecoration(
                          color: Colors.white,
                          borderRadius: BorderRadius.only(
                            topLeft: Radius.circular(20),
                            topRight: Radius.circular(20),
                          ),
                        ),
                        anchors: [0, 1],
                        isSafeArea: true,
                      );
                    },
                    icon: const Icon(
                      Icons.more_horiz_rounded,
                      size: 35,
                      color: Colors.blueGrey,
                    ),
                  ),
                  IconButton(
                    onPressed: () async {
                      await postController.deletePost(
                        post: post,
                        user: currentUser,
                      );
                    },
                    icon: const Icon(
                      Icons.cancel_outlined,
                      size: 35,
                      color: Colors.blueGrey,
                    ),
                  ),
                ],
              ),
            ),
            const SizedBox(
              height: 10,
            ),
            post.backgroundPost != null && post.backgroundPost!.isNotEmpty
                ? Container(
                    width: double.maxFinite,
                    height: 200,
                    alignment: Alignment.center,
                    padding: const EdgeInsets.all(10),
                    decoration: BoxDecoration(
                      borderRadius: BorderRadius.circular(10),
                      gradient: LinearGradient(
                        colors: post.backgroundPost!
                            .map((hex) =>
                                ColorStringReverseFunction.hexToColor(hex))
                            .toList(),
                        begin: Alignment.topLeft,
                        end: Alignment.bottomRight,
                      ),
                    ),
                    child: SingleChildScrollView(
                      child: ExpandableContent(
                        content: post.content!,
                        isAligCenter: true,
                        style: theme.textTheme.titleLarge!
                            .copyWith(color: Colors.white),
                      ),
                    ),
                  )
                : Column(
                    children: [
                      Align(
                        alignment: Alignment.topLeft,
                        child: ExpandableContent(
                            content: post.content!,
                            style: theme.textTheme.titleLarge!.copyWith(
                              fontSize: 18,
                              overflow: TextOverflow.ellipsis,
                            )),
                      ),
                      const SizedBox(
                        height: 20,
                      ),
                    ],
                  ),
            const SizedBox(
              height: 10,
            ),
            Row(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                post.imageUrls != null
                    ? SizedBox(
                        height: 100,
                        width: MediaQuery.sizeOf(context).width / 2 - 25,
                        child: StackImageWidget(
                          imageUrls: post.imageUrls!,
                        ),
                      )
                    : const SizedBox(),
                const SizedBox(
                  width: 10,
                ),
                post.gif != null
                    ? SizedBox(
                        width: MediaQuery.sizeOf(context).width / 2 - 25,
                        child: DisplayGifWidget(gifUrl: post.gif!))
                    : const SizedBox(),
              ],
            ),
            const SizedBox(
              height: 10,
            ),
            post.postPolls != null
                ? PostPollWidget(
                    postPollsModel: post.postPolls!,
                    postController: postController,
                    postId: post.postId,
                    userId: currentUser.id,
                  )
                : const SizedBox.shrink(),
            const SizedBox(
              height: 10,
            ),
            Padding(
              padding: const EdgeInsets.symmetric(horizontal: 10),
              child: Row(
                mainAxisAlignment: MainAxisAlignment.spaceBetween,
                children: [
                  Expanded(
                    child: Material(
                      child: InkWell(
                        onTap: () async {
                          if (post.likedList != null) {
                            final FetchFirestoreDataFunctions
                                fetchFirestoreDataFunctions =
                                FetchFirestoreDataFunctions();
                            var likeUsers = await fetchFirestoreDataFunctions
                                .fetchPostLikeUsers(post.likedList!);
                            await showFlexibleBottomSheet(
                              minHeight: 0,
                              initHeight: 0.8,
                              maxHeight: 1,
                              context: context,
                              builder:
                                  (context, scrollController, bottomSheet) {
                                return LikeUserListSheet(
                                  likeUsers: likeUsers,
                                  scrollController: scrollController,
                                );
                              },
                              duration: const Duration(milliseconds: 500),
                              bottomSheetColor: Colors.white,
                              bottomSheetBorderRadius: const BorderRadius.only(
                                topLeft: Radius.circular(20),
                                topRight: Radius.circular(20),
                              ),
                              isSafeArea: true,
                            );
                          }
                        },
                        child: Row(
                          children: [
                            const Icon(
                              Icons.favorite,
                              size: 25,
                              color: Colors.redAccent,
                            ),
                            const SizedBox(width: 5),
                            Text(
                              "$likeCount",
                              style: const TextStyle(
                                color: Colors.black,
                                fontSize: 15,
                              ),
                            ),
                          ],
                        ),
                      ),
                    ),
                  ),
                  Expanded(
                    child: Text(
                      "$commentCount comments",
                      style: const TextStyle(
                        color: Colors.black,
                        fontSize: 15,
                      ),
                    ),
                  ),
                  Expanded(
                    child: Align(
                      alignment: Alignment.centerRight,
                      child: Text(
                        "$shareCount shares",
                        style: const TextStyle(
                          color: Colors.black,
                          fontSize: 15,
                        ),
                      ),
                    ),
                  ),
                ],
              ),
            ),
            const SizedBox(
              height: 10,
            ),
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                Expanded(
                  child: Material(
                    child: InkWell(
                      highlightColor: Colors.redAccent,
                      onTap: () async {
                        if (isLiked) {
                          await postController.unlikePost(
                              post.postId!, currentUser.id!);
                        } else {
                          await postController.likePost(post, currentUser);
                        }
                      },
                      child: Row(
                        mainAxisAlignment: MainAxisAlignment.start,
                        children: [
                          const SizedBox(width: 10),
                          Icon(
                            isLiked
                                ? Icons.favorite
                                : Icons.favorite_border_rounded,
                            size: 30,
                            color: Colors.redAccent,
                          ),
                          const SizedBox(width: 10),
                          Text(
                            isLiked ? "Unlike" : "Like",
                            style: TextStyle(
                              color: isLiked ? Colors.red : Colors.black54,
                              fontSize: 17,
                            ),
                          ),
                        ],
                      ),
                    ),
                  ),
                ),
                Expanded(
                  child: Material(
                    child: InkWell(
                      highlightColor: Colors.purpleAccent,
                      onTap: () async {
                        Get.delete<PostCommentController>();
                        await showFlexibleBottomSheet(
                          minHeight: 0,
                          initHeight: 0.9,
                          maxHeight: 1,
                          context: context,
                          builder: (context, scrollController, bottomSheet) {
                            return PostCommentListSheet(
                              scrollController: scrollController,
                              currentUser: currentUser,
                              post: post,
                            );
                          },
                          duration: const Duration(milliseconds: 500),
                          bottomSheetColor: Colors.white,
                          bottomSheetBorderRadius: const BorderRadius.only(
                            topLeft: Radius.circular(20),
                            topRight: Radius.circular(20),
                          ),
                          isSafeArea: true,
                        );
                      },
                      child: const SingleChildScrollView(
                        scrollDirection: Axis.horizontal,
                        child: Row(
                          mainAxisAlignment: MainAxisAlignment.center,
                          children: [
                            Icon(
                              Icons.comment_rounded,
                              size: 30,
                              color: Colors.purpleAccent,
                            ),
                            SizedBox(
                              width: 10,
                            ),
                            Text(
                              "Comment",
                              style: TextStyle(
                                color: Colors.black54,
                                fontSize: 17,
                              ),
                            ),
                          ],
                        ),
                      ),
                    ),
                  ),
                ),
                Expanded(
                  child: Material(
                    child: InkWell(
                      highlightColor: Colors.blueAccent,
                      onTap: () async {
                        await GeneralBottomsheetShowFunction
                            .showScrollableGeneralBottomsheet(
                          widgetBuilder: (context, controller) =>
                              ShareSheetCustom(
                            scrollController: controller,
                            currentUser: currentUser,
                            onPressed: () async {
                              await postController
                                  .incrementSharedCount(post, currentUser)
                                  .then((_) {
                                Get.back();
                                successMessage("Post shared successfully!");
                              });
                            },
                          ),
                          context: context,
                          initHeight: 0.8,
                          color: Colors.transparent,
                        );
                      },
                      child: const Row(
                        mainAxisAlignment: MainAxisAlignment.center,
                        children: [
                          Icon(
                            Icons.share,
                            size: 30,
                            color: Colors.blue,
                          ),
                          SizedBox(
                            width: 10,
                          ),
                          Text(
                            "Share",
                            style: TextStyle(
                              color: Colors.black54,
                              fontSize: 17,
                            ),
                          ),
                        ],
                      ),
                    ),
                  ),
                )
              ],
            )
          ],
        ),
      );
    });
  }
}

```

---


### Pages\Society\Widgets\post_notification_controller.dart

```dart
import 'dart:async';

import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:tictactoe_gameapp/Configs/messages.dart';
import 'package:tictactoe_gameapp/Models/Functions/notification_add_functions.dart';
import 'package:tictactoe_gameapp/Models/general_notifications_model.dart';

class PostNotificationController extends GetxController
    with GetSingleTickerProviderStateMixin {
  final String userId;
  PostNotificationController(this.userId);

  final FirebaseFirestore _firestore = FirebaseFirestore.instance;
  late final TabController tabController;

  // Danh sách thông báo và số lượng thông báo chưa đọc
  var notifications = <GeneralNotificationsModel>[].obs;
  var unisReadedCount = 0.obs;

  // Map phân loại thông báo để dễ dàng hiển thị trên UI
  var likeNotifications = <GeneralNotificationsModel>[].obs;
  var commentNotifications = <GeneralNotificationsModel>[].obs;
  var sharedNotifications = <GeneralNotificationsModel>[].obs;

  // Trang hiện tại và số lượng thông báo mỗi trang
  final int notificationsPerPage = 12;
  DocumentSnapshot? lastDocument;

  @override
  void onInit() {
    super.onInit();
    tabController = TabController(length: 3, vsync: this);
    _listenToNotifications();
    removeOldNotifications();
  }

  // Lắng nghe và phân loại thông báo theo thời gian thực, với tính năng thông báo nhóm
  void _listenToNotifications() {
    _firestore
        .collection("notifications")
        .where("receiverId", isEqualTo: userId)
        .orderBy("timestamp", descending: true)
        .limit(notificationsPerPage)
        .snapshots()
        .listen((snapshot) {
      var allNotifications = snapshot.docs
          .map((doc) => GeneralNotificationsModel.fromJson(doc.data()))
          .toList();

      // Lưu trữ tài liệu cuối cùng để phân trang
      if (snapshot.docs.isNotEmpty) {
        lastDocument = snapshot.docs.last;
      }

      notifications.value = allNotifications;
      unisReadedCount.value =
          allNotifications.where((n) => !n.isReaded!).length;

      // Phân loại thông báo
      _categorizeNotifications(allNotifications);
    });
  }

  // Phân loại thông báo thành các nhóm dựa trên loại thông báo
  void _categorizeNotifications(
      List<GeneralNotificationsModel> allNotifications) {
    likeNotifications.value = allNotifications
        .where((n) => n.type == "like")
        .take(notificationsPerPage)
        .toList();

    commentNotifications.value = allNotifications
        .where((n) => n.type == "comment")
        .take(notificationsPerPage)
        .toList();

    sharedNotifications.value = allNotifications
        .where((n) => n.type == "share")
        .take(notificationsPerPage)
        .toList();
  }

  // Đánh dấu tất cả thông báo thuộc một loại là đã đọc
  Future<void> markAllAsReadByType(String type) async {
    // Lọc thông báo theo kiểu type
    List<GeneralNotificationsModel> notificationsToMarkAsRead;
    if (type == "like") {
      notificationsToMarkAsRead =
          likeNotifications.where((n) => !n.isReaded!).toList();
    } else if (type == "comment") {
      notificationsToMarkAsRead =
          commentNotifications.where((n) => !n.isReaded!).toList();
    } else if (type == "share") {
      notificationsToMarkAsRead =
          sharedNotifications.where((n) => !n.isReaded!).toList();
    } else {
      return; // Không làm gì nếu type không hợp lệ
    }

    // Cập nhật Firestore cho từng thông báo chưa đọc
    WriteBatch batch = _firestore.batch();
    for (var notification in notificationsToMarkAsRead) {
      batch.update(
        _firestore.collection("notifications").doc(notification.id),
        {"isReaded": true},
      );
    }
    await batch.commit();

    // Cập nhật trạng thái local
    for (var n in notificationsToMarkAsRead) {
      n.isReaded = true;
    }
    unisReadedCount.value = notifications.where((n) => !n.isReaded!).length;

    // Cập nhật lại danh sách các thông báo đã phân loại
    _categorizeNotifications(notifications);
  }

  // Đánh dấu thông báo là đã đọc
  Future<void> markAsRead(String notificationId) async {
    await _firestore
        .collection("notifications")
        .doc(notificationId)
        .update({"isReaded": true}).catchError((e) => errorMessage(e));

    // Cập nhật trạng thái local
    var index = notifications.indexWhere((n) => n.id == notificationId);
    if (index != -1) {
      notifications[index].isReaded = true;
      unisReadedCount.value = notifications.where((n) => !n.isReaded!).length;
      _categorizeNotifications(notifications);
    }
  }

  // Phân trang để lấy thêm thông báo
  Future<void> loadMoreNotifications() async {
    if (lastDocument == null) return; // Không có thông báo mới hơn

    final snapshot = await _firestore
        .collection("notifications")
        .where("receiverId", isEqualTo: userId)
        .orderBy("timestamp", descending: true)
        .startAfterDocument(lastDocument!)
        .limit(notificationsPerPage)
        .get();

    if (snapshot.docs.isNotEmpty) {
      lastDocument = snapshot.docs.last;
      var moreNotifications = snapshot.docs
          .map((doc) => GeneralNotificationsModel.fromJson(doc.data()))
          .toList();

      // Thêm thông báo mới vào danh sách và cập nhật
      notifications.addAll(moreNotifications);
      unisReadedCount.value = notifications.where((n) => !n.isReaded!).length;
      _categorizeNotifications(notifications);
    }
  }

  // Hàm tự động xóa các thông báo cũ hơn 7 ngày
  Future<void> removeOldNotifications() async {
    // Tính toán thời điểm 7 ngày trước
    final sevenDaysAgo = DateTime.now().subtract(const Duration(days: 7));

    // Lọc các thông báo có timestamp cũ hơn 7 ngày và giới hạn số lượng xử lý mỗi lần
    final oldNotifications = await _firestore
        .collection("notifications")
        .where("timestamp", isLessThan: sevenDaysAgo)
        .where("isReaded", isEqualTo: true)
        .get();

    // Xóa các thông báo đã lọc
    if (oldNotifications.docs.isNotEmpty) {
      WriteBatch batch = _firestore.batch();
      for (var doc in oldNotifications.docs) {
        batch.delete(doc.reference);
      }
      await batch.commit();
    }
  }

  Future<void> deleteNotification(String notificationId) async {
    await _firestore
        .collection("notifications")
        .doc(notificationId)
        .delete()
        .catchError((e) => errorMessage(e));
    Get.back();
  }

  var isNotifed = false.obs;

  Future<void> checkIsNotifed(String postId) async {
    final NotificationAddFunctions notificationAddFunctions =
        NotificationAddFunctions(firestore: _firestore);
    isNotifed.value = await notificationAddFunctions.getFieldDataFromCollection(
          collectionPath: "posts",
          docId: postId,
          fieldName: "isNotified",
        ) ??
        true;
  }

  Future<void> turnOffNotify(String postId) async {
    await checkIsNotifed(postId);
    if (isNotifed.value) {
      await _firestore
          .collection("posts")
          .doc(postId)
          .update({"isNotified": false})
          .catchError((e) => errorMessage(e))
          .then(
              (_) => successMessage("Now, you can not receive notifications"));
      await checkIsNotifed(postId);
    } else {
      isNotifed.value == true;
      await _firestore
          .collection("posts")
          .doc(postId)
          .update({"isNotified": true})
          .catchError((e) => errorMessage(e))
          .then((_) => successMessage("Now, you can receive notifications"));
      await checkIsNotifed(postId);
    }
    Get.back();
  }
}

```

---


### Pages\Society\Widgets\post_notification_page.dart

```dart
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:tictactoe_gameapp/Models/user_model.dart';
import 'package:tictactoe_gameapp/Pages/Society/Widgets/post_notification_controller.dart';
import 'package:tictactoe_gameapp/Pages/Society/Widgets/post_notification_tabs/post_comment_tab.dart';
import 'package:tictactoe_gameapp/Pages/Society/Widgets/post_notification_tabs/post_like_tab.dart';
import 'package:tictactoe_gameapp/Pages/Society/Widgets/post_notification_tabs/post_other_tab.dart';

class PostNotificationPage extends StatelessWidget {
  final UserModel user;
  const PostNotificationPage({super.key, required this.user});

  @override
  Widget build(BuildContext context) {
    final ThemeData theme = Theme.of(context);
    final PostNotificationController postNotificationController =
        Get.put(PostNotificationController(user.id!));
    return Scaffold(
      appBar: AppBar(
        centerTitle: false,
        leading: IconButton(
          onPressed: () {
            Get.back();
          },
          icon: const Icon(
            Icons.arrow_back_rounded,
            size: 35,
            color: Colors.black,
          ),
        ),
        title: Text(
          "Notifications",
          style: theme.textTheme.headlineMedium,
        ),
        actions: [
          IconButton(
            onPressed: () async {
              int indexTab = postNotificationController.tabController.index;
              if (indexTab == 0) {
                await postNotificationController.markAllAsReadByType("like");
              } else if (indexTab == 1) {
                await postNotificationController.markAllAsReadByType("comment");
              } else {
                await postNotificationController.markAllAsReadByType("share");
              }
            },
            icon: const Icon(
              Icons.done_all_rounded,
              size: 35,
              color: Colors.blueAccent,
            ),
          ),
          IconButton(
            onPressed: () {
              postNotificationController.loadMoreNotifications();
            },
            icon: const Icon(
              Icons.refresh_rounded,
              size: 35,
              color: Colors.blueAccent,
            ),
          ),
        ],
      ),
      body: Column(
        children: [
          TabBar(
            controller: postNotificationController.tabController,
            labelColor: Colors.blueAccent,
            unselectedLabelColor: Colors.black,
            indicatorSize: TabBarIndicatorSize.tab,
            splashBorderRadius: const BorderRadius.only(
              topLeft: Radius.circular(20),
              topRight: Radius.circular(20),
            ),
            indicatorWeight: 5,
            indicatorColor: Colors.white,
            tabs: [
              Container(
                width: double.maxFinite,
                padding: const EdgeInsets.all(5),
                alignment: Alignment.center,
                decoration: const BoxDecoration(
                  color: Colors.lightBlueAccent,
                  borderRadius: BorderRadius.only(
                    topLeft: Radius.circular(20),
                    topRight: Radius.circular(20),
                  ),
                ),
                child: const Text(
                  "Interacts",
                  style: TextStyle(
                    color: Colors.white,
                    fontSize: 20,
                    fontWeight: FontWeight.bold,
                  ),
                ),
              ),
              Container(
                width: double.maxFinite,
                padding: const EdgeInsets.all(5),
                alignment: Alignment.center,
                decoration: const BoxDecoration(
                  color: Colors.lightBlueAccent,
                  borderRadius: BorderRadius.only(
                    topLeft: Radius.circular(20),
                    topRight: Radius.circular(20),
                  ),
                ),
                child: const Text(
                  "Comments",
                  maxLines: 1,
                  style: TextStyle(
                    color: Colors.white,
                    fontSize: 20,
                    fontWeight: FontWeight.bold,
                  ),
                ),
              ),
              Container(
                width: double.maxFinite,
                padding: const EdgeInsets.all(5),
                alignment: Alignment.center,
                decoration: const BoxDecoration(
                  color: Colors.lightBlueAccent,
                  borderRadius: BorderRadius.only(
                    topLeft: Radius.circular(20),
                    topRight: Radius.circular(20),
                  ),
                ),
                child: const Text(
                  "Others",
                  style: TextStyle(
                    color: Colors.white,
                    fontSize: 20,
                    fontWeight: FontWeight.bold,
                  ),
                ),
              ),
            ],
          ),
          Expanded(
            child: TabBarView(
                controller: postNotificationController.tabController,
                children: [
                  PostLikeTab(
                    postNotificationController: postNotificationController,
                    theme: theme,
                    user: user,
                  ),
                  PostCommentTab(
                    postNotificationController: postNotificationController,
                    theme: theme,
                    user: user,
                  ),
                  PostOthersTab(
                    postNotificationController: postNotificationController,
                    theme: theme,
                    user: user,
                  ),
                ]),
          )
        ],
      ),
    );
  }
}

```

---


### Pages\Society\Widgets\share_sheet_custom.dart

```dart
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:tictactoe_gameapp/Components/belong_to_users/avatar_user_widget.dart';
import 'package:tictactoe_gameapp/Data/fetch_firestore_database.dart';
import 'package:tictactoe_gameapp/Models/user_model.dart';
import 'package:tictactoe_gameapp/Pages/Society/About/user_about_page.dart';
import 'package:tictactoe_gameapp/Pages/Society/Widgets/post_edit_model.dart';

class ShareSheetCustom extends StatelessWidget {
  final ScrollController scrollController;
  final UserModel currentUser;
  final VoidCallback onPressed;
  const ShareSheetCustom(
      {super.key,
      required this.scrollController,
      required this.currentUser,
      required this.onPressed});

  @override
  Widget build(BuildContext context) {
    final FirestoreController firestoreController = Get.find();
    final ThemeData theme = Theme.of(context);
    RxString audienceMode = "Public".obs;
    return Padding(
      padding: const EdgeInsets.all(10.0),
      child: SingleChildScrollView(
        controller: scrollController,
        child: Column(
          mainAxisAlignment: MainAxisAlignment.start,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Center(
              child: Container(
                height: 5,
                width: 50,
                margin: const EdgeInsets.only(top: 10),
                decoration: const BoxDecoration(
                  color: Colors.white,
                  borderRadius: BorderRadius.all(Radius.circular(20)),
                ),
              ),
            ),
            const SizedBox(
              height: 20,
            ),
            Container(
              height: 300,
              width: double.maxFinite,
              padding: const EdgeInsets.all(10),
              decoration: BoxDecoration(
                borderRadius: BorderRadius.circular(10),
                color: Colors.white,
              ),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.end,
                children: [
                  Row(
                    children: [
                      AvatarUserWidget(
                        radius: 30,
                        imagePath: currentUser.image!,
                        gradientColors: currentUser.avatarFrame,
                      ),
                      const SizedBox(width: 10),
                      Expanded(
                        child: Column(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          children: [
                            Text(
                              currentUser.name!,
                              style: theme.textTheme.bodyLarge!
                                  .copyWith(color: Colors.blueAccent),
                            ),
                            const SizedBox(
                              height: 10,
                            ),
                            SingleChildScrollView(
                              scrollDirection: Axis.horizontal,
                              child: Row(
                                children: [
                                  GestureDetector(
                                      onTap: () {
                                        audienceMode.value = "Private";
                                      },
                                      child: Obx(
                                        () => Container(
                                          height: 40,
                                          width: 100,
                                          margin:
                                              const EdgeInsets.only(right: 10),
                                          alignment: Alignment.center,
                                          decoration: BoxDecoration(
                                            color:
                                                audienceMode.value == "Private"
                                                    ? Colors.blueAccent
                                                    : Colors.grey.shade400,
                                            borderRadius:
                                                BorderRadius.circular(10),
                                          ),
                                          child: Row(
                                            mainAxisAlignment:
                                                MainAxisAlignment.center,
                                            children: [
                                              Icon(
                                                Icons.person,
                                                color: audienceMode.value ==
                                                        "Private"
                                                    ? Colors.white
                                                    : Colors.black,
                                              ),
                                              const SizedBox(width: 5),
                                              Text(
                                                "Private",
                                                style: theme
                                                    .textTheme.bodyMedium!
                                                    .copyWith(
                                                  color: audienceMode.value ==
                                                          "Private"
                                                      ? Colors.white
                                                      : Colors.black,
                                                ),
                                              ),
                                            ],
                                          ),
                                        ),
                                      )),
                                  GestureDetector(
                                    onTap: () {
                                      audienceMode.value = "Friends";
                                    },
                                    child: Obx(() => Container(
                                          height: 40,
                                          width: 100,
                                          margin:
                                              const EdgeInsets.only(right: 10),
                                          alignment: Alignment.center,
                                          decoration: BoxDecoration(
                                            color:
                                                audienceMode.value == "Friends"
                                                    ? Colors.blueAccent
                                                    : Colors.grey.shade400,
                                            borderRadius:
                                                BorderRadius.circular(10),
                                          ),
                                          child: Row(
                                            mainAxisAlignment:
                                                MainAxisAlignment.center,
                                            children: [
                                              Icon(
                                                Icons.people_alt_rounded,
                                                color: audienceMode.value ==
                                                        "Friends"
                                                    ? Colors.white
                                                    : Colors.black,
                                              ),
                                              const SizedBox(width: 5),
                                              Text(
                                                "Friends",
                                                style: theme
                                                    .textTheme.bodyMedium!
                                                    .copyWith(
                                                  color: audienceMode.value ==
                                                          "Friends"
                                                      ? Colors.white
                                                      : Colors.black,
                                                ),
                                              ),
                                            ],
                                          ),
                                        )),
                                  ),
                                  GestureDetector(
                                    onTap: () {
                                      audienceMode.value = "Public";
                                    },
                                    child: Obx(() => Container(
                                          height: 40,
                                          width: 100,
                                          margin:
                                              const EdgeInsets.only(right: 10),
                                          alignment: Alignment.center,
                                          decoration: BoxDecoration(
                                            color:
                                                audienceMode.value == "Public"
                                                    ? Colors.blueAccent
                                                    : Colors.grey.shade400,
                                            borderRadius:
                                                BorderRadius.circular(10),
                                          ),
                                          child: Row(
                                            mainAxisAlignment:
                                                MainAxisAlignment.center,
                                            children: [
                                              Icon(
                                                Icons.public,
                                                color: audienceMode.value ==
                                                        "Public"
                                                    ? Colors.white
                                                    : Colors.black,
                                              ),
                                              const SizedBox(width: 5),
                                              Text(
                                                "Public",
                                                style: theme
                                                    .textTheme.bodyMedium!
                                                    .copyWith(
                                                  color: audienceMode.value ==
                                                          "Public"
                                                      ? Colors.white
                                                      : Colors.black,
                                                ),
                                              ),
                                            ],
                                          ),
                                        )),
                                  ),
                                ],
                              ),
                            ),
                          ],
                        ),
                      ),
                    ],
                  ),
                  const Expanded(
                      child: TextField(
                    minLines: null,
                    maxLines: null,
                    expands: true,
                    decoration: InputDecoration(
                      hintText: "Write a comment...",
                    ),
                  )),
                  ElevatedButton(
                      onPressed: onPressed,
                      style: ElevatedButton.styleFrom(
                        backgroundColor: Colors.blue,
                        foregroundColor: Colors.white,
                        shadowColor: Colors.redAccent,
                        elevation: 5,
                      ),
                      child: const Text("Share now")),
                ],
              ),
            ),
            const Text(
              "Send in Messenger",
              overflow: TextOverflow.clip,
              style: TextStyle(
                fontSize: 20,
                color: Colors.white,
                fontWeight: FontWeight.bold,
              ),
            ),
            Obx(
              () {
                if (firestoreController.friendsList.isEmpty) {
                  return const SizedBox();
                }
                var friends = firestoreController.friendsList.toList();
                return SizedBox(
                  height: 120,
                  width: double.infinity,
                  child: ListView.builder(
                    scrollDirection: Axis.horizontal,
                    physics: const BouncingScrollPhysics(),
                    itemCount: friends.length,
                    itemBuilder: (context, index) {
                      var friend = friends[index];
                      return Padding(
                        padding: const EdgeInsets.all(8.0),
                        child: Column(
                          children: [
                            Stack(
                              children: [
                                GestureDetector(
                                  onTap: () {
                                    Get.to(
                                        UserAboutPage(
                                          unknownableUser: friend,
                                        ),
                                        transition: Transition.upToDown);
                                  },
                                  child: AvatarUserWidget(
                                    radius: 35,
                                    imagePath: friend.image!,
                                    gradientColors:friend.avatarFrame,
                                  ),
                                ),
                                Positioned(
                                  bottom: 0,
                                  right: 0,
                                  child: Container(
                                    width: 20,
                                    height: 20,
                                    decoration: BoxDecoration(
                                      color: Colors.green,
                                      borderRadius: BorderRadius.circular(100),
                                      border: Border.all(
                                        color: Colors.white,
                                        width: 3,
                                      ),
                                    ),
                                  ),
                                ),
                              ],
                            ),
                            Text(
                              friend.name!,
                              style: const TextStyle(
                                fontSize: 18,
                                color: Colors.white,
                              ),
                            ),
                          ],
                        ),
                      );
                    },
                  ),
                );
              },
            ),
            const Text(
              "Share to",
              overflow: TextOverflow.clip,
              style: TextStyle(
                fontSize: 20,
                color: Colors.white,
                fontWeight: FontWeight.bold,
              ),
            ),
            SizedBox(
              height: 200,
              width: double.infinity,
              child: ListView.builder(
                  scrollDirection: Axis.horizontal,
                  itemCount: PostEditModel.listPostEditModels.length,
                  itemBuilder: (context, index) {
                    var option = PostEditModel.listPostEditModels[index];
                    return Padding(
                      padding: const EdgeInsets.all(10),
                      child: Column(
                        children: [
                          InkWell(
                            borderRadius: BorderRadius.circular(100),
                            splashColor: Colors.lightBlueAccent,
                            onTap: onPressed,
                            child: Ink(
                              padding: const EdgeInsets.all(20),
                              decoration: const BoxDecoration(
                                color: Colors.white,
                                shape: BoxShape.circle,
                              ),
                              child: Icon(
                                option.icon,
                                size: 35,
                              ),
                            ),
                          ),
                          const SizedBox(
                            height: 5,
                          ),
                          Text(
                            option.title,
                            style: const TextStyle(
                                fontSize: 15,
                                color: Colors.white,
                                fontWeight: FontWeight.w400),
                          ),
                        ],
                      ),
                    );
                  }),
            )
          ],
        ),
      ),
    );
  }
}

```

---


### Pages\Society\Widgets\social_livestreams_widget.dart

```dart
import 'dart:convert';

import 'package:flutter/material.dart';
import 'package:flutter_animate/flutter_animate.dart';
import 'package:get/get.dart';
import 'package:tictactoe_gameapp/Components/belong_to_users/avatar_user_widget.dart';
import 'package:tictactoe_gameapp/Configs/constants.dart';
import 'package:tictactoe_gameapp/Models/Functions/time_functions.dart';
import 'package:tictactoe_gameapp/Models/user_model.dart';
import 'package:tictactoe_gameapp/Pages/Society/agora_livestreaming/agora_livestreaming_page.dart';
import 'package:tictactoe_gameapp/Pages/Society/agora_livestreaming/create_livestream_room_page.dart';
import 'package:tictactoe_gameapp/Pages/Society/agora_livestreaming/livestream_controller.dart';
import 'package:tictactoe_gameapp/Pages/Society/agora_livestreaming/livestream_doc_service.dart';
import 'package:tictactoe_gameapp/Components/shimmers/lives_placeholder_widget.dart';

class SocialLivestreamsWidget extends StatelessWidget {
  final UserModel user;
  final ThemeData theme;
  const SocialLivestreamsWidget(
      {super.key, required this.user, required this.theme});

  @override
  Widget build(BuildContext context) {
    final LiveStreamController liveStreamController =
        Get.put(LiveStreamController());
    final GlobalKey<RefreshIndicatorState> refreshIndicatorState =
        GlobalKey<RefreshIndicatorState>();
    return Scaffold(
      body: Padding(
        padding: const EdgeInsets.all(10.0),
        child: Column(
          children: [
            ElevatedButton(
                onPressed: () {
                  Get.to(
                    () => CreateLivestreamRoomPage(currentUser: user),
                    transition: Transition.leftToRightWithFade,
                  );
                },
                style: ElevatedButton.styleFrom(
                  backgroundColor: Colors.blue,
                  foregroundColor: Colors.white,
                  shadowColor: Colors.redAccent,
                  padding: const EdgeInsets.all(5),
                  elevation: 5,
                ),
                child: const Padding(
                  padding: EdgeInsets.symmetric(horizontal: 10.0),
                  child: Row(
                    mainAxisAlignment: MainAxisAlignment.spaceBetween,
                    children: [
                      Icon(
                        Icons.live_tv_sharp,
                        size: 30,
                      ),
                      Text(
                        "Create your own live",
                        style: TextStyle(
                          fontSize: 16,
                        ),
                      ),
                      Icon(
                        Icons.arrow_forward_rounded,
                        size: 30,
                      ),
                    ],
                  ),
                )),
            SizedBox(
              height: 50,
              child: ListView.builder(
                scrollDirection: Axis.horizontal,
                itemCount: 10,
                itemBuilder: (contex, index) {
                  return Container(
                    width: 100,
                    alignment: Alignment.center,
                    margin:
                        const EdgeInsets.symmetric(horizontal: 5, vertical: 5),
                    decoration: BoxDecoration(
                      color: Colors.blueGrey,
                      borderRadius: BorderRadius.circular(10),
                    ),
                    child: Text("Cate $index"),
                  );
                },
              ),
            ),
            Expanded(
              child: Obx(() {
                if (liveStreamController.liveStreamsList.isEmpty) {
                  return const LivesPlaceholderWidget();
                } else {
                  var liveStreams =
                      liveStreamController.liveStreamsList.toList();
                  return NotificationListener<ScrollNotification>(
                    onNotification: (ScrollNotification scrollInfo) {
                      if (scrollInfo.metrics.pixels >=
                          scrollInfo.metrics.maxScrollExtent - 200) {
                        liveStreamController.fetchMoreLiveStreams();
                      }
                      return true;
                    },
                    child: RefreshIndicator(
                      key: refreshIndicatorState,
                      backgroundColor: Colors.blue,
                      color: Colors.white,
                      onRefresh: () async {
                        await liveStreamController.fetchInitialLiveStreams();
                      },
                      child: GridView.builder(
                          controller: liveStreamController.scrollController,
                          gridDelegate:
                              const SliverGridDelegateWithFixedCrossAxisCount(
                            crossAxisCount: 2,
                            childAspectRatio: 0.7,
                          ),
                          itemCount: liveStreams.length,
                          itemBuilder: (context, index) {
                            var liveStream = liveStreams[index];
                            var streamer = liveStream.streamer!;
                            return InkWell(
                              onTap: () async {
                                final LiveStreamService liveStreamService =
                                    LiveStreamService();
                                await liveStreamService
                                    .incrementViewerCount(liveStream.streamId!);
                                Get.to(
                                  () => AgoraLivestreamingPage(
                                    currentUser: user,
                                    channelId: liveStream.channelId!,
                                    isStreamer: false,
                                    liveStreamModel: liveStream,
                                  ),
                                  transition: Transition.zoom,
                                );
                              },
                              splashColor: Colors.blueAccent,
                              borderRadius: BorderRadius.circular(10),
                              child: Container(
                                margin: const EdgeInsets.all(5),
                                padding: const EdgeInsets.all(10),
                                decoration: BoxDecoration(
                                  image: DecorationImage(
                                    image: MemoryImage(
                                      base64Decode(
                                        liveStream.thumbnailUrl!,
                                      ),
                                    ),
                                    fit: BoxFit.cover,
                                  ),
                                  color: Colors.white,
                                  borderRadius: BorderRadius.circular(10),
                                  // border: Border.all(color: Colors.pinkAccent, width: 3),
                                ),
                                child: Column(
                                  mainAxisAlignment:
                                      MainAxisAlignment.spaceBetween,
                                  children: [
                                    Column(
                                      crossAxisAlignment:
                                          CrossAxisAlignment.start,
                                      mainAxisSize: MainAxisSize.min,
                                      children: [
                                        Row(
                                          mainAxisAlignment:
                                              MainAxisAlignment.spaceBetween,
                                          children: [
                                            Container(
                                              width: 60,
                                              height: 30,
                                              alignment: Alignment.center,
                                              decoration: BoxDecoration(
                                                color: Colors.red,
                                                borderRadius:
                                                    BorderRadius.circular(10),
                                              ),
                                              child: const Text(
                                                "Live",
                                                style: TextStyle(
                                                  color: Colors.white,
                                                  fontWeight: FontWeight.bold,
                                                ),
                                              ),
                                            ),
                                            Container(
                                              padding:
                                                  const EdgeInsets.symmetric(
                                                horizontal: 10,
                                                vertical: 5,
                                              ),
                                              decoration: BoxDecoration(
                                                color: Colors.white,
                                                borderRadius:
                                                    BorderRadius.circular(50),
                                              ),
                                              child: Row(
                                                children: [
                                                  const Icon(
                                                    Icons.visibility_rounded,
                                                    color: Colors.lightBlue,
                                                    size: 20,
                                                  ),
                                                  const SizedBox(
                                                    width: 5,
                                                  ),
                                                  Text(
                                                    liveStream.viewerCount
                                                        .toString(),
                                                    style: const TextStyle(
                                                      color: Colors.lightBlue,
                                                      fontSize: 14,
                                                    ),
                                                  )
                                                ],
                                              ),
                                            )
                                          ],
                                        ),
                                      ],
                                    ),
                                    Column(
                                      crossAxisAlignment:
                                          CrossAxisAlignment.start,
                                      children: [
                                        SingleChildScrollView(
                                          scrollDirection: Axis.horizontal,
                                          child: Row(
                                            crossAxisAlignment:
                                                CrossAxisAlignment.start,
                                            children: [
                                              AvatarUserWidget(
                                                radius: 20,
                                                imagePath: streamer.image!,
                                                borderThickness: 2,
                                                gradientColors:streamer.avatarFrame,
                                              ),
                                              const SizedBox(
                                                width: 5,
                                              ),
                                              Column(
                                                crossAxisAlignment:
                                                    CrossAxisAlignment.start,
                                                children: [
                                                  Text(
                                                    streamer.name!,
                                                    style: theme
                                                        .textTheme.bodyMedium!
                                                        .copyWith(
                                                      color: Colors
                                                          .lightBlueAccent,
                                                    ),
                                                  ),
                                                  Text(
                                                    liveStream.category ??
                                                        "Default",
                                                    style: const TextStyle(
                                                      color: Colors.blueGrey,
                                                      fontSize: 13,
                                                    ),
                                                  ),
                                                ],
                                              ),
                                            ],
                                          ),
                                        ),
                                        Text(
                                          liveStream.title!,
                                          maxLines: 1,
                                          overflow: TextOverflow.ellipsis,
                                          style: const TextStyle(
                                            color: Colors.lightGreenAccent,
                                            fontSize: 15,
                                            fontWeight: FontWeight.bold,
                                          ),
                                        ),
                                        Text(
                                          liveStream.description!,
                                          maxLines: 2,
                                          overflow: TextOverflow.ellipsis,
                                          style: const TextStyle(
                                            color: Colors.lightGreen,
                                            fontSize: 12,
                                          ),
                                        ),
                                        Align(
                                          alignment: Alignment.centerRight,
                                          child: Text(
                                            TimeFunctions.timeAgo(
                                                now: DateTime.now(),
                                                createdAt:
                                                    liveStream.createdAt!),
                                            style: const TextStyle(
                                              color: Colors.greenAccent,
                                              fontSize: 10,
                                            ),
                                          ),
                                        ),
                                      ],
                                    )
                                  ],
                                ),
                              ),
                            )
                                .animate()
                                .scale(duration: duration750)
                                .fadeIn(duration: duration750);
                          }),
                    ),
                  );
                }
              }),
            ),
          ],
        ),
      ),
    );
  }
}

```

---


### Pages\Society\Widgets\social_posts_widget.dart

```dart
import 'package:flutter/material.dart';
import 'package:flutter_animate/flutter_animate.dart';
import 'package:get/get.dart';
import 'package:tictactoe_gameapp/Components/belong_to_users/avatar_user_widget.dart';
import 'package:tictactoe_gameapp/Components/shimmers/friendavatar_placeholder_widget.dart';
import 'package:tictactoe_gameapp/Configs/constants.dart';
import 'package:tictactoe_gameapp/Data/fetch_firestore_database.dart';
import 'package:tictactoe_gameapp/Models/user_model.dart';
import 'package:tictactoe_gameapp/Pages/Society/About/user_about_page.dart';
import 'package:tictactoe_gameapp/Pages/Society/Widgets/create_post_page.dart';
import 'package:tictactoe_gameapp/Pages/Society/Widgets/post_list_card.dart';
import 'package:tictactoe_gameapp/Pages/Society/social_post_controller.dart';
import 'package:tictactoe_gameapp/Components/shimmers/posts_placeholder_widget.dart';

class SocialPostsWidget extends StatelessWidget {
  final PostController postController;
  final UserModel user;
  final ThemeData theme;
  final GlobalKey<RefreshIndicatorState> refreshIndicatorState;
  const SocialPostsWidget(
      {super.key,
      required this.user,
      required this.theme,
      required this.postController,
      required this.refreshIndicatorState});

  @override
  Widget build(BuildContext context) {
    final FirestoreController firestoreController =
        Get.put(FirestoreController());
    return Scaffold(
      body: Column(
        children: [
          Expanded(
            child: Obx(
              () {
                if (postController.postsList.isEmpty) {
                  return Center(
                    child: Container(
                      decoration: BoxDecoration(
                        color: Colors.white,
                        borderRadius: BorderRadius.circular(100),
                      ),
                      child: const CircularProgressIndicator(
                        color: Colors.blue,
                      ),
                    ),
                  );
                } else {
                  var posts = postController.postsList.toList();
                  return NotificationListener<ScrollNotification>(
                    onNotification: (ScrollNotification scrollInfo) {
                      if (scrollInfo.metrics.pixels >=
                          scrollInfo.metrics.maxScrollExtent - 200) {
                        postController.fetchMoreFilteredPosts();
                      }
                      return true;
                    },
                    child: RefreshIndicator(
                      key: refreshIndicatorState,
                      backgroundColor: Colors.blue,
                      color: Colors.white,
                      onRefresh: () async {
                        await postController.fetchFilteredPosts();
                      },
                      child: ListView.builder(
                        controller: postController.scrollController,
                        itemCount: posts.length +
                            (postController.isFetching.value ? 3 : 0),
                        physics: const BouncingScrollPhysics(),
                        itemBuilder: (context, index) {
                          if (index >= posts.length) {
                            return const PostsPlaceholderWidget();
                          } else {
                            var post = posts[index];
                            var postUser = post.postUser!;
                            return Column(
                              children: [
                                index == 0
                                    ? Column(
                                        crossAxisAlignment:
                                            CrossAxisAlignment.start,
                                        children: [
                                          Row(
                                            children: [
                                              Container(
                                                decoration: BoxDecoration(
                                                    border: Border.all(
                                                      color: Colors.blueAccent,
                                                      width: 3,
                                                    ),
                                                    borderRadius:
                                                        BorderRadius.circular(
                                                            50)),
                                                child: GestureDetector(
                                                  onTap: () {
                                                    Get.to(
                                                        UserAboutPage(
                                                          unknownableUser: user,
                                                        ),
                                                        transition: Transition
                                                            .upToDown);
                                                  },
                                                  child: AvatarUserWidget(
                                                      radius: 25,
                                                      imagePath: user.image!),
                                                ),
                                              ),
                                              const SizedBox(
                                                width: 10,
                                              ),
                                              Expanded(
                                                  child: GestureDetector(
                                                onTap: () => Get.to(
                                                  CreatePostPage(
                                                    userModel: user,
                                                    postController:
                                                        postController,
                                                  ),
                                                  transition: Transition.zoom,
                                                ),
                                                child: Container(
                                                  height: 45,
                                                  padding:
                                                      const EdgeInsets.only(
                                                          left: 20),
                                                  decoration: BoxDecoration(
                                                    color: Colors.white,
                                                    borderRadius:
                                                        BorderRadius.circular(
                                                            50),
                                                    border: Border.all(
                                                      color: Colors.blueGrey,
                                                    ),
                                                  ),
                                                  child: Align(
                                                    alignment:
                                                        Alignment.centerLeft,
                                                    child: Text(
                                                      'What\'s on your mind?',
                                                      style: theme.textTheme
                                                          .titleMedium!
                                                          .copyWith(
                                                              color: Colors
                                                                  .blueGrey),
                                                    ),
                                                  ),
                                                ),
                                              )),
                                              const SizedBox(
                                                width: 10,
                                              ),
                                              IconButton(
                                                onPressed: () {},
                                                icon: const Icon(
                                                  Icons.image,
                                                  color: Colors.lightGreen,
                                                  size: 40,
                                                ),
                                              ),
                                            ],
                                          ),
                                          const SizedBox(
                                            height: 10,
                                          ),
                                          Obx(
                                            () {
                                              if (firestoreController
                                                  .isLoadingFriends.value) {
                                                return SizedBox(
                                                  height: 120,
                                                  width: double.infinity,
                                                  child: ListView.builder(
                                                    scrollDirection:
                                                        Axis.horizontal,
                                                    itemCount: 5,
                                                    itemBuilder:
                                                        (context, index) {
                                                      return const FriendavatarPlaceholderWidget();
                                                    },
                                                  ),
                                                );
                                              } else {
                                                if (firestoreController
                                                    .friendsList.isEmpty) {
                                                  return const SizedBox();
                                                } else {
                                                  var friends =
                                                      firestoreController
                                                          .friendsList
                                                          .toList();
                                                  return SizedBox(
                                                    height: 120,
                                                    width: double.infinity,
                                                    child: ListView.builder(
                                                      scrollDirection:
                                                          Axis.horizontal,
                                                      physics:
                                                          const BouncingScrollPhysics(),
                                                      itemCount: friends.length,
                                                      itemBuilder:
                                                          (context, index) {
                                                        var friend =
                                                            friends[index];
                                                        return Padding(
                                                          padding:
                                                              const EdgeInsets
                                                                  .all(8.0),
                                                          child: Column(
                                                            children: [
                                                              Stack(
                                                                children: [
                                                                  GestureDetector(
                                                                    onTap: () {
                                                                      Get.to(
                                                                          UserAboutPage(
                                                                            unknownableUser:
                                                                                friend,
                                                                          ),
                                                                          transition:
                                                                              Transition.upToDown);
                                                                    },
                                                                    child: AvatarUserWidget(
                                                                        radius:
                                                                            35,
                                                                        imagePath:
                                                                            friend.image!),
                                                                  ),
                                                                  Positioned(
                                                                    bottom: 0,
                                                                    right: 0,
                                                                    child:
                                                                        Container(
                                                                      width: 20,
                                                                      height:
                                                                          20,
                                                                      decoration:
                                                                          BoxDecoration(
                                                                        color: Colors
                                                                            .green,
                                                                        borderRadius:
                                                                            BorderRadius.circular(100),
                                                                        border:
                                                                            Border.all(
                                                                          color:
                                                                              Colors.white,
                                                                          width:
                                                                              3,
                                                                        ),
                                                                      ),
                                                                    ),
                                                                  ),
                                                                ],
                                                              ),
                                                              Text(
                                                                friend.name!,
                                                              ),
                                                            ],
                                                          ),
                                                        );
                                                      },
                                                    ),
                                                  );
                                                }
                                              }
                                            },
                                          ),
                                          Row(
                                            children: [
                                              const SizedBox(width: 10),
                                              const Icon(
                                                Icons.filter_list,
                                                size: 35,
                                              ),
                                              const SizedBox(width: 10),
                                              Obx(() => DropdownButton<String>(
                                                    value: postController
                                                        .selectedOption.value,
                                                    icon: const Icon(Icons
                                                        .radio_button_checked_rounded),
                                                    iconSize: 24,
                                                    iconEnabledColor:
                                                        Colors.blue,
                                                    focusColor: Colors.blue,
                                                    elevation: 16,
                                                    borderRadius:
                                                        const BorderRadius.all(
                                                            Radius.circular(
                                                                10)),
                                                    style: const TextStyle(
                                                        color: Colors.black,
                                                        fontSize: 20),
                                                    underline: const SizedBox(),
                                                    onChanged:
                                                        (String? newValue) {
                                                      if (newValue != null) {
                                                        postController
                                                            .updateSelectedOption(
                                                                newValue);
                                                      }
                                                    },
                                                    items: postController
                                                        .options
                                                        .map<
                                                            DropdownMenuItem<
                                                                String>>((String
                                                            value) {
                                                      return DropdownMenuItem<
                                                          String>(
                                                        value: value,
                                                        child: Text(value),
                                                      );
                                                    }).toList(),
                                                  )),
                                            ],
                                          ),
                                          PostListCard(
                                            post: post,
                                            postUser: postUser,
                                            currentUser: user,
                                            theme: theme,
                                            postController: postController,
                                          ),
                                        ],
                                      )
                                    : PostListCard(
                                        post: post,
                                        postUser: postUser,
                                        currentUser: user,
                                        theme: theme,
                                        postController: postController,
                                      )
                                        .animate()
                                        .scale(duration: duration750)
                                        .fadeIn(duration: duration750),
                                const SizedBox(
                                  height: 10,
                                ),
                              ],
                            );
                          }
                        },
                      ),
                    ),
                  );
                }
              },
            ),
          ),
        ],
      ),
    );
  }
}

```

---


### Pages\Society\Widgets\post_notification_tabs\edit_notify_bottomsheet.dart

```dart
import 'dart:ui';

import 'package:cached_network_image/cached_network_image.dart';
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:tictactoe_gameapp/Configs/assets_path.dart';
import 'package:tictactoe_gameapp/Models/general_notifications_model.dart';
import 'package:tictactoe_gameapp/Pages/Society/Widgets/post_notification_controller.dart';

class EditNotifyBottomsheet extends StatelessWidget {
  final ScrollController scrollController;
  final GeneralNotificationsModel likeNotification;
  final PostNotificationController postNotificationController;
  const EditNotifyBottomsheet(
      {super.key,
      required this.likeNotification,
      required this.scrollController,
      required this.postNotificationController});

  @override
  Widget build(BuildContext context) {
    return SingleChildScrollView(
      controller: scrollController,
      child: Column(
        children: [
          Container(
            height: 5,
            width: 50,
            margin: const EdgeInsets.only(top: 10),
            decoration: const BoxDecoration(
              color: Colors.blueGrey,
              borderRadius: BorderRadius.all(Radius.circular(20)),
            ),
          ),
          const SizedBox(
            height: 10,
          ),
          CircleAvatar(
            backgroundImage: CachedNetworkImageProvider(
                likeNotification.senderModel!.image!),
            radius: 30,
          ),
          Text(
            likeNotification.senderModel!.name!,
            style: const TextStyle(
              color: Colors.blue,
              fontSize: 20,
              fontWeight: FontWeight.bold,
            ),
          ),
          const SizedBox(
            height: 10,
          ),
          Text(
            likeNotification.message!,
            maxLines: 3,
            style: const TextStyle(
              color: Colors.blueGrey,
              fontSize: 15,
            ),
          ),
          const SizedBox(
            height: 10,
          ),
          Material(
            child: InkWell(
              splashColor: Colors.blueGrey,
              onTap: () async {
                Get.showOverlay(
                    asyncFunction: () async {
                      await postNotificationController
                          .turnOffNotify(likeNotification.postId!);
                    },
                    loadingWidget: Center(
                      child: Stack(
                        children: [
                          Positioned.fill(
                            child: BackdropFilter(
                              filter:
                                  ImageFilter.blur(sigmaX: 5.0, sigmaY: 5.0),
                              child: const SizedBox(),
                            ),
                          ),
                          ClipRRect(
                            borderRadius: BorderRadius.circular(100),
                            child: Image.asset(
                              GifsPath.loadingGif,
                              height: 200,
                              width: 200,
                            ),
                          ),
                        ],
                      ),
                    ));
              },
              child: Obx(() => Row(
                    children: [
                      Container(
                        width: 50,
                        height: 50,
                        margin: const EdgeInsets.all(10),
                        decoration: BoxDecoration(
                          shape: BoxShape.circle,
                          color: postNotificationController.isNotifed.value
                              ? Colors.blueAccent
                              : Colors.grey,
                        ),
                        child: postNotificationController.isNotifed.value
                            ? const Icon(
                                Icons.notifications_active_rounded,
                                color: Colors.white,
                              )
                            : const Icon(Icons.notifications_off),
                      ),
                      const SizedBox(
                        width: 10,
                      ),
                      postNotificationController.isNotifed.value
                          ? const Expanded(
                              child: Text(
                                "Turn off status update notifications for this ...",
                              ),
                            )
                          : const Expanded(
                              child: Text(
                                "Turn on status update notifications for this ...",
                              ),
                            ),
                    ],
                  )),
            ),
          ),
          const SizedBox(
            height: 10,
          ),
          Material(
            child: InkWell(
              splashColor: Colors.blueGrey,
              onTap: () async {
                await postNotificationController
                    .deleteNotification(likeNotification.id!);
              },
              child: Row(
                children: [
                  Container(
                    width: 50,
                    height: 50,
                    margin: const EdgeInsets.all(10),
                    decoration: const BoxDecoration(
                      shape: BoxShape.circle,
                      color: Colors.grey,
                    ),
                    child: const Icon(Icons.delete),
                  ),
                  const SizedBox(
                    width: 10,
                  ),
                  const Expanded(child: Text("Delete this notification")),
                ],
              ),
            ),
          ),
          const SizedBox(
            height: 10,
          ),
          Material(
            child: InkWell(
              splashColor: Colors.blueGrey,
              onTap: () {},
              child: Row(
                children: [
                  Container(
                    width: 50,
                    height: 50,
                    margin: const EdgeInsets.all(10),
                    decoration: const BoxDecoration(
                      shape: BoxShape.circle,
                      color: Colors.grey,
                    ),
                    child: const Icon(Icons.report),
                  ),
                  const SizedBox(
                    width: 10,
                  ),
                  const Expanded(child: Text("Report issue to the Boss")),
                ],
              ),
            ),
          ),
        ],
      ),
    );
  }
}

```

---


### Pages\Society\Widgets\post_notification_tabs\post_comment_tab.dart

```dart
import 'package:cached_network_image/cached_network_image.dart';
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:tictactoe_gameapp/Configs/assets_path.dart';
import 'package:tictactoe_gameapp/Models/Functions/time_functions.dart';
import 'package:tictactoe_gameapp/Models/user_model.dart';
import 'package:tictactoe_gameapp/Pages/Society/Widgets/post_notification_controller.dart';

class PostCommentTab extends StatelessWidget {
  final PostNotificationController postNotificationController;
  final UserModel user;
  final ThemeData theme;
  const PostCommentTab(
      {super.key,
      required this.postNotificationController,
      required this.theme,
      required this.user});

  @override
  Widget build(BuildContext context) {
    final ScrollController scrollController = ScrollController();
    return Obx(() {
      if (postNotificationController.commentNotifications.isEmpty) {
        return Center(
          child: Container(
            decoration: BoxDecoration(
              color: Colors.white,
              borderRadius: BorderRadius.circular(100),
            ),
            child: const CircularProgressIndicator(
              color: Colors.blue,
            ),
          ),
        );
      } else {
        var commentNotifications =
            postNotificationController.commentNotifications.toList();
        return NotificationListener<ScrollNotification>(
          onNotification: (ScrollNotification scrollInfo) {
            if (scrollInfo.metrics.pixels >=
                scrollInfo.metrics.maxScrollExtent - 200) {
              postNotificationController.loadMoreNotifications();
            }
            return true;
          },
          child: ListView.builder(
            controller: scrollController,
            physics: const BouncingScrollPhysics(),
            itemCount: commentNotifications.length,
            itemBuilder: (context, index) {
              var commentNotification = commentNotifications[index];
              var commentUser = commentNotification.senderModel!;
              return Material(
                color: commentNotification.isReaded!
                    ? Colors.transparent
                    : Colors.lightBlueAccent.shade100,
                child: InkWell(
                  splashColor: Colors.white,
                  onTap: () {
                    postNotificationController
                        .markAsRead(commentNotification.id!);
                  },
                  child: Padding(
                    padding: const EdgeInsets.all(10),
                    child: Row(
                      children: [
                        Stack(
                          clipBehavior: Clip.none,
                          children: [
                            CircleAvatar(
                              backgroundImage: CachedNetworkImageProvider(
                                  commentUser.image!),
                              radius: 25,
                            ),
                            Positioned(
                              bottom: -10,
                              right: -10,
                              child: Container(
                                width: 30,
                                height: 30,
                                decoration: const BoxDecoration(
                                  shape: BoxShape.circle,
                                  color: Colors.blueAccent,
                                ),
                                child: const Icon(
                                  Icons.thumb_up,
                                  color: Colors.white,
                                ),
                              ),
                            )
                          ],
                        ),
                        const SizedBox(
                          width: 20,
                        ),
                        Expanded(
                          child: Column(
                            crossAxisAlignment: CrossAxisAlignment.start,
                            children: [
                              Text(
                                TimeFunctions.timeAgo(
                                  now: DateTime.now(),
                                  createdAt:
                                      commentNotification.timestamp!.toDate(),
                                ),
                                style: const TextStyle(
                                  color: Colors.blueGrey,
                                  fontSize: 13,
                                ),
                              ),
                              Text(
                                commentNotification.message!,
                                maxLines: 3,
                                overflow: TextOverflow.ellipsis,
                                style: theme.textTheme.titleMedium,
                              ),
                            ],
                          ),
                        ),
                        const SizedBox(
                          width: 10,
                        ),
                        Column(
                          children: [
                            ClipRRect(
                              borderRadius: BorderRadius.circular(10),
                              child: Image.asset(
                                ImagePath.board_9x9,
                                width: 50,
                              ),
                            ),
                          ],
                        )
                      ],
                    ),
                  ),
                ),
              );
            },
          ),
        );
      }
    });
  }
}

```

---


### Pages\Society\Widgets\post_notification_tabs\post_like_tab.dart

```dart
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:tictactoe_gameapp/Components/belong_to_users/avatar_user_widget.dart';
import 'package:tictactoe_gameapp/Configs/assets_path.dart';
import 'package:tictactoe_gameapp/Models/Functions/general_bottomsheet_show_function.dart';
import 'package:tictactoe_gameapp/Models/Functions/time_functions.dart';
import 'package:tictactoe_gameapp/Models/user_model.dart';
import 'package:tictactoe_gameapp/Pages/Society/About/user_about_page.dart';
import 'package:tictactoe_gameapp/Pages/Society/Widgets/post_notification_controller.dart';
import 'package:tictactoe_gameapp/Pages/Society/Widgets/post_notification_tabs/edit_notify_bottomsheet.dart';

class PostLikeTab extends StatelessWidget {
  final PostNotificationController postNotificationController;
  final UserModel user;
  final ThemeData theme;
  const PostLikeTab(
      {super.key,
      required this.postNotificationController,
      required this.theme,
      required this.user});

  @override
  Widget build(BuildContext context) {
    final ScrollController scrollController = ScrollController();
    return Obx(() {
      if (postNotificationController.likeNotifications.isEmpty) {
        return Center(
          child: Container(
            decoration: BoxDecoration(
              color: Colors.white,
              borderRadius: BorderRadius.circular(100),
            ),
            child: const CircularProgressIndicator(
              color: Colors.blue,
            ),
          ),
        );
      } else {
        var likeNotifications =
            postNotificationController.likeNotifications.toList();
        return NotificationListener<ScrollNotification>(
          onNotification: (ScrollNotification scrollInfo) {
            if (scrollInfo.metrics.pixels >=
                scrollInfo.metrics.maxScrollExtent - 200) {
              postNotificationController.loadMoreNotifications();
            }
            return true;
          },
          child: ListView.builder(
            controller: scrollController,
            physics: const BouncingScrollPhysics(),
            itemCount: likeNotifications.length,
            itemBuilder: (context, index) {
              var likeNotification = likeNotifications[index];
              var likeUser = likeNotification.senderModel!;
              return Material(
                color: likeNotification.isReaded!
                    ? Colors.transparent
                    : Colors.lightBlueAccent.shade100,
                child: InkWell(
                  splashColor: Colors.white,
                  onTap: () async {
                    await postNotificationController
                        .markAsRead(likeNotification.id!);
                    Get.to(
                        UserAboutPage(
                          unknownableUser: likeUser,
                        ),
                        transition: Transition.leftToRightWithFade);
                  },
                  onLongPress: () async {
                    await postNotificationController
                        .checkIsNotifed(likeNotification.postId!);
                    await GeneralBottomsheetShowFunction
                        .showScrollableGeneralBottomsheet(
                      widgetBuilder: (context, controller) =>
                          EditNotifyBottomsheet(
                        likeNotification: likeNotification,
                        scrollController: controller,
                        postNotificationController: postNotificationController,
                      ),
                      context: context,
                      initHeight: 0.5,
                    );
                  },
                  child: Padding(
                    padding: const EdgeInsets.all(10),
                    child: Row(
                      children: [
                        Stack(
                          clipBehavior: Clip.none,
                          children: [
                            AvatarUserWidget(
                              radius: 25,
                              imagePath: likeUser.image!,
                              gradientColors: likeUser.avatarFrame,
                            ),
                            Positioned(
                              bottom: -10,
                              right: -10,
                              child: Container(
                                width: 30,
                                height: 30,
                                decoration: const BoxDecoration(
                                  shape: BoxShape.circle,
                                  color: Colors.blueAccent,
                                ),
                                child: const Icon(
                                  Icons.thumb_up,
                                  color: Colors.white,
                                ),
                              ),
                            )
                          ],
                        ),
                        const SizedBox(
                          width: 20,
                        ),
                        Expanded(
                          child: Column(
                            crossAxisAlignment: CrossAxisAlignment.start,
                            children: [
                              Text(
                                TimeFunctions.timeAgo(
                                  now: DateTime.now(),
                                  createdAt:
                                      likeNotification.timestamp!.toDate(),
                                ),
                                style: const TextStyle(
                                  color: Colors.blueGrey,
                                  fontSize: 13,
                                ),
                              ),
                              Text(
                                likeNotification.message!,
                                maxLines: 3,
                                overflow: TextOverflow.ellipsis,
                                style: theme.textTheme.titleMedium,
                              ),
                              Text(
                                "post : ${likeNotification.postId!}",
                                maxLines: 3,
                                overflow: TextOverflow.ellipsis,
                                style: theme.textTheme.titleSmall,
                              ),
                            ],
                          ),
                        ),
                        const SizedBox(
                          width: 10,
                        ),
                        Column(
                          children: [
                            ClipRRect(
                              borderRadius: BorderRadius.circular(10),
                              child: Image.asset(
                                ImagePath.board_9x9,
                                width: 50,
                              ),
                            ),
                          ],
                        )
                      ],
                    ),
                  ),
                ),
              );
            },
          ),
        );
      }
    });
  }
}

```

---


### Pages\Society\Widgets\post_notification_tabs\post_other_tab.dart

```dart
import 'package:cached_network_image/cached_network_image.dart';
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:tictactoe_gameapp/Configs/assets_path.dart';
import 'package:tictactoe_gameapp/Models/Functions/time_functions.dart';
import 'package:tictactoe_gameapp/Models/user_model.dart';
import 'package:tictactoe_gameapp/Pages/Society/Widgets/post_notification_controller.dart';

class PostOthersTab extends StatelessWidget {
  final PostNotificationController postNotificationController;
  final UserModel user;
  final ThemeData theme;
  const PostOthersTab(
      {super.key,
      required this.postNotificationController,
      required this.theme,
      required this.user});

  @override
  Widget build(BuildContext context) {
    final ScrollController scrollController = ScrollController();
    return Obx(() {
      if (postNotificationController.sharedNotifications.isEmpty) {
        return Center(
          child: Container(
            decoration: BoxDecoration(
              color: Colors.white,
              borderRadius: BorderRadius.circular(100),
            ),
            child: const CircularProgressIndicator(
              color: Colors.blue,
            ),
          ),
        );
      } else {
        var sharedNotifications =
            postNotificationController.sharedNotifications.toList();
        return NotificationListener<ScrollNotification>(
          onNotification: (ScrollNotification scrollInfo) {
            if (scrollInfo.metrics.pixels >=
                scrollInfo.metrics.maxScrollExtent - 200) {
              postNotificationController.loadMoreNotifications();
            }
            return true;
          },
          child: ListView.builder(
            controller: scrollController,
            physics: const BouncingScrollPhysics(),
            itemCount: sharedNotifications.length,
            itemBuilder: (context, index) {
              var sharedNotification = sharedNotifications[index];
              var sharedUser = sharedNotification.senderModel!;
              return Material(
                color: sharedNotification.isReaded!
                    ? Colors.transparent
                    : Colors.lightBlueAccent.shade100,
                child: InkWell(
                  splashColor: Colors.white,
                  onTap: () {
                    postNotificationController.markAsRead(sharedNotification.id!);
                  },
                  child: Padding(
                    padding: const EdgeInsets.all(10),
                    child: Row(
                      children: [
                        Stack(
                          clipBehavior: Clip.none,
                          children: [
                            CircleAvatar(
                              backgroundImage:
                                  CachedNetworkImageProvider(sharedUser.image!),
                              radius: 25,
                            ),
                            Positioned(
                              bottom: -10,
                              right: -10,
                              child: Container(
                                width: 30,
                                height: 30,
                                decoration: const BoxDecoration(
                                  shape: BoxShape.circle,
                                  color: Colors.blueAccent,
                                ),
                                child: const Icon(
                                  Icons.thumb_up,
                                  color: Colors.white,
                                ),
                              ),
                            )
                          ],
                        ),
                        const SizedBox(
                          width: 20,
                        ),
                        Expanded(
                          child: Column(
                            crossAxisAlignment: CrossAxisAlignment.start,
                            children: [
                              Text(
                                TimeFunctions.timeAgo(
                                  now: DateTime.now(),
                                  createdAt:
                                      sharedNotification.timestamp!.toDate(),
                                ),
                                style: const TextStyle(
                                  color: Colors.grey,
                                  fontSize: 13,
                                ),
                              ),
                              Text(
                                sharedNotification.message!,
                                maxLines: 3,
                                overflow: TextOverflow.ellipsis,
                                style: theme.textTheme.titleMedium,
                              ),
                              Text(
                                "post : ${sharedNotification.postId!}",
                                maxLines: 3,
                                overflow: TextOverflow.ellipsis,
                                style: theme.textTheme.titleSmall,
                              ),
                            ],
                          ),
                        ),
                        const SizedBox(
                          width: 10,
                        ),
                        Column(
                          children: [
                            ClipRRect(
                              borderRadius: BorderRadius.circular(10),
                              child: Image.asset(
                                ImagePath.board_11x11,
                                width: 50,
                              ),
                            ),
                          ],
                        )
                      ],
                    ),
                  ),
                ),
              );
            },
          ),
        );
      }
    });
  }
}

```

---


### Pages\Society\Widgets\post_polls\create_polls_inpost_page.dart

```dart
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:tictactoe_gameapp/Models/Functions/time_functions.dart';
import 'package:tictactoe_gameapp/Pages/Society/Widgets/post_polls/poll_controller.dart';
import 'package:tictactoe_gameapp/Pages/Society/Widgets/post_polls/text_field_custom_widget.dart';

class CreatePollsInpostPage extends StatelessWidget {
  const CreatePollsInpostPage({super.key});

  @override
  Widget build(BuildContext context) {
    final PollController pollController = Get.put(PollController());
    final ThemeData theme = Theme.of(context);
    return Scaffold(
      appBar: AppBar(
        leading: IconButton(
          onPressed: () => Get.back(),
          icon: const Icon(
            Icons.arrow_back,
            size: 40,
            color: Colors.deepPurple,
          ),
        ),
        centerTitle: false,
        title: Text(
          "Create a poll in your post",
          style: theme.textTheme.bodyLarge,
        ),
        actions: [
          Obx(() {
            return InkWell(
              onTap: pollController.isComplete.value
                  ? () =>
                      Get.back(result: pollController.createPostPollsModel())
                  : null,
              child: Ink(
                height: 50,
                width: 100,
                decoration: BoxDecoration(
                  color: pollController.isComplete.value
                      ? Colors.blueAccent
                      : Colors.grey,
                  borderRadius: BorderRadius.circular(10),
                ),
                child: Center(
                  child: Text(
                    "Done",
                    style: theme.textTheme.bodyLarge!.copyWith(
                        color: pollController.isComplete.value
                            ? Colors.white
                            : Colors.black45),
                  ),
                ),
              ),
            );
          }),
        ],
      ),
      body: Padding(
        padding: const EdgeInsets.all(8.0),
        child: SingleChildScrollView(
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              const Text("Your question *",
                  style: TextStyle(color: Colors.blueGrey)),
              const SizedBox(
                height: 5,
              ),
              TextFieldCustomWidget(
                fieldHeight: 120,
                maxLength: 140,
                labelText: "Add question",
                onChanged: (value) {
                  pollController.questionContent.value = value;
                },
              ),
              const SizedBox(
                height: 20,
              ),
              const Text("Option *", style: TextStyle(color: Colors.blueGrey)),
              const SizedBox(
                height: 5,
              ),
              Obx(() => Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      const Text(
                        "Required Options",
                        style: TextStyle(color: Colors.grey),
                      ),
                      ...List.generate(2, (index) {
                        return OptionField(
                          controller: pollController.optionControllers[index],
                          hintText: "Required Option ${index + 1}",
                        );
                      }),
                      const Divider(),
                      const Text(
                        "Optional Options",
                        style: TextStyle(color: Colors.grey),
                      ),
                      ...pollController.optionControllers
                          .sublist(2)
                          .asMap()
                          .entries
                          .map((entry) => OptionField(
                                controller: entry.value,
                                hintText: "Optional Option ${entry.key + 3}",
                                onRemove: () => pollController
                                    .removeOptionField(entry.key + 2),
                              )),
                    ],
                  )),
              const SizedBox(
                height: 10,
              ),
              OutlinedButton(
                style: OutlinedButton.styleFrom(
                  maximumSize: const Size(150, 50),
                  foregroundColor: Colors.blueAccent,
                  backgroundColor: Colors.white,
                  disabledBackgroundColor: Colors.blueGrey,
                  shape: RoundedRectangleBorder(
                    // The button's outline is defined as a rounded rectangle with circular corners
                    borderRadius: BorderRadius.circular(30.0),
                  ),
                ),
                onPressed: () {
                  pollController.addOptionField();
                },
                child: const Row(
                  children: [
                    Icon(Icons.add),
                    SizedBox(
                      width: 5,
                    ),
                    Text("Add option"),
                  ],
                ),
              ),
              const SizedBox(
                height: 20,
              ),
              const Text("Deadline of poll *",
                  style: TextStyle(color: Colors.blueGrey)),
              const SizedBox(height: 5),
              Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Container(
                    padding: const EdgeInsets.all(5.0),
                    decoration: BoxDecoration(
                        color: Colors.transparent,
                        border: Border.all(color: Colors.black, width: 2),
                        borderRadius: BorderRadius.circular(10)),
                    child: Obx(() => Text(
                          pollController.selectedDateTime.value != null
                              ? TimeFunctions.formatDateTime(
                                  pollController.selectedDateTime.value!)
                              : 'No date/time selected',
                          style: const TextStyle(
                            fontSize: 16,
                            fontWeight: FontWeight.bold,
                          ),
                        )),
                  ),
                  const SizedBox(
                    height: 10,
                  ),
                  ElevatedButton(
                    style: ElevatedButton.styleFrom(
                      maximumSize: const Size(150, 50),
                      backgroundColor: Colors.white,
                    ),
                    onPressed: () async {
                      final result = await TimeFunctions.pickDateTime(context,
                          initialDateTime: DateTime.now());
                      if (result != null) {
                        pollController.selectedDateTime.value = result;
                      }
                    },
                    child: const Row(
                      children: [
                        Icon(Icons.timer),
                        SizedBox(
                          width: 5,
                        ),
                        Text('Deadline'),
                      ],
                    ),
                  ),
                ],
              )
            ],
          ),
        ),
      ),
    );
  }
}

class OptionField extends StatelessWidget {
  final TextEditingController controller;
  final String hintText;
  final VoidCallback? onRemove;

  const OptionField({
    required this.controller,
    required this.hintText,
    this.onRemove,
    super.key,
  });

  @override
  Widget build(BuildContext context) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 5),
      child: Row(
        children: [
          Expanded(
            child: TextField(
              controller: controller,
              maxLength: 30,
              decoration: InputDecoration(
                hintText: hintText,
                border: OutlineInputBorder(
                  borderRadius: BorderRadius.circular(8.0),
                ),
              ),
            ),
          ),
          if (onRemove != null)
            IconButton(
              onPressed: onRemove,
              icon: const Icon(
                Icons.delete,
                color: Colors.red,
                size: 35,
              ),
            ),
        ],
      ),
    );
  }
}

```

---


### Pages\Society\Widgets\post_polls\poll_controller.dart

```dart
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:tictactoe_gameapp/Pages/Society/Widgets/post_polls/post_polls_model.dart';
import 'package:uuid/uuid.dart';

class PollController extends GetxController {
  var uuid = const Uuid();
  RxString questionContent = "".obs;
  RxList<TextEditingController> optionControllers = <TextEditingController>[
    TextEditingController(),
    TextEditingController(),
  ].obs;
  Rxn<DateTime> selectedDateTime = Rxn<DateTime>();
  RxBool isComplete = false.obs;

  @override
  void onInit() {
    super.onInit();
    everAll([questionContent, optionControllers, selectedDateTime], (_) {
      isComplete.value = _checkCompletion();
    });
  }

  @override
  void onClose() {
    for (var controller in optionControllers) {
      controller.dispose();
    }
    super.onClose();
  }

  bool _checkCompletion() {
    return questionContent.isNotEmpty &&
        optionControllers.length >= 2 &&
        optionControllers
            .every((controller) => controller.text.trim().isNotEmpty) &&
        selectedDateTime.value != null &&
        selectedDateTime.value!.isAfter(DateTime.now()) &&
        !_hasDuplicateOptions();
  }

  bool _hasDuplicateOptions() {
    final texts =
        optionControllers.map((c) => c.text.trim().toLowerCase()).toList();
    return texts.toSet().length != texts.length;
  }

  void addOptionField() {
    if (optionControllers.length < 10) {
      optionControllers.add(TextEditingController());
    } else {
      Get.snackbar("Limit Reached", "Maximum 10 options allowed.");
    }
  }

  void removeOptionField(int index) {
    if (optionControllers.length > 2) {
      // Đảm bảo còn ít nhất 2 options
      optionControllers.removeAt(index);
    } else {
      Get.snackbar("Minimum Required", "At least 2 options are required.");
    }
  }

  void setEndDate(DateTime? dateTime) {
    if (dateTime != null && dateTime.isAfter(DateTime.now())) {
      selectedDateTime.value = dateTime;
    } else {
      Get.snackbar("Invalid Date", "End date must be in the future.");
    }
  }

  PostPollsModel createPostPollsModel() {
    String pollId = "${uuid.v4()}_${DateTime.now().millisecondsSinceEpoch}";
    return PostPollsModel(
      pollId: pollId,
      question: questionContent.value.trim(),
      endDate: selectedDateTime.value,
      options: optionControllers
          .asMap()
          .entries
          .map((entry) => OptionalPolls(
                id: entry.key + 1,
                title: entry.value.text.trim(),
                votes: 0,
              ))
          .toList(),
    );
  }
}

```

---


### Pages\Society\Widgets\post_polls\post_polls_card.dart

```dart
import 'package:flutter/material.dart';
import 'package:flutter_polls/flutter_polls.dart';
import 'package:tictactoe_gameapp/Pages/Society/social_post_controller.dart';
import 'package:tictactoe_gameapp/Pages/Society/Widgets/post_polls/post_polls_model.dart';

class PostPollWidget extends StatelessWidget {
  final PostPollsModel postPollsModel;
  final PostController? postController;
  final String? postId;
  final String? userId;

  const PostPollWidget({
    super.key,
    required this.postPollsModel,
    this.postController,
    this.postId,
    this.userId,
  });

  @override
  Widget build(BuildContext context) {
    final int days = DateTime(
      postPollsModel.endDate!.year,
      postPollsModel.endDate!.month,
      postPollsModel.endDate!.day,
    )
        .difference(DateTime(
          DateTime.now().year,
          DateTime.now().month,
          DateTime.now().day,
        ))
        .inDays;
    final bool pollEnded = days < 0;
    return Container(
      padding: const EdgeInsets.all(10),
      decoration: BoxDecoration(
        color: Colors.blue.withOpacity(0.3),
        borderRadius: BorderRadius.circular(10),
        border: Border.all(color: Colors.blueGrey, width: 3),
      ),
      child: FlutterPolls(
        pollId: postPollsModel.pollId,
        hasVoted: postPollsModel.voterList?.contains(userId) ?? false,
        userVotedOptionId: postPollsModel.options
            ?.firstWhere((opt) => opt.votedUserIds?.contains(userId) ?? false,
                orElse: () => OptionalPolls())
            .id
            ?.toString(),
        onVoted: (PollOption pollOption, int newTotalVotes) async {
          if (postId != null && userId != null && postController != null) {
            return await postController!.onVoteFunction(
              pollOption: pollOption,
              newTotalVotes: newTotalVotes,
              postPolls: postPollsModel,
              postId: postId!,
              userId: userId!,
            );
          } else {
            return false;
          }
        },
        pollEnded: pollEnded,
        loadingWidget: const CircularProgressIndicator(
          valueColor: AlwaysStoppedAnimation<Color>(Colors.blueAccent),
        ),
        pollTitle: Align(
          alignment: Alignment.centerLeft,
          child: Text(
            postPollsModel.question!,
            style: const TextStyle(
              fontSize: 14,
              fontWeight: FontWeight.w600,
            ),
          ),
        ),
        pollOptions: List<PollOption>.from(
          postPollsModel.options!.map(
            (option) => PollOption(
              id: option.id.toString(),
              title: Text(
                option.title!,
                maxLines: 2,
                style: const TextStyle(
                    fontSize: 14,
                    fontWeight: FontWeight.w600,
                    overflow: TextOverflow.ellipsis),
              ),
              votes: option.votes!,
            ),
          ),
        ),
        votedPercentageTextStyle: const TextStyle(
          fontSize: 14,
          fontWeight: FontWeight.w600,
        ),
        // pollOptionsFillColor:
        //     pollEnded ? Colors.grey.withOpacity(0.5) : Colors.white,
        // pollOptionsBorder:
        //     pollEnded ? null : Border.all(color: Colors.grey, width: 1),
        metaWidget: Row(
          children: [
            const SizedBox(width: 6),
            postPollsModel.voterList != null
                ? Text(postPollsModel.voterList!.length.toString())
                : const Text("0"),
            const SizedBox(width: 6),
            const Text("Voters"),
            const SizedBox(width: 6),
            const Text(
              '•',
            ),
            const SizedBox(
              width: 6,
            ),
            Expanded(
              child: Text(
                _pollStatusText(days),
              ),
            ),
            GestureDetector(
              onTap: postId != null && userId != null && postController != null
                  ? () async {
                      await postController!.undoVoteFunction(
                        postPolls: postPollsModel,
                        postId: postId!,
                        userId: userId!,
                      );
                    }
                  : null,
              child: const Text(
                "Undo",
                style:
                    TextStyle(color: Colors.blue, fontStyle: FontStyle.italic),
              ),
            )
          ],
        ),
      ),
    );
  }

  String _pollStatusText(int days) {
    if (days < 0) {
      return "Poll ended";
    } else if (days == 0) {
      return "Ends today";
    } else {
      return "Ends in $days days";
    }
  }
}

```

---


### Pages\Society\Widgets\post_polls\post_polls_model.dart

```dart
import 'package:cloud_firestore/cloud_firestore.dart';

class PostPollsModel {
  String? pollId; // ID của poll
  String? question; // Câu hỏi trong poll
  DateTime? endDate; // Ngày kết thúc poll
  List<OptionalPolls>? options; // Các lựa chọn trong poll
  List<String>? voterList;

  PostPollsModel({
    this.pollId,
    this.question,
    this.endDate,
    this.options,
    this.voterList,
  });

  // Constructor để chuyển từ JSON sang PostPollsModel
  PostPollsModel.fromJson(Map<String, dynamic> json) {
    pollId = json['pollId'] as String?;
    question = json['question'] as String?;
    if (json['endDate'] is Timestamp) {
      endDate = (json['endDate'] as Timestamp).toDate();
    }
    if (json['options'] is List) {
      options = (json['options'] as List)
          .map((option) => OptionalPolls.fromJson(option))
          .toList();
    }
    if (json['voterList'] is List) {
      voterList = List<String>.from(json['voterList']);
    }
  }

  // Phương thức để chuyển PostPollsModel thành JSON
  Map<String, dynamic> toJson() {
    final Map<String, dynamic> data = <String, dynamic>{};
    data['pollId'] = pollId;
    data['question'] = question;
    if (endDate != null) {
      data['endDate'] = Timestamp.fromDate(endDate!);
    }
    if (options != null) {
      data['options'] = options?.map((option) => option.toJson()).toList();
    }
    data['voterList'] = voterList;

    return data;
  }
}

class OptionalPolls {
  int? id; // ID của lựa chọn
  String? title; // Nội dung của lựa chọn
  int? votes; // Số lượng votes của lựa chọn
    List<String>? votedUserIds;

  OptionalPolls({
    this.id,
    this.title,
    this.votes,
    this.votedUserIds,
  });

  // Constructor để chuyển từ JSON sang PollOption
  OptionalPolls.fromJson(Map<String, dynamic> json) {
    id = json['id'] as int?;
    title = json['title'] as String?;
    votes = json['votes'] as int? ?? 0;
    if (json['votedUserIds'] is List) {
      votedUserIds = List<String>.from(json['votedUserIds']);
    }
  }

  // Phương thức để chuyển PollOption thành JSON
  Map<String, dynamic> toJson() {
    final Map<String, dynamic> data = <String, dynamic>{};
    data['id'] = id;
    data['title'] = title;
    data['votes'] = votes;
    if (votedUserIds!= null) {
      data['votedUserIds'] = votedUserIds;
    }

    return data;
  }
}

```

---


### Pages\Society\Widgets\post_polls\test_poll.dart

```dart
import 'package:flutter/material.dart';
import 'package:flutter_polls/flutter_polls.dart';
// ignore: depend_on_referenced_packages
import 'package:percent_indicator/linear_percent_indicator.dart';
import 'package:tictactoe_gameapp/Pages/Society/social_post_controller.dart';
import 'package:tictactoe_gameapp/Pages/Society/Widgets/post_polls/post_polls_model.dart';

class PollCard extends StatelessWidget {
  final String title;
  final List<PollOptionData> options;
  final bool hasVoted;
  final String? votedOptionId;
  final bool pollEnded;
  final Function(PollOptionData) onVote;

  const PollCard({
    super.key,
    required this.title,
    required this.options,
    this.hasVoted = false,
    this.votedOptionId,
    this.pollEnded = false,
    required this.onVote,
  });

  @override
  Widget build(BuildContext context) {
    final totalVotes =
        options.fold<int>(0, (sum, option) => sum + option.votes);

    return Card(
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(16),
      ),
      elevation: 4,
      margin: const EdgeInsets.all(16),
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // Poll title
            Text(
              title,
            ),
            const SizedBox(height: 16),

            // Poll options
            ...options.map((option) {
              final isSelected = votedOptionId == option.id;
              final votePercentage =
                  totalVotes == 0 ? 0.0 : option.votes / totalVotes;

              return GestureDetector(
                onTap: (!hasVoted && !pollEnded) ? () => onVote(option) : null,
                child: Container(
                  margin: const EdgeInsets.symmetric(vertical: 8),
                  decoration: BoxDecoration(
                    color: hasVoted
                        ? (isSelected
                            ? Colors.blue.shade100
                            : Colors.grey.shade200)
                        : Colors.white,
                    borderRadius: BorderRadius.circular(12),
                    border: Border.all(
                      color: hasVoted
                          ? (isSelected ? Colors.blue : Colors.grey.shade400)
                          : Colors.grey.shade300,
                      width: 1.5,
                    ),
                  ),
                  child: Stack(
                    children: [
                      // Background progress bar
                      if (hasVoted || pollEnded)
                        LinearPercentIndicator(
                          lineHeight: 48,
                          percent: votePercentage,
                          backgroundColor: Colors.transparent,
                          progressColor:
                              isSelected ? Colors.blue : Colors.grey.shade400,
                          barRadius: const Radius.circular(12),
                        ),

                      // Option text and vote percentage
                      Padding(
                        padding: const EdgeInsets.symmetric(
                          vertical: 12,
                          horizontal: 16,
                        ),
                        child: Row(
                          children: [
                            Expanded(
                              child: Text(
                                option.title,
                              ),
                            ),
                            if (hasVoted || pollEnded)
                              Text(
                                "${(votePercentage * 100).toStringAsFixed(1)}%",
                              ),
                          ],
                        ),
                      ),
                    ],
                  ),
                ),
              );
            }),

            const SizedBox(height: 16),

            // Poll footer
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                Text(
                  "Total votes: $totalVotes",
                ),
                if (pollEnded)
                  const Text(
                    "Poll ended",
                    style: TextStyle(
                      color: Colors.red,
                      fontWeight: FontWeight.bold,
                    ),
                  ),
              ],
            ),
          ],
        ),
      ),
    );
  }
}

class PollOptionData {
  final String id;
  final String title;
  final int votes;

  PollOptionData({
    required this.id,
    required this.title,
    required this.votes,
  });
}

class PostPollWidget2 extends StatelessWidget {
  final PostPollsModel postPollsModel;
  final PostController? postController;
  final String? postId;
  final String? userId;

  const PostPollWidget2({
    super.key,
    required this.postPollsModel,
    this.postController,
    this.postId,
    this.userId,
  });

  @override
  Widget build(BuildContext context) {
    final int daysRemaining = DateTime(
      postPollsModel.endDate!.year,
      postPollsModel.endDate!.month,
      postPollsModel.endDate!.day,
    ).difference(DateTime.now()).inDays;

    final bool pollEnded = daysRemaining < 0;

    return Container(
      padding: const EdgeInsets.all(10),
      decoration: BoxDecoration(
        color: Colors.blue.withOpacity(0.3),
        borderRadius: BorderRadius.circular(10),
        border: Border.all(color: Colors.blueGrey, width: 3),
      ),
      child: PollCard(
        title: postPollsModel.question!,
        options: postPollsModel.options!
            .map(
              (option) => PollOptionData(
                id: option.id.toString(),
                title: option.title!,
                votes: option.votes!,
              ),
            )
            .toList(),
        hasVoted: postPollsModel.voterList?.contains(userId) ?? false,
        pollEnded: pollEnded,
        onVote: (optionId) async {
          final selectedOption = postPollsModel.options!.firstWhere(
            (option) => option.id.toString() == optionId,
          );

          if (postId != null && userId != null && postController != null) {
            await postController!.onVoteFunction(
              pollOption: PollOption(
                id: optionId.id,
                title: Text(selectedOption.title!),
                votes: selectedOption.votes!,
              ),
              newTotalVotes: selectedOption.votes! + 1,
              postPolls: postPollsModel,
              postId: postId!,
              userId: userId!,
            );
          }
        },
      ),
    );
  }

  String _pollStatusText(int daysRemaining) {
    if (daysRemaining < 0) {
      return "Poll ended";
    } else if (daysRemaining == 0) {
      return "Ends today";
    } else {
      return "Ends in $daysRemaining days";
    }
  }
}

```

---


### Pages\Society\Widgets\post_polls\text_field_custom_widget.dart

```dart
import 'package:flutter/material.dart';

class TextFieldCustomWidget extends StatelessWidget {
  final double fieldHeight;
  final String labelText;
  final Function(String)? onChanged;
  final int? maxLength;
  const TextFieldCustomWidget(
      {super.key,
      required this.fieldHeight,
      required this.labelText,
      this.onChanged,
      this.maxLength});

  @override
  Widget build(BuildContext context) {
    return SizedBox(
      height: fieldHeight,
      child: TextField(
        onChanged: onChanged,
        minLines: null,
        maxLines: null,
        expands: true,
        textAlign: TextAlign.left,
        maxLength: maxLength,
        textAlignVertical: TextAlignVertical.top,
        decoration: InputDecoration(
          fillColor: Colors.transparent,
          labelText: labelText,
          alignLabelWithHint: true,
          labelStyle: const TextStyle(color: Colors.grey),
          border: OutlineInputBorder(
            borderRadius: BorderRadius.circular(10),
            borderSide: const BorderSide(
              color: Colors.blueAccent,
            ),
          ),
        ),
      ),
    );
  }
}

```

---


### Pages\Splace\splace_page.dart

```dart
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:tictactoe_gameapp/Configs/assets_path.dart';
import 'package:tictactoe_gameapp/Controller/theme_controller.dart';
import '../../Controller/splace_controller.dart';

class SplacePage extends StatelessWidget {
  const SplacePage({super.key});

  @override
  Widget build(BuildContext context) {
    final SplaceController splaceController = Get.put(SplaceController());
    final ThemeController themeController = Get.find<ThemeController>();

    return !themeController.isDarkMode.value
        ? Scaffold(
            extendBodyBehindAppBar: true,
            backgroundColor: Colors.white,
            body: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                Padding(
                  padding: const EdgeInsets.all(20),
                  child: ClipRRect(
                    borderRadius: BorderRadius.circular(20),
                    child: Image.asset(GifsPath.chatbotGif),
                  ),
                ),
                const SizedBox(height: 30),
                Obx(
                  () => _buildProgressBar(
                    splaceController.progress.value,
                    Colors.blue,
                    Colors.grey,
                  ),
                ),
              ],
            ),
          )
        : Scaffold(
            backgroundColor: Colors.black,
            body: Container(
              width: double.infinity,
              height: double.infinity,
              decoration: const BoxDecoration(
                image: DecorationImage(
                  image: AssetImage(GifsPath.lightGif),
                  fit: BoxFit.cover,
                ),
              ),
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  Image.asset(GifsPath.cyberpunk),
                  const SizedBox(height: 30),
                  Obx(
                    () => _buildProgressBar(
                      splaceController.progress.value,
                      Colors.lightBlueAccent,
                      Colors.white,
                    ),
                  ),
                ],
              ),
            ),
          );
  }

  Widget _buildProgressBar(double progress, Color fillColor, Color bgColor) {
    return Column(
      children: [
        Container(
          width: 300,
          height: 20,
          decoration: BoxDecoration(
            borderRadius: BorderRadius.circular(10),
            gradient: LinearGradient(
              colors: [bgColor.withOpacity(0.3), bgColor.withOpacity(0.1)],
            ),
            boxShadow: [
              BoxShadow(
                color: fillColor.withOpacity(0.5),
                blurRadius: 10,
                spreadRadius: 2,
              ),
            ],
          ),
          child: Stack(
            children: [
              AnimatedContainer(
                duration: const Duration(milliseconds: 100),
                width: 300 * progress,
                decoration: BoxDecoration(
                  borderRadius: BorderRadius.circular(10),
                  gradient: LinearGradient(
                    colors: [fillColor, fillColor.withOpacity(0.7)],
                    begin: Alignment.centerLeft,
                    end: Alignment.centerRight,
                  ),
                ),
              ),
            ],
          ),
        ),
        const SizedBox(height: 10),
        Text(
          "${(progress * 100).toInt()}%", // Hiển thị số nguyên
          style: TextStyle(
            fontSize: 20,
            fontWeight: FontWeight.bold,
            color: fillColor,
            fontFamily: "Orbitron",
            shadows: [
              Shadow(
                color: fillColor.withOpacity(0.8),
                blurRadius: 5,
              ),
            ],
          ),
        ),
      ],
    );
  }
}

```

---


### Pages\UpdateProfile\border_frame_controller.dart

```dart
import 'dart:ui';

import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:tictactoe_gameapp/Controller/theme_controller.dart';
import 'package:tictactoe_gameapp/Models/Functions/gradient_generator_functions.dart';

class BorderFrameController extends GetxController {
  // Rx list to store gradients
  var gradients = <List<Color>>[].obs;
  var isLoading = false.obs;
  final ThemeController themeController = Get.find();
  late final ScrollController scrollController;

  @override
  void onInit() {
    super.onInit();
    scrollController = ScrollController();
    loadMoreGradients();
  }

  @override
  void onClose() {
    scrollController.dispose();
    super.onClose();
  }

  // Load more gradients function
  void loadMoreGradients() {
    if (isLoading.value) return;
    isLoading.value = true;

    Future.delayed(const Duration(milliseconds: 300), () {
      List<List<Color>> newGradients = List.generate(30, (_) {
        final colors =
            GradientGeneratorFunctions.getDynamicRandomGradientColors(
          colorCount: 2,
          isDarkMode: themeController.isDarkMode.value,
        );

        return colors;
      });

      // Sử dụng addAll để thêm nhiều phần tử một lần duy nhất
      gradients.addAll(newGradients);
      isLoading.value = false;
    });
  }
}

```

---


### Pages\UpdateProfile\update_profile_page.dart

```dart
import 'dart:io';
import 'dart:ui';
import 'package:confetti/confetti.dart';
import 'package:flutter/material.dart';
import 'package:flutter_svg/svg.dart';
import 'package:get/get.dart';
import 'package:image_picker/image_picker.dart';
import 'package:tictactoe_gameapp/Components/primary_with_icon_button.dart';
import 'package:tictactoe_gameapp/Configs/theme/colors.dart';
import 'package:tictactoe_gameapp/Configs/constants.dart';
import 'package:tictactoe_gameapp/Configs/messages.dart';
import 'package:tictactoe_gameapp/Controller/profile_controller.dart';
import 'package:tictactoe_gameapp/Models/Functions/color_string_reverse_function.dart';
import 'package:tictactoe_gameapp/Pages/UpdateProfile/border_frame_controller.dart';
import '../../Configs/assets_path.dart';

class UpdateProfile extends StatelessWidget {
  const UpdateProfile({super.key});

  @override
  Widget build(BuildContext context) {
    ProfileController profileController = Get.put(ProfileController());
    RxString imagePath = "".obs;
    TextEditingController nameController = TextEditingController();
    final formKey = GlobalKey<FormState>();
    final ConfettiController confettiController =
        ConfettiController(duration: const Duration(seconds: 5));
    final BorderFrameController frameController =
        Get.put(BorderFrameController());
    RxList<Color> avatarFrame = <Color>[].obs;

    return Scaffold(
      resizeToAvoidBottomInset: true,
      appBar: AppBar(
        leading: IconButton(
          onPressed: () => Get.back(),
          icon: const Icon(
            Icons.arrow_back_ios_new_rounded,
            color: primaryColor,
            size: 35,
          ),
        ),
        title: const Text(
          "Update Profile",
          style: TextStyle(
            fontWeight: FontWeight.bold,
            fontSize: 25,
            color: Colors.black,
          ),
        ),
      ),
      body: Padding(
        padding: const EdgeInsets.only(bottom: 5, right: 20, left: 20),
        child: SingleChildScrollView(
          child: Form(
            key: formKey,
            child: Column(
              mainAxisAlignment: MainAxisAlignment.spaceEvenly,
              children: [
                Column(
                  children: [
                    const Text(
                      "Avatar",
                      style: TextStyle(
                        fontWeight: FontWeight.bold,
                        fontSize: 20,
                      ),
                    ),
                    const Divider(),
                    const SizedBox(height: 20),
                    Row(
                      mainAxisAlignment: MainAxisAlignment.spaceEvenly,
                      children: [
                        Obx(
                          () => avatarFrame.toList().isNotEmpty
                              ? Container(
                                  padding: const EdgeInsets.all(5.0),
                                  decoration: BoxDecoration(
                                    gradient: LinearGradient(
                                      colors: avatarFrame.toList(),
                                      begin: Alignment.topLeft,
                                      end: Alignment.bottomRight,
                                    ),
                                    borderRadius: BorderRadius.circular(40),
                                  ),
                                  child: Obx(
                                    () => imagePath.isEmpty
                                        ? Container(
                                            width: 200,
                                            height: 200,
                                            decoration: BoxDecoration(
                                              color: Colors.white,
                                              borderRadius:
                                                  BorderRadius.circular(40),
                                            ),
                                            child: const Icon(
                                              Icons.add_a_photo_outlined,
                                              size: 50,
                                              color: Colors.grey,
                                            ),
                                          )
                                        : Container(
                                            width: 200,
                                            height: 200,
                                            decoration: BoxDecoration(
                                              // color: Colors.red,
                                              borderRadius:
                                                  BorderRadius.circular(40),
                                            ),
                                            child: ClipRRect(
                                              borderRadius:
                                                  BorderRadius.circular(40),
                                              child: Image.file(
                                                File(
                                                  imagePath.value,
                                                ),
                                                fit: BoxFit.cover,
                                              ),
                                            ),
                                          ),
                                  ),
                                )
                              : Obx(
                                  () => imagePath.isEmpty
                                      ? Container(
                                          width: 200,
                                          height: 200,
                                          decoration: BoxDecoration(
                                            color: Colors.white,
                                            borderRadius:
                                                BorderRadius.circular(40),
                                          ),
                                          child: const Icon(
                                            Icons.add_a_photo_outlined,
                                            size: 50,
                                            color: Colors.grey,
                                          ),
                                        )
                                      : Container(
                                          width: 200,
                                          height: 200,
                                          decoration: BoxDecoration(
                                            // color: Colors.red,
                                            borderRadius:
                                                BorderRadius.circular(40),
                                          ),
                                          child: ClipRRect(
                                            borderRadius:
                                                BorderRadius.circular(40),
                                            child: Image.file(
                                              File(
                                                imagePath.value,
                                              ),
                                              fit: BoxFit.cover,
                                            ),
                                          ),
                                        ),
                                ),
                        ),
                        const SizedBox(width: 20),
                        Column(
                          children: [
                            InkWell(
                              onTap: () async {
                                imagePath.value = await profileController
                                    .pickImage(ImageSource.gallery);
                              },
                              child: Container(
                                padding: const EdgeInsets.all(15),
                                decoration: BoxDecoration(
                                  color: Theme.of(context).colorScheme.primary,
                                  borderRadius: BorderRadius.circular(20),
                                ),
                                child: SvgPicture.asset(
                                  IconsPath.gallery,
                                  width: 40,
                                ),
                              ),
                            ),
                            const SizedBox(height: 30),
                            InkWell(
                              onTap: () async {
                                imagePath.value = await profileController
                                    .pickImage(ImageSource.camera);
                              },
                              child: Container(
                                padding: const EdgeInsets.all(15),
                                decoration: BoxDecoration(
                                  color:
                                      Theme.of(context).colorScheme.secondary,
                                  borderRadius: BorderRadius.circular(20),
                                ),
                                child: SvgPicture.asset(
                                  IconsPath.camera,
                                  width: 40,
                                ),
                              ),
                            ),
                          ],
                        )
                      ],
                    ),
                    const SizedBox(height: 20),
                    const Text(
                      "Nickname",
                      style: TextStyle(
                        fontWeight: FontWeight.bold,
                        fontSize: 20,
                      ),
                    ),
                    const Divider(),
                    const SizedBox(height: 20),
                    TextFormField(
                      controller: nameController,
                      maxLength: 20,
                      validator: nameProfile.call,
                      autovalidateMode: AutovalidateMode.onUserInteraction,
                      decoration: const InputDecoration(
                        hintText: "Enter your name",
                      ),
                    ),
                    const SizedBox(height: 20),
                    const Text(
                      "Border Frame",
                      style: TextStyle(
                        fontWeight: FontWeight.bold,
                        fontSize: 20,
                      ),
                    ),
                    const Divider(),
                    const SizedBox(height: 20),
                    SizedBox(
                      height: 400,
                      child: NotificationListener<ScrollNotification>(
                        onNotification: (ScrollNotification scrollInfo) {
                          if (!frameController.isLoading.value &&
                              scrollInfo.metrics.pixels >=
                                  scrollInfo.metrics.maxScrollExtent * 0.9) {
                            frameController.loadMoreGradients();
                          }
                          return true;
                        },
                        child: Obx(() => GridView.builder(
                              controller: frameController.scrollController,
                              scrollDirection: Axis.vertical,
                              physics: const BouncingScrollPhysics(),
                              gridDelegate:
                                  const SliverGridDelegateWithFixedCrossAxisCount(
                                crossAxisCount: 5,
                                mainAxisSpacing: 10,
                              ),
                              itemCount: frameController.gradients.length +
                                  (frameController.isLoading.value ? 1 : 0),
                              itemBuilder: (context, index) {
                                if (index < frameController.gradients.length) {
                                  var colors = frameController.gradients[index];
                                  return InkWell(
                                    splashColor: Colors.blue,
                                    onTap: () => avatarFrame.value = colors,
                                    child: Container(
                                      margin: const EdgeInsets.only(right: 5),
                                      padding: const EdgeInsets.all(5),
                                      decoration: BoxDecoration(
                                        shape: BoxShape.circle,
                                        gradient: LinearGradient(
                                          colors: colors,
                                          begin: Alignment.topLeft,
                                          end: Alignment.bottomRight,
                                        ),
                                      ),
                                      child: Obx(
                                        () => imagePath.isEmpty
                                            ? const DecoratedBox(
                                                decoration: BoxDecoration(
                                                    shape: BoxShape.circle,
                                                    color: Colors.white),
                                                child: Icon(
                                                  Icons.person,
                                                  size: 35,
                                                  color: Colors.blueGrey,
                                                ),
                                              )
                                            : ClipRRect(
                                                borderRadius:
                                                    BorderRadius.circular(100),
                                                child: Image.file(
                                                  File(
                                                    imagePath.value,
                                                  ),
                                                  fit: BoxFit.cover,
                                                ),
                                              ),
                                      ),
                                    ),
                                  );
                                } else {
                                  return const SizedBox();
                                }
                              },
                            )),
                      ),
                    ),
                  ],
                ),
                const SizedBox(height: 30),
                PrimaryIconWithButton(
                  color: Theme.of(context).colorScheme.primary,
                  buttonText: "Save",
                  onTap: () async {
                    if (formKey.currentState!.validate()) {
                      Get.showOverlay(
                          asyncFunction: () async {
                            await profileController.updateProfile(
                              nameController.text,
                              imagePath.value,
                              confettiController,
                              avatarFrame
                                  .toList()
                                  .map((color) =>
                                      ColorStringReverseFunction.colorToHex(
                                          color))
                                  .toList(),
                            );
                            await profileController.initialize();
                          },
                          loadingWidget: Center(
                            child: Stack(
                              children: [
                                Positioned.fill(
                                  child: BackdropFilter(
                                    filter: ImageFilter.blur(
                                        sigmaX: 5.0, sigmaY: 5.0),
                                    child: const SizedBox(),
                                  ),
                                ),
                                ClipRRect(
                                  borderRadius: BorderRadius.circular(100),
                                  child: Image.asset(
                                    GifsPath.loadingGif,
                                    height: 200,
                                    width: 200,
                                  ),
                                ),
                              ],
                            ),
                          )).then((_) => Get.toNamed("/mainHome"));
                    } else {
                      errorMessage("Bro, enter your name clearly!");
                    }
                  },
                  iconPath: IconsPath.save,
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }
}

```

---


### Pages\Web\web_view_edit_controller.dart

```dart
import 'package:flutter/services.dart';
import 'package:flutter_inappwebview/flutter_inappwebview.dart';
import 'package:get/get.dart';
import 'package:tictactoe_gameapp/Configs/messages.dart';

class WebViewEditController extends GetxController {
  late InAppWebViewController webViewController;

  // Rx variables for reactive UI updates
  var canGoBack = false.obs;
  var canGoForward = false.obs;
  var currentUrl = ''.obs;

  // Copy current link to clipboard
  void copyLink(String url) {
    Clipboard.setData(ClipboardData(text: currentUrl.value));
    successMessage('Link "$url" Copied');
  }

  // Update navigation state
  Future<void> updateNavigationState() async {
    try {
      canGoBack.value = await webViewController.canGoBack();
      canGoForward.value = await webViewController.canGoForward();
      currentUrl.value = (await webViewController.getUrl())?.toString() ?? '';
    } catch (e) {
      errorMessage('Error updating navigation state: $e');
    }
  }
}

```

---


### Pages\Web\web_view_edit_sheet.dart

```dart
import 'package:flutter/material.dart';

class WebViewEditSheet extends StatelessWidget {
  final ScrollController scrollController;
  const WebViewEditSheet({super.key, required this.scrollController});

  @override
  Widget build(BuildContext context) {
    return Container();
  }
}

```

---


### Pages\Web\web_view_open.dart

```dart
import 'package:flutter/material.dart';
import 'package:flutter_inappwebview/flutter_inappwebview.dart';
import 'package:get/get.dart';
import 'package:tictactoe_gameapp/Pages/Web/web_view_edit_controller.dart';

class WebViewOpen extends StatelessWidget {
  final String url;

  const WebViewOpen({super.key, required this.url});

  @override
  Widget build(BuildContext context) {
    final WebViewEditController controller = Get.put(WebViewEditController());
    return Scaffold(
      appBar: AppBar(
        leading: IconButton(
          onPressed: () => Get.back(),
          icon: const Icon(
            Icons.arrow_back_rounded,
            size: 35,
          ),
        ),
        title: Column(
          children: [
            const Text(
              "Tic Tac Toe",
              style: TextStyle(
                fontWeight: FontWeight.bold,
                fontSize: 17,
              ),
            ),
            Obx(
              () => Text(
                controller.currentUrl.value,
                maxLines: 1,
                overflow: TextOverflow.ellipsis,
                style: const TextStyle(
                  color: Colors.blue,
                  fontSize: 15,
                ),
              ),
            ),
          ],
        ),
        actions: [
          Obx(
            () => IconButton(
              icon: Icon(
                Icons.arrow_back_ios_new_rounded,
                color: controller.canGoBack.value ? Colors.blue : Colors.white,
              ),
              onPressed: () async {
                if (controller.canGoBack.value) {
                  await controller.webViewController.goBack();
                  controller.updateNavigationState();
                }
              },
            ),
          ),
          Obx(
            () => IconButton(
              icon: Icon(
                Icons.arrow_forward_ios_rounded,
                color:
                    controller.canGoForward.value ? Colors.blue : Colors.white,
              ),
              onPressed: () async {
                if (controller.canGoForward.value) {
                  await controller.webViewController.goForward();
                  controller.updateNavigationState();
                }
              },
            ),
          ),
          IconButton(
            icon: const Icon(
              Icons.refresh,
              color: Colors.blueAccent,
              size: 30,
            ),
            onPressed: () {
              controller.webViewController.reload();
            },
          ),
          IconButton(
            icon: const Icon(
              Icons.copy,
              color: Colors.blueAccent,
              size: 30,
            ),
            onPressed: () {
              controller.copyLink(controller.currentUrl.value);
            },
          ),
        ],
      ),
      body: InAppWebView(
        initialUrlRequest: URLRequest(url: WebUri(url)),
        onWebViewCreated: (webViewController) {
          controller.webViewController = webViewController;
        },
        onLoadStop: (webViewController, url) async {
          await controller.updateNavigationState();
        },
        onProgressChanged: (webViewController, progress) async {
          await controller.updateNavigationState();
        },
      ),
    );
  }
}

```

---


### Pages\Web\web_view_screen.dart

```dart
import 'package:flutter/material.dart';
import 'package:flutter_inappwebview/flutter_inappwebview.dart';
import 'package:tictactoe_gameapp/Configs/constants.dart';

class UltizeScreen extends StatelessWidget {
  const UltizeScreen({super.key});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: SafeArea(
        child: InAppWebView(
          initialUrlRequest: URLRequest(url: WebUri(url2)),
          keepAlive: InAppWebViewKeepAlive(),
          key: GlobalKey(),
        ),
      ),
    );
  }
}

```

---


### Pages\Welcome\welcome_page.dart

```dart
import 'package:concentric_transition/concentric_transition.dart';
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import '../../Configs/assets_path.dart';

class WelcomePage extends StatelessWidget {
  const WelcomePage({super.key});

  @override
  Widget build(BuildContext context) {
    var pages = [
      Container(
        width: double.infinity,
        height: double.infinity,
        decoration: const BoxDecoration(
          image: DecorationImage(
            image: AssetImage(ImagePath.background1),
            fit: BoxFit.cover,
          ),
        ),
        padding: const EdgeInsets.all(30),
        child: Column(
          children: [
            const Text(
              "Welcome",
              style: TextStyle(
                fontSize: 20,
                color: Colors.white,
              ),
            ),
            const Text(
              "Most fun game now available on your smartphone device!",
              textAlign: TextAlign.center,
              style: TextStyle(
                fontSize: 15,
                color: Colors.white,
              ),
            ),
            Image.asset(ImagePath.welcome1, width: 100),
          ],
        ),
      ),
      Container(
        padding: const EdgeInsets.all(30),
        width: double.infinity,
        height: double.infinity,
        decoration: const BoxDecoration(
          image: DecorationImage(
            image: AssetImage(ImagePath.background1),
            fit: BoxFit.cover,
          ),
        ),
        child: Column(
          children: [
            const Text(
              "Compete",
              style: TextStyle(
                fontSize: 20,
                color: Colors.white,
              ),
            ),
            const Text(
              "Play online with your friends and top the leaderboard!",
              textAlign: TextAlign.center,
              style: TextStyle(
                fontSize: 15,
                color: Colors.white,
              ),
            ),
            Image.asset(ImagePath.welcome2, width: 100),
          ],
        ),
      ),
      Container(
        padding: const EdgeInsets.all(30),
        width: double.infinity,
        height: double.infinity,
        decoration: const BoxDecoration(
          image: DecorationImage(
            image: AssetImage(ImagePath.background3),
            fit: BoxFit.cover,
          ),
        ),
        child: Column(
          children: [
            Image.asset(
              ImagePath.welcome3,
              width: 100,
            ),
            const Text(
              "Earn points for each game and make your way to top the scoreboard!",
              textAlign: TextAlign.center,
              style: TextStyle(
                fontSize: 15,
                color: Colors.white,
              ),
            ),
            const SizedBox(
              height: 20,
            ),
            ElevatedButton(
              onPressed: () {
                Get.offAllNamed("/auth");
              },
              child: const Text(
                'Get Started',
                style: TextStyle(color: Colors.red),
              ),
            ),
          ],
        ),
      ),
    ];

    return Scaffold(
      body: ConcentricPageView(
        colors: const [
          Colors.transparent,
          Colors.transparent,
          Colors.transparent,
        ],
        itemCount: 3,
        physics: const BouncingScrollPhysics(),
        onFinish: () {
          Get.offAllNamed("/auth");
        },
        itemBuilder: (index) {
          return pages[index];
        },
      ),
    );
  }
}

```

---


### Test\customed_error_widget.dart

```dart
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';

class CustomErrorWidget extends StatelessWidget {
  final FlutterErrorDetails errorDetails;
  const CustomErrorWidget({super.key, required this.errorDetails});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: Colors.red,
      body: SafeArea(
        child: Center(
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              const Icon(Icons.error, color: Colors.white, size: 64),
              const SizedBox(height: 16),
              Text(
                kDebugMode
                    ? errorDetails.summary.toString()
                    : 'Oups! Something went wrong!',
                textAlign: TextAlign.center,
                style: const TextStyle(
                  fontSize: 20,
                  color: Colors.white,
                  fontWeight: FontWeight.bold,
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }
}

```

---


### Test\game_history\game_history_page.dart

```dart
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:tictactoe_gameapp/Components/belong_to_users/avatar_user_widget.dart';
import 'package:tictactoe_gameapp/Configs/assets_path.dart';
import 'package:tictactoe_gameapp/Controller/profile_controller.dart';
import 'package:tictactoe_gameapp/Test/game_history/Widgets/tictactoe_history_widget.dart';

class GameHistoryPage extends StatelessWidget {
  const GameHistoryPage({super.key});

  @override
  Widget build(BuildContext context) {
    final user = Get.find<ProfileController>().user!;
    return Scaffold(
      appBar: AppBar(
        leading: IconButton(
          onPressed: () {
            Get.back();
          },
          icon: const Icon(
            Icons.arrow_back_ios_new_rounded,
            size: 30,
            color: Colors.blue,
          ),
        ),
        centerTitle: false,
        title: Row(
          children: [
            AvatarUserWidget(
              radius: 25,
              imagePath: user.image!,
              gradientColors: user.avatarFrame,
            ),
            const SizedBox(
              width: 5,
            ),
            Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  user.name!,
                  style: const TextStyle(
                    fontSize: 18,
                    fontWeight: FontWeight.w600,
                    fontFamily: "Orbitron",
                  ),
                ),
                Row(
                  children: [
                    Image.asset(
                      TrimRanking.diamondTrim,
                      width: 20,
                    ),
                    const SizedBox(
                      width: 5,
                    ),
                    const Text(
                      "Diamond II",
                      style: TextStyle(
                        fontSize: 13,
                        fontFamily: "Orbitron",
                      ),
                    ),
                  ],
                ),
              ],
            ),
          ],
        ),
        actions: [
          IconButton(
            onPressed: () {},
            icon: const Icon(
              Icons.bar_chart_rounded,
              size: 30,
              color: Colors.blue,
            ),
          ),
          IconButton(
            onPressed: () {},
            icon: const Icon(
              Icons.favorite_border_rounded,
              size: 30,
              color: Colors.blue,
            ),
          ),
        ],
      ),
      body: Padding(
        padding: const EdgeInsets.all(10),
        child: DefaultTabController(
          length: 4,
          child: Column(
            children: [
              TabBar(
                labelColor: Colors.blueAccent,
                unselectedLabelColor: Colors.grey,
                indicatorSize: TabBarIndicatorSize.tab,
                indicatorColor: Colors.blueAccent,
                labelStyle: const TextStyle(
                  fontSize: 12,
                  fontWeight: FontWeight.w600,
                  fontFamily: "Orbitron",
                ),
                tabs: [
                  Tab(
                      icon: Image.asset(
                        ImagePath.board_3x3,
                        width: 30,
                      ),
                      text: 'TicTacToe'),
                  Tab(
                      icon: Image.asset(
                        ImagePath.board_6x6,
                        width: 30,
                      ),
                      text: 'Sudoku'),
                  Tab(
                      icon: Image.asset(
                        ImagePath.board_9x9,
                        width: 30,
                      ),
                      text: 'Match3'),
                  Tab(
                      icon: Image.asset(
                        ImagePath.board_11x11,
                        width: 30,
                      ),
                      text: 'Minesweeper'),
                ],
              ),
              const Expanded(
                child: TabBarView(
                  children: [
                    TictactoeHistoryWidget(),
                    TictactoeHistoryWidget(),
                    TictactoeHistoryWidget(),
                    TictactoeHistoryWidget(),
                  ],
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }
}

```

---


### Test\game_history\Widgets\tictactoe_history_widget.dart

```dart
import 'package:dotted_border/dotted_border.dart';
import 'package:flutter/material.dart';
import 'package:flutter_animate/flutter_animate.dart';
import 'package:get/get.dart';
import 'package:tictactoe_gameapp/Configs/assets_path.dart';
import 'package:tictactoe_gameapp/Configs/constants.dart';

class TictactoeHistoryWidget extends StatelessWidget {
  const TictactoeHistoryWidget({super.key});

  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        const Row(
          mainAxisAlignment: MainAxisAlignment.spaceBetween,
          children: [
            Text(
              "BLUE TEAM",
              style: TextStyle(
                fontSize: 18,
                color: Colors.blue,
                fontWeight: FontWeight.bold,
                fontFamily: "Orbitron",
              ),
            ),
            Text(
              "RED TEAM",
              style: TextStyle(
                fontSize: 18,
                color: Colors.red,
                fontWeight: FontWeight.bold,
                fontFamily: "Orbitron",
              ),
            ),
          ],
        ),
        Expanded(
          child: ListView.builder(
            itemCount: listChamA.length,
            itemBuilder: (context, index) {
              return Container(
                padding: const EdgeInsets.all(8.0),
                height: 100,
                decoration:
                    BoxDecoration(border: Border.all(color: Colors.blueGrey)),
                child: Row(
                  mainAxisAlignment: MainAxisAlignment.spaceBetween,
                  children: [
                    Column(
                      children: [
                        ClipRRect(
                          borderRadius: BorderRadius.circular(10),
                          child: Image.asset(
                            listChamA[index],
                            width: 50,
                          ),
                        ),
                        const SizedBox(
                          height: 5,
                        ),
                        Row(
                          children: [
                            Image.asset(
                              TrimRanking.diamondTrim,
                              width: 20,
                            ),
                            const SizedBox(
                              width: 5,
                            ),
                            const Text(
                              "You",
                              style: TextStyle(
                                  fontSize: 15,
                                  fontFamily: "Orbitron",
                                  fontWeight: FontWeight.w600),
                            ),
                          ],
                        ),
                      ],
                    ),
                    Column(
                      children: [
                        GestureDetector(
                          onTap: _showBoardHistory,
                          child: Container(
                            width: 50,
                            padding: const EdgeInsets.all(10),
                            decoration: BoxDecoration(
                                color: Colors.blueGrey,
                                borderRadius: BorderRadius.circular(10),
                                border:
                                    Border.all(color: Colors.white, width: 3)),
                            child: const Icon(
                              Icons.tv_rounded,
                              color: Colors.white,
                            ),
                          ),
                        ),
                        const SizedBox(
                          height: 5,
                        ),
                        const Text(
                          "VS",
                          style: TextStyle(
                            fontSize: 16,
                            fontWeight: FontWeight.bold,
                            fontFamily: "Orbitron",
                          ),
                        )
                      ],
                    ),
                    Column(
                      children: [
                        ClipRRect(
                          borderRadius: BorderRadius.circular(10),
                          child: Image.asset(
                            listChamA[index],
                            width: 50,
                          ),
                        ),
                        const SizedBox(
                          height: 5,
                        ),
                        Row(
                          children: [
                            const Text(
                              "Enemy",
                              style: TextStyle(
                                  fontSize: 15,
                                  fontFamily: "Orbitron",
                                  fontWeight: FontWeight.w600),
                            ),
                            const SizedBox(
                              width: 5,
                            ),
                            Image.asset(
                              TrimRanking.diamondTrim,
                              width: 20,
                            ),
                          ],
                        ),
                      ],
                    ),
                  ],
                ),
              );
            },
          ),
        ),
      ],
    );
  }

  void _showBoardHistory() {
    Get.dialog(Dialog(
      backgroundColor: Colors.transparent,
      child: SizedBox(
        height: 400,
        child: DottedBorder(
          borderType: BorderType.RRect,
          color: Colors.blueAccent,
          padding: const EdgeInsets.all(3),
          strokeWidth: 5,
          dashPattern: const [10, 5],
          radius: const Radius.circular(20),
          child: Container(
            alignment: Alignment.center,
            decoration: BoxDecoration(
                color: Colors.transparent,
                borderRadius: BorderRadius.circular(20),
                image: const DecorationImage(
                    image: AssetImage(ImagePath.background1),
                    fit: BoxFit.fill)),
            child: InteractiveViewer(
              panEnabled: true, // Cho phép kéo thả
              scaleEnabled: true, // Cho phép phóng to, thu nhỏ
              minScale: 0.0000000000001, // Tỷ lệ thu nhỏ tối thiểu
              maxScale: 4.0, // Tỷ lệ phóng to tối đa
              boundaryMargin: const EdgeInsets.all(
                  double.infinity), // Cho phép kéo ra ngoài biên
              child: SizedBox(
                width: 100, // Adjust width based on grid size
                height: 100, // Adjust height based on grid size
                child: GridView.builder(
                  physics:
                      const NeverScrollableScrollPhysics(), // Disable GridView's own scrolling
                  gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(
                    crossAxisCount: 3,
                    childAspectRatio: 1.0,
                  ),
                  itemCount: 9,
                  itemBuilder: (context, index) {
                    return Container(
                      margin: const EdgeInsets.all(0.5),
                      decoration: const BoxDecoration(
                        color: Colors.white,
                      ),
                      child: Center(
                        child: Image.asset(ChampionsPathA.aatrox)
                            .animate()
                            .fadeIn(
                                duration: const Duration(milliseconds: 750)),
                      ),
                    );
                  },
                ),
              ),
            ),
          ),
        ),
      ),
    ).animate().scale(duration: const Duration(milliseconds: 750)));
  }
}

```

---


### Test\livestream_preview\agora_preview_controller.dart

```dart
import 'package:get/get.dart';
import 'package:permission_handler/permission_handler.dart';
import 'package:agora_rtc_engine/agora_rtc_engine.dart';
import 'package:tictactoe_gameapp/Configs/constants.dart';
import 'package:tictactoe_gameapp/Configs/messages.dart';

class AgoraPreviewController extends GetxController {
  // Variables to track the state of permissions
  RxBool isCameraPermissionGranted = false.obs;
  RxBool isMicrophonePermissionGranted = false.obs;
  
  // Variables to control camera and mic states
  RxBool isCameraOn = true.obs;
  RxBool isMicrophoneOn = true.obs;

  // Agora engine instance
  late RtcEngine agoraEngine;

  @override
  void onInit() {
    super.onInit();
    initializeAgoraEngine();
    checkPermissions();
  }

  // Initialize Agora RTC Engine
  Future<void> initializeAgoraEngine() async {
    agoraEngine = createAgoraRtcEngine();
    await agoraEngine.initialize( RtcEngineContext(appId: apiAgoraAppId));
  }

  // Check camera and microphone permissions
  Future<void> checkPermissions() async {
    final cameraStatus = await Permission.camera.status;
    final micStatus = await Permission.microphone.status;

    if (!cameraStatus.isGranted) {
      isCameraPermissionGranted.value = await Permission.camera.request().isGranted;
    } else {
      isCameraPermissionGranted.value = true;
    }

    if (!micStatus.isGranted) {
      isMicrophonePermissionGranted.value = await Permission.microphone.request().isGranted;
    } else {
      isMicrophonePermissionGranted.value = true;
    }
  }

  // Toggle camera
  void toggleCamera() {
    isCameraOn.value = !isCameraOn.value;
    agoraEngine.muteLocalVideoStream(!isCameraOn.value);
  }

  // Toggle microphone
  void toggleMicrophone() {
    isMicrophoneOn.value = !isMicrophoneOn.value;
    agoraEngine.muteLocalAudioStream(!isMicrophoneOn.value);
  }

  // Start preview
  Future<void> startPreview() async {
    if (isCameraPermissionGranted.value && isMicrophonePermissionGranted.value) {
      await agoraEngine.startPreview();
    } else {
      errorMessage("Please grant camera and microphone permissions to proceed.");
    }
  }

  // Stop preview
  Future<void> stopPreview() async {
    await agoraEngine.stopPreview();
  }

  @override
  void onClose() {
    agoraEngine.release();
    super.onClose();
  }
}

```

---
